/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*%%%%%%%%%%%%%%%%%%%%%%%% Дата формирования: 29.08.2012 19:04 %%%%%%%%%%%%%%%%%%%%%%%%*/
/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*********************************************************************/
/* begin 20111221_AlterTable_WebServiceLog.sql */
/*********************************************************************/
--<VERSION>ALL</VERSION>
--<DATE>2012-02-29</DATE>

IF not EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'webservicelog' AND TABLE_SCHEMA = 'dbo')  
      create table dbo.Webservicelog (name nvarchar(50), date datetime  DEFAULT  GETDATE(), host nvarchar(15),Duration float,Params nvarchar(1024))
IF NOT EXISTS(SELECT col.id 
				FROM syscolumns col
				LEFT JOIN sys.tables tab on col.id = tab.object_id
				WHERE tab.name = 'webservicelog'
						AND SCHEMA_NAME(tab.schema_id) = 'dbo'
						AND col.name = 'UserName')
      ALTER TABLE dbo.Webservicelog ADD UserName nvarchar(60) NULL

GRANT INSERT ON [dbo].[Webservicelog] TO [public]
GO
GRANT REFERENCES ON [dbo].[Webservicelog] TO [public]
GO
GRANT SELECT ON [dbo].[Webservicelog] TO [public]
GO
GRANT UPDATE ON [dbo].[Webservicelog] TO [public]
GO
GRANT DELETE ON [dbo].[Webservicelog] TO [public]
GO
GRANT VIEW DEFINITION ON [dbo].[Webservicelog] TO [public]
GO

-- if webservicelog table exists in non-dbo schema,
-- then create same table in dbo schema, fill data to it and drop
-- non-dbo schema table
IF EXISTS(SELECT * 
			FROM INFORMATION_SCHEMA.TABLES 
			WHERE TABLE_NAME = 'webservicelog'
				AND TABLE_SCHEMA <> 'dbo')
BEGIN

	print 'webservicelog processing...'

	declare @otherSchema as nvarchar(50)
	SELECT top 1 @otherSchema = TABLE_SCHEMA 
			FROM INFORMATION_SCHEMA.TABLES 
			WHERE TABLE_NAME = 'webservicelog'
				AND TABLE_SCHEMA <> 'dbo'
				
	declare @sql as nvarchar(max)
	set @sql = '
				INSERT INTO dbo.webservicelog (name, date, host, Duration, Params)
				SELECT name, date, host, Duration, Params from ' + @otherSchema + '.webservicelog 
				'
	
	set @sql = @sql + '
				DROP TABLE ' + @otherSchema + '.webservicelog 
				'
	print @sql
	exec (@sql)
	
	print 'webservicelog processing complete'

END 

GO
/*********************************************************************/
/* end 20111221_AlterTable_WebServiceLog.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwReplPublisherDB.sql */
/*********************************************************************/
if object_id('dbo.mwReplPublisherDB', 'fn') is not null
	drop function dbo.mwReplPublisherDB
go

--<VERSION>ALL</VERSION>
--<DATE>2012-03-03</DATE>

create function dbo.mwReplPublisherDB()
returns varchar (254)
as
begin
	--возвращаем имя базы с первого поискового сервера, будем считать на остальных серверах данные одинаковые
	declare @repl_setting varchar(254)

	select @repl_setting = lower(isnull(ss_parmvalue, ''))
	from SystemSettings with(nolock)
	where ss_parmname = 'mwReplPublisherDB'

	if @repl_setting is null
	begin
		set @repl_setting = ''
	end
	
	if len(@repl_setting) > 0
	begin
		if substring(@repl_setting, 1, 1) <> '['
			set @repl_setting = '[' + @repl_setting

		if substring(@repl_setting, len(@repl_setting), 1) <> ']'
			set @repl_setting = @repl_setting + ']'
	end
	
	return @repl_setting
end
go

grant exec on dbo.mwReplPublisherDB to public
go
/*********************************************************************/
/* end fn_mwReplPublisherDB.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwReplSubscriberDB.sql */
/*********************************************************************/
if object_id('dbo.mwReplSubscriberDB', 'fn') is not null
	drop function dbo.mwReplSubscriberDB
go

--<VERSION>ALL</VERSION>
--<DATE>2012-03-03</DATE>

-- Функция возвращает значение настройки 'MWReplSubscriberDB' из таблицы SystemSettings - имя поисковой базы данных
-- ВНИМАНИЕ!!! Функция предназначена для использования только на основном сервере
-- ВНИМАНИЕ!!! Функция устарела - вместо неё используйте функцию mwReplGetSubscriptions() (для случая нескольких поисковых БД)

create function dbo.mwReplSubscriberDB()
returns varchar (254)
as
begin
	--возвращает имя базы с первого поискового сервера, будем считать на остальных серверах данные одинаковые
	declare @repl_setting varchar(254)
	
	select @repl_setting = lower(isnull(ss_parmvalue, ''))
	from SystemSettings with(nolock)
	where ss_parmname = 'MWReplSubscriberDB'
	
	if @repl_setting is null
	begin
		set @repl_setting = ''
	end

	if len(@repl_setting) > 0
	begin
		if substring(@repl_setting, 1, 1) <> '['
			set @repl_setting = '[' + @repl_setting

		if substring(@repl_setting, len(@repl_setting), 1) <> ']'
			set @repl_setting = @repl_setting + ']'
	end

	return @repl_setting
end
go

grant exec on dbo.mwReplSubscriberDB to public
go
/*********************************************************************/
/* end fn_mwReplSubscriberDB.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwFillTP.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwFillTP]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwFillTP]
GO

CREATE procedure [dbo].[mwFillTP] (@tokey int, @calcKey int = null)
as
begin
	declare @sql varchar(4000)
	declare @source varchar(200)
	set @source = ''

	declare @tokeyStr varchar (20)
	set @tokeyStr = cast(@tokey as varchar(20))

	declare @calcKeyStr varchar (20)
	set @calcKeyStr = cast(@calcKey as varchar(20))

	if dbo.mwReplIsSubscriber() > 0 and len(dbo.mwReplPublisherDB()) > 0
		set @source = '[mt].' + dbo.mwReplPublisherDB() + '.'
	
	--delete from dbo.tp_tours where to_key = @calcKey	
	if not exists(select 1 from dbo.tp_tours with(nolock) where to_key = @tokey)
	begin
		set @sql = '
		insert into dbo.tp_tours with(rowlock) (
			[TO_Key],
			[TO_TRKey],
			[TO_Name],
			[TO_PRKey],
			[TO_CNKey],
			[TO_Rate],
			[TO_DateCreated],
			[TO_DateValid],
			[TO_PriceFor],
			[TO_OpKey],
			[TO_XML],
			[TO_DateBegin],
			[TO_DateEnd],
			[TO_IsEnabled],
			[TO_PROGRESS],
			[TO_UPDATE],
			[TO_UPDATETIME],
			[TO_DateValidBegin],
			[TO_CalculateDateEnd],
			[TO_PriceCount],
			[to_attribute],
			[TO_MinPrice],
			[TO_HotelNights]
		)
		select
			[TO_Key],
			[TO_TRKey],
			[TO_Name],
			[TO_PRKey],
			[TO_CNKey],
			[TO_Rate],
			[TO_DateCreated],
			[TO_DateValid],
			[TO_PriceFor],
			[TO_OpKey],
			[TO_XML],
			[TO_DateBegin],
			[TO_DateEnd],
			[TO_IsEnabled],
			[TO_PROGRESS],
			[TO_UPDATE],
			[TO_UPDATETIME],
			[TO_DateValidBegin],
			[TO_CalculateDateEnd],
			[TO_PriceCount],
			[to_attribute],
			[TO_MinPrice],
			[TO_HotelNights]
		from
			' + @source + 'dbo.tp_tours with(nolock)
		where
			to_key = ' + @tokeyStr

		exec (@sql)
	end
	
	if(@calcKey is not null)
		delete from dbo.TP_TurDates where TD_CalculatingKey = @calcKey
	else
		delete from dbo.TP_TurDates where TD_TOKey = @tokey
	--if not exists(select 1 from dbo.TP_TurDates with(nolock) where td_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.TP_TurDates with(rowlock) (
			[TD_Key],
			[TD_TOKey],
			[TD_Date],
			[TD_UPDATE],
			[TD_CHECKMARGIN],
			[TD_CalculatingKey]
		)
		select
			[TD_Key],
			[TD_TOKey],
			[TD_Date],
			[TD_UPDATE],
			[TD_CHECKMARGIN],
			[TD_CalculatingKey]
		from
			' + @source + 'dbo.TP_TurDates with(nolock)
		where
			'
		if(@calcKey is not null)
			set @sql = @sql + 'TD_CalculatingKey = ' + @calcKeyStr
		else
			set @sql = @sql + 'TD_TOKey = ' + @tokeyStr

		exec (@sql)		
	end	
	
    delete dbo.tp_services where ts_tokey = @tokey
	--if not exists(select 1 from dbo.tp_services with(nolock) where ts_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.tp_services with(rowlock) (
			[TS_Key],
			[TS_TOKey],
			[TS_SVKey],
			[TS_Code],
			[TS_SubCode1],
			[TS_SubCode2],
			[TS_CNKey],
			[TS_CTKey],
			[TS_Day],
			[TS_Days],
			[TS_Men],
			[TS_Name],
			[TS_OpPartnerKey],
			[TS_OpPacketKey],
			[TS_Attribute],
			[TS_TEMPGROSS],
			[TS_CHECKMARGIN],
			[TS_CalculatingKey]
		)
		select
			[TS_Key],
			[TS_TOKey],
			[TS_SVKey],
			[TS_Code],
			[TS_SubCode1],
			[TS_SubCode2],
			[TS_CNKey],
			[TS_CTKey],
			[TS_Day],
			[TS_Days],
			[TS_Men],
			[TS_Name],
			[TS_OpPartnerKey],
			[TS_OpPacketKey],
			[TS_Attribute],
			[TS_TEMPGROSS],
			[TS_CHECKMARGIN],
			[TS_CalculatingKey]
		from
			' + @source + 'dbo.tp_services with(nolock)
		where
			'
		if(@calcKey is not null)
			set @sql = @sql + 'TS_CalculatingKey = ' + @calcKeyStr
		else
			set @sql = @sql + 'TS_TOKey = ' + @tokeyStr

		exec (@sql)
	end

	delete from dbo.tp_lists where ti_tokey = @tokey
	--if not exists(select 1 from dbo.tp_lists with(nolock) where ti_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.tp_lists with(rowlock) (
			[TI_Key],
			[TI_TOKey],
			[TI_Name],
			[TI_FirstHDKey],
			[TI_FirstHRKey],
			[TI_FirstPNKey],
			[TI_Days],
			[TI_HotelKeys],
			[TI_PansionKeys],
			[TI_HotelDays],
			[TI_FirstHDStars],
			[TI_FirstRsKey],
			[TI_SecondHDKey],
			[TI_SecondHRKey],
			[TI_SecondPNKey],
			[TI_SecondHDStars],
			[TI_SecondCtKey],
			[TI_SecondRsKey],
			[TI_CtKeyFrom],
			[TI_CtKeyTo],
			[TI_ApKeyFrom],
			[TI_ApKeyTo],
			[ti_firsthotelday],
			[ti_hdpartnerkey],
			[ti_totaldays],
			[ti_nights],
			[ti_lasthotelday],
			[ti_chkey],
			[ti_chbackkey],
			[ti_hdday],
			[ti_hdnights],
			[ti_chday],
			[ti_chbackday],
			[ti_chpkkey],
			[ti_chprkey],
			[ti_chbackpkkey],
			[ti_chbackprkey],
			[TI_FirstCtKey],
			[TI_UPDATE],
			[TI_FIRSTHOTELPARTNERKEY],
			[ti_hotelroomkeys],
			[ti_hotelstars],
			[TI_CalculatingKey]
		)
		select
			[TI_Key],
			[TI_TOKey],
			[TI_Name],
			[TI_FirstHDKey],
			[TI_FirstHRKey],
			[TI_FirstPNKey],
			[TI_Days],
			[TI_HotelKeys],
			[TI_PansionKeys],
			[TI_HotelDays],
			[TI_FirstHDStars],
			[TI_FirstRsKey],
			[TI_SecondHDKey],
			[TI_SecondHRKey],
			[TI_SecondPNKey],
			[TI_SecondHDStars],
			[TI_SecondCtKey],
			[TI_SecondRsKey],
			[TI_CtKeyFrom],
			[TI_CtKeyTo],
			[TI_ApKeyFrom],
			[TI_ApKeyTo],
			[ti_firsthotelday],
			[ti_hdpartnerkey],
			[ti_totaldays],
			[ti_nights],
			[ti_lasthotelday],
			[ti_chkey],
			[ti_chbackkey],
			[ti_hdday],
			[ti_hdnights],
			[ti_chday],
			[ti_chbackday],
			[ti_chpkkey],
			[ti_chprkey],
			[ti_chbackpkkey],
			[ti_chbackprkey],
			[TI_FirstCtKey],
			[TI_UPDATE],
			[TI_FIRSTHOTELPARTNERKEY],
			[ti_hotelroomkeys],
			[ti_hotelstars],
			[TI_CalculatingKey]
		from
			' + @source + 'dbo.tp_lists with(nolock)
		where
			'
		if(@calcKey is not null)
			set @sql = @sql + 'TI_CalculatingKey = ' + @calcKeyStr
		else
			set @sql = @sql + 'TI_TOKey = ' + @tokeyStr

		exec (@sql)
	end

	delete from dbo.tp_servicelists where tl_tokey = @tokey
	--if not exists(select 1 from dbo.tp_servicelists with(nolock) where tl_tokey = @calcKey)
	begin	
		set @sql = 
		'insert into dbo.tp_servicelists with(rowlock) (
			[TL_Key],
			[TL_TOKey],
			[TL_TSKey],
			[TL_TIKey],
			[TL_CalculatingKey]
		)
		select
			[TL_Key],
			[TL_TOKey],
			[TL_TSKey],
			[TL_TIKey],
			[TL_CalculatingKey]
		from
			' + @source + 'dbo.tp_servicelists with(nolock)
		where
			'

		if(@calcKey is not null)
			set @sql = @sql + 'TL_CalculatingKey = ' + @calcKeyStr
		else
			set @sql = @sql + 'TL_TOKey = ' + @tokeyStr

		exec (@sql)
	end

	delete from dbo.tp_prices where tp_tokey = @tokey
	--if not exists(select 1 from dbo.tp_prices with(nolock) where tp_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.tp_prices with(rowlock) (
			[TP_Key],
			[TP_TOKey],
			[TP_DateBegin],
			[TP_DateEnd],
			[TP_Gross],
			[TP_TIKey],
			[TP_CalculatingKey]
		)
		select
			[TP_Key],
			[TP_TOKey],
			[TP_DateBegin],
			[TP_DateEnd],
			[TP_Gross],
			[TP_TIKey],
			[TP_CalculatingKey]
		from
			' + @source + 'dbo.tp_prices with(nolock)
		where
			'

		if(@calcKey is not null)
			set @sql = @sql + 'TP_CalculatingKey = ' + @calcKeyStr
		else
			set @sql = @sql + 'TP_TOKey = ' + @tokeyStr

		exec (@sql)
	end
end
GO

GRANT EXEC ON [dbo].[mwFillTP] TO PUBLIC
GO
/*********************************************************************/
/* end sp_mwFillTP.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplDisableDeletedPrices.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwReplDisableDeletedPrices]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	DROP PROCEDURE [dbo].[mwReplDisableDeletedPrices]
GO

--<VERSION>ALL</VERSION>
--<DATE>2012-03-03</DATE>

CREATE procedure [dbo].[mwReplDisableDeletedPrices]
as
begin
	declare @cnKey int
	declare @ctKeyFrom int

	select top 100000 * into #mwReplDeletedPricesTemp from dbo.mwReplDeletedPricesTemp with(nolock);
	create index x_pricekey on #mwReplDeletedPricesTemp(rdp_pricekey);
	
	delete from dbo.mwReplDeletedPricesTemp with(rowlock)
	where exists(select 1 from #mwReplDeletedPricesTemp r where r.rdp_pricekey = mwReplDeletedPricesTemp.rdp_pricekey);
	
	if dbo.mwReplIsPublisher() > 0 
	begin
		declare @sql varchar (500);
		declare @source varchar(200);
		set @source = '';
		
		if exists(select 1 from #mwReplDeletedPricesTemp)
		begin
			
			DECLARE @subscriptionLinkedServer as nvarchar(50)
			DECLARE @subscriptionDatabaseName as nvarchar(100)			

			DECLARE subscriptionsCursor CURSOR FOR
			SELECT linkedServerName, subscriptionDatabaseName
			FROM [dbo].[mwReplGetSubscriptions]()

			BEGIN TRY

				OPEN subscriptionsCursor

				FETCH NEXT FROM subscriptionsCursor INTO @subscriptionLinkedServer, @subscriptionDatabaseName
				
				WHILE @@Fetch_Status = 0
				BEGIN
				
					SET @source = @subscriptionLinkedServer + '.' + @subscriptionDatabaseName
				
					SET @sql = '
					insert into ' + @source + '.dbo.mwReplDeletedPricesTemp with(rowlock) (rdp_pricekey, rdp_cnkey, rdp_ctdeparturekey)
					select rdp_pricekey, rdp_cnkey, rdp_ctdeparturekey from #mwReplDeletedPricesTemp';

					EXEC (@sql);
					
					FETCH NEXT FROM subscriptionsCursor INTO @subscriptionLinkedServer, @subscriptionDatabaseName
				
				END

			END TRY
			BEGIN CATCH

				DECLARE @errorMessage as nvarchar(max)
				SET @errorMessage = 'Error in mwReplDisableDeletedPrices: ' + ERROR_MESSAGE()

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage)
				
				RAISERROR (@errorMessage, 18, 100); 

			END CATCH

			CLOSE subscriptionsCursor
			DEALLOCATE subscriptionsCursor
		end
	end
	else if dbo.mwReplIsSubscriber() > 0
	begin
		if exists(select 1 from #mwReplDeletedPricesTemp)
		begin
			insert into dbo.mwDeleted with(rowlock) (del_key)
			select rdp_pricekey from #mwReplDeletedPricesTemp;
			
			if exists(select 1 from SystemSettings where SS_ParmName = 'MWDivideByCountry' and SS_ParmValue = 1)
			begin
				--Используется секционирование ценовых таблиц			
				declare mwPriceDataTableNameCursor cursor for
					select distinct dbo.mwGetPriceTableName(rdp_cnkey, rdp_ctdeparturekey) as ptn_tablename
					from
						#mwReplDeletedPricesTemp with(nolock);
					
				declare @mwPriceDataTableName varchar(200);
				open mwPriceDataTableNameCursor;
				fetch next from mwPriceDataTableNameCursor into @mwPriceDataTableName;

				while @@FETCH_STATUS = 0
				begin
					if exists (select * from sys.objects where object_id = OBJECT_ID(N'[dbo].[' + @mwPriceDataTableName + ']') AND type in (N'U'))
					begin
						set @sql='
							update [dbo].[' + @mwPriceDataTableName + '] with(rowlock)
							set pt_isenabled = 0
							where exists(select 1 from #mwReplDeletedPricesTemp r where r.rdp_pricekey = pt_pricekey)';
							
							exec (@sql);
							
							set @sql = '
							declare @cnKey int
							declare @ctKeyFrom int
							select top 1 @cnKey = pt_cnkey, @ctKeyFrom = pt_ctkeyfrom from [dbo].[' + @mwPriceDataTableName + '] with(nolock);
							update mwSpoDataTable set sd_isenabled = -1 where sd_isenabled = 1 and sd_cnkey = @cnKey and sd_ctkeyfrom = @ctKeyFrom and sd_hdkey not in (select distinct pt_hdkey from [dbo].[' + @mwPriceDataTableName + '] with(nolock) where pt_isenabled = 1 and pt_tourkey = sd_tourkey)';
							--print @sql
							--exec (@sql);
							
					end
					
					fetch next from mwPriceDataTableNameCursor into @mwPriceDataTableName;					
				end

				close mwPriceDataTableNameCursor;
				deallocate mwPriceDataTableNameCursor;
			end
			else
			begin
				--Секционирование не используется
				update dbo.mwPriceDataTable with(rowlock)
				set pt_isenabled = 0
				where exists(select 1 from #mwReplDeletedPricesTemp r where r.rdp_pricekey = pt_pricekey);
			end
		end
	end
	
	drop index x_pricekey on #mwReplDeletedPricesTemp;
	drop table #mwReplDeletedPricesTemp;
end
GO

GRANT EXECUTE ON [dbo].[mwReplDisableDeletedPrices] TO PUBLIC
GO
/*********************************************************************/
/* end sp_mwReplDisableDeletedPrices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwReplGetSubscriptions.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplGetSubscriptions]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
begin

	DROP FUNCTION [dbo].[mwReplGetSubscriptions]

end
else
begin

	-- функция создается в первый раз: перенесем значение из функции dbo.mwReplSubscriberDB
	-- в настройку 'Subscriptions'
	declare @existingSubscriberDB as nvarchar(50)

	set @existingSubscriberDB = dbo.mwReplSubscriberDB()
	
	if exists(select ss_parmname from dbo.SystemSettings where ss_parmname = 'Subscriptions')
	begin
		declare @existingParmValue as nvarchar(max)
		select @existingParmValue = ss_parmvalue from dbo.SystemSettings where ss_parmname = 'Subscriptions'

		declare @newParmValue as nvarchar(max)
		if not (coalesce(@existingParmValue, '')  like '%[mw].' + @existingSubscriberDB + '%')
		begin

			set @newParmValue = coalesce(@existingParmValue + ',', '') + '[mw].' + @existingSubscriberDB

			update dbo.SystemSettings
			set
				SS_ParmValue = @newParmValue
			where
				ss_parmname = 'Subscriptions'

		end

	end
	else
	begin
		insert into dbo.SystemSettings(
			ss_parmname,
			ss_parmvalue
		)
		values(
			'Subscriptions',
			'[mw].' + @existingSubscriberDB
		)
	end

end
go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--<VERSION>ALL</VERSION>
--<DATE>2012-03-05</DATE>
-- MEG00032642. 03.03.2012. Golubinsky.

-- Возвращает все подписки из настройки SystemSettings "Subscriptions"
-- в результирующей таблице.
-- Если не задана настройка "Subscriptions", то возвращает в качестве linked-сервера значение "mw", в качестве поисковой БД 
-- результат выполнения функции dbo.mwReplSubscriberDB() (в целях обратной совместимости)
CREATE function [dbo].[mwReplGetSubscriptions]()

returns @subscriptions table(
	linkedServerName nvarchar(50),				-- имя linked-сервера, через который будет обращение к серверу с поисковой БД
	subscriptionDatabaseName nvarchar(100))		-- название поисковой БД
begin
	
	if dbo.mwReplIsPublisher() = 0
		return

	declare @settingName as nvarchar(100)
	declare @settingsValue as nvarchar(max)

	set @settingName = 'Subscriptions'
	set @settingsValue = ''

	select @settingsValue = ss_parmvalue from SystemSettings
	where ss_parmname = @settingName

	declare @lastDelimiterIndex as int, @settingValueLength as int
		set @lastDelimiterIndex = 0
		set @settingValueLength = len(@settingsValue)

	declare @currentDotIndex as int, @currentCommaIndex as int
	declare @currentLinkedServer as nvarchar(200), @currentDatabase as nvarchar(200)

	while @lastDelimiterIndex < @settingValueLength
	begin

		set @currentDotIndex = charindex('.', @settingsValue, @lastDelimiterIndex)
		set @currentLinkedServer = substring(@settingsValue, @lastDelimiterIndex+1, @currentDotIndex-@lastDelimiterIndex-1)

		set @lastDelimiterIndex = @currentDotIndex

		set @currentCommaIndex = charindex(',', @settingsValue, @lastDelimiterIndex)
		if  @currentCommaIndex <= 0 or @currentCommaIndex >= @settingValueLength
			set @currentCommaIndex = @settingValueLength+1
		set @currentDatabase = substring(@settingsValue, @lastDelimiterIndex+1, @currentCommaIndex-@lastDelimiterIndex-1)
		
		set @lastDelimiterIndex = @currentCommaIndex

		if substring(@currentLinkedServer, 1, 1) <> '['
			set @currentLinkedServer = '[' + @currentLinkedServer

		if substring(@currentLinkedServer, len(@currentLinkedServer), 1) <> ']'
			set @currentLinkedServer = @currentLinkedServer + ']'

		if substring(@currentDatabase, 1, 1) <> '['
			set @currentDatabase = '[' + @currentDatabase

		if substring(@currentDatabase, len(@currentDatabase), 1) <> ']'
			set @currentDatabase = @currentDatabase + ']'

		insert into @subscriptions
		values (@currentLinkedServer, @currentDatabase)

	end

	return
end

GO

grant SELECT on [dbo].[mwReplGetSubscriptions] to public
GO

/*********************************************************************/
/* end fn_mwReplGetSubscriptions.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplDisableDeletedPrices.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwReplDisableDeletedPrices]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	DROP PROCEDURE [dbo].[mwReplDisableDeletedPrices]
GO

--<VERSION>ALL</VERSION>
--<DATE>2012-03-03</DATE>

CREATE procedure [dbo].[mwReplDisableDeletedPrices]
as
begin
	declare @cnKey int
	declare @ctKeyFrom int

	select top 100000 * into #mwReplDeletedPricesTemp from dbo.mwReplDeletedPricesTemp with(nolock);
	create index x_pricekey on #mwReplDeletedPricesTemp(rdp_pricekey);
	
	delete from dbo.mwReplDeletedPricesTemp with(rowlock)
	where exists(select 1 from #mwReplDeletedPricesTemp r where r.rdp_pricekey = mwReplDeletedPricesTemp.rdp_pricekey);
	
	if dbo.mwReplIsPublisher() > 0 
	begin
		declare @sql varchar (500);
		declare @source varchar(200);
		set @source = '';
		
		if exists(select 1 from #mwReplDeletedPricesTemp)
		begin
			
			DECLARE @subscriptionLinkedServer as nvarchar(50)
			DECLARE @subscriptionDatabaseName as nvarchar(100)			

			DECLARE subscriptionsCursor CURSOR FOR
			SELECT linkedServerName, subscriptionDatabaseName
			FROM [dbo].[mwReplGetSubscriptions]()

			BEGIN TRY

				OPEN subscriptionsCursor

				FETCH NEXT FROM subscriptionsCursor INTO @subscriptionLinkedServer, @subscriptionDatabaseName
				
				WHILE @@Fetch_Status = 0
				BEGIN
				
					SET @source = @subscriptionLinkedServer + '.' + @subscriptionDatabaseName
				
					SET @sql = '
					insert into ' + @source + '.dbo.mwReplDeletedPricesTemp with(rowlock) (rdp_pricekey, rdp_cnkey, rdp_ctdeparturekey)
					select rdp_pricekey, rdp_cnkey, rdp_ctdeparturekey from #mwReplDeletedPricesTemp';

					EXEC (@sql);
					
					FETCH NEXT FROM subscriptionsCursor INTO @subscriptionLinkedServer, @subscriptionDatabaseName
				
				END

			END TRY
			BEGIN CATCH

				DECLARE @errorMessage as nvarchar(max)
				SET @errorMessage = 'Error in mwReplDisableDeletedPrices: ' + ERROR_MESSAGE()

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage)
				
				RAISERROR (@errorMessage, 18, 100); 

			END CATCH

			CLOSE subscriptionsCursor
			DEALLOCATE subscriptionsCursor
		end
	end
	else if dbo.mwReplIsSubscriber() > 0
	begin
		if exists(select 1 from #mwReplDeletedPricesTemp)
		begin
			insert into dbo.mwDeleted with(rowlock) (del_key)
			select rdp_pricekey from #mwReplDeletedPricesTemp;
			
			if exists(select 1 from SystemSettings where SS_ParmName = 'MWDivideByCountry' and SS_ParmValue = 1)
			begin
				--Используется секционирование ценовых таблиц			
				declare mwPriceDataTableNameCursor cursor for
					select distinct dbo.mwGetPriceTableName(rdp_cnkey, rdp_ctdeparturekey) as ptn_tablename
					from
						#mwReplDeletedPricesTemp with(nolock);
					
				declare @mwPriceDataTableName varchar(200);
				open mwPriceDataTableNameCursor;
				fetch next from mwPriceDataTableNameCursor into @mwPriceDataTableName;

				while @@FETCH_STATUS = 0
				begin
					if exists (select * from sys.objects where object_id = OBJECT_ID(N'[dbo].[' + @mwPriceDataTableName + ']') AND type in (N'U'))
					begin
						set @sql='
							update [dbo].[' + @mwPriceDataTableName + '] with(rowlock)
							set pt_isenabled = 0
							where exists(select 1 from #mwReplDeletedPricesTemp r where r.rdp_pricekey = pt_pricekey)';
							
							exec (@sql);
							
							set @sql = '
							declare @cnKey int
							declare @ctKeyFrom int
							select top 1 @cnKey = pt_cnkey, @ctKeyFrom = pt_ctkeyfrom from [dbo].[' + @mwPriceDataTableName + '] with(nolock);
							update mwSpoDataTable set sd_isenabled = -1 where sd_isenabled = 1 and sd_cnkey = @cnKey and sd_ctkeyfrom = @ctKeyFrom and sd_hdkey not in (select distinct pt_hdkey from [dbo].[' + @mwPriceDataTableName + '] with(nolock) where pt_isenabled = 1 and pt_tourkey = sd_tourkey)';
							--print @sql
							--exec (@sql);
							
					end
					
					fetch next from mwPriceDataTableNameCursor into @mwPriceDataTableName;					
				end

				close mwPriceDataTableNameCursor;
				deallocate mwPriceDataTableNameCursor;
			end
			else
			begin
				--Секционирование не используется
				update dbo.mwPriceDataTable with(rowlock)
				set pt_isenabled = 0
				where exists(select 1 from #mwReplDeletedPricesTemp r where r.rdp_pricekey = pt_pricekey);
			end
		end
	end
	
	drop index x_pricekey on #mwReplDeletedPricesTemp;
	drop table #mwReplDeletedPricesTemp;
end
GO

GRANT EXECUTE ON [dbo].[mwReplDisableDeletedPrices] TO PUBLIC
GO
/*********************************************************************/
/* end sp_mwReplDisableDeletedPrices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplAddSubscription.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwReplAddSubscription]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwReplAddSubscription]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--<VERSION>ALL</VERSION>
--<DATE>2012-03-28</DATE>
-- MEG00032642. 03.03.2012. Golubinsky.
-- Вставляет запись о подписчике в таблицу SystemSettings как настройку Subscriptions

CREATE PROCEDURE mwReplAddSubscription
(
	@linkedServerName nvarchar(50),				-- имя linked-сервера, через который будет обращение к серверу с поисковой БД
	@subscriptionDatabaseName nvarchar(100)		-- название поисковой БД	
)
AS
BEGIN
	SET NOCOUNT ON;

	if dbo.mwReplIsPublisher() = 0
	begin
		return
	end

	-- облачим в скобки переданные имена, если их передали без кавычек
    if substring(@linkedServerName, 1, 1) <> '['
		set @linkedServerName = '[' + @linkedServerName

	if substring(@linkedServerName, len(@linkedServerName), 1) <> ']'
		set @linkedServerName = @linkedServerName + ']'

	if substring(@subscriptionDatabaseName, 1, 1) <> '['
		set @subscriptionDatabaseName = '[' + @subscriptionDatabaseName

	if substring(@subscriptionDatabaseName, len(@subscriptionDatabaseName), 1) <> ']'
		set @subscriptionDatabaseName = @subscriptionDatabaseName + ']'

	-- проверим, есть ли уже запись с переданным сервером и базой данных
	if not exists (select linkedServerName, subscriptionDatabaseName 
					from dbo.mwReplGetSubscriptions() as existingSeeting
					where linkedServerName = @linkedServerName 
							and subscriptionDatabaseName = @subscriptionDatabaseName)
	begin
	
		if exists(select ss_parmname from dbo.SystemSettings where ss_parmname = 'Subscriptions')
		begin			
			update dbo.SystemSettings
			set
				SS_ParmValue = (case
									when (len(SS_ParmValue) = 0) or (SS_ParmValue is null)
										then @linkedServerName + '.' + @subscriptionDatabaseName
									else SS_ParmValue + ',' + @linkedServerName + '.' + @subscriptionDatabaseName
								end
								)
			where
				ss_parmname = 'Subscriptions'
		end
		else
		begin
			insert into dbo.SystemSettings(
				ss_parmname,
				ss_parmvalue
			)
			values(
				'Subscriptions',
				@linkedServerName + '.' + @subscriptionDatabaseName
			)
		end
	
	end
END
GO

GRANT EXECUTE ON [dbo].[mwReplAddSubscription] TO PUBLIC
GO

GRANT CONTROL ON [dbo].[mwReplAddSubscription] TO [public]
GO
/*********************************************************************/
/* end sp_mwReplAddSubscription.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplRemoveSubscription.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwReplRemoveSubscription]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwReplRemoveSubscription]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--<VERSION>ALL</VERSION>
--<DATE>2012-03-28</DATE>
-- MEG00032642. 03.03.2012. Golubinsky.
-- Удаляет запись о подписчике из таблицы SystemSettings (настройка Subscriptions)

CREATE PROCEDURE mwReplRemoveSubscription
(
	@linkedServerName nvarchar(50),				-- имя linked-сервера, через который будет обращение к серверу с поисковой БД
	@subscriptionDatabaseName nvarchar(100)			-- название поисковой БД	
)
AS
BEGIN
	SET NOCOUNT ON;

	if dbo.mwReplIsPublisher() = 0
	begin
		return
	end

	-- облачим в скобки переданные имена, если их передали без кавычек
    if substring(@linkedServerName, 1, 1) <> '['
		set @linkedServerName = '[' + @linkedServerName

	if substring(@linkedServerName, len(@linkedServerName), 1) <> ']'
		set @linkedServerName = @linkedServerName + ']'

	if substring(@subscriptionDatabaseName, 1, 1) <> '['
		set @subscriptionDatabaseName = '[' + @subscriptionDatabaseName

	if substring(@subscriptionDatabaseName, len(@subscriptionDatabaseName), 1) <> ']'
		set @subscriptionDatabaseName = @subscriptionDatabaseName + ']'

	declare @existingParmValue as nvarchar(max)
	select @existingParmValue = ss_parmvalue from dbo.SystemSettings where ss_parmname = 'Subscriptions'
	
	set @existingParmValue = replace(@existingParmValue, @linkedServerName + '.' + @subscriptionDatabaseName, '')

	set @existingParmValue = replace(@existingParmValue, ',,', ',')
	
	if @existingParmValue like ',%'
		set @existingParmValue = SUBSTRING(@existingParmValue, 2, len(@existingParmValue))
	
	if @existingParmValue like '%,'
		set @existingParmValue = SUBSTRING(@existingParmValue, 1, len(@existingParmValue)-1)
	
	update SystemSettings
	set SS_ParmValue = @existingParmValue
	where SS_ParmName = 'Subscriptions'

END
GO

GRANT EXECUTE ON [dbo].[mwReplRemoveSubscription] TO PUBLIC
GO

GRANT CONTROL ON [dbo].[mwReplRemoveSubscription] TO [public]
GO
/*********************************************************************/
/* end sp_mwReplRemoveSubscription.sql */
/*********************************************************************/

/*********************************************************************/
/* begin view_mwFlightDirections.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='v' and name='mwFlightDirections')
	drop view dbo.mwFlightDirections
go

Create view [dbo].[mwFlightDirections] as
select distinct 
	tl_key as fd_trkey
	, tl_cnkey as fd_cnkey
	, ch_citykeyfrom as fd_ctkeyfrom
	, ch_citykeyto as fd_ctkeyto
from tbl_TurList with(nolock) 
inner join turservice with(nolock) on (tl_key = ts_trkey and ts_svkey = 1) 
inner join descriptions with(nolock) 
					on tl_key = ds_pkkey and ds_dtkey = 115 
							and ds_tableid = 37 
							and ds_value like '%1%'
inner join tbl_Costs with(nolock) on	(cs_svkey = 1 and cs_pkkey = ts_pkkey ) 
inner join Charter with(nolock) on (cs_svkey = 1 and cs_code = ch_key 
									and ch_citykeyfrom = ts_subcode2 
									and  ch_citykeyto = ts_ctkey)
where 
	IsNull(cs_dateend, '2100-01-01') >= getdate() 
	and IsNull(cs_checkindateend, '2100-01-01') >=getdate() 
	and exists(select top 1 td_trkey 
					from turdate with(nolock) 
					where td_date >= getdate()
							and td_trkey = tl_key)

go
grant select on dbo.mwFlightDirections to public
go
/*********************************************************************/
/* end view_mwFlightDirections.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwCheckQuotesEx2.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwCheckQuotesEx2]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
	DROP FUNCTION [dbo].[mwCheckQuotesEx2]
GO

CREATE FUNCTION [dbo].[mwCheckQuotesEx2]
(
	@svkey int, 
	@code int, 
	@subcode1 int,
	@subcode2 int, 
	@agentKey int, 
	@partnerKey int, 
	@date datetime,
	@day int,
	@days int,
	@requestOnRelease smallint, 
	@noPlacesResult int, 
	@checkAgentQuotes smallint, 
	@checkCommonQuotes smallint,
	@checkNoLongQuotes smallint,
	@findFlight smallint,
	@cityFrom int,
	@cityTo int,
	@flightpkkey int,
	@tourDuration int,
	@expiredReleaseResult int,
	@linked_day int = null)

returns @tmpResQuotes table(
	qt_svkey int,
	qt_code int,
	qt_subcode1 int,
	qt_subcode2 int,
	qt_agent int,
	qt_prkey int,
	qt_bycheckin int,
	qt_byroom int,
	qt_places int,
	qt_allPlaces int,
	qt_type int,
	qt_long int,
	qt_additional varchar(2000))
begin
	--<VERSION>ALL</VERSION>
	--<DATE>2012-04-28</DATE>

      declare @isSubCode2 smallint
      select @isSubCode2 = isnull(SV_ISSUBCODE2, 0) from [Service] where SV_key = @svkey
      if(@isSubCode2 <= 0)
            set @subcode2 = 0
            
      if(@svkey = 1)
            set @subcode2 = -1

      -- MEG00023260 Paul G 20.12.2010
      -- сделал для 9-й версии более гибкую настройку @noPlacesResult
      if exists(select 1 from systemsettings where ss_parmname like 'NoPlacesQuoteResult_' + convert(varchar, @svkey))
      begin
            select @noPlacesResult = cast(IsNull(ss_parmvalue,@noPlacesResult) as int) from systemsettings where ss_parmname like 'NoPlacesQuoteResult_' + convert(varchar, @svkey)
      end
      -- End MEG00023260

	if (@svkey = 1)
	begin
		declare @tariffToStop varchar(20)
		set @tariffToStop = ',' + ltrim(str(@subcode1)) + ','
		if exists(select 1 from dbo.systemsettings where ss_parmname='MWTariffsToStop' and charindex(@tariffToStop, ',' + ss_parmvalue + ',') > 0)
			set @noPlacesResult = 0
	end

	declare @ALLDAYS_CHECK int
	set @ALLDAYS_CHECK = -777

	-- для квот на продолжительность
	declare @long int
	if(@svkey = 1 or @svkey = 2 or @svkey = 4 or @checkNoLongQuotes = @ALLDAYS_CHECK)
		set @long = @tourDuration
	else
		set @long = @days

	if(@day <= 0 or @day is null)
		set @day = 1
	if(@days <= 0 or @days is null)
		set @days = 1


	declare @dateFrom datetime
	declare @dateTo datetime
	set @dateFrom = dateadd(day, @day - 1, @date)
	set @dateTo = dateadd(day, @day + @days - 2, @date)
	--karimbaeva 20-04-2012 не было обаботки квот, если стоп ставиться плагином Stop-sale на авиаперелеты
	declare @linked_date datetime, @dt1 datetime, @dt2 datetime, @ctFromStop int, @ctToStop int
	if @linked_day is not null
	begin
		set @linked_date = dateadd(day, @linked_day - 1, @date)
		if(@linked_date > @dateFrom)
		begin
			set @dt1 = @dateFrom
			set @dt2 = @linked_date
		end
		else
		begin
			set @dt1 = @linked_date
			set @dt2 = @dateFrom
		end
	end

	declare @tmpSubcode1 int
	if(@svkey = 3 and @subcode1 > 0 and @subcode2 <= 0) -- hotelRoomKey --> subcode1, subcode2
	begin
		select @tmpSubcode1 = hr_rmkey, @subcode2 = hr_rckey from hotelrooms with(nolock) where hr_key = @subcode1
		set @subcode1 = @tmpSubcode1
	end

				
	
	declare @result int
	declare @currentDate datetime
	select @currentDate = currentDate from dbo.mwCurrentDate


	declare @qtSvkey int, @qtCode int, @qtSubcode1 int, @qtSubcode2 int, @qtAgent int,
		@qtPrkey int, @qtNotcheckin int, @qtRelease int, @qtPlaces int, @qtDate datetime,
		@qtByroom int, @qtType int, @qtLong int, @qtPlacesAll int, @qtStop smallint, @qtQoId int

	declare	@svkeyRes int, @codeRes int, @subcode1Res int, 
		@subcode2Res int, @agentRes int, @prkeyRes int,
		@bycheckinRes int, @byroomRes int, @placesRes int,
		@allPlacesRes int, @typeRes int, @longRes int, @releaseRes int, @additional varchar(2000), @stopSale smallint

	set @svkeyRes = 0
	set @codeRes = 0
	set @subcode1Res = 0
	set @subcode2Res = 0
	set @agentRes = 0
	set @prkeyRes = 0
	set @bycheckinRes = 0
	set @byroomRes = 0
	set @typeRes = 0
	set @allPlacesRes = 0
	set @longRes = 0
	set @releaseRes = -1
	set @additional = ''

	declare @tmpQuotes table(
		qt_svkey int,
		qt_code int,
		qt_subcode1 int,
		qt_subcode2 int,
		qt_agent int,
		qt_prkey int,
		qt_bycheckin int,
		qt_release int,
		qt_places int,
		qt_date datetime,
		qt_byroom int,
		qt_type int,
		qt_long int,
		qt_placesAll int,
		qt_stop smallint,
		qt_qoid int
	)

	declare @tmpDate datetime
	declare @dayOfWeek int

	if(@svkey <> 1 or @findFlight <= 0)
	begin
		if(@svkey = 1)
		begin

			if(isnull(@cityFrom, 0) <= 0 or isnull(@cityTo, 0) <= 0)
				select @cityFrom = ch_citykeyfrom, @cityTo = ch_citykeyto from charter with(nolock) where ch_key = @code
				
			--karimbaeva 20-04-2012 не было обаботки квот, если стоп ставиться плагином Stop-sale на авиаперелеты
			if(@linked_date is not null and @linked_date < @dateFrom)
			begin
				set @ctFromStop = @cityTo
				set @ctToStop = @cityFrom
			end
			else
			begin
				set @ctFromStop = @cityFrom
				set @ctToStop =@cityTo
			end

			set @dayOfWeek = datepart(dw, @dateFrom) - 1
			if(@dayOfWeek = 0)
				set @dayOfWeek = 7

				if (@flightpkkey < 0)
				begin
					 if not exists(select top 1 ch_key from charter with(nolock) inner join airseason with(nolock) on as_chkey = ch_key
				where ch_key = @code 
					and (AS_WEEK is null or len(as_week)=0 or as_week like ('%' + cast(@dayOfWeek as varchar) + '%')) -- Golubinsky. 13.12.2011. MEG00039207. проверка AS_WEEK на случай, когда поле не заполнено
					and (as_dateFrom is null or (as_dateFrom is not null and @dateFrom >= as_dateFrom))
					and (AS_DATETO is null or (AS_DATETO is not null and @dateFrom <= AS_DATETO)))	-- Golubinsky. 13.12.2011. MEG00039207. проверка диапазона дат на случай, если as_dateFrom и AS_DATETO null
					begin
						insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
							return 
					end
				end
				else
				begin
			if (@flightpkkey >= 0)
			begin
			--karimbaeva 20-04-2012 не было обаботки квот, если стоп ставиться плагином Stop-sale на авиаперелеты
			 if not exists(select top 1 ch_key from charter with(nolock) inner join airseason with(nolock) on as_chkey = ch_key
						inner join tbl_costs on (cs_svkey = 1 and cs_code = ch_key 
						and (@dateFrom between cs_date and cs_dateend
							or @dateFrom between cs_checkindatebeg and cs_checkindateend)
						and cs_subcode1=@subcode1 and cs_pkkey = @flightpkkey)
						where ch_key = @code 
							and (AS_WEEK is null or len(as_week)=0 or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
							and (as_dateFrom is null or (as_dateFrom is not null and @dateFrom >= as_dateFrom))
							and (AS_DATETO is null or (AS_DATETO is not null and @dateFrom <= AS_DATETO)))
				or exists(select 1 from dbo.stopavia with(nolock) 
						where sa_ctkeyfrom = @ctFromStop and sa_ctkeyto = @ctToStop
							and isnull(sa_stop, 0) > 0 
							and sa_dbeg = @dt1 and sa_dend = @dt2)
				begin
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
						qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
					values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
						return 
				end
				end
			end
		end


					
		--

		insert into @tmpQuotes
		select 
			qo_svkey,
			qo_code,
			isnull(qo_subcode1, 0) as qo_subcode1,
			isnull(qo_subcode2, 0) as qo_subcode2,
			isnull(qp_agentkey, 0) as qp_agentkey,
			isnull(qt_prkey, 0) as qt_prkey,
			isnull(qp_isnotcheckin, 0) as qp_isnotcheckin, 
			qd_release, 
			isnull(qp_places, 0) - isnull(qp_busy, 0),
			qd_date,
			qt_byroom,
			qd_type,
			isnull(ql_duration, 0) as ql_duration,
			isnull(qp_places, 0),
			(case when (isnull(ss_id, 0) > 0 and isnull(ss_isdeleted, 0) = 0) then 1 else 0 end) as qt_stop,
			qo_id as qt_qoid
		from quotas q with(nolock) inner join 
			quotadetails qd with(nolock) on qt_id = qd_qtid inner join quotaparts qp with(nolock) on qd_id = qp_qdid
			left outer join quotalimitations ql with(nolock) on qp_id = ql_qpid
			right outer join quotaobjects qo with(nolock) on qt_id = qo_qtid 
			left outer join StopSales ss with(nolock) on (qd_id = ss_qdid and isnull(ss_isdeleted, 0) = 0)
		where
			qo_svkey = @svkey
			--and isnull(QP_IsNotCheckin, 0) = 0
			and qo_code = @code
			and isnull(qo_subcode1, 0) in (0, @subcode1)
			and isnull(qo_subcode2, 0) in (0, @subcode2)
			and ((@checkAgentQuotes > 0 and @checkCommonQuotes > 0 and isnull(qp_agentkey, 0) in (0, @agentKey)) or
				(@checkAgentQuotes <= 0 and isnull(qp_agentkey, 0) = 0) or
				(@checkAgentQuotes > 0 and @checkCommonQuotes <= 0 and isnull(qp_agentkey, 0) in (0, @agentKey)))
			and (@partnerKey < 0 or isnull(qt_prkey, 0) in (0, @partnerKey))
			and ((@days = 1 and qd_date = @dateFrom) or (@days > 1 and qd_date between @dateFrom and @dateTo))
			and (@tourDuration < 0 or (@checkNoLongQuotes <> @ALLDAYS_CHECK and isnull(ql_duration, 0) in (0, @long)) or (@checkNoLongQuotes = @ALLDAYS_CHECK and isnull(ql_duration, 0) = @long))
			and not exists (select top 1 1 
									from StopSales inner join QuotaObjects on qo_id=ss_qoid
									where ((@days = 1 and ss_date = @dateFrom) or (@days > 1 and ss_date between @dateFrom and @dateTo))
									and ss_qdid is null
									and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
									and isnull(ss_isdeleted, 0) = 0
									and qd.QD_Type = (SS_AllotmentAndCommitment + 1)
									and qo_svkey = @svkey
									and qo_code = @code
									and isnull(qo_subcode1, 0) in (0, @subcode1)
									and isnull(qo_subcode2, 0) in (0, @subcode2))
		-- Paul G 07.02.2011 MEG00031547, MEG00031454
		-- Не отлавливались такие дни, на которые нет квот, но есть стоп-сейл.
		-- Да и вообще не учитывались стопы с пустой ссылкой на QuotaDetails.
		-- Добавил union, который учитывает стопы с пустой ссылкой на QuotaDetails.
		union
			select
				qo_svkey,
				qo_code,
				isnull(qo_subcode1, 0) as qo_subcode1,
				isnull(qo_subcode2, 0) as qo_subcode2,
				0,
				isnull(ss_prkey, 0) as qt_prkey,
				0,null,0,ss_date,null,isnull(SS_AllotmentAndCommitment, 0) + 1,0,0,1,
				qo_id as qt_qoid
			from StopSales
				inner join QuotaObjects on qo_id=ss_qoid
			where ((@days = 1 and ss_date = @dateFrom) or (@days > 1 and ss_date between @dateFrom and @dateTo))
					and ss_qdid is null
					and isnull(ss_isdeleted, 0) = 0
					and qo_svkey = @svkey
					and qo_code = @code
					and isnull(qo_subcode1, 0) in (0, @subcode1)
					and isnull(qo_subcode2, 0) in (0, @subcode2)
					and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
		order by
			qd_date, qp_agentkey DESC, qd_type DESC, QT_PrKey DESC, qp_isnotcheckin, ql_duration DESC, qo_subcode1 DESC, qo_subcode2 DESC

		if(@tourDuration < 0) -- надо проверить все возможные квоты по дням на все возможные продолжительности (используется при проверке наличия мест в отеле и на перелете)
		begin
			set @checkNoLongQuotes = @ALLDAYS_CHECK

			declare @durations table(
				duration int
			)

			insert into @durations select distinct qt_long from @tmpQuotes order by qt_long

			declare @rowCount int
			set @rowCount = @@rowCount

			if(@rowCount > 1)
			begin
				declare @quotaDuration int
				declare durationCur cursor fast_forward read_only for
					select duration from @durations
	
				open durationCur
	
				fetch next from durationCur into @quotaDuration
				while(@@fetch_status = 0)
				begin
					if(len(@additional) > 0)
						set @additional = @additional + '|'
	
					select 
						@additional = @additional + qt_additional
					from dbo.mwCheckQuotesEx(@svkey, @code, @subcode1, @subcode2, @agentKey, @partnerKey, 
						@date, @day, @days, @requestOnRelease, @noPlacesResult, @checkAgentQuotes, 
						@checkCommonQuotes, @ALLDAYS_CHECK, @findFlight, @cityFrom,	@cityTo, @flightpkkey,
						@quotaDuration,	@expiredReleaseResult)
	
					fetch next from durationCur into @quotaDuration
				end
	
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, @additional)
			
				close durationCur
				deallocate durationCur
	
				return
			end
			else if(@rowCount = 1)
				select @long = duration from @durations
			else
				set @long = 0
		end
		else
		begin
			-- check stopsale
			-- MT ignore stop on object for commitment quotas
			if exists(select 1 
					from stopsales with(nolock) 
						inner join quotaobjects qo with(nolock) on ss_qoid = qo_id
					where qo_svkey = @svkey and qo_code = @code and isnull(qo_subcode1, 0) in (0, @subcode1)
						and isnull(qo_subcode2, 0) in (0, @subcode2) and ss_date between @dateFrom and @dateTo
						and (ss_qdid is null ) 
						and isnull(ss_isdeleted, 0) = 0 
						and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
						-- MEG00032187 Paul G 14.02.2011
						-- Отсеиваем те стопы, которые ставятся только на allotment (ss_allotmentandcommitment = 0)
						-- и по которым на соответствующие дни есть квоты commitment.
						and (IsNull(ss_allotmentandcommitment, 0) = 1 
							or not exists(select 1 from
							quotas with(nolock) inner join quotaobjects qo1 with(nolock) on
							qo1.qo_qtid = qt_id inner join quotadetails with(nolock) on qd_qtid = qt_id
						--MEG00029495 Paul G 18.02.2010
						--Добавил условие qd_places > qd_busy
						--Смысл в том, что это условие должно проверять существование квот commitment на некоторые дни, но только тех
						--на которые еще есть места. Иначе возможна ситуация, когда на все commitment закончились места, а allotment на стопе
						--и проверка на наличие стопа не сработает
							 where qo.qo_svkey = qo1.qo_svkey and qo.qo_code = qo1.qo_code and qo.qo_subcode1 in (qo1.qo_subcode1, 0) and qo.qo_subcode2 in (qo1.qo_subcode2, 0) and qd_date = ss_date and qd_places > qd_busy and qd_type = 2 /*commitment*/)))
			begin
						insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
							return 
			end

		end

		if ( isnull((select min(qt_bycheckin)
					from @tmpQuotes
					where qt_date = @dateFrom), 1) = 1 AND @checkNoLongQuotes != @ALLDAYS_CHECK AND (SELECT CASE WHEN (SELECT COUNT(*) FROM @tmpQuotes) > 0 THEN 1 ELSE 0 END)=1)
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
									qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
								values(0, 0, 0, 0, 0, 0, 0, 0, case when @stopSale > 0 then 0 else @noPlacesResult end, 0, 0, 0)
								return
		end

		if isnull((select max(stopSale)
					from (	select min(qt_stop) as stopSale
							from @tmpQuotes
							where qt_qoid = (select top 1 qt_qoid from @tmpQuotes where qt_date = @dateFrom) and isnull(qt_prkey, 0) = isnull(@partnerkey, 0)
							group by qt_date) as tbl), 0) = 1
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
							return 
		end		

		-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
		declare @prevSubCode1 int, @prevSubCode2 int, @prevQtType int
		-- MEG00024921 End

		declare qCur cursor fast_forward read_only for 
		select
			qt_svkey,
			qt_code,
			qt_subcode1,
			qt_subcode2,
			qt_agent,
			qt_prkey,
			qt_bycheckin,
			qt_release,
			qt_places,
			qt_date,
			qt_byroom,
			qt_type,
			qt_long,
			qt_placesAll,
			qt_stop,
			qt_qoid
		from @tmpQuotes

		open qCur

		fetch next from qCur 
			into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
				@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, 
				@qtByroom, @qtType, @qtLong, @qtPlacesAll, @qtStop, @qtQoId

		-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
		set @prevSubCode1 = @qtSubcode1
		set @prevSubCode2 = @qtSubcode2
		set @prevQtType = @qtType
		-- MEG00024921 End

		if(@@fetch_status = 0)
		begin
			set @result = 1000000

			declare @prevDate datetime, @dateRes int, @dateAllPlaces int, 
				@wasLongQuota smallint, @wasAgentQuota smallint, @checkAfterWasLong smallint, @checkAfterWasAgent smallint

			set @prevDate = @dateFrom
			if(@qtDate = @dateFrom)
				set @dateRes = 0
			else
				set @dateRes = -1
			set @dateAllPlaces = 0
			set @stopSale = 1
			set @wasLongQuota = 0
			set @wasAgentQuota = 0
			set @checkAfterWasLong = 0
			set @checkAfterWasAgent = 0	

			declare @quoteOnFirstDayExist smallint -- признак существования квоты на ПЕРВЫЙ день
				set @quoteOnFirstDayExist = 0

			while(@@fetch_status = 0)
			begin

				if(@qtStop > 0) -- stop sale
				begin
					close qCur
					deallocate qCur

					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
						qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
					values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
					return
				end

				if(@checkNoLongQuotes != @ALLDAYS_CHECK)
				begin
					-- Если обрабатываемая квота - квота на первый день, то выставляем индикатор в true
					if (@qtDate = @dateFrom and @qtNotcheckin = 0)
						set @quoteOnFirstDayExist = 1

					-- Если обрабатываемая квота - квота НЕ на первый день и в первый день ее не обнаруживалось, то возвращаем ЗАПРОС
					if (@qtDate != @dateFrom and @quoteOnFirstDayExist = 0)
					begin
						--MEG00032854 Paul G 05.04.2011
						--раньше в этом месте анализ квот прекращался и возвращался запрос, но это неправильно. 
						set @dateRes = -1
					end
				end

				--MEG00035270 Paul G 14.06.2011
				--для дальнейшего анализа квоты необходимо выполнение условия:
				--если она не на заезд, то должна найтись другая квота на заезд, на день предоставления услуги, но в том же объекте квотирования
				--эта проверка нужна для того, чтобы при наличии 2-х объектов квотирования с разными разбиениями на заезды не пересекались
				if (@qtNotcheckin = 1 and not exists(select 1 from @tmpQuotes where qt_qoid = @qtQoId and qt_bycheckin = 0 and qt_date = @dateFrom))
				begin
					fetch next from qCur 
						into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
							@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, 
							@qtByroom, @qtType, @qtLong, @qtPlacesAll, @qtStop, @qtQoId

					continue
				end
				--End MEG00035270

				if(@qtNotcheckin <= 0 or @qtDate <> @dateFrom or @checkNoLongQuotes = @ALLDAYS_CHECK)
				begin
					if(@prevDate != @qtDate)
					begin

						if(@dateRes = 0 /*and @stopSale <= 0*/ and ((@wasLongQuota > 0 and @checkAfterWasLong <= 0 and @checkNoLongQuotes > 0) or (@wasAgentQuota > 0 and @checkAfterWasAgent <= 0 and @checkCommonQuotes > 0)))
							set @dateRes = -1
				
						if(@checkNoLongQuotes = @ALLDAYS_CHECK)
						begin
							if(len(@additional) > 0)
								set @additional = @additional + ','

							if(@dateRes = 0 and @stopSale <= 0)
								set @dateRes = @noPlacesResult

							set @additional = @additional + ltrim(str(@dateRes)) + ':' + ltrim(str(@dateAllPlaces))
						end
						else
						if(@dateRes <= 0 or @dateRes < @result or @qtStop > 0)
						begin
							set @result = @dateRes
							set @allPlacesRes = @dateAllPlaces -- total places in quota

							if(@result = 0 or @qtStop > 0) -- no places
							begin
								close qCur
								deallocate qCur

								insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
									qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
								values(0, 0, 0, 0, 0, 0, 0, 0, case when @qtStop > 0 then 0 else @noPlacesResult end, 0, 0, 0)
								return
							end
						end
						else
						begin
							if(@wasLongQuota > 0)
								set @checkAfterWasLong = 1

							if(@wasAgentQuota > 0)
								set @checkAfterWasAgent = 1
						end
		
						if(datediff(day, @prevDate, @qtDate) > 1) -- there are days for wich quota doesn't exist
						begin
							set @result = -1 -- request
							if(@checkNoLongQuotes = @ALLDAYS_CHECK)
							begin
								set @tmpDate = dateadd(day, 1, @prevDate)
								while(@tmpDate < @qtDate)
								begin
									if(len(@additional) > 0)
										set @additional = @additional + ','

									set @additional = @additional + '-1:0'
									set @tmpDate = dateadd(day, 1, @tmpDate)
								end
							end
						end

						
							
						set @prevDate = @qtDate
						set @dateRes = 0
						set @dateAllPlaces = 0
						set @stopSale = 1
						set @wasLongQuota = 0
						set @wasAgentQuota = 0
						set @checkAfterWasLong = 0
						set @checkAfterWasAgent = 0

						-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
						set @prevSubCode1 = @qtSubcode1
						set @prevSubCode2 = @qtSubcode2
						set @prevQtType = @qtType
						-- MEG00024921 End

					end
					
					if( -- MEG00024921, Danil, 10.02.2010: это условие было странным образом закомментарено + добавлена проверка на qtStop.
						-- Привел логику в соответствие с версией хранимки для 2007.2, где в аналогичной ситуации все работает.
						-- Проверку на qtStop перенес в следующий if
						(@stopSale <= 0 or ((@prevSubCode1 = @qtSubcode1 and @prevSubCode2 = @qtSubcode2) or @prevQtType <> @qtType))
						and not(@agentKey > 0 and @qtAgent = 0 and @wasAgentQuota > 0 and (@checkCommonQuotes <= 0))
								and not(@long > 0 and @qtLong = 0 and @wasLongQuota > 0 and (@checkNoLongQuotes <= 0)))
					begin
						if((@qtRelease is null or datediff(day, @currentDate, @qtDate) > isnull(@qtRelease, 0))
							-- MEG00024921, Danil, 10.02.2010: сюда перенес проверку на qtStop из условия выше (по аналогии с версией 2007.2)
							and isnull(@qtStop, 0) = 0)
							-- MEG00024921 End
						begin
							if((@requestOnRelease <= 0 or @qtRelease is null or @qtRelease > 0) and
								@qtPlaces > 0 and not(@stopSale > 0 and @wasAgentQuota > 0 /*request for agents if they have agent quota and this quota is stopped (they try to reserve general quota by low cost)*/))
							begin
								set @dateRes = @dateRes + @qtPlaces
								set @dateAllPlaces = @dateAllPlaces + @qtPlacesAll
								
								if (@qtPlaces < @result) -- result перезапишется
								begin
									set @svkeyRes = @qtSvkey
									set @codeRes = @qtCode
									set @subcode1Res = @qtSubcode1
									set @subcode2Res = @qtSubcode2
									set @agentRes = @qtAgent
									set @prkeyRes = @qtPrkey										
									set @byroomRes = @qtByroom
									set @typeRes = @qtType
									set @longRes = @qtLong
									set @releaseRes = @qtRelease
								end
							end
							else if(@qtPlaces > 0)
								set @dateRes = -1
						end
						else 
						begin
							if(isnull(@qtStop, 0) = 0 and @qtPlaces > 0)
								set @dateRes = @expiredReleaseResult -- no or request (0 or -1)
							else
							-- MEG00024921, Danil, 10.02.2010: добавил эту секцию, чтобы в случае, если не стоп, 
							-- а просто закончились места возвращалось @noPlacesResult
							if(isnull(@qtStop, 0) = 0)
							begin
								set @dateRes = @noPlacesResult -- no places
							end
							else
							-- MEG00024921 End
							begin
								set @dateRes = 0 -- stop sale
								set @result = 0
							end
						end
						--set @bycheckinRes =  1 - @qtNotcheckin
--set @bycheckinRes =  0
						
						-- MEG00024921, Danil, 10.02.2010: простановка признака "был ли стоп" для проверяемой даты
						-- опять же по аналогии с 2007.2
						if (isnull(@qtStop, 0) = 0)
							set @stopSale = 0
						-- MEG00024921 End
					end
					else if(@dateRes = 0 and @checkNoLongQuotes <> @ALLDAYS_CHECK)
					begin
						close qCur
						deallocate qCur
						insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
						-- MEG00024921, Danil, 10.02.2010: добавил значение qt_additional и его заполнение
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, case when @stopSale > 0 then 0 else @noPlacesResult end, 0, 0, 0, '0=0:0')
						-- MEG00024921 End
						return 
					end

					if(@wasAgentQuota <= 0 and @qtAgent > 0) -- признак того, что агентская квота заведена, но закончилась
						set @wasAgentQuota = 1
					if(@wasLongQuota <= 0 and @qtLong > 0)  -- признак того, что квота на продолжительность заведена, но закончилась
						set @wasLongQuota = 1
				end

				-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
				set @prevSubCode1 = @qtSubcode1
				set @prevSubCode2 = @qtSubcode2
				set @prevQtType = @qtType
				-- MEG00024921 End
				
				fetch next from qCur into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
					@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, @qtByroom, @qtType, 
					@qtLong, @qtPlacesAll, @qtStop, @qtQoId
			end

			if(@checkNoLongQuotes = @ALLDAYS_CHECK)
			begin
				if(len(@additional) > 0)
					set @additional = @additional + ','

				if(@dateRes = 0 and @stopSale <= 0)
					set @dateRes = @noPlacesResult
				
				set @additional = @additional + ltrim(str(@dateRes)) + ':' + ltrim(str(@dateAllPlaces))
			end
			else
			if(@dateRes <= 0 or @dateRes < @result)
			begin
				set @result = @dateRes
				set @allPlacesRes = @dateAllPlaces -- total places in quota

				if(@result = 0) -- iano iao
					set @result = case when @stopSale > 0 then 0 else @noPlacesResult end
			end

			if(@qtDate <> @dateTo and ((@result > 0 and @bycheckinRes <= 0) or @checkNoLongQuotes = @ALLDAYS_CHECK)) -- ia iaio ec aao aeaiaciia eaioa ia caaaaaia
			begin
				set @result = -1 -- cai?in
				if(@checkNoLongQuotes = @ALLDAYS_CHECK)
				begin
					set @tmpDate = dateadd(day, 1, @qtDate)
					while(@tmpDate <= @dateTo)
					begin
						if(len(@additional) > 0)
							set @additional = @additional + ','

						set @additional = @additional + '-1:0'
						set @tmpDate = dateadd(day, 1, @tmpDate)
					end
				end
			end
		end
		else
		begin
			set @result = -1
			if(@checkNoLongQuotes = @ALLDAYS_CHECK)
			begin
				set @tmpDate = @dateFrom
				while(@tmpDate <= @dateTo)
				begin
					if(len(@additional) > 0)
						set @additional = @additional + ','

					set @additional = @additional + '-1:0'
					set @tmpDate = dateadd(day, 1, @tmpDate)								
				end
			end
		end
	end
	else
	begin
		set @partnerKey = -1 -- подбираем перелеты от разных партнеров
		if(isnull(@cityFrom, 0) <= 0 or isnull(@cityTo, 0) <= 0)
			select @cityFrom = ch_citykeyfrom, @cityTo = ch_citykeyto from charter with(nolock) where ch_key = @code
		
		if(@linked_date is not null and @linked_date < @dateFrom)
		begin
			set @ctFromStop = @cityTo
			set @ctToStop = @cityFrom
				end
		else
		begin
			set @ctFromStop = @cityFrom
			set @ctToStop =@cityTo
		end
			
		set @dayOfWeek = datepart(dw, @dateFrom) - 1
		if(@dayOfWeek = 0)
			set @dayOfWeek = 7
		
		--karimbaeva 20-04-2012 не было обаботки квот, если стоп ставиться плагином Stop-sale на авиаперелеты	
		if @flightpkkey >= 0
		begin
			if not exists(
				select top 1 ch_key 
				from charter with(nolock) 
				inner join airseason with(nolock) on as_chkey = ch_key
				inner join tbl_costs with(nolock) on (cs_svkey = 1 
														and cs_code = ch_key 
														and (@dateFrom between cs_date and cs_dateend
															or @dateFrom between cs_checkindatebeg and cs_checkindateend)
														and cs_subcode1=@subcode1 
														and cs_pkkey = @flightpkkey)
				where ch_citykeyfrom = @cityFrom 
						and ch_citykeyto = @cityTo 
						and (AS_WEEK is null 
								or len(as_week)=0 
								or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
						and @dateFrom between as_dateFrom and as_dateto
						)
			or exists(select 1 from dbo.stopavia with(nolock) 
						where sa_ctkeyfrom = @ctFromStop and sa_ctkeyto = @ctToStop
							and isnull(sa_stop, 0) > 0 
							and sa_dbeg = @dt1 and sa_dend = @dt2)
			begin
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
					return 
			end

			insert into @tmpQuotes
			select distinct
				qo_svkey,
				qo_code,
				isnull(qo_subcode1, 0) as qo_subcode1,
				isnull(qo_subcode2, 0) as qo_subcode2,
				isnull(qp_agentkey, 0) as qp_agentkey,
				isnull(qt_prkey, 0) as qt_prkey,
				isnull(qp_isnotcheckin, 0) as qp_isnotcheckin, 
				qd_release as qt_release, 
				isnull(qp_places, 0) - isnull(qp_busy, 0),
				qd_date,
				qt_byroom,
				qd_type,
				isnull(ql_duration, 0) as ql_duration,
				isnull(qp_places, 0),
				(case when (isnull(ss_id, 0) > 0 and isnull(ss_isdeleted, 0) = 0) then 1 else 0 end) as qt_stop,
				qo_id as qt_qoid
			from quotas q with(nolock) inner join 
				quotadetails qd with(nolock) on qt_id = qd_qtid inner join quotaparts qp with(nolock) on qd_id = qp_qdid
				left outer join quotalimitations ql with(nolock) on qp_id = ql_qpid
				right outer join quotaobjects qo with(nolock) on qt_id = qo_qtid 
				left outer join StopSales ss with(nolock) on (qd_id = ss_qdid and isnull(ss_isdeleted, 0) = 0)
				 inner join charter on (qo_svkey = @svkey and ch_key = qo_code) inner join airseason on as_chkey = ch_key
			where
				exists (select top 1 cs_id from tbl_costs with(nolock)
					where cs_svkey=@svkey and cs_code=qo_code and cs_subcode1=@subcode1 
						and (@dateFrom between cs_date and cs_dateend 
							or @dateFrom between cs_checkindatebeg and cs_checkindateend)
						and cs_pkkey = @flightpkkey)
				and qo_svkey = @svkey
				and isnull(qo_subcode1, 0) in (0, @subcode1)
			--	and isnull(qo_subcode2, 0) in (0, @subcode2)
				and ((@checkAgentQuotes > 0 and @checkCommonQuotes > 0 and isnull(qp_agentkey, 0) in (0, @agentKey)) or
					(@checkAgentQuotes <= 0 and isnull(qp_agentkey, 0) = 0) or
					(@checkAgentQuotes > 0 and @checkCommonQuotes <= 0 and isnull(qp_agentkey, 0) in (0, @agentKey)))
				and (@partnerKey < 0 or isnull(qt_prkey, 0) in (0, @partnerKey))
				and qd_date = @dateFrom
				and ch_citykeyfrom = @cityFrom and ch_citykeyto = @cityTo 
				and (AS_WEEK is null or len(as_week)=0 or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
				and @dateFrom between as_dateFrom and as_dateto
				and (@tourDuration < 0 or (@checkNoLongQuotes <> @ALLDAYS_CHECK and isnull(ql_duration, 0) in (0, @long)) or (@checkNoLongQuotes = @ALLDAYS_CHECK and isnull(ql_duration, 0) = @long))
			order by
				qd_date, qp_agentkey DESC, qd_type DESC, QT_PrKey DESC, qp_isnotcheckin, ql_duration DESC, qo_subcode1 DESC, qo_subcode2 DESC
		end
		else
		begin
		--karimbaeva 20-04-2012 не было обаботки квот, если стоп ставиться плагином Stop-sale на авиаперелеты
			if not exists(select top 1 ch_key from charter with(nolock) inner join airseason with(nolock) on as_chkey = ch_key
				where ch_citykeyfrom = @cityFrom and ch_citykeyto = @cityTo 
					and (AS_WEEK is null or len(as_week)=0 or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
					and @dateFrom between as_dateFrom and as_dateto)
				or exists(select 1 from dbo.stopavia with(nolock) 
						where sa_ctkeyfrom = @cityFrom and sa_ctkeyto = @cityTo
							and isnull(sa_stop, 0) > 0 
							and sa_dbeg = @dt1 and sa_dend = @dt2)
			begin
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
					return 
			end

			insert into @tmpQuotes
			select distinct
				qo_svkey,
				qo_code,
				isnull(qo_subcode1, 0) as qo_subcode1,
				isnull(qo_subcode2, 0) as qo_subcode2,
				isnull(qp_agentkey, 0) as qp_agentkey,
				isnull(qt_prkey, 0) as qt_prkey,
				isnull(qp_isnotcheckin, 0) as qp_isnotcheckin, 
				qd_release, 
				isnull(qp_places, 0) - isnull(qp_busy, 0),
				qd_date,
				qt_byroom,
				qd_type,
				isnull(ql_duration, 0) as ql_duration,
				isnull(qp_places, 0),
				(case when (isnull(ss_id, 0) > 0 and isnull(ss_isdeleted, 0) = 0) then 1 else 0 end) as qt_stop,
				qo_id as qt_qoid
			from quotas q with(nolock) inner join 
				quotadetails qd with(nolock) on qt_id = qd_qtid inner join quotaparts qp with(nolock) on qd_id = qp_qdid
				left outer join quotalimitations ql with(nolock) on qp_id = ql_qpid
				right outer join quotaobjects qo with(nolock) on qt_id = qo_qtid 
				left outer join StopSales ss with(nolock) on (qd_id = ss_qdid and isnull(ss_isdeleted, 0) = 0)
				inner join charter with(nolock) on (qo_svkey = @svkey and ch_key = qo_code) inner join airseason with(nolock) on as_chkey = ch_key
			where
				qo_svkey = @svkey
				--and isnull(QP_IsNotCheckin, 0) = 0
				and isnull(qo_subcode1, 0) in (0, @subcode1)
			--	and isnull(qo_subcode2, 0) in (0, @subcode2)
				and 
				(	(@agentKey != -666
						and ((@checkAgentQuotes > 0 and @checkCommonQuotes > 0 and isnull(qp_agentkey, 0) in (0, @agentKey)) or
						(@checkAgentQuotes <= 0 and isnull(qp_agentkey, 0) = 0) or
						(@checkAgentQuotes > 0 and @checkCommonQuotes <= 0 and isnull(qp_agentkey, 0) in (0, @agentKey)))
					)
					or (@agentKey = -666 and qp_agentkey>0)
				)
				and (@partnerKey < 0 or isnull(qt_prkey, 0) in (0, @partnerKey))
				and qd_date = @dateFrom
				and ch_citykeyfrom = @cityFrom and ch_citykeyto = @cityTo 
				and (AS_WEEK is null or len(as_week)=0 or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
				and @dateFrom between as_dateFrom and as_dateto
				and (@tourDuration < 0 or (@checkNoLongQuotes <> @ALLDAYS_CHECK and isnull(ql_duration, 0) in (0, @long)) or (@checkNoLongQuotes = @ALLDAYS_CHECK and isnull(ql_duration, 0) = @long))
			order by
				qd_date, qp_agentkey DESC, qd_type DESC, QT_PrKey DESC, qp_isnotcheckin, ql_duration DESC, qo_subcode1 DESC, qo_subcode2 DESC
		end

		update @tmpQuotes 
			set qt_stop = 1 
		from stopsales with(nolock) inner join quotaobjects qo with(nolock) on (ss_qoid = qo_id and ss_date = @dateFrom)
				where qt_svkey = qo.qo_svkey and qt_code = qo.qo_code 
					and isnull(qt_subcode1, 0) in (0, qo.qo_subcode1)
					and isnull(qt_subcode2, 0) in (0, qo.qo_subcode2)					
					and ss_qdid is null and isnull(ss_isdeleted, 0) = 0

		declare qCur cursor fast_forward read_only for 
		select
			qt_svkey,
			qt_code,
			qt_subcode1,
			qt_subcode2,
			qt_agent,
			qt_prkey,
			qt_bycheckin,
			qt_release,
			qt_places,
			qt_date,
			qt_byroom,
			qt_type,
			qt_long,
			qt_placesAll,
			qt_stop,
			qt_qoid
		from @tmpQuotes

		open qCur

		fetch next from qCur into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
			@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, @qtByroom, @qtType, 
			@qtLong, @qtPlacesAll, @qtStop, @qtQoId

		declare @prevCode int
		declare @wasAgent int
		declare @wasLong int		
		if(@@fetch_status = 0)
		begin
			set @result = 0
			set @stopSale = 1
			set @wasAgent = 0
			set @wasLong = 0
			while(@@fetch_status = 0)
			begin
				if((@wasLong > 0 and @qtLong = 0 and (@result <> 0 or @checkNoLongQuotes <= 0)) or (@wasAgent > 0 and @qtAgent = 0 and (@result <> 0 or @checkCommonQuotes <= 0)))
					break

				if(isnull(@qtStop, 0) = 0)
					set @stopSale = 0

				if(@qtLong > 0)
					set @wasLong = 1

				if(@qtAgent > 0)
					set @wasAgent = 1

				if(@qtPlaces > 0 and @qtPlaces > @result and isnull(@qtStop, 0) = 0)
				begin
					if(@qtRelease is null or datediff(day, @currentDate, @qtDate) > isnull(@qtRelease, 0))
					begin
							if(@requestOnRelease <= 0 or @qtRelease is null or @qtRelease > 0)
							begin
								set @result = @qtPlaces

								set @svkeyRes = @qtSvkey
								set @codeRes = @qtCode
								set @subcode1Res = @qtSubcode1
								set @subcode2Res = @qtSubcode2
								set @agentRes = @qtAgent
								set @prkeyRes = @qtPrkey
								set @bycheckinRes = 0
								set @byroomRes = @qtByroom
								set @typeRes = @qtType
								set @longRes = @qtLong
								set @allPlacesRes = @qtPlacesAll
								set @releaseRes = @qtRelease
							end
							else if(@result = 0)
								set @result = -1;
					end
					else
					begin if(@result = 0)
						set @result = @expiredReleaseResult
					end
				end
	
				fetch next from qCur into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
					@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, @qtByroom, @qtType, 
					@qtLong, @qtPlacesAll, @qtStop, @qtQoId
	
			end		

			if(@result = 0)
			begin
				if(@stopSale <= 0)
					set @result = @noPlacesResult
				else
					set @result = 0
			end
		end
		else
			set @result = -1
	end

	close qCur
	deallocate qCur

	if(@checkNoLongQuotes <> @ALLDAYS_CHECK)
	begin
		if (@result > 0)
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
				qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
			values(@svkeyRes, @codeRes, @subcode1Res, @subcode2Res, @agentRes, 
				@prkeyRes, @bycheckinRes, @byroomRes, @result, @allPlacesRes, @typeRes, @longRes)
		else
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
				qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
			values(0, 0, 0, 0, 0, 0, 0, 0, @result, 0, 0, 0)
	end
	else
	begin
			set @additional = ltrim(str(@long)) + '=' + @additional
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
				qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
			values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, @additional)
	end
	
	return
end
GO

GRANT SELECT ON [dbo].[mwCheckQuotesEx2] TO PUBLIC
GO

/*********************************************************************/
/* end fn_mwCheckQuotesEx2.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.19)_ADD_COLUMNS_Accmdmentype.sql */
/*********************************************************************/
-- кол-во взрослых на осн.месте
if not exists (select 1 from dbo.syscolumns where name = 'AC_NADMAIN' and id = object_id(N'[dbo].[Accmdmentype]'))
begin
	alter table dbo.Accmdmentype add AC_NADMAIN int null
end
go
-- кол-во детей на осн.месте
if not exists (select 1 from dbo.syscolumns where name = 'AC_NCHMAIN' and id = object_id(N'[dbo].[Accmdmentype]'))
begin
	alter table dbo.Accmdmentype add AC_NCHMAIN int null
end
go
-- кол-во взрослых на доп.месте
if not exists (select 1 from dbo.syscolumns where name = 'AC_NADEXTRA' and id = object_id(N'[dbo].[Accmdmentype]'))
begin
	alter table dbo.Accmdmentype add AC_NADEXTRA int null
end
go
-- кол-во детей на доп.месте
if not exists (select 1 from dbo.syscolumns where name = 'AC_NCHEXTRA' and id = object_id(N'[dbo].[Accmdmentype]'))
begin
	alter table dbo.Accmdmentype add AC_NCHEXTRA int null
end
go
-- количество инфантов на основном месте (из числа детей на основном месте)
if not exists (select 1 from dbo.syscolumns where name = 'AC_NCHISINFMAIN' and id = object_id(N'[dbo].[Accmdmentype]'))
begin
	alter table dbo.Accmdmentype add AC_NCHISINFMAIN int null
end
go
-- количество инфантов на доп. месте (из числа детей на доп. месте)
if not exists (select 1 from dbo.syscolumns where name = 'AC_NCHISINFEXTRA' and id = object_id(N'[dbo].[Accmdmentype]'))
begin
	alter table dbo.Accmdmentype add AC_NCHISINFEXTRA int null
end
go
/*********************************************************************/
/* end (2012.03.19)_ADD_COLUMNS_Accmdmentype.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.19)_Convert_Accmdmentype.sql */
/*********************************************************************/
-- конвертация данных, если столбец AC_NRealPlaces не калькулируемый
if exists(select 1 from dbo.syscolumns where name = 'AC_NRealPlaces'and id = object_id(N'[dbo].[Accmdmentype]') and iscomputed = 0)
begin

DECLARE @maxChildAge int

set @maxChildAge=
(SELECT [SS_ParmValue]
FROM [SystemSettings]
where [SS_ParmName]='SYSCheckChildAge')

if(@maxChildAge is null) begin
	set @maxChildAge=16
end

 update Accmdmentype
 set 
 --AC_NADMAIN - количество взрослых на основном месте
 AC_NADMAIN = case when AC_NRealPlaces is not null 
     then AC_NRealPlaces 
     else 
      case when AC_MAIN = 1 
       then 1 
       else 0 
      end
     end,
	 
     --AC_NADEXTRA - количество взрослых на дополнительном месте
     AC_NADEXTRA = case when isnull(AC_NMenExBed,case when AC_MAIN = 0  then 1 else 0 end)<=
						(case when isnull(AC_AGETO,100)<=@maxChildAge then
							1
						else
							0
						end)
						+
						(case when isnull(AC_AGETO2,100)<=@maxChildAge then
							1
						else
							0
						end)					
					then
						0 --все дополнительные места уже отданы детям
					else
						isnull(AC_NMenExBed,case when AC_MAIN = 0  then 1 else 0 end) -
						(case when isnull(AC_AGETO,100)<=@maxChildAge then
							1
						else
							0
						end)
						+
						(case when isnull(AC_AGETO2,100)<=@maxChildAge then
							1
						else
							0
						end)	--все доп. места, которые не заняты детьми			
					end,

     --AC_NCHEXTRA - количество детей на дополнительном месте
     AC_NCHEXTRA = case when isnull(AC_NMenExBed,case when AC_MAIN = 0  then 1 else 0 end)<
						(case when isnull(AC_AGETO,100)<=@maxChildAge then
							1
						else
							0
						end)
						+
						(case when isnull(AC_AGETO2,100)<=@maxChildAge then
							1
						else
							0
						end)					
					then
						isnull(AC_NMenExBed,case when AC_MAIN = 0  then 1 else 0 end)--все дополнительные места принадлежат детям
					else
						(case when isnull(AC_AGETO,100)<=@maxChildAge then
							1
						else
							0
						end)
						+
						(case when isnull(AC_AGETO2,100)<=@maxChildAge then
							1
						else
							0
						end)	--детям принадлежит одно или два места			
					end,
	 
 --AC_NCHMAIN - количество детей на основном месте
 AC_NCHMAIN = 0,
 
 --AC_NCHISINFMAIN - количество инфантов на основном месте
 AC_NCHISINFMAIN = 0,
 
 --AC_NCHISINFEXTRA - количество инфантов на дополнительном месте
 AC_NCHISINFEXTRA = 0
 
 from Accmdmentype
end
go
/*********************************************************************/
/* end (2012.03.19)_Convert_Accmdmentype.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.19)_Alter_COLUMNS_Accmdmentype.sql */
/*********************************************************************/
-- Калькулируемые поля AC_NRealPlaces
if exists (select 1 from dbo.syscolumns where name = 'AC_NRealPlaces' and id = object_id(N'[dbo].[Accmdmentype]'))
begin	
	alter table dbo.Accmdmentype drop column AC_NRealPlaces
end
if not exists (select 1 from dbo.syscolumns where name = 'AC_NRealPlaces' and id = object_id(N'[dbo].[Accmdmentype]'))
begin	
	alter table dbo.Accmdmentype add AC_NRealPlaces as isnull(AC_NADMAIN, 0) + isnull(AC_NCHMAIN, 0)
end
go

-- Калькулируемые поля AC_NMenExBed
if exists (select 1 from dbo.syscolumns where name = 'AC_NMenExBed' and id = object_id(N'[dbo].[Accmdmentype]'))
begin	
	alter table dbo.Accmdmentype drop column AC_NMenExBed
end
if not exists (select 1 from dbo.syscolumns where name = 'AC_NMenExBed' and id = object_id(N'[dbo].[Accmdmentype]'))
begin	
	alter table dbo.Accmdmentype add AC_NMenExBed as isnull(AC_NADEXTRA, 0) + isnull(AC_NCHEXTRA, 0)
end
go
/*********************************************************************/
/* end (2012.03.19)_Alter_COLUMNS_Accmdmentype.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_GetTourPrice.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetTourPrice]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
begin
	if  EXISTS (select * from syscolumns where name='PC_SummPrice' and id=object_id('TP_PriceComponents'))
		alter table [dbo].[TP_PriceComponents] drop column [PC_SummPrice]
	DROP FUNCTION [dbo].[GetTourPrice]
end
GO

CREATE FUNCTION [dbo].[GetTourPrice] 
(
	-- функция для вычисляемого столбца в таблице TP_PriceComponents
	-- <date>2009.02.03</date>
	-- <version>2012-02-10</version>
	@gross_1 money,
	@addCostIsCommission_1 money,
	@addCostNoCommission_1 money,
	@IsCommission_1 bit,
	@IsCommissionOnly_1 bit,
	@MarginPercent_1 money,
	@hasGross_1 bit,
	
	@gross_2 money,
	@addCostIsCommission_2 money,
	@addCostNoCommission_2 money,
	@IsCommission_2 bit,
	@IsCommissionOnly_2 bit,
	@MarginPercent_2 money,
	@hasGross_2 bit,
	
	@gross_3 money,
	@addCostIsCommission_3 money,
	@addCostNoCommission_3 money,
	@IsCommission_3 bit,
	@IsCommissionOnly_3 bit,
	@MarginPercent_3 money,
	@hasGross_3 bit,
	
	@gross_4 money,
	@addCostIsCommission_4 money,
	@addCostNoCommission_4 money,
	@IsCommission_4 bit,
	@IsCommissionOnly_4 bit,
	@MarginPercent_4 money,
	@hasGross_4 bit,
	
	@gross_5 money,
	@addCostIsCommission_5 money,
	@addCostNoCommission_5 money,
	@IsCommission_5 bit,
	@IsCommissionOnly_5 bit,
	@MarginPercent_5 money,
	@hasGross_5 bit,
	
	@gross_6 money,
	@addCostIsCommission_6 money,
	@addCostNoCommission_6 money,
	@IsCommission_6 bit,
	@IsCommissionOnly_6 bit,
	@MarginPercent_6 money,
	@hasGross_6 bit,
	
	@gross_7 money,
	@addCostIsCommission_7 money,
	@addCostNoCommission_7 money,
	@IsCommission_7 bit,
	@IsCommissionOnly_7 bit,
	@MarginPercent_7 money,
	@hasGross_7 bit,
	
	@gross_8 money,
	@addCostIsCommission_8 money,
	@addCostNoCommission_8 money,
	@IsCommission_8 bit,
	@IsCommissionOnly_8 bit,
	@MarginPercent_8 money,
	@hasGross_8 bit,
	
	@gross_9 money,
	@addCostIsCommission_9 money,
	@addCostNoCommission_9 money,
	@IsCommission_9 bit,
	@IsCommissionOnly_9 bit,
	@MarginPercent_9 money,
	@hasGross_9 bit,
	
	@gross_10 money,
	@addCostIsCommission_10 money,
	@addCostNoCommission_10 money,
	@IsCommission_10 bit,
	@IsCommissionOnly_10 bit,
	@MarginPercent_10 money,
	@hasGross_10 bit,
	
	@gross_11 money,
	@addCostIsCommission_11 money,
	@addCostNoCommission_11 money,
	@IsCommission_11 bit,
	@IsCommissionOnly_11 bit,
	@MarginPercent_11 money,
	@hasGross_11 bit,
	
	@gross_12 money,
	@addCostIsCommission_12 money,
	@addCostNoCommission_12 money,
	@IsCommission_12 bit,
	@IsCommissionOnly_12 bit,
	@MarginPercent_12 money,
	@hasGross_12 bit,
	
	@gross_13 money,
	@addCostIsCommission_13 money,
	@addCostNoCommission_13 money,
	@IsCommission_13 bit,
	@IsCommissionOnly_13 bit,
	@MarginPercent_13 money,
	@hasGross_13 bit,
	
	@gross_14 money,
	@addCostIsCommission_14 money,
	@addCostNoCommission_14 money,
	@IsCommission_14 bit,
	@IsCommissionOnly_14 bit,
	@MarginPercent_14 money,
	@hasGross_14 bit,
	
	@gross_15 money,
	@addCostIsCommission_15 money,
	@addCostNoCommission_15 money,
	@IsCommission_15 bit,
	@IsCommissionOnly_15 bit,
	@MarginPercent_15 money,
	@hasGross_15 bit
)
RETURNS money
AS
BEGIN
	-- старая формула расчета 1ого картежа
	-- (цена + доплата с которой дается коммисия) * (1 + (наценка/100)*(1 - (1 - даем коммисию)*только с коммисионных услуг)) + доплата с которой наценка не дается
	-- новая формула расчета 1ого картежа
	-- (цена + доплата с которой дается коммисия + (1-только с коммисионных услуг)*(доплата с которой наценка не дается)) * (1 + (наценка/100)*(1 - (1 - даем коммисию)*только с коммисионных услуг)) + только с коммисионных услуг*доплата с которой наценка не дается
	-- совсем новая формула
	-- Gross * (1 + MPX * (1 + (IC - 1) * CO)) 
	-- + ACIC * (1 + MPX) 
	-- + ACNC * (1 + MPX * (1 - CO))
	-- заменил проверку на null для gross - пришлось добавить еще по одному параметру - битовое поле 1- если данный картеж используется под услугу 0 - если он пустой.
	-- теперь если картеж используется но цена на услугу null то и цена на тур будет null
	
	RETURN
	((case when  @hasGross_1 = 1 then  @gross_1 else 0 end) * (1 + (isnull( @MarginPercent_1, 0)/100) * (1 + (isnull( @IsCommission_1, 0) - 1) * isnull( @IsCommissionOnly_1, 0))) + isnull( @addCostIsCommission_1, 0) * (1 + (isnull( @MarginPercent_1, 0)/100)) + isnull( @addCostNoCommission_1, 0) * (1 + (isnull( @MarginPercent_1, 0)/100) * (1 - isnull( @IsCommissionOnly_1, 0)))) +
	((case when  @hasGross_2 = 1 then  @gross_2 else 0 end) * (1 + (isnull( @MarginPercent_2, 0)/100) * (1 + (isnull( @IsCommission_2, 0) - 1) * isnull( @IsCommissionOnly_2, 0))) + isnull( @addCostIsCommission_2, 0) * (1 + (isnull( @MarginPercent_2, 0)/100)) + isnull( @addCostNoCommission_2, 0) * (1 + (isnull( @MarginPercent_2, 0)/100) * (1 - isnull( @IsCommissionOnly_2, 0)))) +
	((case when  @hasGross_3 = 1 then  @gross_3 else 0 end) * (1 + (isnull( @MarginPercent_3, 0)/100) * (1 + (isnull( @IsCommission_3, 0) - 1) * isnull( @IsCommissionOnly_3, 0))) + isnull( @addCostIsCommission_3, 0) * (1 + (isnull( @MarginPercent_3, 0)/100)) + isnull( @addCostNoCommission_3, 0) * (1 + (isnull( @MarginPercent_3, 0)/100) * (1 - isnull( @IsCommissionOnly_3, 0)))) +
	((case when  @hasGross_4 = 1 then  @gross_4 else 0 end) * (1 + (isnull( @MarginPercent_4, 0)/100) * (1 + (isnull( @IsCommission_4, 0) - 1) * isnull( @IsCommissionOnly_4, 0))) + isnull( @addCostIsCommission_4, 0) * (1 + (isnull( @MarginPercent_4, 0)/100)) + isnull( @addCostNoCommission_4, 0) * (1 + (isnull( @MarginPercent_4, 0)/100) * (1 - isnull( @IsCommissionOnly_4, 0)))) +
	((case when  @hasGross_5 = 1 then  @gross_5 else 0 end) * (1 + (isnull( @MarginPercent_5, 0)/100) * (1 + (isnull( @IsCommission_5, 0) - 1) * isnull( @IsCommissionOnly_5, 0))) + isnull( @addCostIsCommission_5, 0) * (1 + (isnull( @MarginPercent_5, 0)/100)) + isnull( @addCostNoCommission_5, 0) * (1 + (isnull( @MarginPercent_5, 0)/100) * (1 - isnull( @IsCommissionOnly_5, 0)))) +
	((case when  @hasGross_6 = 1 then  @gross_6 else 0 end) * (1 + (isnull( @MarginPercent_6, 0)/100) * (1 + (isnull( @IsCommission_6, 0) - 1) * isnull( @IsCommissionOnly_6, 0))) + isnull( @addCostIsCommission_6, 0) * (1 + (isnull( @MarginPercent_6, 0)/100)) + isnull( @addCostNoCommission_6, 0) * (1 + (isnull( @MarginPercent_6, 0)/100) * (1 - isnull( @IsCommissionOnly_6, 0)))) +
	((case when  @hasGross_7 = 1 then  @gross_7 else 0 end) * (1 + (isnull( @MarginPercent_7, 0)/100) * (1 + (isnull( @IsCommission_7, 0) - 1) * isnull( @IsCommissionOnly_7, 0))) + isnull( @addCostIsCommission_7, 0) * (1 + (isnull( @MarginPercent_7, 0)/100)) + isnull( @addCostNoCommission_7, 0) * (1 + (isnull( @MarginPercent_7, 0)/100) * (1 - isnull( @IsCommissionOnly_7, 0)))) +
	((case when  @hasGross_8 = 1 then  @gross_8 else 0 end) * (1 + (isnull( @MarginPercent_8, 0)/100) * (1 + (isnull( @IsCommission_8, 0) - 1) * isnull( @IsCommissionOnly_8, 0))) + isnull( @addCostIsCommission_8, 0) * (1 + (isnull( @MarginPercent_8, 0)/100)) + isnull( @addCostNoCommission_8, 0) * (1 + (isnull( @MarginPercent_8, 0)/100) * (1 - isnull( @IsCommissionOnly_8, 0)))) +
	((case when  @hasGross_9 = 1 then  @gross_9 else 0 end) * (1 + (isnull( @MarginPercent_9, 0)/100) * (1 + (isnull( @IsCommission_9, 0) - 1) * isnull( @IsCommissionOnly_9, 0))) + isnull( @addCostIsCommission_9, 0) * (1 + (isnull( @MarginPercent_9, 0)/100)) + isnull( @addCostNoCommission_9, 0) * (1 + (isnull( @MarginPercent_9, 0)/100) * (1 - isnull( @IsCommissionOnly_9, 0)))) +
	((case when @hasGross_10 = 1 then @gross_10 else 0 end) * (1 + (isnull(@MarginPercent_10, 0)/100) * (1 + (isnull(@IsCommission_10, 0) - 1) * isnull(@IsCommissionOnly_10, 0))) + isnull(@addCostIsCommission_10, 0) * (1 + (isnull(@MarginPercent_10, 0)/100)) + isnull(@addCostNoCommission_10, 0) * (1 + (isnull(@MarginPercent_10, 0)/100) * (1 - isnull(@IsCommissionOnly_10, 0)))) +
	((case when @hasGross_11 = 1 then @gross_11 else 0 end) * (1 + (isnull(@MarginPercent_11, 0)/100) * (1 + (isnull(@IsCommission_11, 0) - 1) * isnull(@IsCommissionOnly_11, 0))) + isnull(@addCostIsCommission_11, 0) * (1 + (isnull(@MarginPercent_11, 0)/100)) + isnull(@addCostNoCommission_11, 0) * (1 + (isnull(@MarginPercent_11, 0)/100) * (1 - isnull(@IsCommissionOnly_11, 0)))) +
	((case when @hasGross_12 = 1 then @gross_12 else 0 end) * (1 + (isnull(@MarginPercent_12, 0)/100) * (1 + (isnull(@IsCommission_12, 0) - 1) * isnull(@IsCommissionOnly_12, 0))) + isnull(@addCostIsCommission_12, 0) * (1 + (isnull(@MarginPercent_12, 0)/100)) + isnull(@addCostNoCommission_12, 0) * (1 + (isnull(@MarginPercent_12, 0)/100) * (1 - isnull(@IsCommissionOnly_12, 0)))) +
	((case when @hasGross_13 = 1 then @gross_13 else 0 end) * (1 + (isnull(@MarginPercent_13, 0)/100) * (1 + (isnull(@IsCommission_13, 0) - 1) * isnull(@IsCommissionOnly_13, 0))) + isnull(@addCostIsCommission_13, 0) * (1 + (isnull(@MarginPercent_13, 0)/100)) + isnull(@addCostNoCommission_13, 0) * (1 + (isnull(@MarginPercent_13, 0)/100) * (1 - isnull(@IsCommissionOnly_13, 0)))) +
	((case when @hasGross_14 = 1 then @gross_14 else 0 end) * (1 + (isnull(@MarginPercent_14, 0)/100) * (1 + (isnull(@IsCommission_14, 0) - 1) * isnull(@IsCommissionOnly_14, 0))) + isnull(@addCostIsCommission_14, 0) * (1 + (isnull(@MarginPercent_14, 0)/100)) + isnull(@addCostNoCommission_14, 0) * (1 + (isnull(@MarginPercent_14, 0)/100) * (1 - isnull(@IsCommissionOnly_14, 0)))) +
	((case when @hasGross_15 = 1 then @gross_15 else 0 end) * (1 + (isnull(@MarginPercent_15, 0)/100) * (1 + (isnull(@IsCommission_15, 0) - 1) * isnull(@IsCommissionOnly_15, 0))) + isnull(@addCostIsCommission_15, 0) * (1 + (isnull(@MarginPercent_15, 0)/100)) + isnull(@addCostNoCommission_15, 0) * (1 + (isnull(@MarginPercent_15, 0)/100) * (1 - isnull(@IsCommissionOnly_15, 0))))
END
GO

grant exec on [dbo].[GetTourPrice] to public
go

if (EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)
	and not EXISTS (select * from syscolumns where name='PC_SummPrice' and id=object_id('TP_PriceComponents')))
		alter table [dbo].[TP_PriceComponents] 
		add [PC_SummPrice]  AS ([dbo].[GetTourPrice](
			[Gross_1],[AddCostIsCommission_1],[AddCostNoCommission_1],[IsCommission_1],[CommissionOnly_1],[MarginPercent_1],case when [SCPId_1] is not null then 1 else 0 end,
			[Gross_2],[AddCostIsCommission_2],[AddCostNoCommission_2],[IsCommission_2],[CommissionOnly_2],[MarginPercent_2],case when [SCPId_2] is not null then 1 else 0 end,
			[Gross_3],[AddCostIsCommission_3],[AddCostNoCommission_3],[IsCommission_3],[CommissionOnly_3],[MarginPercent_3],case when [SCPId_3] is not null then 1 else 0 end,
			[Gross_4],[AddCostIsCommission_4],[AddCostNoCommission_4],[IsCommission_4],[CommissionOnly_4],[MarginPercent_4],case when [SCPId_4] is not null then 1 else 0 end,
			[Gross_5],[AddCostIsCommission_5],[AddCostNoCommission_5],[IsCommission_5],[CommissionOnly_5],[MarginPercent_5],case when [SCPId_5] is not null then 1 else 0 end,
			[Gross_6],[AddCostIsCommission_6],[AddCostNoCommission_6],[IsCommission_6],[CommissionOnly_6],[MarginPercent_6],case when [SCPId_6] is not null then 1 else 0 end,
			[Gross_7],[AddCostIsCommission_7],[AddCostNoCommission_7],[IsCommission_7],[CommissionOnly_7],[MarginPercent_7],case when [SCPId_7] is not null then 1 else 0 end,
			[Gross_8],[AddCostIsCommission_8],[AddCostNoCommission_8],[IsCommission_8],[CommissionOnly_8],[MarginPercent_8],case when [SCPId_8] is not null then 1 else 0 end,
			[Gross_9],[AddCostIsCommission_9],[AddCostNoCommission_9],[IsCommission_9],[CommissionOnly_9],[MarginPercent_9],case when [SCPId_9] is not null then 1 else 0 end,
			[Gross_10],[AddCostIsCommission_10],[AddCostNoCommission_10],[IsCommission_10],[CommissionOnly_10],[MarginPercent_10],case when [SCPId_10] is not null then 1 else 0 end,
			[Gross_11],[AddCostIsCommission_11],[AddCostNoCommission_11],[IsCommission_11],[CommissionOnly_11],[MarginPercent_11],case when [SCPId_11] is not null then 1 else 0 end,
			[Gross_12],[AddCostIsCommission_12],[AddCostNoCommission_12],[IsCommission_12],[CommissionOnly_12],[MarginPercent_12],case when [SCPId_12] is not null then 1 else 0 end,
			[Gross_13],[AddCostIsCommission_13],[AddCostNoCommission_13],[IsCommission_13],[CommissionOnly_13],[MarginPercent_13],case when [SCPId_13] is not null then 1 else 0 end,
			[Gross_14],[AddCostIsCommission_14],[AddCostNoCommission_14],[IsCommission_14],[CommissionOnly_14],[MarginPercent_14],case when [SCPId_14] is not null then 1 else 0 end,
			[Gross_15],[AddCostIsCommission_15],[AddCostNoCommission_15],[IsCommission_15],[CommissionOnly_15],[MarginPercent_15],case when [SCPId_15] is not null then 1 else 0 end))
go
/*********************************************************************/
/* end fn_GetTourPrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.27)_insert_SystemSettings.sql */
/*********************************************************************/
if not exists (select top 1 1 from systemsettings where ss_parmname = 'NewReCalculatePrice')
begin
	insert into systemsettings (SS_ParmName, SS_ParmValue) values (N'NewReCalculatePrice', 0)
end
go
/*********************************************************************/
/* end (2012.02.27)_insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.21)_Insert_SystemSettings.sql */
/*********************************************************************/
if not exists(select 1 from systemsettings where ss_parmname = 'MTDynamicCountries')
begin
--************************************************************************************
	--ПРОСТАВЛЯЕТ КЛЮЧ СТАНЫ, ДОБАВИТЬ ДЛЯ РАБОТЫ С ДИНАМИЧЕСКИМ ЦЕНООБРАЗОВАНИЕМ
--************************************************************************************
	insert into systemsettings (ss_parmname,ss_parmvalue) values ('MTDynamicCountries','')
end
go
/*********************************************************************/
/* end (2012.02.21)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.29)_Insert_ObjectAliases.sql */
/*********************************************************************/
IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 1147))
	insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
	values (1147,'DL_CalculatePriceDate', 'Дата расчета цены по услуге', 'Service cost calculation date', 60, 1)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 44))
	insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
	values (44,'CostOffers', 'Ценовые блоки', 'Cost offers', 0, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 44001))
	insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
	values (44001,'CO_Name', 'Название ценового блока', 'Cost offer name', 0, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 44002))
	insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
	values (44002,'CO_Code', 'Код ценового блока', 'Cost offer code', 0, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 44003))
	insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
	values (44003,'CO_SaleDateBeg', 'Дата начала продажи', 'Sale date begin', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 44004))
	insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
	values (44004,'CO_SaleDateEnd', 'Дата окончания продажи', 'Sale date end', 0, null)
go
/*********************************************************************/
/* end (2012.02.29)_Insert_ObjectAliases.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_PricesDeleted.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TP_PricesDeleted]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[TP_PricesDeleted](
		[TPD_Id] [int] IDENTITY(1,1) NOT NULL,
		[TPD_TPKey] [int] NOT NULL,
		[TPD_TOKey] [int] NOT NULL,
		[TPD_DateBegin] [datetime] NOT NULL,
		[TPD_DateEnd] [datetime] NULL,
		[TPD_Gross] [float] NULL,
		[TPD_TIKey] [int] NOT NULL,
		[TPD_CalculatingKey] [int] NOT NULL,
	 CONSTRAINT [PK_TP_PricesDeleted] PRIMARY KEY CLUSTERED 
	(
		[TPD_Id] ASC
	)WITH (PAD_INDEX  = ON, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
	) ON [PRIMARY]
end
GO
IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_TPD_TOKey]') AND parent_object_id = OBJECT_ID(N'[dbo].[TP_PricesDeleted]'))
begin
	ALTER TABLE [dbo].[TP_PricesDeleted]  WITH NOCHECK ADD  CONSTRAINT [FK_TPD_TOKey] FOREIGN KEY([TPD_TOKey])
	REFERENCES [dbo].[TP_Tours] ([TO_Key])
	ON DELETE CASCADE
	
	ALTER TABLE [dbo].[TP_PricesDeleted] CHECK CONSTRAINT [FK_TPD_TOKey]
end
GO
grant select, insert, update, delete on [dbo].[TP_PricesDeleted] to public
go

/*********************************************************************/
/* end CREATE_TP_PricesDeleted.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_AddCostTypes.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[AddCostTypes]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[AddCostTypes](
	[ACT_Id] [int] IDENTITY(1,1) NOT NULL,
	[ACT_Name] [nvarchar](50) NOT NULL,
	CONSTRAINT [PK_AddCostTypes] PRIMARY KEY CLUSTERED 
	(
		[ACT_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

grant select, update, insert, delete on dbo.AddCostTypes to public
go
/*********************************************************************/
/* end CREATE_AddCostTypes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_AddCostNames.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[AddCostNames]') and objectproperty(id, N'IsUserTable') = 1 ) 
	CREATE TABLE [dbo].[AddCostNames](
		[ACN_Id] [int] IDENTITY(1,1) NOT NULL,
		[ACN_Name] [nvarchar](150) NOT NULL,
		[ACN_SvKey] [int] NOT NULL,
	 CONSTRAINT [PK_AddCostNames] PRIMARY KEY CLUSTERED 
	(
		[ACN_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

grant select, update, insert, delete on dbo.AddCostNames to public
go



/*********************************************************************/
/* end CREATE_AddCostNames.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_ALTER_AddCosts.sql */
/*********************************************************************/
-- удалим старую identity column

if exists (select * from syscolumns where name='AC_KEY' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_KEY];
end
go

-- создадим новые колонки

if not exists (select * from syscolumns where name='ADC_Id' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_Id] [int] IDENTITY(1,1) NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_TypeId' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_TypeId] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_TLKey' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_TLKey] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_SVKey' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_SVKey] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_Code' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_Code] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_SubCode1' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_SubCode1] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_SubCode2' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_SubCode2] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_PansionKey' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_PansionKey] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_CheckinDateBeg' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_CheckinDateBeg] [datetime] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_CheckinDateEnd' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_CheckinDateEnd] [datetime] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_LongMin' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_LongMin] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_LongMax' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_LongMax] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_PartnerKey' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_PartnerKey] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_IsCommission' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_IsCommission] [bit] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_Rate' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_Rate] [nvarchar](2) NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_Value' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_Value] [money] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_ValueChild' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_ValueChild] [money] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_CreateDate' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_CreateDate] [datetime] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_DisableDate' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_DisableDate] [datetime] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_UpdateDate' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_UpdateDate] [datetime] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_UpdateUserName' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_UpdateUserName] [nvarchar](100) NULL;
end
go

if not exists (select * from syscolumns where name='ADC_UpdateUserKey' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_UpdateUserKey] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_Name' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_Name] [nvarchar](128) NULL;
end
go

if not exists (select * from syscolumns where name='ADC_ACNId' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_ACNId] [int] NULL;
end
go

if not exists (select * from syscolumns where name='ADC_IsDay' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_IsDay] [bit] NOT NULL;
end
go

if not exists (select * from syscolumns where name='ADC_Description' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts add [ADC_Description] [nvarchar](128) NULL;
end
go

-- удалим старые колонки

if exists (select * from syscolumns where name='AC_DATE' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_DATE];
end
go

if exists (select * from syscolumns where name='AC_CODE' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_CODE];
end
go

if exists (select * from syscolumns where name='AC_SUBCODE1' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_SUBCODE1];
end
go

if exists (select * from syscolumns where name='AC_SUBCODE2' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_SUBCODE2];
end
go

if exists (select * from syscolumns where name='AC_HDKEY' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_HDKEY];
end
go

if exists (select * from syscolumns where name='AC_PNKEY' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_PNKEY];
end
go

if exists (select * from syscolumns where name='AC_YESNO' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_YESNO];
end
go

if exists (select * from syscolumns where name='AC_MAIN' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_MAIN];
end
go

if exists (select * from syscolumns where name='AC_AGEFROM' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_AGEFROM];
end
go

if exists (select * from syscolumns where name='AC_AGETO' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_AGETO];
end
go

if exists (select * from syscolumns where name='AC_RATE' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_RATE];
end
go

if exists (select * from syscolumns where name='AC_PRICE' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_PRICE];
end
go

if exists (select * from syscolumns where name='AC_SVKEY' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_SVKEY];
end
go

if exists (select * from syscolumns where name='AC_CNKEY' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_CNKEY];
end
go

if exists (select * from syscolumns where name='AC_PrKey' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_PrKey];
end
go

if exists (select * from syscolumns where name='AC_DateEnd' and id=object_id('dbo.AddCosts'))
begin
	alter table dbo.AddCosts drop column [AC_DateEnd];
end
go

-- создадим новые ограничения

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[PK_AddCosts]')  and OBJECTPROPERTY(id, N'IsPrimaryKey') = 1) 
begin
	ALTER TABLE [dbo].[AddCosts] ADD CONSTRAINT [PK_AddCosts] PRIMARY KEY CLUSTERED 
	(
		[ADC_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) 
	ON [PRIMARY]
end
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_AddCosts_AddCostNames]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[AddCosts]  WITH CHECK ADD  CONSTRAINT [FK_AddCosts_AddCostNames] FOREIGN KEY([ADC_ACNId])
	REFERENCES [dbo].[AddCostNames] ([ACN_Id])
GO

ALTER TABLE [dbo].[AddCosts] CHECK CONSTRAINT [FK_AddCosts_AddCostNames]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_AddCosts_AddCostTypes]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[AddCosts]  WITH CHECK ADD  CONSTRAINT [FK_AddCosts_AddCostTypes] FOREIGN KEY([ADC_TypeId])
	REFERENCES [dbo].[AddCostTypes] ([ACT_Id])
GO

ALTER TABLE [dbo].[AddCosts] CHECK CONSTRAINT [FK_AddCosts_AddCostTypes]
GO

if exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_AddCosts_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[AddCosts]  drop constraint FK_AddCosts_tbl_TurList
go

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_AddCosts_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[AddCosts]  WITH CHECK ADD  CONSTRAINT [FK_AddCosts_tbl_TurList] FOREIGN KEY([ADC_TLKey])
	REFERENCES [dbo].[tbl_TurList] ([TL_KEY])
	on delete cascade
GO

ALTER TABLE [dbo].[AddCosts] CHECK CONSTRAINT [FK_AddCosts_tbl_TurList]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_AddCosts_ADC_CreateDate]') ) 
	ALTER TABLE [dbo].[AddCosts] ADD  CONSTRAINT [DF_AddCosts_ADC_CreateDate]  DEFAULT (getdate()) FOR [ADC_CreateDate]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_AddCosts_ADC_ACNId]') ) 
	ALTER TABLE [dbo].[AddCosts] ADD  CONSTRAINT [DF_AddCosts_ADC_ACNId]  DEFAULT ((1)) FOR [ADC_ACNId]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_AddCosts_ADC_IsDay]') ) 
	ALTER TABLE [dbo].[AddCosts] ADD  CONSTRAINT [DF_AddCosts_ADC_IsDay]  DEFAULT ((0)) FOR [ADC_IsDay]
GO

grant select, update, insert, delete on dbo.AddCosts to public
go
/*********************************************************************/
/* end (2012.03.23)_ALTER_AddCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_ALTER_CostOffers.sql */
/*********************************************************************/
-- удалим старые ограничения
IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_CostOffers_CostOfferTypes]') AND parent_object_id = OBJECT_ID(N'[dbo].[CostOffers]'))
	ALTER TABLE [dbo].[CostOffers] DROP CONSTRAINT [FK_CostOffers_CostOfferTypes]
go

IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_CostOffers_Partners]') AND parent_object_id = OBJECT_ID(N'[dbo].[CostOffers]'))
	ALTER TABLE [dbo].[CostOffers] DROP CONSTRAINT [FK_CostOffers_Partners]
go

IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_CostOffers_CostOfferTypes]') AND parent_object_id = OBJECT_ID(N'[dbo].[CostOffers]'))
	ALTER TABLE [dbo].[CostOffers] DROP CONSTRAINT [FK_CostOffers_CostOfferTypes]
go


-- удалим старые колонки
-- только если нету записей в таблице
if not exists (select top 1 1 from dbo.CostOffers)
begin
	if exists (select * from syscolumns where name='CO_Name' and id=object_id('dbo.CostOffers'))
	begin
		alter table dbo.CostOffers drop column [CO_Name];
	end
	if exists (select * from syscolumns where name='CO_NameLat' and id=object_id('dbo.CostOffers'))
	begin
		alter table dbo.CostOffers drop column [CO_NameLat];
	end
	if exists (select * from syscolumns where name='CO_PartnerId' and id=object_id('dbo.CostOffers'))
	begin
		alter table dbo.CostOffers drop column [CO_PartnerId];
	end
	if exists (select * from syscolumns where name='CO_TypeId' and id=object_id('dbo.CostOffers'))
	begin
		alter table dbo.CostOffers drop column [CO_TypeId];
	end
end
go


-- создадим новые колонки
if not exists (select * from syscolumns where name='CO_PKKey' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_PKKey] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_SVKey' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_SVKey] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_Name' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_Name] [nvarchar](254) NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_SPOTypeId' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_SPOTypeId] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_State' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_State] [smallint] NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_DateActive' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_DateActive] [datetime] NULL;
end
go

if not exists (select * from syscolumns where name='CO_DateClose' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_DateClose] [datetime] NULL;
end
go

if not exists (select * from syscolumns where name='CO_Code' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_Code] [nvarchar](254) NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_PartnerKey' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_PartnerKey] [int] NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_Description' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_Description] [nvarchar](254) NOT NULL;
end
go

if not exists (select * from syscolumns where name='CO_DateLastPublish' and id=object_id('dbo.CostOffers'))
begin
	alter table dbo.CostOffers add [CO_DateLastPublish] [datetime] NULL;
end
go

-- изменим существующие колонки
if exists (select * from syscolumns where name='CO_SeasonId' and id=object_id('dbo.CostOffers') and isnullable = 1)
begin
	alter table dbo.CostOffers alter column [CO_SeasonId] [int] NOT NULL;
end
go


-- создадим новые ограничения
if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOffers_Partners]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[CostOffers]  WITH CHECK ADD  CONSTRAINT [FK_CostOffers_Partners] FOREIGN KEY([CO_PartnerKey])
	REFERENCES [dbo].[tbl_Partners] ([PR_KEY])
GO

ALTER TABLE [dbo].[CostOffers] CHECK CONSTRAINT [FK_CostOffers_Partners]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOffers_Seasons]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[CostOffers]  WITH CHECK ADD  CONSTRAINT [FK_CostOffers_Seasons] FOREIGN KEY([CO_SeasonId])
	REFERENCES [dbo].[Seasons] ([SN_Id])
GO

ALTER TABLE [dbo].[CostOffers] CHECK CONSTRAINT [FK_CostOffers_Seasons]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOffers_SPOType]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[CostOffers]  WITH CHECK ADD  CONSTRAINT [FK_CostOffers_SPOType] FOREIGN KEY([CO_SPOTypeId])
	REFERENCES [dbo].[SPOTypes] ([ST_Id])
GO

ALTER TABLE [dbo].[CostOffers] CHECK CONSTRAINT [FK_CostOffers_SPOType]
GO

--if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOffers_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
--	ALTER TABLE [dbo].[CostOffers]  WITH CHECK ADD  CONSTRAINT [FK_CostOffers_TurList] FOREIGN KEY([CO_PKKey])
--	REFERENCES [dbo].[tbl_TurList] ([TL_KEY])
--	ON DELETE CASCADE
--GO

if exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOffers_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	alter table costoffers drop constraint FK_CostOffers_TurList
go

--if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOffers_TurList]') ) 
--	ALTER TABLE [dbo].[CostOffers] CHECK CONSTRAINT [FK_CostOffers_TurList]
--GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_CostOffers_State]') ) 
	ALTER TABLE [dbo].[CostOffers] ADD  CONSTRAINT [DF_CostOffers_State]  DEFAULT ((0)) FOR [CO_State]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_CostOffer_CO_Code]') ) 
	ALTER TABLE [dbo].[CostOffers] ADD  CONSTRAINT [DF_CostOffer_CO_Code]  DEFAULT ('') FOR [CO_Code]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_CostOffer_CO_PartnerKey]') ) 
	ALTER TABLE [dbo].[CostOffers] ADD  CONSTRAINT [DF_CostOffer_CO_PartnerKey]  DEFAULT ((0)) FOR [CO_PartnerKey]
GO

-- 10759 tkachuk если constraint по полю co_description уже существует, надо выяснить его имя и удалить

IF EXISTS (SELECT name FROM sysobjects so JOIN sysconstraints sc
ON so.id = sc.constid WHERE object_name(so.parent_obj) = 'costOffers'
AND so.xtype ='D' AND sc.colid = 
 (SELECT colid FROM syscolumns WHERE id = object_id('costOffers') AND name = 'co_description'))
BEGIN

	DECLARE @defname VARCHAR(100), @cmd VARCHAR(1000)

	SET @defname = 
	(SELECT name FROM sysobjects so JOIN sysconstraints sc
	ON so.id = sc.constid WHERE object_name(so.parent_obj) = 'costOffers'
	AND so.xtype ='D' AND sc.colid = 
	 (SELECT colid FROM syscolumns WHERE id = object_id('costOffers') AND name = 'co_description'))

	SET @cmd = 'ALTER TABLE costOffers DROP CONSTRAINT ' + @defname

	EXEC(@cmd)
END

GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_CostOffer_CO_Description]') ) 
	ALTER TABLE [dbo].[CostOffers] ADD  CONSTRAINT [DF_CostOffer_CO_Description]  DEFAULT ('') FOR [CO_Description]
GO
/*********************************************************************/
/* end (2012.03.23)_ALTER_CostOffers.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_ServiceComponents.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TP_ServiceComponents]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[TP_ServiceComponents](
		[SC_Id] [int] IDENTITY(1,1) NOT NULL,
		[SC_SVKey] [int] NOT NULL,
		[SC_Code] [int] NOT NULL,
		[SC_SubCode1] [int] NULL,
		[SC_SubCode2] [int] NULL,
		[SC_PRKey] [int] NULL,
		[SC_Priority] [int] NULL,
	 CONSTRAINT [PK_TP_ServiceComponents] PRIMARY KEY CLUSTERED 
	(
		[SC_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

grant select, update, insert, delete on dbo.TP_ServiceComponents to public
go

/*********************************************************************/
/* end CREATE_TP_ServiceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_ServiceCalculateParametrs.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TP_ServiceCalculateParametrs]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[TP_ServiceCalculateParametrs](
		[SCP_Id] [bigint] IDENTITY(1,1) NOT NULL,
		[SCP_SCId] [int] NOT NULL,
		[SCP_SvKey] [int] NOT NULL,
		[SCP_Date] [datetime] NOT NULL,
		[SCP_DateCheckIn] [datetime] NOT NULL,
		[SCP_Men] [int] NOT NULL,
		[SCP_Days] [smallint] NULL,
		[SCP_PKKey] [int] NOT NULL,
		[SCP_DeleteDate] [datetime] NULL,
		[SCP_TourDays] [smallint] NULL,
	 CONSTRAINT [PK_TP_ServiceCalculateParametrs1] PRIMARY KEY CLUSTERED 
	(
		[SCP_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
go

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_ServiceCalculateParametrs_TP_ServiceComponents]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_ServiceCalculateParametrs]  WITH CHECK ADD  CONSTRAINT [FK_TP_ServiceCalculateParametrs_TP_ServiceComponents] FOREIGN KEY([SCP_SCId])
	REFERENCES [dbo].[TP_ServiceComponents] ([SC_Id])
GO

ALTER TABLE [dbo].[TP_ServiceCalculateParametrs] CHECK CONSTRAINT [FK_TP_ServiceCalculateParametrs_TP_ServiceComponents]
GO

grant select, update, insert, delete on dbo.TP_ServiceCalculateParametrs to public
go


/*********************************************************************/
/* end CREATE_TP_ServiceCalculateParametrs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_ServicePriceActualDate.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TP_ServicePriceActualDate]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[TP_ServicePriceActualDate](
		[SPAD_Id] [int] IDENTITY(1,1) NOT NULL,
		[SPAD_SCPId] [bigint] NULL,
		[SPAD_IsCommission] [bit] NULL,
		[SPAD_Rate] [nvarchar](2) NULL,
		[SPAD_SaleDate] [datetime] NULL,
		[SPAD_Gross] [money] NULL,
		[SPAD_Netto] [money] NULL,
		[SPAD_DateLastChange] [datetime] NOT NULL,
		[SPAD_DateLastCalculate] [datetime] NULL,
		[SPAD_NeedApply] [smallint] NOT NULL,
		[SPAD_AutoOnline] [smallint] NOT NULL DEFAULT 0,
	 CONSTRAINT [PK_TP_ServicePriceActualDate] PRIMARY KEY CLUSTERED 
	(
		[SPAD_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
go

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_ServicePriceActualDate_TP_ServiceCalculateParametrs]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_ServicePriceActualDate]  WITH CHECK ADD  CONSTRAINT [FK_TP_ServicePriceActualDate_TP_ServiceCalculateParametrs] FOREIGN KEY([SPAD_SCPId])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
	ON DELETE CASCADE
GO

ALTER TABLE [dbo].[TP_ServicePriceActualDate] CHECK CONSTRAINT [FK_TP_ServicePriceActualDate_TP_ServiceCalculateParametrs]
GO

grant select, update, insert, delete on dbo.TP_ServicePriceActualDate to public
go

/*********************************************************************/
/* end CREATE_TP_ServicePriceActualDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_PriceComponents.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TP_PriceComponents]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[TP_PriceComponents](
		[PC_Id] [bigint] IDENTITY(1,1) NOT NULL,
		[PC_TIKey] [int] NOT NULL,
		[PC_TOKey] [int] NOT NULL,
		[PC_TRKey] [int] NOT NULL,
		[PC_TourDate] [datetime] NOT NULL,
		[PC_TPKey] [int] NULL,
		[PC_HotelKey] [int] NOT NULL,
		[PC_DepartureKey] [int] NOT NULL,
		[PC_CreateDate] [datetime] NOT NULL,
		[PC_UpdateDate] [datetime] NULL,
		[PC_SummPrice]  AS ([dbo].[GetTourPrice](
			[Gross_1],[AddCostIsCommission_1],[AddCostNoCommission_1],[IsCommission_1],[CommissionOnly_1],[MarginPercent_1],case when [SCPId_1] is not null then 1 else 0 end,
			[Gross_2],[AddCostIsCommission_2],[AddCostNoCommission_2],[IsCommission_2],[CommissionOnly_2],[MarginPercent_2],case when [SCPId_2] is not null then 1 else 0 end,
			[Gross_3],[AddCostIsCommission_3],[AddCostNoCommission_3],[IsCommission_3],[CommissionOnly_3],[MarginPercent_3],case when [SCPId_3] is not null then 1 else 0 end,
			[Gross_4],[AddCostIsCommission_4],[AddCostNoCommission_4],[IsCommission_4],[CommissionOnly_4],[MarginPercent_4],case when [SCPId_4] is not null then 1 else 0 end,
			[Gross_5],[AddCostIsCommission_5],[AddCostNoCommission_5],[IsCommission_5],[CommissionOnly_5],[MarginPercent_5],case when [SCPId_5] is not null then 1 else 0 end,
			[Gross_6],[AddCostIsCommission_6],[AddCostNoCommission_6],[IsCommission_6],[CommissionOnly_6],[MarginPercent_6],case when [SCPId_6] is not null then 1 else 0 end,
			[Gross_7],[AddCostIsCommission_7],[AddCostNoCommission_7],[IsCommission_7],[CommissionOnly_7],[MarginPercent_7],case when [SCPId_7] is not null then 1 else 0 end,
			[Gross_8],[AddCostIsCommission_8],[AddCostNoCommission_8],[IsCommission_8],[CommissionOnly_8],[MarginPercent_8],case when [SCPId_8] is not null then 1 else 0 end,
			[Gross_9],[AddCostIsCommission_9],[AddCostNoCommission_9],[IsCommission_9],[CommissionOnly_9],[MarginPercent_9],case when [SCPId_9] is not null then 1 else 0 end,
			[Gross_10],[AddCostIsCommission_10],[AddCostNoCommission_10],[IsCommission_10],[CommissionOnly_10],[MarginPercent_10],case when [SCPId_10] is not null then 1 else 0 end,
			[Gross_11],[AddCostIsCommission_11],[AddCostNoCommission_11],[IsCommission_11],[CommissionOnly_11],[MarginPercent_11],case when [SCPId_11] is not null then 1 else 0 end,
			[Gross_12],[AddCostIsCommission_12],[AddCostNoCommission_12],[IsCommission_12],[CommissionOnly_12],[MarginPercent_12],case when [SCPId_12] is not null then 1 else 0 end,
			[Gross_13],[AddCostIsCommission_13],[AddCostNoCommission_13],[IsCommission_13],[CommissionOnly_13],[MarginPercent_13],case when [SCPId_13] is not null then 1 else 0 end,
			[Gross_14],[AddCostIsCommission_14],[AddCostNoCommission_14],[IsCommission_14],[CommissionOnly_14],[MarginPercent_14],case when [SCPId_14] is not null then 1 else 0 end,
			[Gross_15],[AddCostIsCommission_15],[AddCostNoCommission_15],[IsCommission_15],[CommissionOnly_15],[MarginPercent_15],case when [SCPId_15] is not null then 1 else 0 end)),
		[PC_OldSummPrice] [money] NULL,
		[PC_Rate] [nvarchar](2) NULL,
		[PC_Days] [int] NULL,
		[PC_DateLastChangeGross] [datetime] NULL,
		[PC_DateLastChangeAddCost] [datetime] NULL,
		[PC_DateLastChangeMargin] [datetime] NULL,
		[PC_DateLastUpdateToPrice] [datetime] NULL,
		[PC_State] [smallint] not null default(0),
		[Gross_1] [money] NULL,
		[AddCostNoCommission_1] [money] NULL,
		[AddCostIsCommission_1] [money] NULL,
		[MarginPercent_1] [money] NULL,
		[CommissionOnly_1] [bit] NULL,
		[IsCommission_1] [bit] NULL,
		[SCPId_1] [bigint] NULL,
		[SVKey_1] [int] NULL,
		[Gross_2] [money] NULL,
		[AddCostNoCommission_2] [money] NULL,
		[AddCostIsCommission_2] [money] NULL,
		[MarginPercent_2] [money] NULL,
		[CommissionOnly_2] [bit] NULL,
		[IsCommission_2] [bit] NULL,
		[SCPId_2] [bigint] NULL,
		[SVKey_2] [int] NULL,
		[Gross_3] [money] NULL,
		[AddCostNoCommission_3] [money] NULL,
		[AddCostIsCommission_3] [money] NULL,
		[MarginPercent_3] [money] NULL,
		[CommissionOnly_3] [bit] NULL,
		[IsCommission_3] [bit] NULL,
		[SCPId_3] [bigint] NULL,
		[SVKey_3] [int] NULL,
		[Gross_4] [money] NULL,
		[AddCostNoCommission_4] [money] NULL,
		[AddCostIsCommission_4] [money] NULL,
		[MarginPercent_4] [money] NULL,
		[CommissionOnly_4] [bit] NULL,
		[IsCommission_4] [bit] NULL,
		[SCPId_4] [bigint] NULL,
		[SVKey_4] [int] NULL,
		[Gross_5] [money] NULL,
		[AddCostNoCommission_5] [money] NULL,
		[AddCostIsCommission_5] [money] NULL,
		[MarginPercent_5] [money] NULL,
		[CommissionOnly_5] [bit] NULL,
		[IsCommission_5] [bit] NULL,
		[SCPId_5] [bigint] NULL,
		[SVKey_5] [int] NULL,
		[Gross_6] [money] NULL,
		[AddCostNoCommission_6] [money] NULL,
		[AddCostIsCommission_6] [money] NULL,
		[MarginPercent_6] [money] NULL,
		[CommissionOnly_6] [bit] NULL,
		[IsCommission_6] [bit] NULL,
		[SCPId_6] [bigint] NULL,
		[SVKey_6] [int] NULL,
		[Gross_7] [money] NULL,
		[AddCostNoCommission_7] [money] NULL,
		[AddCostIsCommission_7] [money] NULL,
		[MarginPercent_7] [money] NULL,
		[CommissionOnly_7] [bit] NULL,
		[IsCommission_7] [bit] NULL,
		[SCPId_7] [bigint] NULL,
		[SVKey_7] [int] NULL,
		[Gross_8] [money] NULL,
		[AddCostNoCommission_8] [money] NULL,
		[AddCostIsCommission_8] [money] NULL,
		[MarginPercent_8] [money] NULL,
		[CommissionOnly_8] [bit] NULL,
		[IsCommission_8] [bit] NULL,
		[SCPId_8] [bigint] NULL,
		[SVKey_8] [int] NULL,
		[Gross_9] [money] NULL,
		[AddCostNoCommission_9] [money] NULL,
		[AddCostIsCommission_9] [money] NULL,
		[MarginPercent_9] [money] NULL,
		[CommissionOnly_9] [bit] NULL,
		[IsCommission_9] [bit] NULL,
		[SCPId_9] [bigint] NULL,
		[SVKey_9] [int] NULL,
		[Gross_10] [money] NULL,
		[AddCostNoCommission_10] [money] NULL,
		[AddCostIsCommission_10] [money] NULL,
		[MarginPercent_10] [money] NULL,
		[CommissionOnly_10] [bit] NULL,
		[IsCommission_10] [bit] NULL,
		[SCPId_10] [bigint] NULL,
		[SVKey_10] [int] NULL,
		[Gross_11] [money] NULL,
		[AddCostNoCommission_11] [money] NULL,
		[AddCostIsCommission_11] [money] NULL,
		[MarginPercent_11] [money] NULL,
		[CommissionOnly_11] [bit] NULL,
		[IsCommission_11] [bit] NULL,
		[SCPId_11] [bigint] NULL,
		[SVKey_11] [int] NULL,
		[Gross_12] [money] NULL,
		[AddCostNoCommission_12] [money] NULL,
		[AddCostIsCommission_12] [money] NULL,
		[MarginPercent_12] [money] NULL,
		[CommissionOnly_12] [bit] NULL,
		[IsCommission_12] [bit] NULL,
		[SCPId_12] [bigint] NULL,
		[SVKey_12] [int] NULL,
		[Gross_13] [money] NULL,
		[AddCostNoCommission_13] [money] NULL,
		[AddCostIsCommission_13] [money] NULL,
		[MarginPercent_13] [money] NULL,
		[CommissionOnly_13] [bit] NULL,
		[IsCommission_13] [bit] NULL,
		[SCPId_13] [bigint] NULL,
		[SVKey_13] [int] NULL,
		[Gross_14] [money] NULL,
		[AddCostNoCommission_14] [money] NULL,
		[AddCostIsCommission_14] [money] NULL,
		[MarginPercent_14] [money] NULL,
		[CommissionOnly_14] [bit] NULL,
		[IsCommission_14] [bit] NULL,
		[SCPId_14] [bigint] NULL,
		[SVKey_14] [int] NULL,
		[Gross_15] [money] NULL,
		[AddCostNoCommission_15] [money] NULL,
		[AddCostIsCommission_15] [money] NULL,
		[MarginPercent_15] [money] NULL,
		[CommissionOnly_15] [bit] NULL,
		[IsCommission_15] [bit] NULL,
		[SCPId_15] [bigint] NULL,
		[SVKey_15] [int] NULL,
	 CONSTRAINT [PK_TP_PriceComponents] PRIMARY KEY CLUSTERED 
	(
		[PC_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
go

if not exists (SELECT * FROM fn_listextendedproperty (N'MS_Description', N'SCHEMA', N'dbo', N'TABLE', N'TP_PriceComponents', N'COLUMN', N'PC_Days'))
	EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Продолжительность услуги. Потребуется для быстрого перерасчета наценки' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'TP_PriceComponents', @level2type=N'COLUMN',@level2name=N'PC_Days'
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs] FOREIGN KEY([SCPId_1])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs1]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs1] FOREIGN KEY([SCPId_2])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs1]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs10]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs10] FOREIGN KEY([SCPId_11])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs10]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs11]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs11] FOREIGN KEY([SCPId_12])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs11]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs12]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs12] FOREIGN KEY([SCPId_13])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs12]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs13]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs13] FOREIGN KEY([SCPId_14])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs13]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs14]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs14] FOREIGN KEY([SCPId_15])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs14]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs2]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs2] FOREIGN KEY([SCPId_3])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs2]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs3]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs3] FOREIGN KEY([SCPId_4])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs3]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs4]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs4] FOREIGN KEY([SCPId_5])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs4]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs5]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs5] FOREIGN KEY([SCPId_6])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs5]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs6]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs6] FOREIGN KEY([SCPId_7])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs6]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs7]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs7] FOREIGN KEY([SCPId_8])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs7]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs8]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs8] FOREIGN KEY([SCPId_9])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs8]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_ServiceCalculateParametrs9]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs9] FOREIGN KEY([SCPId_10])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_ServiceCalculateParametrs9]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_TP_Tours1]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_TP_Tours1] FOREIGN KEY([PC_TOKey])
	REFERENCES [dbo].[TP_Tours] ([TO_Key])
	ON DELETE CASCADE
go

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_TP_Tours1]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_PriceComponents_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_PriceComponents]  WITH CHECK ADD  CONSTRAINT [FK_TP_PriceComponents_tbl_TurList] FOREIGN KEY([PC_TRKey])
	REFERENCES [dbo].[tbl_TurList] ([TL_Key])
GO

ALTER TABLE [dbo].[TP_PriceComponents] CHECK CONSTRAINT [FK_TP_PriceComponents_tbl_TurList]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_TP_PriceComponents_PC_CreateDate]') ) 
	ALTER TABLE [dbo].[TP_PriceComponents] ADD  CONSTRAINT [DF_TP_PriceComponents_PC_CreateDate]  DEFAULT (getdate()) FOR [PC_CreateDate]
GO

grant select, update, insert, delete on dbo.TP_PriceComponents to public
go
/*********************************************************************/
/* end CREATE_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_TourMarginActualDate.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TP_TourMarginActualDate]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[TP_TourMarginActualDate](
		[TMAD_Id] [int] IDENTITY(1,1) NOT NULL,
		[TMAD_TRKey] [int] NOT NULL,
		[TMAD_SvKey] [int] NOT NULL,
		[TMAD_DateCheckIn] [datetime] NULL,
		[TMAD_Percent] [money] NULL,
		[TMAD_IsCommission] [bit] NOT NULL,
		[TMAD_Long] [smallint] NULL,
		[TMAD_DateLastChange] [datetime] NOT NULL,
		[TMAD_DateLastCalculate] [datetime] NULL,
		[TMAD_NeedApply] [smallint] NULL,
	 CONSTRAINT [PK_TP_TourMarginActualDate] PRIMARY KEY CLUSTERED 
	(
		[TMAD_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
go

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_TourMarginActualDate_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_TourMarginActualDate]  WITH CHECK ADD  CONSTRAINT [FK_TP_TourMarginActualDate_tbl_TurList] FOREIGN KEY([TMAD_TRKey])
	REFERENCES [dbo].[tbl_TurList] ([TL_Key])
	ON DELETE CASCADE
GO

ALTER TABLE [dbo].[TP_TourMarginActualDate] CHECK CONSTRAINT [FK_TP_TourMarginActualDate_tbl_TurList]
GO

grant select, update, insert, delete on dbo.TP_TourMarginActualDate to public
go

/*********************************************************************/
/* end CREATE_TP_TourMarginActualDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_QueueAddCosts.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TP_QueueAddCosts]') and objectproperty(id, N'IsUserTable') = 1 ) 
    CREATE TABLE [dbo].[TP_QueueAddCosts](
		[QAC_Id] [bigint] IDENTITY(1,1) NOT NULL,
		[QAC_ADCId] [int] NOT NULL,
		[QAC_DateCheckIn] [datetime] NOT NULL,
		[QAC_SVKey] [int] NOT NULL,
		[QAC_SCPId] [bigint] NOT NULL,
		[QAC_DateCreate] [datetime] NOT NULL,
		[QAC_TRKey] [int] NOT NULL,
		[QAC_TourLongMin] [smallint] NULL,
		[QAC_TourLongMax] [smallint] NULL,
	 CONSTRAINT [PK_TP_QueueAddCosts] PRIMARY KEY CLUSTERED 
	(
		[QAC_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
go

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_QueueAddCosts_AddCosts]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_QueueAddCosts]  WITH CHECK ADD  CONSTRAINT [FK_TP_QueueAddCosts_AddCosts] FOREIGN KEY([QAC_ADCId])
	REFERENCES [dbo].[AddCosts] ([ADC_Id])
GO

ALTER TABLE [dbo].[TP_QueueAddCosts] CHECK CONSTRAINT [FK_TP_QueueAddCosts_AddCosts]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_QueueAddCosts_TP_ServiceCalculateParametrs]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_QueueAddCosts]  WITH CHECK ADD  CONSTRAINT [FK_TP_QueueAddCosts_TP_ServiceCalculateParametrs] FOREIGN KEY([QAC_SCPId])
	REFERENCES [dbo].[TP_ServiceCalculateParametrs] ([SCP_Id])
	ON DELETE CASCADE
GO

ALTER TABLE [dbo].[TP_QueueAddCosts] CHECK CONSTRAINT [FK_TP_QueueAddCosts_TP_ServiceCalculateParametrs]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_TP_QueueAddCosts_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[TP_QueueAddCosts]  WITH CHECK ADD  CONSTRAINT [FK_TP_QueueAddCosts_tbl_TurList] FOREIGN KEY([QAC_TRKey])
	REFERENCES [dbo].[tbl_TurList] ([TL_Key])
	ON DELETE CASCADE
GO

ALTER TABLE [dbo].[TP_QueueAddCosts] CHECK CONSTRAINT [FK_TP_QueueAddCosts_tbl_TurList]
GO

if not exists( select * from dbo.sysobjects  where id = object_id(N'[dbo].[DF_TP_QueueAddCosts_QAC_DateCreate]') ) 
	ALTER TABLE [dbo].[TP_QueueAddCosts] ADD  CONSTRAINT [DF_TP_QueueAddCosts_QAC_DateCreate]  DEFAULT (getdate()) FOR [QAC_DateCreate]
GO

grant select, update, insert, delete on dbo.TP_QueueAddCosts to public
go

/*********************************************************************/
/* end CREATE_TP_QueueAddCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_CostOfferPackets.sql */
/*********************************************************************/
if not exists (select 1 from sysobjects where id = object_id(N'[dbo].[CostOfferPackets]') and xtype = 'U')
	CREATE TABLE [dbo].[CostOfferPackets](
		[COP_ID] [int] IDENTITY(1,1) NOT NULL,
		[COP_COID] [int] NOT NULL,
		[COP_PKKey] [int] NOT NULL,
	 CONSTRAINT [PK_CostOfferPackets] PRIMARY KEY CLUSTERED 
	(
		[COP_ID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOfferPackets_CostOffers]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	ALTER TABLE [dbo].[CostOfferPackets]  WITH CHECK ADD  CONSTRAINT [FK_CostOfferPackets_CostOffers] FOREIGN KEY([COP_COID])
	REFERENCES [dbo].[CostOffers] ([CO_Id])
	ON DELETE CASCADE
GO

ALTER TABLE [dbo].[CostOfferPackets] CHECK CONSTRAINT [FK_CostOfferPackets_CostOffers]
GO

--if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOfferPackets_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
--	ALTER TABLE [dbo].[CostOfferPackets]  WITH CHECK ADD  CONSTRAINT [FK_CostOfferPackets_tbl_TurList] FOREIGN KEY([COP_PKKey])
--	REFERENCES [dbo].[tbl_TurList] ([TL_KEY])
--GO

--ALTER TABLE [dbo].[CostOfferPackets] CHECK CONSTRAINT [FK_CostOfferPackets_tbl_TurList]
--GO

if exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_CostOfferPackets_tbl_TurList]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
	alter table CostOfferPackets drop constraint FK_CostOfferPackets_tbl_TurList
go

grant select, update, insert, delete on dbo.CostOfferPackets to public
go
/*********************************************************************/
/* end CREATE_CostOfferPackets.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_TP_PricesCleaner.sql */
/*********************************************************************/
if not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[TP_PricesCleaner]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
BEGIN

CREATE TABLE [dbo].[TP_PricesCleaner](
	[PC_Id] [bigint] IDENTITY(1,1) NOT NULL,
	[PC_TRKEY] [int] NOT NULL,
	[PC_TOKEY] [int] NOT NULL,
	[PC_TPKEY] [int] NOT NULL,
	[PC_CalculatingKey] [int] NOT NULL,
	[PC_CreateDate] [datetime] NOT NULL,
 CONSTRAINT [PK_TP_PricesCleaner] PRIMARY KEY CLUSTERED 
(
	[PC_Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[TP_PricesCleaner] ADD  CONSTRAINT [DF__TP_Prices__PC_Cr__07FE24C0]  DEFAULT (getdate()) FOR [PC_CreateDate]

END

GO

grant select, insert, update, delete on [dbo].[TP_PricesCleaner] to public
GO
/*********************************************************************/
/* end CREATE_TP_PricesCleaner.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_mwReplQueue.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplQueue]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[mwReplQueue](
		[rq_id] [int] IDENTITY(1,1) NOT NULL,
		[rq_crdate] [datetime] NOT NULL,
		[rq_mode] [int] NOT NULL,
		[rq_tokey] [int] NOT NULL,
		[rq_state] [int] NOT NULL,
		[rq_priority] [int] NOT NULL,
		[rq_remark] [varchar](256) NULL,
		[rq_startdate] [datetime] NULL,
		[rq_enddate] [datetime] NULL,
		[RQ_CalculatingKey] [int] NULL,
		[RQ_OverwritePrices] [bit] NULL
	CONSTRAINT [PK_mwReplQueue] PRIMARY KEY CLUSTERED 
	(
		[rq_id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
end
GO

IF NOT EXISTS (SELECT * FROM sys.sysconstraints WHERE constid = OBJECT_ID(N'[dbo].[DF_mwReplQueue_rq_crdate]'))
	ALTER TABLE [dbo].[mwReplQueue] ADD  CONSTRAINT [DF_mwReplQueue_rq_crdate]  DEFAULT (getdate()) FOR [rq_crdate]
GO

IF NOT EXISTS (SELECT * FROM sys.sysconstraints WHERE constid = OBJECT_ID(N'[dbo].[DF_mwReplQueue_rq_state]'))
	ALTER TABLE [dbo].[mwReplQueue] ADD  CONSTRAINT [DF_mwReplQueue_rq_state]  DEFAULT ((1)) FOR [rq_state]
GO

IF NOT EXISTS (SELECT * FROM sys.sysconstraints WHERE constid = OBJECT_ID(N'[dbo].[DF_mwReplQueue_rq_priority]'))
	ALTER TABLE [dbo].[mwReplQueue] ADD  CONSTRAINT [DF_mwReplQueue_rq_priority]  DEFAULT ((500)) FOR [rq_priority]
GO

if exists (select id from syscolumns where id = OBJECT_ID('mwReplQueue') and name = 'rq_add')
	alter table dbo.mwReplQueue drop column rq_add
go

if not exists (select id from syscolumns where id = OBJECT_ID('mwReplQueue') and name = 'rq_CalculatingKey')
	alter table dbo.mwReplQueue add rq_CalculatingKey int
go

if not exists (select id from syscolumns where id = OBJECT_ID('mwReplQueue') and name = 'rq_OverwritePrices')
	alter table dbo.mwReplQueue add rq_OverwritePrices bit
go

grant select, update, insert, delete on dbo.mwReplQueue to public
go

/*********************************************************************/
/* end CREATE_mwReplQueue.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.01.27)_ADD_COLUMNS_TP_Flights.sql */
/*********************************************************************/
if not exists (select 1 from dbo.syscolumns where name = 'TF_TSKeyOld' and id = object_id(N'[dbo].[TP_Flights]'))
	alter table dbo.TP_Flights add TF_TSKeyOld int null
go
	
if not exists (select 1 from dbo.syscolumns where name = 'TF_TSKeyNew' and id = object_id(N'[dbo].[TP_Flights]'))
	alter table dbo.TP_Flights add TF_TSKeyNew int null
go
/*********************************************************************/
/* end (2012.01.27)_ADD_COLUMNS_TP_Flights.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.04.11)_ADD_TF_SubCode1New_TP_Flights.sql */
/*********************************************************************/
if not exists (select * from syscolumns where name='TF_SubCode1New' and id=object_id('dbo.TP_Flights'))
begin
	alter table dbo.TP_Flights add TF_SubCode1New int null;
end
go
/*********************************************************************/
/* end (2012.04.11)_ADD_TF_SubCode1New_TP_Flights.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.04.11)_DATA_AirService.sql */
/*********************************************************************/
update AirService
set AS_CODE = AS_NAMELAT
where AS_CODE is null
go
/*********************************************************************/
/* end (2012.04.11)_DATA_AirService.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.21)_ADD_CS_COID_tbl_Costs.sql */
/*********************************************************************/
if not exists (select * from syscolumns where name='CS_COID' and id=object_id('dbo.tbl_Costs'))
begin
	alter table dbo.tbl_Costs add CS_COID int null;
end
go

exec sp_refreshviewforall 'Costs'
go
/*********************************************************************/
/* end (2012.02.21)_ADD_CS_COID_tbl_Costs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.21)_ADD_TP_Updatedate_TP_Prices.sql */
/*********************************************************************/
if not exists (select * from syscolumns where name='TP_Updatedate' and id=object_id('TP_Prices'))
	alter table dbo.TP_Prices add TP_Updatedate datetime null;

go
/*********************************************************************/
/* end (2012.02.21)_ADD_TP_Updatedate_TP_Prices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.01)_Add_Columns_mwReplTours.sql */
/*********************************************************************/
if not exists(select id from syscolumns where id = OBJECT_ID('mwReplTours') and name = 'RT_CalcKey')
     alter TABLE [dbo].[mwReplTours] add [RT_CalcKey] int NULL
go

if exists(select id from syscolumns where id = OBJECT_ID('mwReplTours') and name = 'RT_add')
     alter TABLE [dbo].[mwReplTours] drop column [RT_add]
go 

if not exists(select id from syscolumns where id = OBJECT_ID('mwReplTours') and name = 'RT_OverwritePrices')
     ALTER TABLE dbo.mwReplTours add rt_overwritePrices bit null default 1
go
/*********************************************************************/
/* end (2012.02.01)_Add_Columns_mwReplTours.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_SCP_Object1_TP_ServiceCalculateParametrs.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_SCP_Object1' and id = object_id(N'TP_ServiceCalculateParametrs'))
	CREATE NONCLUSTERED INDEX [x_SCP_Object1] ON [dbo].[TP_ServiceCalculateParametrs] 
	(
		[SCP_SCId] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO



/*********************************************************************/
/* end INDEX_ADD_x_SCP_Object1_TP_ServiceCalculateParametrs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_QueueAddCosts_TP_QueueAddCosts.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_TP_QueueAddCosts' and id = object_id(N'TP_QueueAddCosts'))
	CREATE NONCLUSTERED INDEX [x_TP_QueueAddCosts] ON [dbo].[TP_QueueAddCosts] 
	(
		[QAC_ADCId] ASC,
		[QAC_SCPId] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_QueueAddCosts_TP_QueueAddCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_ServiceCalculateParametrs_TP_ServiceCalculateParametrs.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_TP_ServiceCalculateParametrs' and id = object_id(N'TP_ServiceCalculateParametrs'))
	CREATE NONCLUSTERED INDEX [x_TP_ServiceCalculateParametrs] ON [dbo].[TP_ServiceCalculateParametrs] 
	(
		[SCP_SCId] ASC,
		[SCP_Date] ASC,
		[SCP_DateCheckIn] ASC,
		[SCP_Men] ASC,
		[SCP_Days] ASC,
		[SCP_TourDays] ASC,
		[SCP_PKKey] ASC,
		[SCP_DeleteDate] ASC,
		[SCP_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_ServiceCalculateParametrs_TP_ServiceCalculateParametrs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_ServiceComponents_1_TP_ServiceComponents.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_TP_ServiceComponents_1' and id = object_id(N'TP_ServiceComponents'))
	CREATE NONCLUSTERED INDEX [x_TP_ServiceComponents_1] ON [dbo].[TP_ServiceComponents] 
	(
		[SC_SVKey] ASC,
		[SC_Code] ASC,
		[SC_SubCode1] ASC,
		[SC_SubCode2] ASC,
		[SC_PRKey] ASC,
		[SC_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_ServiceComponents_1_TP_ServiceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_TP_ServicePriceActualDate_NeedApply_TP_ServicePriceActualDate.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='X_TP_ServicePriceActualDate_NeedApply' and id = object_id(N'TP_ServicePriceActualDate'))
	CREATE NONCLUSTERED INDEX [X_TP_ServicePriceActualDate_NeedApply] ON [dbo].[TP_ServicePriceActualDate] 
	(
		[SPAD_SaleDate] ASC,
		[SPAD_NeedApply] ASC
	)
	INCLUDE ( [SPAD_Id],
	[SPAD_SCPId],
	[SPAD_IsCommission],
	[SPAD_Rate],
	[SPAD_Gross],
	[SPAD_DateLastChange],
	[SPAD_AutoOnline],
	[SPAD_DateLastCalculate]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_X_TP_ServicePriceActualDate_NeedApply_TP_ServicePriceActualDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_ServicePriceActualDate_TP_ServicePriceActualDate.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_TP_ServicePriceActualDate' and id = object_id(N'TP_ServicePriceActualDate'))
	CREATE NONCLUSTERED INDEX [x_TP_ServicePriceActualDate] ON [dbo].[TP_ServicePriceActualDate] 
	(
		[SPAD_SCPId],
		[SPAD_SaleDate]
	)
	include
	(
		[SPAD_Netto],
		[SPAD_NeedApply],
		[SPAD_Gross],
		[SPAD_IsCommission],
		[SPAD_Rate],
		[SPAD_DateLastChange],
		[SPAD_DateLastCalculate],
		[SPAD_AutoOnline]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_ServicePriceActualDate_TP_ServicePriceActualDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_TourMarginActualDate_TP_TourMarginActualDate.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_TP_TourMarginActualDate' and id = object_id(N'TP_TourMarginActualDate'))
	CREATE NONCLUSTERED INDEX [x_TP_TourMarginActualDate] ON [dbo].[TP_TourMarginActualDate] 
	(
		[TMAD_NeedApply]
	)
	INCLUDE 
	(
		[TMAD_Id],
		[TMAD_TRKey],
		[TMAD_SvKey],
		[TMAD_DateCheckIn],
		[TMAD_Percent],
		[TMAD_IsCommission],
		[TMAD_Long]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_TourMarginActualDate_TP_TourMarginActualDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_FindHottel_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_FindHottel')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_FindHottel] ON [dbo].[TP_PriceComponents] 
	(
		[PC_DepartureKey],
		[PC_HotelKey],
		[PC_TourDate],
		[PC_TOKey],
		[SVKey_1]
	)
	INCLUDE
	( 
		[PC_Id],
		[PC_Days],
		[MarginPercent_1],
		[SCPId_1],
		[PC_TPKey]		
	) 
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_FindHottel_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_TourDate_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'X_TP_PriceComponents_TourDate')
CREATE NONCLUSTERED INDEX [X_TP_PriceComponents_TourDate] ON [dbo].[TP_PriceComponents] 
(		
	PC_TourDate,
	PC_TOKey,
	PC_Days,
	PC_Rate
)
include
(	
	PC_Id,
	SVKey_1,
	SCPId_1,
	SVKey_2,
	SCPId_2,
	SVKey_3,
	SCPId_3,
	SVKey_4,
	SCPId_4,
	SVKey_5,
	SCPId_5,
	SVKey_6,
	SCPId_6,
	SVKey_7,
	SCPId_7,
	SVKey_8,
	SCPId_8,
	SVKey_9,
	SCPId_9,
	SVKey_10,
	SCPId_10,
	SVKey_11,
	SCPId_11,
	SVKey_12,
	SCPId_12,
	SVKey_13,
	SCPId_13,
	SVKey_14,
	SCPId_14,
	SVKey_15,
	SCPId_15
)
 WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO



/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_TourDate_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege1_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege1')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege1] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_1],
		[SVKey_1]
	) INCLUDE 
	(		
		[Gross_1],		
		[AddCostNoCommission_1],
		[AddCostIsCommission_1],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege1_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege2_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege2')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege2] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_2],
		[SVKey_2]
	) INCLUDE 
	(		
		[Gross_2],		
		[AddCostNoCommission_2],
		[AddCostIsCommission_2],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege2_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege3_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege3')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege3] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_3],
		[SVKey_3]
	) INCLUDE 
	(		
		[Gross_3],		
		[AddCostNoCommission_3],
		[AddCostIsCommission_3],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege3_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege4_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege4')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege4] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_4],
		[SVKey_4]
	) INCLUDE 
	(		
		[Gross_4],		
		[AddCostNoCommission_4],
		[AddCostIsCommission_4],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege4_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege5_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege5')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege5] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_5],
		[SVKey_5]
	) INCLUDE 
	(		
		[Gross_5],		
		[AddCostNoCommission_5],
		[AddCostIsCommission_5],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege5_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege6_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege6')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege6] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_6],
		[SVKey_6]
	) INCLUDE 
	(		
		[Gross_6],		
		[AddCostNoCommission_6],
		[AddCostIsCommission_6],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege6_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege7_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege7')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege7] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_7],
		[SVKey_7]
	) INCLUDE 
	(		
		[Gross_7],		
		[AddCostNoCommission_7],
		[AddCostIsCommission_7],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege7_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege8_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege8')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege8] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_8],
		[SVKey_8]
	) INCLUDE 
	(		
		[Gross_8],		
		[AddCostNoCommission_8],
		[AddCostIsCommission_8],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege8_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege9_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege9')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege9] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_9],
		[SVKey_9]
	) INCLUDE 
	(		
		[Gross_9],		
		[AddCostNoCommission_9],
		[AddCostIsCommission_9],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege9_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege10_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege10')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege10] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_10],
		[SVKey_10]
	) INCLUDE 
	(		
		[Gross_10],		
		[AddCostNoCommission_10],
		[AddCostIsCommission_10],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege10_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege11_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege11')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege11] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_11],
		[SVKey_11]
	) INCLUDE 
	(		
		[Gross_11],		
		[AddCostNoCommission_11],
		[AddCostIsCommission_12],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege11_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege12_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege12')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege12] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_12],
		[SVKey_12]
	) INCLUDE 
	(		
		[Gross_12],
		[AddCostNoCommission_12],
		[AddCostIsCommission_12],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege12_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege13_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege13')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege13] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_13],
		[SVKey_13]
	) INCLUDE 
	(		
		[Gross_13],		
		[AddCostNoCommission_13],
		[AddCostIsCommission_13],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege13_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege14_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege14')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege14] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_14],
		[SVKey_14]
	) INCLUDE 
	(		
		[Gross_14],		
		[AddCostNoCommission_14],
		[AddCostIsCommission_14],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege14_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_Cortege15_TP_PriceComponents.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'x_TP_PriceComponents_Cortege15')
	CREATE NONCLUSTERED INDEX [x_TP_PriceComponents_Cortege15] ON [dbo].[TP_PriceComponents] 
	(
		[SCPId_15],
		[SVKey_15]
	) INCLUDE 
	(		
		[Gross_15],		
		[AddCostNoCommission_15],
		[AddCostIsCommission_15],
		[PC_Id],
		[PC_TOKey],
		[PC_Rate],
		[PC_TourDate]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_Cortege15_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_Search_AddCosts.sql */
/*********************************************************************/
if not exists ( select * from sysindexes where id = object_id(N'[dbo].[AddCosts]') and name = N'X_Search' ) 
	CREATE NONCLUSTERED INDEX [X_Search] ON [dbo].[AddCosts] 
	(
		[ADC_TLKey],
		[ADC_ACNId],
		[ADC_SVKey],
		[ADC_Code],
		[ADC_SubCode1],
		[ADC_SubCode2],
		[ADC_PartnerKey],
		[ADC_PansionKey],
		[ADC_CheckinDateBeg],
		[ADC_CheckinDateEnd],
		[ADC_LongMin],
		[ADC_LongMax],		
		[ADC_CreateDate] desc,
		[ADC_DisableDate]		
	)
	include
	(
		ADC_TypeId,
		ADC_Value,
		ADC_ValueChild,
		ADC_Rate,
		ADC_IsCommission,
		ADC_IsDay
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_X_Search_AddCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_CostOffers_CostOffers.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_CostOffers' and id = object_id(N'CostOffers'))
	create index x_CostOffers on CostOffers
	(
		CO_PKKey,
		CO_SaleDateBeg,
		CO_SaleDateEnd,
		CO_PartnerKey,
		CO_SVKey,
		CO_SeasonId
	);
go
/*********************************************************************/
/* end INDEX_ADD_x_CostOffers_CostOffers.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_COID_tbl_Costs.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='X_COID' and id = object_id(N'tbl_Costs'))
	CREATE NONCLUSTERED INDEX [X_COID] ON [dbo].[tbl_Costs] 
	(
		[CS_COID] ASC
	)
	INCLUDE ( [CS_SVKEY],
	[CS_CODE],
	[CS_PKKEY],
	[CS_PRKEY]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]

go
/*********************************************************************/
/* end INDEX_ADD_x_COID_tbl_Costs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_CS_CINNUM_CS_COID_CS_UPDDATE_tbl_Costs.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='X_CS_CINNUM_CS_COID_CS_UPDDATE' and id = object_id(N'tbl_Costs'))
	CREATE NONCLUSTERED INDEX [X_CS_CINNUM_CS_COID_CS_UPDDATE] ON [dbo].[tbl_Costs] 
	(
		CS_CINNUM, CS_COID, CS_UPDDATE
	)
	INCLUDE ( [CS_SVKEY],
	[CS_PKKEY],
	[CS_PRKEY],
	[cs_DateSellBeg],
	[cs_DateSellEnd]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]

go
/*********************************************************************/
/* end INDEX_ADD_X_CS_CINNUM_CS_COID_CS_UPDDATE_tbl_Costs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_Prices_CalculatingKey_TP_Prices.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_Prices]') AND name = N'x_TP_Prices_CalculatingKey')
	CREATE NONCLUSTERED INDEX [x_TP_Prices_CalculatingKey] ON [dbo].[TP_Prices] 
	(
		[TP_CalculatingKey] ASC,
		[tp_updatedate] ASC
	)
	INCLUDE ( [TP_Key],
	[TP_TOKey],
	[TP_DateBegin],
	[TP_DateEnd],
	[TP_Gross],
	[TP_TIKey]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_Prices_CalculatingKey_TP_Prices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_COS_Code_COId_CostOfferServices.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_COS_Code_COId' and id = object_id(N'CostOfferServices'))
CREATE NONCLUSTERED INDEX [x_COS_Code_COId] ON [dbo].[CostOfferServices] 
(
	[COS_CODE] ASC,
	[COS_COID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_COS_Code_COId_CostOfferServices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_COP_PKKey_COID_CostOfferPackets.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_COP_PKKey_COID' and id = object_id(N'CostOfferPackets'))
CREATE NONCLUSTERED INDEX [x_COP_PKKey_COID] ON [dbo].[CostOfferPackets] 
(
	[COP_PKKey] ASC,
	[COP_COID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO

/*********************************************************************/
/* end INDEX_ADD_x_COP_PKKey_COID_CostOfferPackets.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ALTER_X_TM_TlKey_TURMARGIN.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TURMARGIN]') AND name = N'X_TM_TlKey')
DROP INDEX [X_TM_TlKey] ON [dbo].[TURMARGIN] WITH ( ONLINE = OFF )
GO
CREATE NONCLUSTERED INDEX [X_TM_TlKey] ON [dbo].[TURMARGIN] 
(
	TM_TlKey,
	TM_SVKEY,
	TM_Week,
	TM_LONG,
	TM_DateBeg,
	TM_DateEnd
) include (TM_Margin, TM_MarginType, TM_FromPacket, TM_DateSellEnd, TM_DateSellBeg)
WITH (PAD_INDEX  = ON, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 20) ON [PRIMARY]
GO



/*********************************************************************/
/* end INDEX_ALTER_X_TM_TlKey_TURMARGIN.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_XML_SCHEMA_ArrayOfInt.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.xml_schema_collections c, sys.schemas s WHERE c.schema_id = s.schema_id AND (quotename(s.name) + '.' + quotename(c.name)) = N'[dbo].[ArrayOfInt]')
begin
	CREATE XML SCHEMA COLLECTION [dbo].[ArrayOfInt] AS 
	N'<?xml version="1.0" encoding="utf-16"?>
	<xs:schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xs="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified" elementFormDefault="qualified">
	  <xsd:element name="ArrayOfInt">
		<xsd:complexType>
		  <xsd:sequence>
			<xsd:element maxOccurs="unbounded" name="int" type="xsd:unsignedInt" />
		  </xsd:sequence>
		</xsd:complexType>
	  </xsd:element>
	</xs:schema>'
end
GO
/*********************************************************************/
/* end CREATE_XML_SCHEMA_ArrayOfInt.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_XML_SCHEMA_ArrayOfShort.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.xml_schema_collections c, sys.schemas s WHERE c.schema_id = s.schema_id AND (quotename(s.name) + '.' + quotename(c.name)) = N'[dbo].[ArrayOfShort]')
begin
	CREATE XML SCHEMA COLLECTION [dbo].[ArrayOfShort] AS 
	N'<?xml version="1.0" encoding="utf-16"?>
	<xs:schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xs="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified" elementFormDefault="qualified">
	  <xsd:element name="ArrayOfShort">
		<xsd:complexType>
		  <xsd:sequence>
			<xsd:element maxOccurs="unbounded" name="short" type="xsd:unsignedShort" />
		  </xsd:sequence>
		</xsd:complexType>
	  </xsd:element>
	</xs:schema>'
end
GO


/*********************************************************************/
/* end CREATE_XML_SCHEMA_ArrayOfShort.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_XML_SCHEMA_ArrayOfLong.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.xml_schema_collections c, sys.schemas s WHERE c.schema_id = s.schema_id AND (quotename(s.name) + '.' + quotename(c.name)) = N'[dbo].[ArrayOfLong]')
begin
	CREATE XML SCHEMA COLLECTION [dbo].[ArrayOfLong] AS 
	N'<?xml version="1.0" encoding="utf-16"?>
	<xs:schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xs="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified" elementFormDefault="qualified">
	  <xsd:element name="ArrayOfLong">
		<xsd:complexType>
		  <xsd:sequence>
			<xsd:element maxOccurs="unbounded" name="long" type="xsd:unsignedLong" />
		  </xsd:sequence>
		</xsd:complexType>
	  </xsd:element>
	</xs:schema>'
end
GO


/*********************************************************************/
/* end CREATE_XML_SCHEMA_ArrayOfLong.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CREATE_XML_SCHEMA_ArrayOfPairOfInt32DateTime.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.xml_schema_collections c, sys.schemas s WHERE c.schema_id = s.schema_id AND (quotename(s.name) + '.' + quotename(c.name)) = N'[dbo].[ArrayOfPairOfInt32DateTime]')
begin
	CREATE XML SCHEMA COLLECTION [dbo].[ArrayOfPairOfInt32DateTime] AS 
	N'<?xml version="1.0" encoding="utf-16"?>
	<xs:schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xs="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified" elementFormDefault="qualified">
	  <xsd:element name="ArrayOfPairOfInt32DateTime">
		<xsd:complexType>
		  <xsd:sequence>
			<xsd:element maxOccurs="unbounded" name="PairOfInt32DateTime">
			  <xsd:complexType>
				<xsd:sequence>
				  <xsd:element name="First" type="xsd:unsignedInt" />
				  <xsd:element name="Second" type="xsd:dateTime" />
				</xsd:sequence>
			  </xsd:complexType>
			</xsd:element>
		  </xsd:sequence>
		</xsd:complexType>
	  </xsd:element>
	</xs:schema>'
end
GO
/*********************************************************************/
/* end CREATE_XML_SCHEMA_ArrayOfPairOfInt32DateTime.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceAddCosts.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetServiceAddCosts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetServiceAddCosts]
GO
CREATE PROCEDURE [dbo].[GetServiceAddCosts]
	(
		-- хранимка расчитывает доплаты по услуге
		--<data>2012-03-12</data>
		--<version>2009.02.10</version>
		/*mv 27.01.2012 : Внимание!
			в хранимке [dbo].[GetServiceAddCosts] 
			добавил параметр @days - новый обязательный параметр
			передача ключа партнера теперь идет сразу за SubCode2 (по аналогии с GetServiceCosts)
			переименовал параметр, возвращающий валюту @addCostRate
		  mv 27.01.2012_2 Добавил учет типа доплаты (за взрослого/ребенка и т.д.)
		  mv 27.01.2012_3 Добавил параметр "дата расчета" - @sellDate
		  AleXK 31.01.2012 Добавил 2 выходных параметра доплата за ребенка и доплата за взрослого
		  Gorshkov 10.02.2012 Добавил необязательный параметр - тип доплаты (@addCostType)
		  Gorshkov 10.02.2012_2 Теперь хранимка возвращает не сумму всех доплат, а только сумму последних доплат по каждому классу доплат
		*/
		@tourKey int,
		@svKey int,
		@code int,
		@SubCode1 int,
		@SubCode2 int,
		@partnerKey int,
		@tourDate datetime,
		@tourDays int,
		@serviceDays int,
		@men int,
		@sellDate datetime = null,
		@addCostClass int = null,
		@addCostValueIsCommission money output,
		@addCostValueNoCommission money output,
		-- тут доплата только за 1 взрослого
		@addCostFromAdult money output,
		-- тут доплата только за 1 ребенка
		@addCostFromChild money output,
		@addCostRate nvarchar(2) output
	)
AS
BEGIN
	set @addCostValueIsCommission = null
	set @addCostValueNoCommission = null
	set @addCostFromAdult = null
	set @addCostFromChild = null
	set	@addCostRate=null

	if @tourKey is null
	begin
		return 0
	end

	declare @internal_pansionKey int, @internal_subCode1 int, @internal_subCode2 int, @internal_subCode3 int,
			@internal_Main_Count int, @internal_ExB_Count int
	-- отдельно обработаем отель
	if (@svKey = 3)
	begin
		set @internal_pansionKey = @SubCode2
		
		select @internal_subCode1 = HR_RMKEY, @internal_subCode2 = HR_RCKEY, @internal_subCode3=HR_ACKEY
		from HotelRooms with(nolock)
		where HR_KEY = @SubCode1
		
		if @internal_subCode1 is null
		begin
			return 0
		end
		
		select @internal_Main_Count=IsNull(AC_NRealPlaces,0), @internal_ExB_Count=IsNull(AC_NMenExBed,0) 
		from Accmdmentype with(nolock)
		where AC_Key=@internal_subCode3
		
		If @internal_Main_Count=0 and @internal_ExB_Count=0
		begin
			set @internal_Main_Count=1
		end
	end
	else
	begin
		set @internal_pansionKey = null
		set @internal_subCode1=@SubCode1 
		set @internal_subCode2=@SubCode2
	end
	
	-- если наща услуга без продолжительности то устанавливаем ей продолжительность равную продолжительности тура
	-- что бы доплата не обнылялась если она за сутки
	if (exists (select top 1 1 from [Service] with(nolock) where SV_KEY = @svKey and SV_IsDuration != 1))
	begin
		set @serviceDays = @tourDays
	end;
	
	with onlyNeededAddCosts as
	(
		select *
		from dbo.AddCosts with(nolock)
		where 
			ADC_TLKey = @tourKey
			and ADC_SVKey = @svKey
			and (ADC_Code = 0 or ADC_Code = @code)
			and (ADC_SubCode1=0 or ADC_SubCode1 = @internal_subCode1)
			and (ADC_SubCode2=0 or ADC_SubCode2 = @internal_subCode2)
			and (ADC_PartnerKey=0 or ADC_PartnerKey = @partnerKey)
			and ((@internal_pansionKey is not null and (ADC_PansionKey=0 or ADC_PansionKey = @internal_pansionKey)) or (@internal_pansionKey is null))	
			and @tourDate between ADC_CheckinDateBeg and ADC_CheckinDateEnd
			and ((isnull(ADC_LongMin, 0) = 0 and isnull(ADC_LongMax, 0) = 0) or (@tourDays between ADC_LongMin and ADC_LongMax))
			and ((@sellDate is not null and @sellDate >= CONVERT(varchar(8), ADC_CreateDate, 112)) or (@sellDate is null))
			and ((ADC_DisableDate is null) or (ADC_DisableDate is not null and @sellDate < CONVERT(varchar(8), ADC_DisableDate, 112)))
			and (@addCostClass is null or ADC_ACNId = @addCostClass)
	),
	theLatestInEachAddCostType as
	(
		select ADC_TypeId, ADC_Value, ADC_ValueChild, ADC_CreateDate, ADC_Rate, ADC_IsCommission, ADC_IsDay
		from onlyNeededAddCosts as onac
		where ADC_CreateDate = (select max(ac.ADC_CreateDate)
								from onlyNeededAddCosts as ac 
								where ac.ADC_ACNId = onac.ADC_ACNId)
	)
	
	select top 1
		@addCostValueIsCommission = sum(case when ADC_IsCommission = 1 then isnull(ADC_Value * (CASE WHEN ADC_IsDay = 0 THEN @serviceDays ELSE 1 END) * (CASE ADC_TypeID WHEN 1 THEN 1 WHEN 3 THEN @internal_Main_Count ELSE @men END), 0) else 0 end) +
									sum(case when ADC_IsCommission = 1 then isnull(isnull(ADC_ValueChild, 0) * (CASE WHEN ADC_IsDay = 0 THEN @serviceDays ELSE 1 END) * (CASE ADC_TypeID WHEN 1 THEN 0 when 2 then 0 WHEN 3 THEN @internal_ExB_Count END), 0) else 0 end),
		@addCostValueNoCommission = sum(case when ADC_IsCommission = 0 then isnull(ADC_Value * (CASE WHEN ADC_IsDay = 0 THEN @serviceDays ELSE 1 END) * (CASE ADC_TypeID WHEN 1 THEN 1 WHEN 3 THEN @internal_Main_Count ELSE @men END), 0) else 0 end) +
									sum(case when ADC_IsCommission = 0 then isnull(isnull(ADC_ValueChild, 0) * (CASE WHEN ADC_IsDay = 0 THEN @serviceDays ELSE 1 END) * (CASE ADC_TypeID WHEN 1 THEN 0 when 2 then 0 WHEN 3 THEN @internal_ExB_Count END), 0) else 0 end),
		@addCostFromAdult = sum(isnull(ADC_Value * (CASE WHEN ADC_IsDay = 0 THEN @serviceDays ELSE 1 END), 0)),
		@addCostFromChild = sum(isnull((case when ADC_TypeID = 3 then isnull(ADC_ValueChild, 0) else ADC_Value end) * (CASE WHEN ADC_IsDay = 0 THEN @serviceDays ELSE 1 END), 0)),
		@addCostRate = ADC_Rate
	from theLatestInEachAddCostType
	group by ADC_Rate;
END

GO



grant exec on [dbo].[GetServiceAddCosts] to public
go
/*********************************************************************/
/* end sp_GetServiceAddCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetTourMargin.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetTourMargin]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetTourMargin]
GO
CREATE PROCEDURE [dbo].[GetTourMargin]
	(
		--<DATE>2012-03-14</DATE>
		--<VERSION>2009.02.04</VERSION>
		@TrKey int, 
		@Date datetime, 
		@margin float output, 
		@marginType int output, 
		@svKey int, 
		@days int, 
		@sellDate DateTime = null,
		@packetKey int		
	)
as	
	SET DATEFIRST 1

	if @sellDate is null
	begin
		set @sellDate = GetDate()
	end

	set @margin = 0
	set @marginType = 0

	declare @nFromPacket int
	declare @dtSale DateTime
	Set @nFromPacket = 0
	
	-- посмотрим используется ли динамическое ценообразование
	declare @NewReCalculatePrice bit; set @NewReCalculatePrice=0
	if ( exists( select top 1 1 from SystemSettings where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue = 1))
	begin
		set @NewReCalculatePrice=1
	end

	SELECT TOP 1	@margin = TM_Margin, @marginType = TM_MarginType, @nFromPacket = TM_FromPacket, 
					@dtSale = ISNULL(TM_DateSellEnd,ISNULL(DATEADD(YEAR,10,TM_DateSellBeg),DATEADD(YEAR,15,GetDate())))
	FROM
		dbo.TurMargin
	WHERE
		TM_TlKey = @TrKey 
		and @Date Between TM_DateBeg and TM_DateEnd
		and (TM_SVKEY = @svKey or TM_SVKEY = 0)
		-- @sellDate обрабатывается только если НЕ используется динамическое ценообразование
		and (@NewReCalculatePrice = 1 or
			(@sellDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@sellDate <= (TM_DateSellEnd + 1) or TM_DateSellEnd is null))
		and ((TM_Week like '%' + cast(datepart(weekday, @Date)as varchar(1)) + '%') or TM_Week like '.......' or TM_Week like '')
		and (TM_LONG = @days - 1 or TM_LONG = 0)
	ORDER BY	TM_SVKEY DESC,  TM_DateBeg DESC, TM_DateEnd, 4, TM_LONG DESC
	
	-- обработка наценки на пакет обрабатывается только если НЕ используется динамическое ценообразование
	if @nFromPacket = 1 AND @packetKey > 0 and @NewReCalculatePrice = 0
	begin 
		set @margin = 0
		set @marginType = 0
		SELECT TOP 1	@margin = TM_Margin, @marginType = TM_MarginType, @nFromPacket = TM_FromPacket, 
						@dtSale = ISNULL(TM_DateSellEnd,ISNULL(DATEADD(YEAR,10,TM_DateSellBeg),DATEADD(YEAR,15,GetDate())))
		FROM
			dbo.TurMargin
		WHERE
			TM_TlKey = @packetKey
			and @Date Between TM_DateBeg and TM_DateEnd
			and (TM_SVKEY = @svKey or TM_SVKEY = 0)
			and (@sellDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@sellDate <= (TM_DateSellEnd + 1) or TM_DateSellEnd is null)
			and ((TM_Week like '%' + cast(datepart(weekday, @Date)as varchar(1)) + '%') or TM_Week like '.......' or TM_Week like '')
			and (TM_LONG = @days - 1 or TM_LONG = 0)
			and TM_FromPacket = 0
		ORDER BY	TM_SVKEY DESC,  TM_DateBeg DESC, TM_DateEnd, 4, TM_LONG DESC
	end

	if @margin is null
	begin
		set @margin = 0
	end
	If @marginType is null
	begin
		set @marginType = 0		
	end
	Return 0
GO

grant exec on [dbo].[GetTourMargin] to public
go
/*********************************************************************/
/* end sp_GetTourMargin.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetCalculateHotelCombination.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetCalculateHotelCombination]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetCalculateHotelCombination]
GO
CREATE PROCEDURE [dbo].[GetCalculateHotelCombination]
	(
		-- хранимка возвращает список комбинаций (номер, категория, размещение, питание) по ключам отеля
		@hotelKeys nvarchar(max) -- список ключей отеллей разделенных запятой
	)
AS
--<data>2012-03-02</data>
--<version>2009.02.01</version>
BEGIN
	declare @hotelService int
	set @hotelService = 3
	
	select distinct HR_RMKEY, HR_RCKEY, HR_ACKEY, SC_SubCode2
	from TP_ServiceComponents join HotelRooms on HR_KEY = SC_SubCode1
	where SC_SVKey = @hotelService
	and SC_Code in (select xt_key from dbo.ParseKeys(@hotelKeys))
END

GO

grant exec on [dbo].[GetCalculateHotelCombination] to public
go

/*********************************************************************/
/* end sp_GetCalculateHotelCombination.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_CreateServiceCalculateParametrs.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_CreateServiceCalculateParametrs]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_CreateServiceCalculateParametrs]
GO

CREATE PROCEDURE [dbo].[ReCalculate_CreateServiceCalculateParametrs]
	(
		-- хранимка создает структуру детализации цены по услугам
		--<data>2012-03-01</data>
		--<version>2009.02.04</version>
		--.03 mv 29-02-2012 Добавил заполнение поля SCP_TourDays
		--.02 mv 28-02-2012 (MEG00040283) Добавил обработку продолжительности для а/п
		@nSvkey int,
		@nCode int,
		@nSubcode1 int,
		@nSubcode2 int,
		@nPrkey int,
		@nDay int,
		@turdate datetime,
		@nMen int,
		@nServiceDays int,
		@nPacketkey int,
		@nTourDays int,
		@scId int output, -- ключ найденой записи в таблице TP_ServiceComponents
		@scpId int output -- ключ найденой записи в таблице TP_ServiceCalculateParametrs
	)
AS
BEGIN
	-- обнулим значение
	set @scId = null
	set @scpId = null

	-- проверим есть ли на запись в TP_Services записи в TP_ServiceComponents
	-- пробуем найти запись под нашу услугу
	set @scId = isnull((select top 1 SC_Id
						from TP_ServiceComponents with (nolock)
						where SC_SVKey = @nSvkey
						and SC_Code = @nCode
						and SC_SubCode1 = @nSubcode1
						and SC_SubCode2 = @nSubcode2
						and SC_PRKey = @nPrkey), null)
						
	-- если не нашли то добавим новую
	if (@scId is null)
	begin
		insert into TP_ServiceComponents (SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey)
		values (@nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey)
		
		set @scId = SCOPE_IDENTITY()
	end
	
	-- проверим есть ли подходящая запись в таблице TP_ServiceCalculateParametrs
	set @scpId = isnull((	select top 1 SCP_Id
							from TP_ServiceCalculateParametrs with (nolock)
							where SCP_SCId = @scId
							and SCP_Date = dateAdd(dd, @nDay-1, @turdate)
							and SCP_DateCheckIn = @turdate
							and SCP_Men = @nMen
							and SCP_Days = @nServiceDays
							and SCP_TourDays = @nTourDays
							and SCP_PKKey = @nPacketkey
							and SCP_DeleteDate is null), null)
							
	-- если не нашли, то добавим новую
	if (@scpId is null)
	begin
		insert into TP_ServiceCalculateParametrs(SCP_SCId, SCP_Date, SCP_DateCheckIn, SCP_Men, SCP_Days, SCP_PKKey, SCP_TourDays, SCP_SvKey)
		values (@scId, dateAdd(dd, @nDay-1, @turdate), @turdate, @nMen, @nServiceDays, @nPacketkey, @nTourDays, @nSvkey)
		
		set @scpId = SCOPE_IDENTITY()
	end
END


GO
grant exec on [dbo].[ReCalculate_CreateServiceCalculateParametrs] to public
go
/*********************************************************************/
/* end sp_ReCalculate_CreateServiceCalculateParametrs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts_CalculatePriceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts_CalculatePriceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts_CalculatePriceList]
GO
CREATE PROCEDURE [dbo].[ReCalculateCosts_CalculatePriceList]
	(
		@scpId int,
		@brutto money output,
		@IsCommission bit output,
		
		@svKey int,
		@code int,
		@code1 int,
		@code2 int,
		@prKey int,
		@packetKey int,
		@date datetime,
		@days int,
		@resRate varchar(2),
		@men int,
		@discountPercent decimal(14,2),
		@margin decimal(14,2),
		@marginType int,
		@sellDate dateTime, 
		@netto decimal(14,2),		
		@discount decimal(14,2),
		@nettoDetail varchar(100),
		@sBadRate varchar(2),
		@dtBadDate dateTime,
		@sDetailed varchar(100),
		@nSPId int,
		@tourKey int,
		@tourDate datetime,
		@tourDays int,
		@IsDuration smallint
	)
as

--<data>2012-02-15</data>
--<version>2009.02.04</version>

BEGIN
	declare @useDiscountDays int
	
	-- если наща услуга без продолжительности то устанавливаем ей продолжительность равную продолжительности тура
	if (@IsDuration != 1)
	begin
		set @days = @tourDays
	end

	/*Нужно вставить логику которая идет перед расчетом услуги в старом CalculatePriceList*/

	set @brutto = null	
	set @sellDate = null
	set @margin = 0
	set @marginType = 0

	/*попробуем найти запись нужной нам цены*/
	-- gorshkov у строк вставленных этой хранимкой (там пониже есть инсерт)
	-- SPAD_DateLastChange = SPAD_DateLastCalculate = getdate()
	-- т.е. здесь нужно использовать <= а не <
	select	@brutto = SPAD_Gross,
			@IsCommission = SPAD_IsCommission
	from TP_ServicePriceActualDate
	where SPAD_SCPId = @scpId
	and SPAD_SaleDate is null
	-- или расчитана и перенесена или только расчитана но не перенесена
	and SPAD_NeedApply = 0
	
	if (@brutto is null)
	begin
		-- не нашли раститанной цены, нужно расчитать и записать результат в TP_ServicePriceActualDate
		exec GetServiceCost @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
		@resRate, @men, @discountPercent, @margin, @marginType,
		@sellDate, @netto output, @brutto output, @discount output,
		@nettoDetail output, @sBadRate output, @dtBadDate output,
		@sDetailed output,  @nSPId output, @useDiscountDays output,
		@tourKey, @tourDate, @tourDays, 0
		
		/*Нужно вствить логику на праверку устаревших данных по полю SPAD_SaleDate
		Если есть строки с SPAD_SaleDate <= getadte() то у ней, она должны быть нужно установить SPAD_SaleDate = null, а старые записи с SPAD_SaleDate = null удалить
		Пока не понятно как это будет работать нужно обсудить*/		
		
		if (@discount is null)
			set @IsCommission = 0
		else
			set @IsCommission = 1
		
		if (not exists (select SPAD_ID
						from TP_ServicePriceActualDate
						where SPAD_SCPId = @scpId
						and SPAD_SaleDate is null))
		begin
			-- gorshkov зафиксировал время, которое будет вставляться в SPAD_DateLastChange и SPAD_DateLastCalculate
			declare @modificationDate datetime;
			set @modificationDate=getdate();
			insert into TP_ServicePriceActualDate (SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross, SPAD_Netto, SPAD_DateLastChange, SPAD_DateLastCalculate, SPAD_NeedApply)
			values (@scpId, @IsCommission, @resRate, null, @brutto, @netto, @modificationDate, @modificationDate , 0)
		end
		else
		begin
			-- обновим и скажем чтобы обновились цены в других турах
			update TP_ServicePriceActualDate
			set SPAD_Gross = @brutto,
			SPAD_Netto = @netto,
			SPAD_IsCommission = @IsCommission,
			SPAD_DateLastCalculate = getdate(),
			SPAD_NeedApply = 0
			where SPAD_SCPId = @scpId
		end
	end
END

GO

grant exec on [dbo].[ReCalculateCosts_CalculatePriceList] to public
go

/*********************************************************************/
/* end sp_ReCalculateCosts_CalculatePriceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateMargins_CalculatePriceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateMargins_CalculatePriceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateMargins_CalculatePriceList]
GO
CREATE PROCEDURE [dbo].[ReCalculateMargins_CalculatePriceList]
	(
		--<DATE>2012-02-03</DATE>
		--<VERSION>2009.02.01</VERSION>
		@TrKey int,
		@toKey int,
		@Date datetime, 
		@margin float output, 
		@marginType int output, 
		@svKey int, 
		@days int, 
		@sellDate DateTime = null,
		@packetKey int
	)
as
	declare @needApply int
	
	set @margin = null
	set @marginType = null
	set @needApply = null
	
	-- выходим если тур инливидуальный или не найден
	if (isnull(@toKey, 0) = 0)
	begin
		return;
	end
	
	select top 1 @margin = TMAD_Percent, @marginType = TMAD_IsCommission, @needApply = TMAD_NeedApply
	from TP_TourMarginActualDate
	where TMAD_TRKey = @TrKey
	and TMAD_SvKey = @svKey
	and TMAD_DateCheckIn = @Date
	and TMAD_Long = @days
	
	-- если та наценко которая у нас есть актуальна
	if ((@needApply is not null) and (@needApply = 0 or @needApply = 2))
	begin
		-- возвращаем значения
		return;
	end
	-- нужно перерасчитать  наценку или записей в кеше нету
	else if ((@needApply is not null and @needApply = 1) 
				or (@needApply is null))
	begin
		-- получим значение наценки
		-- в GetTourMargin уже есть проверка кэша на наличие актуальной наценки
		exec GetTourMargin @TrKey, @Date, @margin output, @marginType output, @svKey, @days, @sellDate, @packetKey
		
		-- если записей в кеше не было
		if (@needApply is null)
		begin
			insert into TP_TourMarginActualDate (TMAD_TRKey, TMAD_SvKey, TMAD_DateCheckIn, TMAD_Percent, TMAD_IsCommission, TMAD_Long, TMAD_DateLastChange, TMAD_DateLastCalculate, TMAD_NeedApply)
			values (@TrKey, @svKey, @Date, @margin, @marginType, @days, getdate(), getdate(), 2)
		end
		else
		-- записи в кеше были, но они не актуальны
		begin
			-- запишем расчитанные значения
			update TP_TourMarginActualDate
			set TMAD_Percent = @margin,
			TMAD_IsCommission = @marginType,
			TMAD_DateLastCalculate = getdate(),
			TMAD_NeedApply = 2
			where TMAD_TRKey = @trKey
			and TMAD_SvKey = @svKey
			and TMAD_DateCheckIn = @Date
			and TMAD_Long = @days
			and (TMAD_Percent != @margin or TMAD_IsCommission != @marginType or TMAD_NeedApply != 2)
		end
	end
GO

grant exec on [dbo].[ReCalculateMargins_CalculatePriceList] to public
go
/*********************************************************************/
/* end sp_ReCalculateMargins_CalculatePriceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts_GrossMigrate.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts_GrossMigrate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts_GrossMigrate]
GO
CREATE PROCEDURE [dbo].[ReCalculateCosts_GrossMigrate]
	(
		-- хранимка переносит цены из таблицы TP_PriceActualDate в TP_PriceComponents
		-- <version>2009.02.08</version>
		-- <data>2012-03-11</data>
		@countItems int,
		-- ключи тех записей которые нужно расчитать
		@xSCPIdTable nvarchar(max) = null,
		-- ключи тех записей которые нужно расчитать, если задан этот параметр, то SPAD_AutoOnline игнорируется
		@xOnlySCPIdTable nvarchar(max) = null
	)
AS
BEGIN
	set nocount on;
	declare @beginTime datetime
	set @beginTime = getDate()
	
	print '1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	create table #tpServicePriceActualDateTable
	(
		SPAD_SCPId bigint,
		SPAD_Id bigint,
		SPAD_Gross money,
		SPAD_Rate nvarchar(2),
		SPAD_IsCommission bit,
		SPAD_AutoOnline int,
		SCP_DateCheckIn datetime,
		SCP_SvKey int
	)
	
	create index x_tpServicePriceActualDateTable on #tpServicePriceActualDateTable
	(
		SCP_DateCheckIn,
		SPAD_Rate,
		SPAD_SCPId,
		SCP_SvKey,
		SPAD_Gross
	) include (SPAD_Id, SPAD_IsCommission, SPAD_AutoOnline)

	/*таблица цен которые будут мигрировать*/
	declare @tableForMigrate table
	(
		xSCPId int,
		xSPADId int,
		xRate nvarchar(2),
		xGross money,
		xIsCommission bit,
		xAutoOnline smallint,
		-- дата заезда
		xTurdate datetime,
		xSvKey int,
		xPCid bigint
	);
	
	if (@xOnlySCPIdTable is not null)
	begin
		insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
		select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
		from TP_ServicePriceActualDate with(nolock) join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
		where SPAD_SaleDate is null
		and SPAD_NeedApply = 0
		and SCP_Id in (select xt_key from dbo.ParseKeys(@xOnlySCPIdTable))
		
		print '1.1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
	end
	else if (@xSCPIdTable is not null)
	begin
		insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
		select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
		from TP_ServicePriceActualDate with(nolock) join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
		where SPAD_SaleDate is null
		and SPAD_NeedApply = 0
		and SPAD_AutoOnline = 1
		and SCP_Id in (select xt_key from dbo.ParseKeys(@xSCPIdTable))
		
		print '1.2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
	end
	else
	begin
		insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
		select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
		from TP_ServicePriceActualDate with(nolock) join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
		where SPAD_SaleDate is null
		and SPAD_NeedApply = 0
		and SPAD_AutoOnline = 1
		
		print '1.3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
	end
	
	insert into @tableForMigrate (xSCPId, xSPADId, xGross, xRate, xIsCommission, xAutoOnline, xTurdate, xSvKey, xPCid)
	select SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey, PC_Id
	from #tpServicePriceActualDateTable join TP_PriceComponents with(nolock) on PC_TourDate = SCP_DateCheckIn and SPAD_Rate = PC_Rate
	where 
	(
			(SPAD_SCPId = SCPId_1 and SCP_SvKey = SvKey_1 and isnull(SPAD_Gross, -100500) != isnull(Gross_1, -100500))
		or	(SPAD_SCPId = SCPId_2 and SCP_SvKey = SvKey_2 and isnull(SPAD_Gross, -100500) != isnull(Gross_2, -100500))
		or	(SPAD_SCPId = SCPId_3 and SCP_SvKey = SvKey_3 and isnull(SPAD_Gross, -100500) != isnull(Gross_3, -100500))
		or	(SPAD_SCPId = SCPId_4 and SCP_SvKey = SvKey_4 and isnull(SPAD_Gross, -100500) != isnull(Gross_4, -100500))
		or	(SPAD_SCPId = SCPId_5 and SCP_SvKey = SvKey_5 and isnull(SPAD_Gross, -100500) != isnull(Gross_5, -100500))
		or	(SPAD_SCPId = SCPId_6 and SCP_SvKey = SvKey_6 and isnull(SPAD_Gross, -100500) != isnull(Gross_6, -100500))
		or	(SPAD_SCPId = SCPId_7 and SCP_SvKey = SvKey_7 and isnull(SPAD_Gross, -100500) != isnull(Gross_7, -100500))
		or	(SPAD_SCPId = SCPId_8 and SCP_SvKey = SvKey_8 and isnull(SPAD_Gross, -100500) != isnull(Gross_8, -100500))
		or	(SPAD_SCPId = SCPId_9 and SCP_SvKey = SvKey_9 and isnull(SPAD_Gross, -100500) != isnull(Gross_9, -100500))
		or	(SPAD_SCPId = SCPId_10 and SCP_SvKey = SvKey_10 and isnull(SPAD_Gross, -100500) != isnull(Gross_10, -100500))
		or	(SPAD_SCPId = SCPId_11 and SCP_SvKey = SvKey_11 and isnull(SPAD_Gross, -100500) != isnull(Gross_11, -100500))
		or	(SPAD_SCPId = SCPId_12 and SCP_SvKey = SvKey_12 and isnull(SPAD_Gross, -100500) != isnull(Gross_12, -100500))
		or	(SPAD_SCPId = SCPId_13 and SCP_SvKey = SvKey_13 and isnull(SPAD_Gross, -100500) != isnull(Gross_13, -100500))
		or	(SPAD_SCPId = SCPId_14 and SCP_SvKey = SvKey_14 and isnull(SPAD_Gross, -100500) != isnull(Gross_14, -100500))
		or	(SPAD_SCPId = SCPId_15 and SCP_SvKey = SvKey_15 and isnull(SPAD_Gross, -100500) != isnull(Gross_15, -100500))
	)
	
	print '2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	declare @PriceComponentsRows int;
	set @PriceComponentsRows = 0;
		
	-- разобьем апдейт на 15 - по каждому картежу свой
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_1 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_1
	and xSvKey = SvKey_1
	and isnull(xGross, -100500) != isnull(Gross_1, -100500)
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_2 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_2
	and xSvKey = SvKey_2
	and isnull(xGross, -100500) != isnull(Gross_2, -100500)
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_3 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_3
	and xSvKey = SvKey_3
	and isnull(xGross, -100500) != isnull(Gross_3, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_4 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_4
	and xSvKey = SvKey_4
	and isnull(xGross, -100500) != isnull(Gross_4, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_5 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_5
	and xSvKey = SvKey_5
	and isnull(xGross, -100500) != isnull(Gross_5, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_6 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_6
	and xSvKey = SvKey_6
	and isnull(xGross, -100500) != isnull(Gross_6, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_7 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_7
	and xSvKey = SvKey_7
	and isnull(xGross, -100500) != isnull(Gross_7, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_8 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_8
	and xSvKey = SvKey_8
	and isnull(xGross, -100500) != isnull(Gross_8, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_9 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_9
	and xSvKey = SvKey_9
	and isnull(xGross, -100500) != isnull(Gross_9, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_10 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_10
	and xSvKey = SvKey_10
	and isnull(xGross, -100500) != isnull(Gross_10, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_11 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_11
	and xSvKey = SvKey_11
	and isnull(xGross, -100500) != isnull(Gross_11, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_12 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_12
	and xSvKey = SvKey_12
	and isnull(xGross, -100500) != isnull(Gross_12, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_13 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_13
	and xSvKey = SvKey_13
	and isnull(xGross, -100500) != isnull(Gross_13, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_14 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_14
	and xSvKey = SvKey_14
	and isnull(xGross, -100500) != isnull(Gross_14, -100500)
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set 
	PC_DateLastChangeGross = getdate(), 
	PC_UpdateDate = getdate(),
	Gross_15 = xGross,
	PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCid
	where xSCPId = SCPId_15
	and xSvKey = SvKey_15
	and isnull(xGross, -100500) != isnull(Gross_15, -100500)
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	print '3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
		
	print 'Количество строк в TP_PriceComponents: ' + convert(nvarchar(max), @PriceComponentsRows)
	
	/*обновим галку о необходимости переноса цены*/
	update TP_ServicePriceActualDate
	set SPAD_AutoOnline = 0
	where SPAD_Id in (select SPAD_Id from #tpServicePriceActualDateTable)
	
	print '4: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	print 'Количество строк в TP_ServicePriceActualDate: ' + convert(nvarchar(max), @@rowcount)
END

GO

grant exec on [dbo].[ReCalculateCosts_GrossMigrate] to public
go
/*********************************************************************/
/* end sp_ReCalculateCosts_GrossMigrate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts_MarginMigrate.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts_MarginMigrate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts_MarginMigrate]
GO
CREATE PROCEDURE [dbo].[ReCalculateCosts_MarginMigrate]
	(
		-- хранимка переносит цены из таблицы TP_PriceActualDate в TP_PriceComponents
		-- <version>2009.02.08</version>
		-- <data>2012-03-06</data>
		@countItems int,
		-- ключи записей из кеша которые нам нужно расчитать
		@xTMADIdTable nvarchar(max) = null
	)
AS
BEGIN
	-- уберем признак переноса тех данных которые переносить не нужно
	update TP_TourMarginActualDate
	set TMAD_NeedApply = 0
	from TP_TourMarginActualDate
	where TMAD_NeedApply = 2
	and not exists 
	(
		select top 1 1
		from TP_PriceComponents with(nolock)
		where PC_TRKey = TMAD_TRKey
		and PC_TourDate = TMAD_DateCheckIn
		and PC_Days = TMAD_Long
		and (	SVKey_1 = TMAD_SvKey
				or SVKey_2 = TMAD_SvKey
				or SVKey_3 = TMAD_SvKey
				or SVKey_4 = TMAD_SvKey
				or SVKey_5 = TMAD_SvKey
				or SVKey_6 = TMAD_SvKey
				or SVKey_7 = TMAD_SvKey
				or SVKey_8 = TMAD_SvKey
				or SVKey_9 = TMAD_SvKey
				or SVKey_10 = TMAD_SvKey
				or SVKey_11 = TMAD_SvKey
				or SVKey_12 = TMAD_SvKey
				or SVKey_13 = TMAD_SvKey
				or SVKey_14 = TMAD_SvKey
				or SVKey_15 = TMAD_SvKey			
			)
	)

	/*таблица цен которые будут мигрировать*/
	declare @tableForMigrate table
	(
		xTMADId int,
		xTRKey int,
		xTourDate datetime,
		xSvKey int,
		xLong int,
		xMarginPercent money,
		xCommissionOnly bit,
		xPCId bigint	
	);
	
	with tpTourMarginActualDate as
	(
		select top (@countItems) TMAD_Id, TMAD_TRKey, TMAD_DateCheckIn, TMAD_SvKey, TMAD_Long, TMAD_Percent, TMAD_IsCommission
		from TP_TourMarginActualDate with(nolock)
		where TMAD_NeedApply = 2
		and ((@xTMADIdTable is null) or (TMAD_Id in (select xt_key from dbo.ParseKeys(@xTMADIdTable))))
	)
	insert into @tableForMigrate (xTMADId, xTRKey, xTourDate, xSvKey, xLong, xMarginPercent, xCommissionOnly, xPCId)
	select TMAD_Id, TMAD_TRKey, TMAD_DateCheckIn, TMAD_SvKey, TMAD_Long, TMAD_Percent, TMAD_IsCommission, PC_Id
	from tpTourMarginActualDate join TP_PriceComponents with(nolock) on PC_TRKey = TMAD_TRKey
	where 
		PC_TourDate = TMAD_DateCheckIn
	and PC_Days = TMAD_Long
	and (	SVKey_1 = TMAD_SvKey
			or SVKey_2 = TMAD_SvKey
			or SVKey_3 = TMAD_SvKey
			or SVKey_4 = TMAD_SvKey
			or SVKey_5 = TMAD_SvKey
			or SVKey_6 = TMAD_SvKey
			or SVKey_7 = TMAD_SvKey
			or SVKey_8 = TMAD_SvKey
			or SVKey_9 = TMAD_SvKey
			or SVKey_10 = TMAD_SvKey
			or SVKey_11 = TMAD_SvKey
			or SVKey_12 = TMAD_SvKey
			or SVKey_13 = TMAD_SvKey
			or SVKey_14 = TMAD_SvKey
			or SVKey_15 = TMAD_SvKey			
		)
	
	declare @PriceComponentsRows int; set @PriceComponentsRows=0;
	
	/*перенесем изменения в основную таблицу*/
	-- разобьем апдейт по кортежам
	
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_1 = xCommissionOnly,
		MarginPercent_1 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_1 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_2 = xCommissionOnly,
		MarginPercent_2 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_2 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_3 = xCommissionOnly,
		MarginPercent_3 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_3 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_4 = xCommissionOnly,
		MarginPercent_4 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_4 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_5 = xCommissionOnly,
		MarginPercent_5 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_5 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_6 = xCommissionOnly,
		MarginPercent_6 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_6 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_7 = xCommissionOnly,
		MarginPercent_7 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_7 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_8 = xCommissionOnly,
		MarginPercent_8 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_8 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_9 = xCommissionOnly,
		MarginPercent_9 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_9 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_10 = xCommissionOnly,
		MarginPercent_10 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_10 = xSvKey		
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_11 = xCommissionOnly,
		MarginPercent_11 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_11 = xSvKey		
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_12 = xCommissionOnly,
		MarginPercent_12 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_12 = xSvKey	
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_13 = xCommissionOnly,
		MarginPercent_13 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_13 = xSvKey		
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_14 = xCommissionOnly,
		MarginPercent_14 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_14 = xSvKey		
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
			
	update TP_PriceComponents
	set	PC_DateLastChangeMargin = getdate(), 
		PC_UpdateDate = getdate(),
		CommissionOnly_15 = xCommissionOnly,
		MarginPercent_15 = xMarginPercent,
		PC_State = 1
	from TP_PriceComponents join @tableForMigrate on PC_Id = xPCId
	where	SVKey_15 = xSvKey
		
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	

	print 'Количество строк в TP_PriceComponents: ' + convert(nvarchar(max), @PriceComponentsRows)
		
	/*обновим галку о необходимости переноса цены*/
	update TP_TourMarginActualDate
	set TMAD_NeedApply = 0
	where TMAD_Id in (select xTMADId from @tableForMigrate)
	print 'Количество строк в TP_TourMarginActualDate: ' + convert(nvarchar(max), @@rowcount)
END

GO

grant exec on [dbo].[ReCalculateCosts_MarginMigrate] to public
go
/*********************************************************************/
/* end sp_ReCalculateCosts_MarginMigrate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_MigrateToPrice.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_MigrateToPrice]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_MigrateToPrice]
GO
CREATE PROCEDURE [dbo].[ReCalculate_MigrateToPrice]	
	(
		-- хранимка суммирует стоимость отдельных услуг и кладет их в TP_Prices		
		--<version>2009.2.07</version>
		--<data>2012-05-21</data>
		-- максимальное количество записей для переноса за 1 раз
		@countItem int
	)
AS
BEGIN
	SET ARITHABORT ON;

	declare @tempGrossTable table
	(
		xPCId int,
		xTPKey int,
		xSummPrice money,
		xSummPriceOld money,
		xToKey int
	)

	insert into @tempGrossTable (xPCId, xTPKey, xSummPrice, xToKey)
	select top (@countItem) PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey
	from TP_PriceComponents with(nolock)
	where PC_State = 1
	
	print 'Количество строк в TP_PriceComponents: ' + convert(nvarchar(max), @@rowcount)
	
	declare currReCalculate_MigrateToPrice cursor for select distinct xToKey from @tempGrossTable
	declare @toKey int
	OPEN currReCalculate_MigrateToPrice
		FETCH NEXT FROM currReCalculate_MigrateToPrice INTO @toKey
		WHILE @@FETCH_STATUS = 0
		begin
			
			insert into CalculatingPriceLists (CP_CreateDate,CP_PriceTourKey) values (GETDATE(),@toKey) 
			declare @cpKey int
			set @cpKey = scope_identity()
			
			-- переносим цены в таблицу для удаленных цен
			insert into tp_pricesdeleted (TPD_TPKey, TPD_TOKey, TPD_TIKey, TPD_Gross, TPD_DateBegin, TPD_DateEnd, TPD_CalculatingKey)
			select TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, @cpKey 
			from tp_prices with(nolock)
			where tp_key in (	select xTPKey 
								from @tempgrosstable 
								where xSummPrice is null
								and xToKey = @toKey)
								
			-- удаляем цены из tp_prices
			delete from tp_prices
			where tp_key in (select xTPKey
								from @tempgrosstable
								where xSummPrice is null
								and xToKey = @toKey)
			
			--восстанавливаем цены из таблицы удаленных цен
			insert into tp_prices (TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, TP_CalculatingKey)
			select TPD_TPKey, TPD_TOKey, TPD_TIKey, TPD_Gross, TPD_DateBegin, TPD_DateEnd, @cpKey
			from tp_pricesdeleted with(nolock)
			where tpd_tpkey in (select xTPKey
								from @tempgrosstable
								where xSummPrice is not null
								and xToKey = @toKey)
								
			-- и удаляем из из таблицы удаленных цен
			delete from tp_pricesdeleted
			where tpd_tpkey in (select xTPKey
								from @tempgrosstable
								where xSummPrice is not null
								and xToKey = @toKey)
								
			-- обновляем цены, которые ранее не были удалены и изменились, или ранее были удалены но сейчас востановились
			update TP_Prices
			set TP_Gross = CEILING(xSummPrice),
			tp_updatedate = GetDate(),
			TP_CalculatingKey = @cpKey
			from TP_Prices join @tempGrossTable on TP_Key = xTPKey
			where xSummPrice is not null
			and xToKey = @toKey
			
			if exists (select top 1 1 from TP_Tours where to_Key = @toKey and to_isEnabled = 1)
			begin
				-- Реплицируем только если тур уже выставлен в online
				exec FillMasterWebSearchFields @toKey, @cpKey
			end
		
		FETCH NEXT FROM currReCalculate_MigrateToPrice INTO @toKey
		end

	CLOSE currReCalculate_MigrateToPrice
	DEALLOCATE currReCalculate_MigrateToPrice
	
	-- отметим что уже перенесли
	update TP_PriceComponents
	set PC_DateLastUpdateToPrice = getdate(),
	PC_State = 0
	where PC_Id in (select xPCId from @tempGrossTable)
END


GO

grant exec on [dbo].[ReCalculate_MigrateToPrice] to public
go
/*********************************************************************/
/* end sp_ReCalculate_MigrateToPrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_ViewHottelCost.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_ViewHotelCost]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_ViewHotelCost]
GO
CREATE PROCEDURE [dbo].[ReCalculate_ViewHotelCost]
	(
		-- хранимка выводит информацию о ценах на отель
		--<version>2009.2.07</version>
		--<data>2012-04-05</data>
		@departureKey int,										-- ключ города вылета
		@tourKey int = null,									-- ключ тура
		@hotelKeys xml ([dbo].[ArrayOfInt]) = null,				-- ключ отеля
		@checkinDateBegin datetime = null,						-- дата начала заезда
		@checkinDateEnd datetime = null,						-- дата начала заезда
		@roomKeys xml ([dbo].[ArrayOfInt]) = null,				-- ключ типа комнаты
		@roomCategoryKeys xml ([dbo].[ArrayOfInt]) = null,		-- ключ категории номера		
		@accommodationKeys xml ([dbo].[ArrayOfInt]) = null,		-- ключ размещения
		@pansionKeys xml ([dbo].[ArrayOfInt]) = null,			-- ключ питания
		@longList xml ([dbo].[ArrayOfShort]) = null,			-- продолжительности
		@weekDays nvarchar(7) = null,							-- дни недели
		@agentCommission money = null,							-- процент агентской коммисии
		@IsChangePriceOnly bit = null,							-- только с измененными ценами
		@IsDeletePriceOnly bit = null,							-- только с удаленными ценами
		@isHideAccommodationWithAdult bit = null,				-- только размещения без доп. мест
		@IsOnlineOnly bit = null								-- только выставленные в интернет туры
	)
AS
BEGIN
	SET ARITHABORT ON;
	SET DATEFIRST 1;
	set nocount on;
	
	declare @beginTime datetime
	set @beginTime = getDate()

	declare @hotelService int, @aviaService int
	set @hotelService = 3
	set @aviaService = 1
	
	declare @tableHotelKeys table
	(
		xHotelKey int
	)	
	insert into @tableHotelKeys(xHotelKey)
	select tbl.res.value('.', 'int') 
	from @hotelKeys.nodes('/ArrayOfInt/int') as tbl(res)
	
	print 'Парсинг @hotelKeys: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	declare @tableLongList table
	(
		xLong int
	)
	insert into @tableLongList(xLong)
	select tbl.res.value('.', 'smallint') 
	from @longList.nodes('/ArrayOfShort/short') as tbl(res);
	
	print 'Парсинг @longList: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	declare @tpKeys nvarchar(max)
	set @tpKeys = ''
	
	select @tpKeys = @tpKeys + convert(nvarchar(max), PC_TPKey) + ', '
	from TP_PriceComponents with(nolock)
	where PC_TOKey = isnull(@tourKey, PC_TOKey)
	and PC_HotelKey in (select xHotelKey from @tableHotelKeys)
	and PC_DepartureKey = isnull(@departureKey, 0)
	and PC_TourDate between isnull(@checkinDateBegin, PC_TourDate) and isnull(@checkinDateEnd, PC_TourDate)
	and (@weekDays is null or (@weekDays like '%' + convert(nvarchar(1), datepart(dw, PC_TourDate)) + '%'))
	and (@longList is null or (PC_Days in (select xLong from @tableLongList)))
	group by PC_TPKey
	
	print 'Определяем ключи @tpKeys: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
			
	-- проверяем актуальность цен
	declare @result table
	(
		tpKey bigint,
		newPrice money
	)
	-- делаем инсерт во веременную таблицу, что бы результата не выводился при запуске этой хранимки
	insert into @result (tpKey, newPrice)
	exec ReCalculate_CheckActualPrice @tpKeys
	print 'exec ReCalculate_CheckActualPrice ' + '''' +  @tpKeys + ''''
	
	print 'Расчитываем изменения в ценах: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	declare @hotelRoomsTable table
	(
		SC_Id int,
		SC_Code int,
		SC_SubCode1 int,
		SC_SubCode2 int,
		SC_PRKey int,
		HR_RMKEY int,
		HR_ACKEY int,
		HR_RCKEY int
	)
	
	insert into @hotelRoomsTable(SC_Id, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey, HR_RMKEY, HR_ACKEY, HR_RCKEY)
	select SC_Id, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey, HR_RMKEY, HR_ACKEY, HR_RCKEY
	from HotelRooms join TP_ServiceComponents on SC_SubCode1 = HR_KEY
	where 
		SC_Code in (select xHotelKey from @tableHotelKeys)
	and (@pansionKeys is null or (SC_SubCode2 in	(select tbl.res.value('.', 'int') from @pansionKeys.nodes('/ArrayOfInt/int') as tbl(res))))
	and (isnull(@isHideAccommodationWithAdult, 0) = 0 or (HR_ACKEY in (select AC_KEY from Accmdmentype where isnull(AC_NMenExBed, 0) = 0)))
	
	print 'Заполнение вспомогательной таблицы: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	delete @hotelRoomsTable
	where 
		(@roomKeys is not null and (HR_RMKEY not in (select tbl.res.value('.', 'int') from @roomKeys.nodes('/ArrayOfInt/int') as tbl(res))))
	and (@roomCategoryKeys is not null and (HR_RCKEY not in	(select tbl.res.value('.', 'int') from @roomCategoryKeys.nodes('/ArrayOfInt/int') as tbl(res))))
	and (@accommodationKeys is not null and (HR_ACKEY not in (select tbl.res.value('.', 'int') from @accommodationKeys.nodes('/ArrayOfInt/int') as tbl(res))))
	
	print 'Очистка вспомогательной таблицы: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	select PC_Id, PC_TPKey, PC_TourDate, SCP_Date, SC_Code, SC_SubCode1, HR_RMKEY, HR_ACKEY, HR_RCKEY, SC_SubCode2, SC_PRKey, PC_Days, SCP_Days, SCP_Men, PC_TOKey, PC_SummPrice, TO_TRKey, TO_Name, TO_Rate, TO_IsEnabled,
	AddCostIsCommission_1, AddCostNoCommission_1, CommissionOnly_1, Gross_1, IsCommission_1, MarginPercent_1, SCPId_1, SVKey_1,
	AddCostIsCommission_2, AddCostNoCommission_2, CommissionOnly_2, Gross_2, IsCommission_2, MarginPercent_2, SCPId_2, SVKey_2,
	AddCostIsCommission_3, AddCostNoCommission_3, CommissionOnly_3, Gross_3, IsCommission_3, MarginPercent_3, SCPId_3, SVKey_3,
	AddCostIsCommission_4, AddCostNoCommission_4, CommissionOnly_4, Gross_4, IsCommission_4, MarginPercent_4, SCPId_4, SVKey_4,
	AddCostIsCommission_5, AddCostNoCommission_5, CommissionOnly_5, Gross_5, IsCommission_5, MarginPercent_5, SCPId_5, SVKey_5,
	AddCostIsCommission_6, AddCostNoCommission_6, CommissionOnly_6, Gross_6, IsCommission_6, MarginPercent_6, SCPId_6, SVKey_6,
	AddCostIsCommission_7, AddCostNoCommission_7, CommissionOnly_7, Gross_7, IsCommission_7, MarginPercent_7, SCPId_7, SVKey_7,
	AddCostIsCommission_8, AddCostNoCommission_8, CommissionOnly_8, Gross_8, IsCommission_8, MarginPercent_8, SCPId_8, SVKey_8,
	AddCostIsCommission_9, AddCostNoCommission_9, CommissionOnly_9, Gross_9, IsCommission_9, MarginPercent_9, SCPId_9, SVKey_9,
	AddCostIsCommission_10, AddCostNoCommission_10, CommissionOnly_10, Gross_10, IsCommission_10, MarginPercent_10, SCPId_10, SVKey_10,
	AddCostIsCommission_11, AddCostNoCommission_11, CommissionOnly_11, Gross_11, IsCommission_11, MarginPercent_11, SCPId_11, SVKey_11,
	AddCostIsCommission_12, AddCostNoCommission_12, CommissionOnly_12, Gross_12, IsCommission_12, MarginPercent_12, SCPId_12, SVKey_12,
	AddCostIsCommission_13, AddCostNoCommission_13, CommissionOnly_13, Gross_13, IsCommission_13, MarginPercent_13, SCPId_13, SVKey_13,
	AddCostIsCommission_14, AddCostNoCommission_14, CommissionOnly_14, Gross_14, IsCommission_14, MarginPercent_14, SCPId_14, SVKey_14,
	AddCostIsCommission_15, AddCostNoCommission_15, CommissionOnly_15, Gross_15, IsCommission_15, MarginPercent_15, SCPId_15, SVKey_15
	from TP_PriceComponents with(nolock) join TP_Tours with(nolock) on TO_Key = PC_TOKey
	join TP_ServiceCalculateParametrs with (nolock) on SCPId_1 = SCP_Id
	join @hotelRoomsTable on SCP_SCId = SC_Id
	where PC_TOKey = isnull(@tourKey, PC_TOKey)
	and PC_HotelKey in (select xHotelKey from @tableHotelKeys)
	and PC_DepartureKey = isnull(@departureKey, 0)
	and PC_TourDate between isnull(@checkinDateBegin, PC_TourDate) and isnull(@checkinDateEnd, PC_TourDate)
	and (@weekDays is null or (@weekDays like '%' + convert(nvarchar(1), datepart(dw, PC_TourDate)) + '%'))
	and (@longList is null or (PC_Days in (select xLong from @tableLongList)))
	and (isnull(@IsDeletePriceOnly, 0) = 0 or PC_SummPrice is null)
	and (@IsOnlineOnly is null or (@IsOnlineOnly = case when PC_SummPrice is null then 0 else TO_IsEnabled end))
	
	print 'Выводим результат: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
END

GO

grant exec on [dbo].[ReCalculate_ViewHotelCost] to public
go

/*********************************************************************/
/* end sp_ReCalculate_ViewHottelCost.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts.sql */
/*********************************************************************/
	IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts]
GO
CREATE PROCEDURE [dbo].[ReCalculateCosts]
	(
		-- хранимка перерасчитывает услуги из очереди перерасчета
		--<version>2009.02.04</version>
		--<data>2012-02-22</data>
		@countReCalculateItems int,
		-- ключи тех записей которые нужно расчитать
		@xSCPIdTable nvarchar(max) = null
	)
AS
BEGIN
	declare @tempGrossTable table
	(
		xSPADId int,
		xSPADGross money,
		xSPADNetto money,
		xSPADIsCommission bit
	)

	declare @svKey int, @code int, @code1 int, @code2 int, @prKey int, @packetKey int, @date datetime, @days int,
	@resRate varchar(2), @men int, @discountPercent decimal(14,2), @margin decimal(14,2), @marginType int,
	@sellDate dateTime, @netto decimal(14,2), @brutto decimal(14,2), @discount decimal(14,2),
	@nettoDetail varchar(100), @sBadRate varchar(2), @dtBadDate dateTime,
	@sDetailed varchar(100),  @nSPId int, @useDiscountDays int,
	@spadId int, @spadIsCommission bit,
	@tourKey int, @tourDate datetime, @tourDays int, @includeAddCost bit, @IsDuration smallint
	
	declare cursorReCalculateCosts cursor fast_forward read_only for
	select top (@countReCalculateItems) SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey, SCP_PKKey, SCP_Date, SCP_Days,
	SPAD_Rate, SCP_Men, 0, 0, 0,
	SPAD_SaleDate, 0, 0, 0,
	'', '', '' ,
	'', null, 0,
	SPAD_Id, SV_IsDuration, SCP_TourDays
	from TP_ServicePriceActualDate with(nolock) join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
	join TP_ServiceComponents with(nolock) on SCP_SCId = SC_Id
	join [Service] on SC_SVKey = SV_Key
	where SPAD_SaleDate is null
	and SPAD_NeedApply = 1
	and ((@xSCPIdTable is null) or (SCP_Id in (select xt_key from dbo.ParseKeys(@xSCPIdTable))))

	open cursorReCalculateCosts
	fetch next from cursorReCalculateCosts into @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
	@resRate, @men, @discountPercent, @margin, @marginType,
	@sellDate, @netto, @brutto, @discount,
	@nettoDetail, @sBadRate, @dtBadDate,
	@sDetailed,  @nSPId, @useDiscountDays,
	@spadId, @IsDuration, @tourDays
	
	while (@@FETCH_STATUS = 0)
	begin
		
		set @netto = null;
		set @brutto = null;
		
		-- тут нам не нужно считать доплату, поэтому передаем фейковые значения
		set @tourKey = -100500
		set @tourDate = '1900-01-01'
		set @includeAddCost = 0
		
		-- если наща услуга без продолжительности то устанавливаем ей продолжительность равную продолжительности тура
		if (@IsDuration != 1)
		begin
			set @days = @tourDays
		end
		
		exec GetServiceCost @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
		@resRate, @men, @discountPercent, @margin, @marginType,
		@sellDate, @netto output, @brutto output, @discount output,
		@nettoDetail output, @sBadRate output, @dtBadDate output,
		@sDetailed output,  @nSPId output, @useDiscountDays output,		
		@tourKey, @tourDate, @tourDays, @includeAddCost
		
		if (@discount is null)
			set @spadIsCommission = 0
		else
			set @spadIsCommission = 1
		
		/*после того как получили стоимость услуги запишем ее значение в о временную таблицу*/
		insert into @tempGrossTable (xSPADId, xSPADGross, xSPADNetto, xSPADIsCommission)
		values (@spadId, @brutto, @netto, @spadIsCommission)
						
		fetch next from cursorReCalculateCosts into @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
		@resRate, @men, @discountPercent, @margin, @marginType,
		@sellDate, @netto, @brutto, @discount,
		@nettoDetail, @sBadRate, @dtBadDate,
		@sDetailed,  @nSPId, @useDiscountDays,
		@spadId, @IsDuration, @tourDays
	end
	close cursorReCalculateCosts
	deallocate cursorReCalculateCosts
	
	/*закончили расчет теперь обновим основную таблицу*/
	update TP_ServicePriceActualDate
	set SPAD_Gross = xSPADGross,
	SPAD_Netto = xSPADNetto,
	SPAD_IsCommission = xSPADIsCommission,
	SPAD_DateLastCalculate = getdate(),
	SPAD_NeedApply = 0
	from TP_ServicePriceActualDate join @tempGrossTable on xSPADId = SPAD_Id
	
	print 'Количество строк: ' + convert(nvarchar(max), @@rowcount)
END

GO
grant exec on [dbo].[ReCalculateCosts] to public
go
/*********************************************************************/
/* end sp_ReCalculateCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateAddCosts.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateAddCosts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateAddCosts]
GO
CREATE PROCEDURE [dbo].[ReCalculateAddCosts]
	(
		-- хранимка обсчитывает изменившиеся доплаты
		-- <date>2012-03-22</date>
		-- <version>2009.02.24</version>
		-- количество записей из таблицы TP_QueueAddCosts, за 1 обработку
		@amountItem int,
		-- необязательный параметр - ключи туров, если задан то расчитываем доплаты только по ним
		@tourKeys nvarchar(max) = null,
		-- необязательный параметр, ключи из очереди на перерасчет, если заданы то рассчитаваем только по ним
		@xQACIdTable nvarchar(max) = null
	)
AS
BEGIN
	SET ARITHABORT ON;
	declare @beginTime datetime
	set @beginTime = getDate()
	
	-- таблица для храниния результата расчета доплат
	declare @tableResult table
	(
		xSCPId int,
		xTRKey int,
		xDateCheckIn datetime,
		xValueIsCommission money,
		xValueNoCommission money,
		xQAC_Id int,
		xSVKey int,
		xQAC_TourLongMin smallint,
		xQAC_TourLongMax smallint
	)

	insert into @tableResult (xQAC_Id, xSCPId, xTRKey, xDateCheckIn, xSVKey, xQAC_TourLongMin, xQAC_TourLongMax)
	select top (@amountItem) QAC_Id, QAC_SCPID, QAC_TRKey, QAC_DateCheckIn, QAC_SVKey, QAC_TourLongMin, QAC_TourLongMax
	from TP_QueueAddCosts with(nolock)
	where 
	-- если задан ключ тура то выбираем строки только для него
	(@tourKeys is null or QAC_TRKey in (select xt_key from dbo.ParseKeys(@tourKeys)))
	-- если заданы конкретные записи в очереди то расчитываем только по ним
	and ((@xQACIdTable is null) or (QAC_Id in (select xt_key from dbo.ParseKeys(@xQACIdTable))))
	
	
	print 'Заполнение временной таблицы: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	declare @SCPId int, @nPacketkey int, @nSvkey int, @nCode int, @nSubcode1 int, @nSubcode2 int, @tourdateCheckIn datetime, @nServiceDays int, @nPrkey int, @men int, @nTourDays int;

	-- нам не нужны дублирующие строки в курсоре, чтобы не вызывать несколько раз один и тот же расчет наценки
	-- поэтому групируем строки по SCP_Id и xTOKey - уникальной паре для расчета
	declare cursorReCalculateAddCosts cursor fast_forward read_only for
	with distinctTableResult as
	(
		select xTRKey, xSCPId,
		case when isnull(xQAC_TourLongMin, 0) = 0 then null else xQAC_TourLongMin end as xQAC_TourLongMin, 
		case when isnull(xQAC_TourLongMax, 0) = 0 then null else xQAC_TourLongMax end as xQAC_TourLongMax
		from @tableResult
		group by xSCPId, xTRKey, xQAC_TourLongMin, xQAC_TourLongMax
	)
	select SCP_Id, xTRKey, SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SCP_DateCheckIn, SCP_Days, SC_PRKey, SCP_Men, SCP_TourDays
		from	distinctTableResult join TP_ServiceCalculateParametrs with(nolock) on xSCPId = SCP_Id
				join TP_ServiceComponents with(nolock) on SCP_SCId = SC_Id
		where	xTRKey is not null
				and isnull(SCP_TourDays, 0) between isnull(xQAC_TourLongMin, -32000) and isnull(xQAC_TourLongMax, 32000)

	print 'Определение курсора: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()				
	
	open cursorReCalculateAddCosts
	fetch next from cursorReCalculateAddCosts into @SCPId, @nPacketkey, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @tourdateCheckIn, @nServiceDays, @nPrkey, @men, @nTourDays
	while (@@FETCH_STATUS = 0)
	begin
		declare @addCostValueIsCommission money, @addCostValueNoCommission money, @addCostFromAdult money, @addCostFromChild money, @tourRate nvarchar(2)

		exec GetServiceAddCosts @nPacketkey, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @tourdateCheckIn,
			@nTourDays, @nServiceDays, @men, null, null, @addCostValueIsCommission output, @addCostValueNoCommission output, @addCostFromAdult output, @addCostFromChild output, @tourRate output

		update @tableResult 
			set xValueIsCommission = @addCostValueIsCommission,
				xValueNoCommission = @addCostValueNoCommission
		where xSCPId=@SCPId
		
		fetch next from cursorReCalculateAddCosts into @SCPId, @nPacketkey, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @tourdateCheckIn, @nServiceDays, @nPrkey, @men, @nTourDays
	end
	close cursorReCalculateAddCosts
	deallocate cursorReCalculateAddCosts
	
	print 'Работа с курсором: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	declare @PriceComponentsRows int; set @PriceComponentsRows=0;
	
	/*переносим результат*/
	--	разобьем update по кортежам
	
	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_1 = xValueIsCommission,
		AddCostNoCommission_1 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_1 = xSCPId
	where SVKey_1 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_2 = xValueIsCommission,
		AddCostNoCommission_2 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_2 = xSCPId
	where SVKey_2 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_3 = xValueIsCommission,
		AddCostNoCommission_3 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_3 = xSCPId
	where SVKey_3 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
	
	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_4 = xValueIsCommission,
		AddCostNoCommission_4 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_4 = xSCPId
	where SVKey_4 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_5 = xValueIsCommission,
		AddCostNoCommission_5 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_5 = xSCPId
	where SVKey_5 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_6 = xValueIsCommission,
		AddCostNoCommission_6 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_6 = xSCPId
	where SVKey_6 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_7 = xValueIsCommission,
		AddCostNoCommission_7 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_7 = xSCPId
	where SVKey_7 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_8 = xValueIsCommission,
		AddCostNoCommission_8 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_8 = xSCPId
	where SVKey_8 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_9 = xValueIsCommission,
		AddCostNoCommission_9 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_9 = xSCPId
	where SVKey_9 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_10 = xValueIsCommission,
		AddCostNoCommission_10 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_10 = xSCPId
	where SVKey_10 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_11 = xValueIsCommission,
		AddCostNoCommission_11 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_11 = xSCPId
	where SVKey_11 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_12 = xValueIsCommission,
		AddCostNoCommission_12 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_12 = xSCPId
	where SVKey_12 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_13 = xValueIsCommission,
		AddCostNoCommission_13 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_13 = xSCPId
	where SVKey_13 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_14 = xValueIsCommission,
		AddCostNoCommission_14 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_14 = xSCPId
	where SVKey_14 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	update TP_PriceComponents
	set	PC_DateLastChangeAddCost = getdate(),
		PC_UpdateDate = getdate(),
		AddCostIsCommission_15 = xValueIsCommission,
		AddCostNoCommission_15 = xValueNoCommission,
		PC_State = 1
	from TP_PriceComponents join @tableResult on SCPId_15 = xSCPId
	where SVKey_15 = xSvKey
	and PC_TRKey = xTRKey
	
	set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;

	print 'Количество строк в TP_PriceComponents: ' + convert(nvarchar(max), @PriceComponentsRows)
	
	print 'Перенос результата в TP_PriceComponents: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	/*очистим очередь расчета*/
	delete TP_QueueAddCosts
	where QAC_Id in (select xQAC_Id from @tableResult)
	print 'Количество строк в TP_QueueAddCosts: ' + convert(nvarchar(max), @@rowcount)
	
	print 'Очистка очереди: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
END


GO


grant exec on [dbo].[ReCalculateAddCosts] to public
go

/*********************************************************************/
/* end sp_ReCalculateAddCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateMargin.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateMargin]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateMargin]
GO
CREATE PROCEDURE [dbo].[ReCalculateMargin]
	(
		--Хранимка перерасчитывает наценки из очереди
		--<version>2009.2.04</version>
		--<data>2012-02-22</data>
		-- максимальное количество наценок для расчета за 1 запуск
		@countMargionItems int,
		-- ключи записей из кеша которые нам нужно расчитать
		@xTMADIdTable nvarchar(max) = null
	)
AS
BEGIN	
	declare @tempMarginTable table
	(
		xTMADId int,
		xMarginPercent money,
		xMarginIsCommission bit
	)	
	declare @TMADId int, @TrKey int, @Date datetime, @margin float, @marginType int, @svKey int, @days int, @sellDate dateTime, @packetKey int
	
	declare cursorReCalculateMargin cursor fast_forward read_only for
	select top (@countMargionItems) TMAD_Id, TMAD_TRKey, TMAD_DateCheckIn, 0, 0, TMAD_SvKey, TMAD_Long, '1900-01-01', 0
	from TP_TourMarginActualDate with(nolock)
	where TMAD_NeedApply=1
	and ((@xTMADIdTable is null) or (TMAD_Id in (select xt_key from dbo.ParseKeys(@xTMADIdTable))))
	
	open cursorReCalculateMargin
	fetch next from cursorReCalculateMargin into @TMADId, @TrKey, @Date, @margin, @marginType, @svKey, @days, @sellDate, @packetKey
	while (@@FETCH_STATUS = 0)
	begin
		exec GetTourMargin @TrKey, @Date, @margin output, @marginType output, @svKey, @days, @sellDate, @packetKey
		
		insert into @tempMarginTable (xTMADId, xMarginPercent, xMarginIsCommission)
		values (@TMADId, @margin, @marginType)
		
		fetch next from cursorReCalculateMargin into @TMADId, @TrKey, @Date, @margin, @marginType, @svKey, @days, @sellDate, @packetKey
	end
	close cursorReCalculateMargin
	deallocate cursorReCalculateMargin
	
	--теперь перенесем значения в таблицу
	update TP_TourMarginActualDate
	set TMAD_DateLastCalculate = getdate(),
	TMAD_NeedApply = 2,
	TMAD_Percent = xMarginPercent,
	TMAD_IsCommission = xMarginIsCommission
	from TP_TourMarginActualDate join @tempMarginTable on xTMADId = TMAD_Id
	print 'Количество строк в TP_TourMarginActualDate: ' + convert(nvarchar(max), @@rowcount)
END

GO
grant exec on [dbo].[ReCalculateMargin] to public
go
/*********************************************************************/
/* end sp_ReCalculateMargin.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateAll.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateAll]
GO
create procedure [dbo].[ReCalculateAll] 
(
	-- хранимка обсчитывает изменившиеся цены, доплаты, наценки
	-- количество записей которые мы будем обсчитывать за 1 обработку
    @amountItem int
)
as 
	-- <date>2012-02-22</date>
	-- <version>2009.02.04</version>
    begin
		set nocount on;
    
		declare @beginTime datetime
		set @beginTime = getDate()    
		-- 1.1.1. Запускаем обсчет изменившихся цен
		begin
			print '1.1.1. Запускаем обсчет изменившихся цен (ReCalculateCosts)'
		
			exec dbo.ReCalculateCosts @amountItem
						
			print 'Время обработки: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
			set @beginTime = getDate()
		end
		-- 1.1.2. Переносим цены из таблицы TP_PriceActualDate в TP_PriceComponents
		begin
			print '1.1.2. Переносим цены из таблицы TP_PriceActualDate в TP_PriceComponents (ReCalculateCosts_GrossMigrate)'
		
			exec ReCalculateCosts_GrossMigrate @amountItem
			
			print 'Время обработки: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
			set @beginTime = getDate()
		end
		-- 1.2. Запускаем обсчет изменившихся доплат
		begin
			print '1.2. Запускаем обсчет изменившихся доплат (ReCalculateAddCosts)'
		
			exec dbo.ReCalculateAddCosts @amountItem
			
			print 'Время обработки: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
			set @beginTime = getDate()
		end
		-- 1.3.1. Запускаем обсчет изменившихся наценок
		begin
			print '1.3.1. Запускаем обсчет изменившихся наценок (ReCalculateMargin)'
		
			exec dbo.ReCalculateMargin @amountItem
			
			print 'Время обработки: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
			set @beginTime = getDate()
		end
		-- 1.3.2. Переносим цены из таблицы TP_PriceActualDate в TP_PriceComponents
		begin
			print '1.3.2. Переносим цены из таблицы TP_PriceActualDate в TP_PriceComponents (ReCalculateCosts_MarginMigrate)'
		
			exec ReCalculateCosts_MarginMigrate @amountItem
			
			print 'Время обработки: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
			set @beginTime = getDate()
		end
		-- 2 Запускаем перенос автопереносимых цен
		begin
			print '2 Запускаем перенос автопереносимых цен (ReCalculate_MigrateToPrice)'
		
			exec ReCalculate_MigrateToPrice @countItem = @amountItem
			
			print 'Время обработки: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
			set @beginTime = getDate()
		end
    end
GO

grant exec on [dbo].[ReCalculateAll] to public
go

/*********************************************************************/
/* end sp_ReCalculateAll.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_VerifiedCostOffer.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[VerifiedCostOffer]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[VerifiedCostOffer]
GO
CREATE PROCEDURE [dbo].[VerifiedCostOffer]
	(
		-- Хранимка проверки ценового блока
		--<version>2009.02.04</version>
		--<data>2012-03-30</data>		
		--.03 - признак "@IfSuccessSetActiv" проставляется теперь только при явной передаче "1"
		--.02 - теперь проставляется дата активации (CO_DateActive)
		@costOfferId int,					-- Ключ ценового блока
		@IfSuccessSetActiv bit,				-- Устанавливать активность ценового блока в случае успешной проверки
		@isPublicate bit = NULL,				    -- Публиковать СПО
		@errorMessage nvarchar(max) output	-- сообщение о ошибки проверки ценового блока
	)
AS
BEGIN
	set @errorMessage = ''
	
	/*временная таблица для оптимизации запросов к таблице цен*/
	declare @tempCost table
	(
		xSvKey int,
		xCode int,
		xPkKey int,
		xPartnerKey int
	)
	
	/*заполняем временную таблицу*/
	insert into @tempCost (xSvKey, xCode, xPkKey, xPartnerKey)
	select CS_SVKEY, CS_CODE, CS_PKKEY, CS_PRKEY
	from tbl_Costs
	where CS_COID = @costOfferId
	group by CS_SVKEY, CS_CODE, CS_PKKEY, CS_PRKEY
	
	/*создаем привязки ценового блока к услугам*/
	insert into CostOfferServices (COS_COID, COS_SVKEY, COS_CODE, COS_IsDisable, COS_DisableDate)
	select @costOfferId, xSvKey, xCode, 0, null
	from @tempCost
	where not exists (	select top 1 1 
						from CostOfferServices 
						where COS_COID = @costOfferId 
						and COS_SVKEY = xSvKey 
						and COS_CODE = xCode)
	group by xSvKey, xCode
	
	/*Создаем привязки к пакетам*/
	insert into CostOfferPackets (COP_COID, COP_PKKey)
	select @costOfferId, xPkKey
	from @tempCost
	where not exists (	select top 1 1 
						from CostOfferPackets 
						where COP_COID = @costOfferId 
						and COP_PKKey = xPkKey)
	group by xPkKey
	
	/*проверка на ключ услуги*/
	if (exists (select count(xSvKey)
				from @tempCost 
				group by xSvKey
				having count(xSvKey) > 1))
	begin
		set @errorMessage = @errorMessage + 'Ошибка! Цены в рамках одного ценового блока заведены цены на разные классы услуг '
	end
	/*проверка на партнера*/
	if (exists (select count(xPartnerKey)
				from @tempCost 
				group by xPartnerKey
				having count(xPartnerKey) > 1))
	begin
		set @errorMessage = @errorMessage + 'Ошибка! Цены в рамках одного ценового блока заведены цены на разных партеров '
	end
	
	/*Если все проверки прошли успешно, то устанавливаем нужный нам статус активности и публикуем*/
	if (@errorMessage = '')
	  BEGIN
		if (@IfSuccessSetActiv=1)
			begin 
				update CostOffers
				set CO_State = @IfSuccessSetActiv,
				CO_DateActive = GetDate()
				where CO_Id = @costOfferId
			end
		if (@isPublicate = 1)
			begin 
				update CostOffers 
				set CO_DateLastPublish = GetDate()
				where CO_Id = @costOfferId
			end
	  END
END
go

grant exec on [dbo].[VerifiedCostOffer] to public
go
/*********************************************************************/
/* end sp_VerifiedCostOffer.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateSaleDate.sql */
/*********************************************************************/
if exists ( select * from sys.objects where object_id = object_id(N'[dbo].[ReCalculateSaleDate]') and type in (N'P', N'PC') ) 
    drop procedure [dbo].[ReCalculateSaleDate]
go

create procedure [dbo].[ReCalculateSaleDate] 
	--	Хранимка: 
	--	1.	Ищет цены в TP_ServicePriceActualDate для которых наступил SaleDate и SPAD_NeedApply = 1 
	--		и перерасчитывает их
	--	2.	Удаляет строки из TP_ServicePriceActualDate для которых SaleDate=null и есть аналогичные (одинаковые SPAD_SCPId)
	--		расчитанные (с актуальной ценой) (SPAD_NeedApply=0) для которых для котрых SaleDate=@currentDate
	--	3.	ОбNULLяет SPAD_SaleDate для всех расчитанных (SPAD_NeedApply=0) цен из TP_ServicePriceActualDate 
	--		для котрых SaleDate=@currentDate
	(
		-- для отладочных целей - указываем дату, которая будет считаться текущей
		@virtualCurrentDate datetime = null
	)
as 
	-- <date>2012-03-13</date>
	-- <version>2009.02.04</version>
    begin

	declare @currentDateTime datetime, @currentDate datetime; 
	if (@virtualCurrentDate is not null)
	begin
		set @currentDateTime = @virtualCurrentDate
		set @currentDate = @virtualCurrentDate
	end
	else
	begin
		set @currentDateTime = getdate();  -- 2012-02-17 14:25:12
		set @currentDate = dateadd(dd, 0, datediff(dd, 0, @currentDateTime));  -- 2012-02-17 00:00:00
	end
	
	declare @tempGrossTable table
	(
		xSPADId int,
		xSPADSCPId int,
		xSPADGross money,
		xSPADNetto money,
		xSPADIsCommission bit
	)

	declare @svKey int, @code int, @code1 int, @code2 int, @prKey int, @packetKey int, @date datetime, @days int,
	@resRate varchar(2), @men int, @discountPercent decimal(14,2), @margin decimal(14,2), @marginType int,
	@sellDate dateTime, @netto decimal(14,2), @brutto decimal(14,2), @discount decimal(14,2),
	@nettoDetail varchar(100), @sBadRate varchar(2), @dtBadDate dateTime,
	@sDetailed varchar(100),  @nSPId int, @useDiscountDays int,
	@spadId int, @spadIsCommission bit, @spadScpId int

	-- debugging
	--select SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey, SCP_PKKey, SCP_Date, SCP_Days,
	--SPAD_Rate, SCP_Men, 0, 0, 0,
	--SPAD_SaleDate, 0, 0, 0,
	--'', '', '' ,
	--'', null, 0,
	--SPAD_Id, SPAD_SCPId
	--from TP_ServicePriceActualDate join TP_ServiceCalculateParametrs on SPAD_SCPId = SCP_Id
	--join TP_ServiceComponents on SCP_SCId = SC_Id
	--where	SPAD_NeedApply = 1
	--		and SPAD_SaleDate = @currentDate
			

	declare cursorReCalculateCosts cursor fast_forward read_only for
	select SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey, SCP_PKKey, SCP_Date, SCP_Days,
	SPAD_Rate, SCP_Men, 0, 0, 0,
	SPAD_SaleDate, 0, 0, 0,
	'', '', '' ,
	'', null, 0,
	SPAD_Id, SPAD_SCPId
	from TP_ServicePriceActualDate join TP_ServiceCalculateParametrs on SPAD_SCPId = SCP_Id
	join TP_ServiceComponents on SCP_SCId = SC_Id
	where	SPAD_NeedApply = 1
			and SPAD_SaleDate = @currentDate

	open cursorReCalculateCosts
	fetch next from cursorReCalculateCosts into @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
	@resRate, @men, @discountPercent, @margin, @marginType,
	@sellDate, @netto, @brutto, @discount,
	@nettoDetail, @sBadRate, @dtBadDate,
	@sDetailed,  @nSPId, @useDiscountDays,
	@spadId, @spadScpId
	while (@@FETCH_STATUS = 0)
	begin
		-- тут нам не нужно считать доплату, поэтому передаем фейковые значения
		declare @tourKey int, @tourDate datetime, @tourDays int, @includeAddCost bit
		set @tourKey = -100500
		set @tourDate = '1900-01-01'
		set @tourDays = -100500
		set @includeAddCost = 0
		
		exec GetServiceCost @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
		@resRate, @men, @discountPercent, @margin, @marginType,
		@sellDate, @netto output, @brutto output, @discount output,
		@nettoDetail output, @sBadRate output, @dtBadDate output,
		@sDetailed output,  @nSPId output, @useDiscountDays output,		
		@tourKey, @tourDate, @tourDays, @includeAddCost
		
		-- debugging
		--SELECT	
		--@svKey as N'SvKey', @code as N'Code', @code1 as N'SubCode1', @code2 as N'SubCode2', 
		--@prKey as N'PrKey', @packetKey as N'PacketKey', @date as N'Date', @days as N'Days',
		--@resRate as N'ResRate', @men as N'Men', @discountPercent as N'DiscountPercent', 
		--@margin as N'Margin', @marginType as N'MarginType', @sellDate as N'SellDate',
		
		--@netto as N'@netto',
		--@brutto as N'@brutto',
		--@discount as N'@discount'
		
		
		if (@discount is null)
			set @spadIsCommission = 0
		else
			set @spadIsCommission = 1
		
		-- после того как получили стоимость услуги запишем ее значение во временную таблицу
		insert into @tempGrossTable (xSPADId, xSPADSCPId, xSPADGross, xSPADNetto, xSPADIsCommission)
		values (@spadId, @spadScpId, @brutto, @netto, @spadIsCommission)						
						
		fetch next from cursorReCalculateCosts into @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
		@resRate, @men, @discountPercent, @margin, @marginType,
		@sellDate, @netto, @brutto, @discount,
		@nettoDetail, @sBadRate, @dtBadDate,
		@sDetailed,  @nSPId, @useDiscountDays,
		@spadId, @spadScpId
	end
	close cursorReCalculateCosts
	deallocate cursorReCalculateCosts
	
	-- debugging
	--select * from @tempGrossTable
	
	--select *
	--from TP_ServicePriceActualDate inner join @tempGrossTable on xSPADId = SPAD_Id
	
	-- 1. обновляем толькочто перерасчитанные цены
	update TP_ServicePriceActualDate with(rowlock)
	set	SPAD_DateLastChange = @currentDateTime,
		SPAD_DateLastCalculate = @currentDateTime,
		SPAD_Gross = xSPADGross,
		SPAD_Netto = xSPADNetto,
		SPAD_IsCommission = xSPADIsCommission,
		SPAD_NeedApply = 0
	from TP_ServicePriceActualDate inner join @tempGrossTable on xSPADId = SPAD_Id;
	
	-- debugging
	--select *
	--from TP_ServicePriceActualDate inner join @tempGrossTable on xSPADId = SPAD_Id
	
	--	все что шло до этой строки относилось только к тем строкам которые нужно было перерасчитать 
	--	ну и конечно для них наступил saleDate
	
	--	далее идет обработка всех строк для которых наступил saleDate и которые уже были перерасчитаны
	--	это и те строки которые мы расчитали толькочто и могут быть цены которые были расчитаны заранее
	--	пока такого механизма нет, но он должен появится - в итоге у всех строк которые обрабатываются
	--	ниже должен быть SPAD_NeedApply = 0 и SPAD_SaleDate = @currentDate
	
	--	1. удалим из основной таблицы строки у котрых SPAD_SaleDate=null и есть аналогичные для которых наступил SaleDate
	
	-- debugging
	--with saleDateEqualCurrentDate as
	--(
	--	select SPAD_SCPId from TP_ServicePriceActualDate
	--	where SPAD_SaleDate = @currentDate
	--	-- по идее на данный момент все строки с наступившим SaleDate итак имеют SAPD_NeedApply = 0
	--	-- но на всякий случай пока оставил
	--	and SPAD_NeedApply = 0
	--)
	--select * from TP_ServicePriceActualDate
	--where	SPAD_SCPId in (select SPAD_SCPId from saleDateEqualCurrentDate)
	--		and SPAD_SaleDate is null;
	
	with saleDateEqualCurrentDate as
	(
		select SPAD_SCPId from TP_ServicePriceActualDate
		where SPAD_SaleDate = @currentDate
		-- по идее на данный момент все строки с наступившим SaleDate итак имеют SAPD_NeedApply = 0
		-- но на всякий случай пока оставил
		and SPAD_NeedApply = 0
	)
	delete	TP_ServicePriceActualDate with(rowlock)
	where	SPAD_SCPId in (select SPAD_SCPId from saleDateEqualCurrentDate)
			and SPAD_SaleDate is null;
	
	-- debugging
	--select *
	--from TP_ServicePriceActualDate
	--where SPAD_SaleDate = @currentDate
	--and SPAD_NeedApply = 0
	
	--	2. обновляем все строки из кэша, для которых цена актуальна (т.е. SPAD_NeedApply = 0) и наступил SaleDate
	--	обнуляем им SPAD_SaleDate, тем самым делая их действующими
	update TP_ServicePriceActualDate with(rowlock)
	set	SPAD_DateLastChange = @currentDateTime,
		SPAD_SaleDate = null
	from TP_ServicePriceActualDate
	where SPAD_SaleDate = @currentDate
	and SPAD_NeedApply = 0
	
	-- debugging
	--select *
	--from TP_ServicePriceActualDate
	--where SPAD_SaleDate = @currentDate
	--and SPAD_NeedApply = 0
	
	--	3. далее джоб ReCalculateAll протащит эти изменения до TP_PriceComponents
	
    end
go

grant exec on [dbo].[ReCalculateSaleDate] to public
go

/*********************************************************************/
/* end sp_ReCalculateSaleDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCleaner.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCleaner]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCleaner]
GO
CREATE PROCEDURE [dbo].[ReCalculateCleaner]
(
	@countItems int
)
as
	--<DATE>2012-03-20</DATE>
	--<VERSION>2009.02.04</VERSION>
	
	declare @currentDateTime datetime; set @currentDateTime = getdate();  -- 2012-02-17 14:25:12
	declare @currentDate datetime; set @currentDate = dateadd(dd, 0, datediff(dd, 0, @currentDateTime));  -- 2012-02-17 00:00:00
	
	/*	1a.	Очищаем TP_PriceComponents по дате тура (PC_TourDate)
			Цены на туры которые уже прошли нам не нужны	*/
	while 1=1
	begin
		delete top(@countItems) dbo.TP_PriceComponents where PC_TourDate < @currentDate;
		if (@@rowcount=0)
			break;
	end
	
	/*	1b.	Очищаем TP_PriceComponents по ключу на TP_Prices
			Цены которых нет в tp_prices и в TP_PricesDeleted нам уже не нужны	*/
	while 1=1
	begin
		delete top(@countItems) dbo.TP_PriceComponents 
		where	not exists (select top 1 1 from tp_prices where TP_Key=pc_tpkey) 
				and not exists (select top 1 1 from TP_PricesDeleted where TPD_TPKey=pc_tpkey);
		if (@@rowcount=0)
			break;
	end
	
	/*	2.	Очищаем TP_ServiceCalculateParametrs по дате заезда (SCP_DateCheckIn)
			Каскадом уходя записи из TP_ServicePriceActualDate	*/
	while 1=1
	begin
		delete top(@countItems) dbo.TP_ServiceCalculateParametrs where SCP_DateCheckIn < @currentDate;
		if (@@rowcount=0)
			break;
	end

	/*	3.	Очищаем TP_ServiceComponents по отсутствию ссылок на него со стороны TP_ServiceCalculateParametrs
			Каскадом уходят TP_QueueAddCosts для данных параметров услуги	*/	
	while 1=1
	begin
		delete top(@countItems) dbo.TP_ServiceComponents where SC_Id not in (select SCP_SCId from dbo.TP_ServiceCalculateParametrs);
		if (@@rowcount=0)
			break;
	end

	/*	4.	Очищаем TP_TourMarginActualDate по дате заезда (TMAD_DateCheckIn)
			Наценки на туры которые уже прошли нам не нужны	*/
	while 1=1
	begin
		delete top(@countItems) dbo.TP_TourMarginActualDate where TMAD_DateCheckIn < @currentDate;
		if (@@rowcount=0)
			break;
	end
go

grant exec on [dbo].[ReCalculateCleaner] to public
go

/*********************************************************************/
/* end sp_ReCalculateCleaner.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CreateCostOffer.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCostOffer]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateCostOffer]
GO

CREATE PROCEDURE [dbo].[CreateCostOffer]
	(
		-- хранимка создает костофер
		-- <data>2012-04-01</data>
		-- <version>2009.02.04</version>
		@code varchar(254),
		@name varchar(254),
		@partnerKey int,
		@packetKey int,
		@svKey int,
		@saleDateBeg datetime,
		@saleDateEnd datetime,
		@description varchar(254),
		@coId int output,
		-- сезон к которому прикрепим костофер
		@seasonId int = null
	)
AS
BEGIN
	-- если сезон не задан то находим его тут
	if (@seasonId is null)
	begin
		set @seasonId = (select top 1 SN_ID from Seasons where SN_IsActive = 1 order by SN_CreateDate desc)
	end

	insert into CostOffers (CO_Code, CO_Comment, CO_CreateDate, CO_DateActive, CO_Description, CO_State, CO_IsRules, CO_Name,
	CO_PartnerKey, CO_PKKey, CO_SaleDateBeg, CO_SaleDateEnd, CO_SeasonId, CO_SPOTypeId, CO_SVKey)
	values(@code, '', GETDATE(), null, @description, 0, 0, @name,
	@partnerKey, @packetKey, @saleDateBeg, @saleDateEnd, @seasonId, 1, @svKey)
	
	SET @coId = SCOPE_IDENTITY()

END
	
go 

grant exec on [dbo].[CreateCostOffer] to public
go
/*********************************************************************/
/* end sp_CreateCostOffer.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CostExplorerCostCreatorJob.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CostExplorerCostOfferCreatorJob]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CostExplorerCostOfferCreatorJob]
GO

CREATE PROCEDURE [dbo].[CostExplorerCostOfferCreatorJob]
AS
--<data>2012-03-02</data>
--<version>2009.02.05</version>
--.05 mv 02.03.2012 - изменил параметр "Необходимо активировать после верификации" с "1" на "0" (требование) 
--mv 01.03.2012 - изменил на отбор за день
--mv 26.02.2012 (MEG00040227) Добавил в название CostOffers "код SPO", по налогии с полем "Description"
BEGIN
	DECLARE @CIN_Id int
	DECLARE @CO_Id int
	DECLARE @code varchar(254)
	DECLARE @name varchar(254)
	DECLARE @description varchar(254)
	
	DECLARE @partnerKey int, @packetKey int, @svKey int, @saleDateBeg datetime, @saleDateEnd datetime
	
	CREATE TABLE #temp
	(
		xCinId int
	)
	
	insert into #temp (xCinId)
	select DISTINCT CS_CINNUM from tbl_Costs with(nolock)
	where  CS_CINNUM is not null and CS_COID is null 
	and CS_UPDDATE > DATEADD(DAY,-1,GetDate())
	/*
	select c1.CS_CINNUM from tbl_Costs c1 with(nolock)
	where  c1.CS_CINNUM is not null and c1.CS_COID is null 
	and c1.CS_UPDDATE > DATEADD(HOUR,-1,GetDate())
	and DATEDIFF(MI,
		(select top 1 c2.CS_UPDDATE from tbl_Costs c2 with(nolock) where c2.CS_CINNUM is not null
		and c2.CS_COID is null and c2.CS_CINNUM = c1.CS_CINNUM 
		and c2.CS_UPDDATE > DATEADD(HOUR,-1,GetDate())
		order by CS_UPDDATE desc)
		,GETDATE()) >= 2
	*/	

	DECLARE curr cursor for select xCinId from #temp
	
	OPEN curr
    FETCH NEXT FROM curr INTO @CIN_Id
    WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @CO_Id = (SELECT TOP 1 CIN_SPOKEY FROM CostsInsertNumber with(nolock) WHERE CIN_NUM = @CIN_Id)	
		IF @CO_Id is null 
		BEGIN
			set @code = cast(@CIN_Id as varchar)
			set @name = (select CIN_HotelName from CostsInsertNumber with(nolock) where CIN_Num = @CIN_Id) + '_' + @code
			set @description = @name
			
			select top 1 @partnerKey = CS_PRKEY, @packetKey = CS_PKKEY, @saleDateBeg = cs_DateSellBeg, @saleDateEnd = cs_DateSellEnd, @svKey = CS_SVKEY
			from tbl_costs with(nolock) where cs_cinnum = @CIN_Id
		
			EXEC CreateCostOffer @code,@name,@partnerKey,@packetKey,@svKey,@saleDateBeg,@saleDateEnd,@description,@CO_Id output
		
			--print 'dfgdfg'
			--print @CO_Id
			
			UPDATE CostsInsertNumber SET CIN_SPOKEY = @CO_Id WHERE CIN_NUM = @CIN_Id
		END
			
		UPDATE TBL_COSTS SET CS_COID = @CO_ID WHERE CS_CINNUM = @CIN_Id and CS_COID is null and CS_UPDDATE > DATEADD(DAY,-1,GetDate()) and CS_SVKey=3
		
		DECLARE @error varchar
		
		EXEC VerifiedCostOffer @CO_ID, 0, @error output
		
		FETCH NEXT FROM curr INTO @CIN_Id	
	END	
	
	drop table #temp
	CLOSE curr
	DEALLOCATE curr
END
go 

grant exec on [dbo].[CostExplorerCostOfferCreatorJob] to public
go
/*********************************************************************/
/* end sp_CostExplorerCostCreatorJob.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CalculatePriceListDynamic.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculatePriceListDynamic]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculatePriceListDynamic]
GO

CREATE PROCEDURE [dbo].[CalculatePriceListDynamic]
(
	--<data>2012-05-21</data>
	--<version>2009.02.18</version>
	@nPriceTourKey int,				-- ключ обсчитываемого тура
	@nCalculatingKey int,			-- ключ итерации дозаписи
	@dtSaleDate datetime,			-- дата продажи
	@nNullCostAsZero smallint,		-- считать отсутствующие цены нулевыми (кроме проживания) 0 - нет, 1 - да
	@nNoFlight smallint,			-- при отсутствии перелёта в расписании 0 - ничего не делать, 1 - не обсчитывать тур, 2 - искать подходящий перелёт (если не найдено - не рассчитывать)
	@nUpdate smallint,				-- признак дозаписи 0 - расчет, 1 - дозапись
	@nUseHolidayRule smallint		-- Правило выходного дня: 0 - не использовать, 1 - использовать
)
AS

SET ARITHABORT off;
set nocount on;
declare @beginTime datetime
set @beginTime = getDate()

declare @variant int
declare @pricetour int
declare @turdate datetime
declare @servicedate datetime
declare @price_brutto money
declare @TrKey int
declare @userKey int
--
declare @nServiceKey int
declare @nSvkey int
declare @nCode int
declare @nSubcode1 int
declare @nSubcode2 int
declare @nPrkey int
declare @nPacketkey int
declare @nDay int
declare @nDays int
declare @sRate varchar(3)
declare @nMen int
declare @nMargin money
declare @nMarginType int
declare @nNetto money
declare @nBrutto money
declare @nDiscount money
declare @nTempGross money
declare @tsCheckMargin smallint
declare @tdCheckMargin smallint
declare @TI_DAYS int
declare @TS_CTKEY int
declare @TS_ATTRIBUTE int
--
declare @SERV_NOTCALCULATE int
--
declare @dtPrevDate datetime
declare @nPrevVariant int
declare @nPrevGross money
declare @nPrevGrossKey int
declare @nPrevGrossDate datetime
declare @nPriceFor smallint
declare @nTP_PriceKeyCurrent int
declare @nTP_PriceKeyMax int
declare @NumPrices int, @NumCalculated int
--
declare @fetchStatus smallint
--declare @nCount int
declare @nDeltaProgress money
declare @nTotalProgress money
declare @round smallint
--
declare @hdKey int
declare @prevHdKey int
--
declare @nProgressSkipLimit smallint
declare @nProgressSkipCounter smallint
declare @weekday varchar(3)
declare @nDateFirst smallint
declare @nFlightEnabled smallint
declare @nCH_Key int
declare @CS_PRKEY int
declare @dDateBeg1 datetime -- дата начала 1го периода
declare @dDateBeg3 datetime -- дата начала 2,3го периода
declare @dDateEnd1 datetime -- дата окончания 1го периода
declare @dDateEnd3 datetime -- дата окончания 2,3го периода
--
declare @sDetailed varchar(100) -- не используется, необходима только для передачи в качестве параметра в GSC
declare @sBadRate varchar(3)
declare @dtBadDate DateTime
--
declare @nSPId int -- возвращается из GSC, фактически это ключ из ServicePrices
declare @nPDId int 
declare @nBruttoWithCommission money

--переменные для разбиения сгруппированных цен
declare @priceDate datetime
declare @priceListKey int
declare @numDates int
declare @priceListGross int
---------------------------------------------
declare @ROUND_NOTWITHDISC int
declare @ROUND_SERVICE_MATH int
declare @ROUND_SERVICE0_5 int
declare @ROUND_PRICE0_5 int
declare @ROUND_SERVICE int
declare @ROUND_PRICE int
declare @ROUND_NOT int

Set @ROUND_NOTWITHDISC = 64
Set @ROUND_SERVICE_MATH = 32
Set @ROUND_SERVICE0_5 = 16
Set @ROUND_PRICE0_5 = 8
Set @ROUND_SERVICE = 4
Set @ROUND_PRICE = 2
Set @ROUND_NOT = 1
---------------------------------------------
declare @nIsEnabled smallint
--select @nIsEnabled = TO_IsEnabled from TP_Tours where TO_Key = @nPriceTourKey
--set @nIsEnabled = 0
---------------------------------------------
declare @tpPricesCount int
declare @isPriceListPluginRecalculation smallint
select @tpPricesCount = count(1) from tp_prices with(nolock) where tp_tokey = @nPriceTourKey

if (@nCalculatingKey is null)
begin
	select top 1 @nCalculatingKey = CP_Key from CalculatingPriceLists where CP_PriceTourKey = @nPriceTourKey and CP_Update = 0
	update tp_turdates set td_update = 0 where td_tokey = @nPriceTourKey
	update tp_lists set ti_update = 0 where ti_tokey = @nPriceTourKey
	if (@tpPricesCount <> 0)
		set @isPriceListPluginRecalculation = 1
	else
		set @isPriceListPluginRecalculation = 0
end
else
	set @isPriceListPluginRecalculation = 0

declare @calculatingPriceListsExists smallint -- 0 - CalculatingPriceLists нет, 1 - CalculatingPriceLists есть в базе

print 'Инициализация: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
set @beginTime = getDate()

BEGIN		
	--koshelev
	--MEG00027550
	if @nUpdate = 0
	begin
		update tp_tours with(rowlock) set to_datecreated = GetDate() where to_key = @nPriceTourKey
	end

	select @TrKey = to_trkey, @userKey = to_opkey from tp_tours with(nolock) where to_key = @nPriceTourKey

	delete from CalculatingPriceLists with(rowlock) where CP_PriceTourKey not in (select to_key from tp_tours with(nolock))

	if not exists (select 1 from CalculatingPriceLists with(nolock) where CP_PriceTourKey = @nPriceTourKey) and @nPriceTourKey is not null
	begin	
		insert into CalculatingPriceLists (CP_PriceTourKey, CP_SaleDate, CP_NullCostAsZero, CP_NoFlight, CP_Update, CP_TourKey, CP_UserKey, CP_Status, CP_UseHolidayRule)
		values (@nPriceTourKey, @dtSaleDate, @nNullCostAsZero, @nNoFlight, @nUpdate, @TrKey, @userKey, 1, @nUseHolidayRule)
	end
	else if @nPriceTourKey is not null
	begin
		update CalculatingPriceLists with(rowlock) set CP_Status = 1 where CP_Key = @nCalculatingKey
	end

	DECLARE @sHI_Text varchar(254), @nHIID int
	SELECT @sHI_Text=TO_Name FROM tp_tours with(nolock) where to_key = @nPriceTourKey
	EXEC @nHIID = dbo.InsHistory '', null, 11, @nPriceTourKey, 'INS', @sHI_Text, '', 0, ''

	SET @sHI_Text=CONVERT(varchar(30),@dtSaleDate,104)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11001, null, @sHI_Text, null, null, null, @dtSaleDate, 0
	If @nNullCostAsZero=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11002, null, @sHI_Text, null, @nNullCostAsZero, null, null, 0
	If @nNoFlight=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='Flight search'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11003, null, @sHI_Text, null, @nNoFlight, null, null, 0
	If @nUpdate=0
		SET @sHI_Text='First calculate'
	ELSE
		SET @sHI_Text='Add calculate'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11004, null, @sHI_Text, null, @nUpdate, null, null, 0
	If @nUseHolidayRule = 0
		SET @sHI_Text = 'NO'
	ELSE
		SET @sHI_Text = 'YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11008, null, @sHI_Text, null, @nUpdate, null, null, 0
	
	--Засекаем время начала рассчета begin
	declare @beginPriceCalculate datetime
	set @beginPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@beginPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11009, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время начала рассчета end
	
	print 'Запись в историю: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	Set @nTotalProgress=1
	update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	select @nDateFirst = @@DATEFIRST
	set DATEFIRST 1
	set @SERV_NOTCALCULATE = 32768	
	
	-- временная таблица для @tpFlights
	declare @tpFlights table
	(
		xfTOKey int,
		xfCalculatingKey int,
		xfDate datetime,
		xfTSKeyOld int,
		xfTSKeyNew int
	)
	
	-- временная таблица для @tpService
	declare @tpService table
	(
		xsKey int,
		xsCode int,
		xsSubCode1 int,
		xsSubCode2 int,
		xsOpPartnerKey int,
		xsOpPacketKey int,
		xsDay int,
		xsDays int,
		xsMen int,
		xsTEMPGROSS float,
		xsCHECKMARGIN smallint,
		xsCTKey int,
		xsATTRIBUTE int
	)	

	If @nUpdate=0
	begin
		insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_CalculatingKey, TF_TourDate, TF_TSKeyOld, TF_TSKeyNew)
		output inserted.TF_TOKey, inserted.TF_CalculatingKey, inserted.TF_Date, inserted.TF_TSKeyOld, inserted.TF_TSKeyNew into @tpFlights
		select distinct TO_Key, TD_Date + TS_Day - 1, TS_Code, TS_OpPartnerKey,
			TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, TI_Days, @nCalculatingKey, TD_Date, TS_Key, null
			From TP_Services with(nolock), TP_TurDates with(nolock), TP_Tours with(nolock), TP_Lists with(nolock), TP_ServiceLists with(nolock)
			where TS_TOKey = TO_Key and TS_SVKey = 1 and TD_TOKey = TO_Key and TI_TOKey = TO_Key and TL_TOKey = TO_Key and TL_TSKey = TS_Key and TL_TIKey = TI_Key and TO_Key = @nPriceTourKey
	end
	Else
	BEGIN	
		-- gorshkov нужно обnullить значения TF_CodeNew и TF_TSKeyNew в TP_Flights для дозаписываемого тура, иначе не будет подбираться перелет
		update TP_Flights set TF_CodeNew = null, TF_TSKeyNew = null 
		from TP_Flights cross join TP_TurDates 
		where 
			TD_TOKey=@nPriceTourKey
			and TF_TOKey=@nPriceTourKey
			and TF_TourDate=TD_Date;
	
		select distinct TO_Key, TD_Date + TS_Day - 1 flight_day, TS_Code , TS_OpPartnerKey,	TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, TI_Days, TD_Date, TS_Key
		into #tp_flights2
		from TP_Tours with(nolock) join TP_Services with(nolock) on TO_Key = TS_TOKey and TS_SVKey = 1
			join TP_ServiceLists with(nolock) on TL_TSKey = TS_Key and TS_TOKey = TO_Key
			join TP_Lists with(nolock) on TL_TIKey = TI_Key and TI_TOKey = TO_Key
			join TP_TurDates with(nolock) on TD_TOKey = TO_Key
		where TO_Key = @nPriceTourKey
		
		delete from #tp_flights2 where exists (Select 1 From TP_Flights with(nolock) Where TF_TOKey=@nPriceTourKey and TF_Date=flight_day
			and TF_CodeOld=TS_Code and TF_PRKeyOld=TS_OpPartnerKey and TF_PKKey=TS_OpPacketKey
			and TF_CTKey=TS_CTKey and TF_SubCode1=TS_SubCode1 and TF_SubCode2=TS_SubCode2 and TF_Days = TI_Days)
		
		insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_TourDate, TF_TSKeyOld, TF_TSKeyNew, TF_CalculatingKey)
		output inserted.TF_TOKey, inserted.TF_CalculatingKey, inserted.TF_Date, inserted.TF_TSKeyOld, inserted.TF_TSKeyNew into @tpFlights
		select *, null, @nCalculatingKey  from #tp_flights2
	end

	print 'Подбор перелетов 1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
--------------------------------------- ищем подходящий перелет, если стоит настройка подбора перелета --------------------------------------

	------ проверяем, а подходит ли текущий рейс, указанный в туре ----
	Update	TP_Flights Set TF_TSKeyNew = TF_TSKeyOld,	TF_CodeNew = TF_CodeOld, TF_PRKeyNew = TF_PRKeyOld, TF_SubCode1New = TF_SubCode1, TF_CalculatingKey = @nCalculatingKey
	output inserted.TF_TOKey, inserted.TF_CalculatingKey, inserted.TF_Date, inserted.TF_TSKeyOld, inserted.TF_TSKeyNew into @tpFlights
	Where	exists (SELECT 1 FROM AirSeason WHERE AS_CHKey = TF_CodeOld AND TF_Date BETWEEN AS_DateFrom AND AS_DateTo AND AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%')
			and exists (select 1 from Costs where CS_Code = TF_CodeOld and CS_SVKey = 1 and CS_SubCode1 = TF_Subcode1 and CS_PRKey = TF_PRKeyOld and CS_PKKey = TF_PKKey 
			and TF_Date BETWEEN ISNULL(CS_Date, '1900-01-01') AND ISNULL(CS_DateEnd, '2053-01-01') 
			and TF_TourDate BETWEEN ISNULL(CS_CHECKINDATEBEG, '1900-01-01') AND ISNULL(CS_CHECKINDATEEND, '2053-01-01')
			and (ISNULL(CS_Week, '') = '' or CS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') 
			and (CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long))
			and TF_TOKey = @nPriceTourKey
	
	print 'Подбор перелетов 2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	If @nNoFlight = 2
	BEGIN
		------ проверяем, а есть ли у данного парнера по рейсу, цены на другие рейсы в этом же пакете ----		
		
		IF exists(SELECT TF_ID FROM TP_Flights with(nolock) WHERE TF_TOKey = @nPriceTourKey and TF_CodeNew is Null) 
		begin
			print 'Подбираем перелет'
			
			declare @newFlightsPartnerTable table
			(
				-- идентификатор
				xId int identity(1,1),
				-- ключ услуги перелет
				xTFId int,
				-- ключ исходного партнера
				xPRKey int,
				-- ключ партнера которого подобрали
				xPRKeyNew int,
				-- ключ перелета
				xCHKey int,
				-- ключ тарифа на перелет
				xASKey int
			)
			-- подбираем подходящие нам перелеты
			insert into @newFlightsPartnerTable (xTFId, xCHKey, xASKey, xPRKey, xPRKeyNew)
			SELECT TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			FROM AirSeason with(nolock), Charter with(nolock), Costs with(nolock), TP_Flights with(nolock)
			WHERE CH_CityKeyFrom = TF_Subcode2 and
			CH_CityKeyTo = TF_CTKey and
			CS_Code = CH_Key and
			AS_CHKey = CH_Key and
			CS_SVKey = 1 and
			(	isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = CS_SubCode1), '')
				= 
				isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = TF_Subcode1), '')
			) and
			CS_PKKey = TF_PKKey and
			TF_Date BETWEEN AS_DateFrom and AS_DateTo and
			TF_Date BETWEEN CS_Date and CS_DateEnd and
			AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%' and
			(ISNULL(CS_Week, '') = '' or CS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') and
			(CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long) and
			TF_CodeNew is Null and 
			TF_TOKey = @nPriceTourKey
			group by TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			
			-- удаляем повторяющиеся (если подобралось несколько перелетов)
			delete @newFlightsPartnerTable
			from @newFlightsPartnerTable as a
			where a.xId != (select top 1 b.xId 
							from @newFlightsPartnerTable as b 
							where b.xTFId = a.xTFId
							-- и приорететнее те перелеты в которых партнеры совпадают с исходным
							order by case when b.xPRKey = b.xPRKeyNew then 0 else 1 end)
			
			-- обновляем информацию о найденом перелете
			update TP_Flights with(rowlock)
			set TF_CodeNew = xCHKey,
			TF_SubCode1New = xASKey,
			TF_PRKeyNew = xPRKeyNew,
			TF_CalculatingKey = @nCalculatingKey
			output inserted.TF_TOKey, inserted.TF_CalculatingKey, inserted.TF_Date, inserted.TF_TSKeyOld, inserted.TF_TSKeyNew into @tpFlights
			from TP_Flights with(rowlock) join @newFlightsPartnerTable on TF_Id = xTFId
			
			print 'Закончили подбор перелетов'			
		end
		
		print 'Подбор перелетов 3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
		
	-- 1.	добавить в таблицу tp_services еще строки disctinct (со всеми темиже параметрами что и были), 
	--		кроме TS_CODE, TS_OpPartnerKey (которые берутся из tp_flights)
	
	declare
	@insertedRowCount int ,
	@nTP_ServiceKeyMax int ,
	@nTP_ServiceKeyCurrent int ;
		
	declare
	@TS_Key int ,
	@TS_TOKey int ,
	@TS_SVKey int ,
	@TS_Code int ,
	@TS_SubCode1 int ,
	@TS_SubCode2 int ,
	@TS_CNKey int ,
	@TS_Day smallint ,
	@TS_Days smallint ,
	@TS_Men smallint ,
	@TS_Name varchar(255) ,
	@TS_OpPartnerKey int ,
	@TS_OpPacketKey int ,
	@TS_TEMPGROSS float ,
	@TS_CHECKMARGIN smallint ,
	@TS_CalculatingKey int ,
	@TS_SCId int
	
	print 'Подбор перелетов 3.0: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))				
	--получаем количество строк которые будут вставлены
	select
	@insertedRowCount = count(distinct TF_CodeNew | TF_PRKeyNew)
	from
	dbo.TP_Flights
	where
	TF_TOKey = @nPriceTourKey
	and not exists ( select top 1
						1
					 from
						dbo.TP_Services
					 where
						dbo.TP_Services.TS_SVKey = 1
						and dbo.TP_Services.TS_TOKey = @nPriceTourKey
						and dbo.TP_Services.TS_Code = dbo.TP_Flights.TF_CodeNew
						and dbo.TP_Services.TS_OpPartnerKey = dbo.TP_Flights.TF_PRKeyNew ) ;
	
	print 'Подбор перелетов 3.1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	if (@insertedRowCount > 0) 
	begin
		-- получаем максимальный Id для вставляемых строк
		exec GetNKeys 'TP_Services', @insertedRowCount,	@nTP_ServiceKeyMax output;

		-- вставляем строки в TP_Services
		with servicesRowNumbers([rowNumber],[i]) as
		(
			-- вспомогательная таблица (номер строки, id)
			select
				1 as [rowNumber], @nTP_ServiceKeyMax - @insertedRowCount + 1 as [i]
			union all
			select
				[rowNumber] + 1, [i] + 1
			from
				servicesRowNumbers
			where [rowNumber] < @insertedRowCount
		),
		servicesForInsert as (
		-- вспомогательная таблица (номер строки, все остальные необходимы для вставки в TP_Services столбцы, 
		-- кроме TS_Key)
		select distinct
		row_number() over(order by TF_CodeNew asc) AS servicesForInsertRowNumber,
							TS_TOKey, TS_SVKey, TF_CodeNew, TS_SubCode1, TS_SubCode2,
							TS_CNKey, TS_CTKey, TS_Day, TS_Days, TS_Men, TS_Name,
							TF_PRKeyNew, TS_OpPacketKey, TS_ATTRIBUTE, TS_TEMPGROSS,
							TS_CHECKMARGIN, TS_CalculatingKey
						from
							dbo.TP_Flights
							inner join dbo.TP_Services on TF_TOKey = TS_TOKey
														  and TF_SubCode2 = TS_SubCode2
						where
							TF_TOKey = @nPriceTourKey
							and TS_SVKey = 1
							and not exists ( select top 1 1
											 from
												dbo.TP_Services
											 where
												dbo.TP_Services.TS_SVKey = 1
												and dbo.TP_Services.TS_Code = dbo.TP_Flights.TF_CodeNew
												and dbo.TP_Services.TS_OpPartnerKey = dbo.TP_Flights.TF_PRKeyNew )
		)
		insert into dbo.TP_Services
				(TS_Key, TS_TOKey, TS_SVKey, TS_Code, TS_SubCode1, TS_SubCode2,
				 TS_CNKey, TS_CTKey, TS_Day, TS_Days, TS_Men, TS_Name, TS_OpPartnerKey,
				 TS_OpPacketKey, TS_ATTRIBUTE, TS_TEMPGROSS, TS_CHECKMARGIN,
				 TS_CalculatingKey)
		output inserted.TS_Key, inserted.TS_Code, inserted.TS_SubCode1, inserted.TS_SubCode2, inserted.TS_OpPartnerKey, inserted.TS_OpPacketKey, inserted.TS_Day, inserted.TS_Days, inserted.TS_Men, inserted.TS_TEMPGROSS, inserted.TS_CHECKMARGIN, inserted.TS_CTKey, inserted.TS_Attribute into @tpService
		select i,TS_TOKey, TS_SVKey, TF_CodeNew, TS_SubCode1, TS_SubCode2,
							TS_CNKey, TS_CTKey, TS_Day, TS_Days, TS_Men, TS_Name,
							TF_PRKeyNew, TS_OpPacketKey, TS_ATTRIBUTE, TS_TEMPGROSS,
							TS_CHECKMARGIN, TS_CalculatingKey
		-- объединяем две вспомогательные таблицы (TS_Key и все остальные поля) по номеру строки
		from servicesRowNumbers inner join servicesForInsert on [rowNumber] = servicesForInsertRowNumber;
		
		print 'Подбор перелетов 3.2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	end
	
	-- 2.	изменить tf_tskeynew=ts_key в tp_Flights в строках в которых tf_tskeynew = null 
	--		and tf_codeNew != tf_codeOld и есть строки 
	--		с подходящими параметрами в TP_Services (те которые мы добавили в передыдущем пункте)
		
	update dbo.TP_Flights
	set TF_TSKeyNew = TS_Key
	output inserted.TF_TOKey, inserted.TF_CalculatingKey, inserted.TF_Date, inserted.TF_TSKeyOld, inserted.TF_TSKeyNew into @tpFlights
	from
		dbo.TP_Flights
		cross join dbo.TP_Services 	
	where
		TS_TOKey = TF_TOKey
		and TS_Code = TF_CodeNew
		and TS_OpPartnerKey = TF_PRKeyNew
		and TS_SubCode1 = TF_SubCode1
		and TS_SubCode2 = TF_SubCode2
		and TS_CTKey = TF_CTKey
		and TS_SVKey = 1
		and TF_TSKeyNew is null
		and TF_CodeNew != TF_CodeOld
		and TF_TOKey=@nPriceTourKey ;
	
	print 'Подбор перелетов 3.3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	END
	-----если перелет так и не найден, то в поле TF_CodeNew будет NULL
	
	print 'Подбор перелетов 4: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	--------------------------------------- закончили поиск подходящего перелета --------------------------------------
	if (1 = 1)
	BEGIN
		update [dbo].tp_tours with(rowlock) set to_update = 1 where to_key = @nPriceTourKey
		Set @nTotalProgress=4
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	
		--------------------------------------- сохраняем цены во временной таблице --------------------------------------
		CREATE TABLE #TP_Prices
		(
			[xTP_Key] [int] PRIMARY KEY NOT NULL ,
			[xTP_TOKey] [int] NOT NULL ,
			[xTP_DateBegin] [datetime] NOT NULL ,
			[xTP_DateEnd] [datetime] NULL ,
			-- формула расчета общей цены тура
			[xTP_Gross] as (((case when  [xSCPId_1] is not null then  [xGross_1] else 0 end) * (1 + (isnull( [xMarginPercent_1], 0)/100) * (1 + (isnull( [xIsCommission_1], 0) - 1) * isnull( [xCommissionOnly_1], 0))) + isnull( [xAddCostIsCommission_1], 0) * (1 + (isnull( [xMarginPercent_1], 0)/100)) + isnull( [xAddCostNoCommission_1], 0) * (1 + (isnull( [xMarginPercent_1], 0)/100) * (1 - isnull( [xCommissionOnly_1], 0)))) +
							((case when  [xSCPId_2] is not null then  [xGross_2] else 0 end) * (1 + (isnull( [xMarginPercent_2], 0)/100) * (1 + (isnull( [xIsCommission_2], 0) - 1) * isnull( [xCommissionOnly_2], 0))) + isnull( [xAddCostIsCommission_2], 0) * (1 + (isnull( [xMarginPercent_2], 0)/100)) + isnull( [xAddCostNoCommission_2], 0) * (1 + (isnull( [xMarginPercent_2], 0)/100) * (1 - isnull( [xCommissionOnly_2], 0)))) +
							((case when  [xSCPId_3] is not null then  [xGross_3] else 0 end) * (1 + (isnull( [xMarginPercent_3], 0)/100) * (1 + (isnull( [xIsCommission_3], 0) - 1) * isnull( [xCommissionOnly_3], 0))) + isnull( [xAddCostIsCommission_3], 0) * (1 + (isnull( [xMarginPercent_3], 0)/100)) + isnull( [xAddCostNoCommission_3], 0) * (1 + (isnull( [xMarginPercent_3], 0)/100) * (1 - isnull( [xCommissionOnly_3], 0)))) +
							((case when  [xSCPId_4] is not null then  [xGross_4] else 0 end) * (1 + (isnull( [xMarginPercent_4], 0)/100) * (1 + (isnull( [xIsCommission_4], 0) - 1) * isnull( [xCommissionOnly_4], 0))) + isnull( [xAddCostIsCommission_4], 0) * (1 + (isnull( [xMarginPercent_4], 0)/100)) + isnull( [xAddCostNoCommission_4], 0) * (1 + (isnull( [xMarginPercent_4], 0)/100) * (1 - isnull( [xCommissionOnly_4], 0)))) +
							((case when  [xSCPId_5] is not null then  [xGross_5] else 0 end) * (1 + (isnull( [xMarginPercent_5], 0)/100) * (1 + (isnull( [xIsCommission_5], 0) - 1) * isnull( [xCommissionOnly_5], 0))) + isnull( [xAddCostIsCommission_5], 0) * (1 + (isnull( [xMarginPercent_5], 0)/100)) + isnull( [xAddCostNoCommission_5], 0) * (1 + (isnull( [xMarginPercent_5], 0)/100) * (1 - isnull( [xCommissionOnly_5], 0)))) +
							((case when  [xSCPId_6] is not null then  [xGross_6] else 0 end) * (1 + (isnull( [xMarginPercent_6], 0)/100) * (1 + (isnull( [xIsCommission_6], 0) - 1) * isnull( [xCommissionOnly_6], 0))) + isnull( [xAddCostIsCommission_6], 0) * (1 + (isnull( [xMarginPercent_6], 0)/100)) + isnull( [xAddCostNoCommission_6], 0) * (1 + (isnull( [xMarginPercent_6], 0)/100) * (1 - isnull( [xCommissionOnly_6], 0)))) +
							((case when  [xSCPId_7] is not null then  [xGross_7] else 0 end) * (1 + (isnull( [xMarginPercent_7], 0)/100) * (1 + (isnull( [xIsCommission_7], 0) - 1) * isnull( [xCommissionOnly_7], 0))) + isnull( [xAddCostIsCommission_7], 0) * (1 + (isnull( [xMarginPercent_7], 0)/100)) + isnull( [xAddCostNoCommission_7], 0) * (1 + (isnull( [xMarginPercent_7], 0)/100) * (1 - isnull( [xCommissionOnly_7], 0)))) +
							((case when  [xSCPId_8] is not null then  [xGross_8] else 0 end) * (1 + (isnull( [xMarginPercent_8], 0)/100) * (1 + (isnull( [xIsCommission_8], 0) - 1) * isnull( [xCommissionOnly_8], 0))) + isnull( [xAddCostIsCommission_8], 0) * (1 + (isnull( [xMarginPercent_8], 0)/100)) + isnull( [xAddCostNoCommission_8], 0) * (1 + (isnull( [xMarginPercent_8], 0)/100) * (1 - isnull( [xCommissionOnly_8], 0)))) +
							((case when  [xSCPId_9] is not null then  [xGross_9] else 0 end) * (1 + (isnull( [xMarginPercent_9], 0)/100) * (1 + (isnull( [xIsCommission_9], 0) - 1) * isnull( [xCommissionOnly_9], 0))) + isnull( [xAddCostIsCommission_9], 0) * (1 + (isnull( [xMarginPercent_9], 0)/100)) + isnull( [xAddCostNoCommission_9], 0) * (1 + (isnull( [xMarginPercent_9], 0)/100) * (1 - isnull( [xCommissionOnly_9], 0)))) +
							((case when [xSCPId_10] is not null then [xGross_10] else 0 end) * (1 + (isnull([xMarginPercent_10], 0)/100) * (1 + (isnull([xIsCommission_10], 0) - 1) * isnull([xCommissionOnly_10], 0))) + isnull([xAddCostIsCommission_10], 0) * (1 + (isnull([xMarginPercent_10], 0)/100)) + isnull([xAddCostNoCommission_10], 0) * (1 + (isnull([xMarginPercent_10], 0)/100) * (1 - isnull([xCommissionOnly_10], 0)))) +
							((case when [xSCPId_11] is not null then [xGross_11] else 0 end) * (1 + (isnull([xMarginPercent_11], 0)/100) * (1 + (isnull([xIsCommission_11], 0) - 1) * isnull([xCommissionOnly_11], 0))) + isnull([xAddCostIsCommission_11], 0) * (1 + (isnull([xMarginPercent_11], 0)/100)) + isnull([xAddCostNoCommission_11], 0) * (1 + (isnull([xMarginPercent_11], 0)/100) * (1 - isnull([xCommissionOnly_11], 0)))) +
							((case when [xSCPId_12] is not null then [xGross_12] else 0 end) * (1 + (isnull([xMarginPercent_12], 0)/100) * (1 + (isnull([xIsCommission_12], 0) - 1) * isnull([xCommissionOnly_12], 0))) + isnull([xAddCostIsCommission_12], 0) * (1 + (isnull([xMarginPercent_12], 0)/100)) + isnull([xAddCostNoCommission_12], 0) * (1 + (isnull([xMarginPercent_12], 0)/100) * (1 - isnull([xCommissionOnly_12], 0)))) +
							((case when [xSCPId_13] is not null then [xGross_13] else 0 end) * (1 + (isnull([xMarginPercent_13], 0)/100) * (1 + (isnull([xIsCommission_13], 0) - 1) * isnull([xCommissionOnly_13], 0))) + isnull([xAddCostIsCommission_13], 0) * (1 + (isnull([xMarginPercent_13], 0)/100)) + isnull([xAddCostNoCommission_13], 0) * (1 + (isnull([xMarginPercent_13], 0)/100) * (1 - isnull([xCommissionOnly_13], 0)))) +
							((case when [xSCPId_14] is not null then [xGross_14] else 0 end) * (1 + (isnull([xMarginPercent_14], 0)/100) * (1 + (isnull([xIsCommission_14], 0) - 1) * isnull([xCommissionOnly_14], 0))) + isnull([xAddCostIsCommission_14], 0) * (1 + (isnull([xMarginPercent_14], 0)/100)) + isnull([xAddCostNoCommission_14], 0) * (1 + (isnull([xMarginPercent_14], 0)/100) * (1 - isnull([xCommissionOnly_14], 0)))) +
							((case when [xSCPId_15] is not null then [xGross_15] else 0 end) * (1 + (isnull([xMarginPercent_15], 0)/100) * (1 + (isnull([xIsCommission_15], 0) - 1) * isnull([xCommissionOnly_15], 0))) + isnull([xAddCostIsCommission_15], 0) * (1 + (isnull([xMarginPercent_15], 0)/100)) + isnull([xAddCostNoCommission_15], 0) * (1 + (isnull([xMarginPercent_15], 0)/100) * (1 - isnull([xCommissionOnly_15], 0))))),
			[xTP_TIKey] [int] NOT NULL,
			[xTP_HotelKey] [int] NOT NULL,
			[xTP_DepartureKey] [int] NOT NULL,
			[xTP_CalculatingKey] [int] NULL,
			[xTP_Days] [int] null,
			[xTP_Rate] [nvarchar](2) null,
			[xSCPId_1] [int] null,
			[xSCPId_2] [int] null,
			[xSCPId_3] [int] null,
			[xSCPId_4] [int] null,
			[xSCPId_5] [int] null,
			[xSCPId_6] [int] null,
			[xSCPId_7] [int] null,
			[xSCPId_8] [int] null,
			[xSCPId_9] [int] null,
			[xSCPId_10] [int] null,
			[xSCPId_11] [int] null,
			[xSCPId_12] [int] null,
			[xSCPId_13] [int] null,
			[xSCPId_14] [int] null,
			[xSCPId_15] [int] null,
			
			[xSvKey_1] [int] null,
			[xSvKey_2] [int] null,
			[xSvKey_3] [int] null,
			[xSvKey_4] [int] null,
			[xSvKey_5] [int] null,
			[xSvKey_6] [int] null,
			[xSvKey_7] [int] null,
			[xSvKey_8] [int] null,
			[xSvKey_9] [int] null,
			[xSvKey_10] [int] null,
			[xSvKey_11] [int] null,
			[xSvKey_12] [int] null,
			[xSvKey_13] [int] null,
			[xSvKey_14] [int] null,
			[xSvKey_15] [int] null,
			
			[xGross_1] [money] null,
			[xGross_2] [money] null,
			[xGross_3] [money] null,
			[xGross_4] [money] null,
			[xGross_5] [money] null,
			[xGross_6] [money] null,
			[xGross_7] [money] null,
			[xGross_8] [money] null,
			[xGross_9] [money] null,
			[xGross_10] [money] null,
			[xGross_11] [money] null,
			[xGross_12] [money] null,
			[xGross_13] [money] null,
			[xGross_14] [money] null,
			[xGross_15] [money] null,
			
			[xAddCostIsCommission_1] [money] null,
			[xAddCostIsCommission_2] [money] null,
			[xAddCostIsCommission_3] [money] null,
			[xAddCostIsCommission_4] [money] null,
			[xAddCostIsCommission_5] [money] null,
			[xAddCostIsCommission_6] [money] null,
			[xAddCostIsCommission_7] [money] null,
			[xAddCostIsCommission_8] [money] null,
			[xAddCostIsCommission_9] [money] null,
			[xAddCostIsCommission_10] [money] null,
			[xAddCostIsCommission_11] [money] null,
			[xAddCostIsCommission_12] [money] null,
			[xAddCostIsCommission_13] [money] null,
			[xAddCostIsCommission_14] [money] null,
			[xAddCostIsCommission_15] [money] null,
			
			[xAddCostNoCommission_1] [money] null,
			[xAddCostNoCommission_2] [money] null,
			[xAddCostNoCommission_3] [money] null,
			[xAddCostNoCommission_4] [money] null,
			[xAddCostNoCommission_5] [money] null,
			[xAddCostNoCommission_6] [money] null,
			[xAddCostNoCommission_7] [money] null,
			[xAddCostNoCommission_8] [money] null,
			[xAddCostNoCommission_9] [money] null,
			[xAddCostNoCommission_10] [money] null,
			[xAddCostNoCommission_11] [money] null,
			[xAddCostNoCommission_12] [money] null,
			[xAddCostNoCommission_13] [money] null,
			[xAddCostNoCommission_14] [money] null,
			[xAddCostNoCommission_15] [money] null,
			
			[xMarginPercent_1] [money] null,
			[xMarginPercent_2] [money] null,
			[xMarginPercent_3] [money] null,
			[xMarginPercent_4] [money] null,
			[xMarginPercent_5] [money] null,
			[xMarginPercent_6] [money] null,
			[xMarginPercent_7] [money] null,
			[xMarginPercent_8] [money] null,
			[xMarginPercent_9] [money] null,
			[xMarginPercent_10] [money] null,
			[xMarginPercent_11] [money] null,
			[xMarginPercent_12] [money] null,
			[xMarginPercent_13] [money] null,
			[xMarginPercent_14] [money] null,
			[xMarginPercent_15] [money] null,
			
			[xCommissionOnly_1] [bit] null,
			[xCommissionOnly_2] [bit] null,
			[xCommissionOnly_3] [bit] null,
			[xCommissionOnly_4] [bit] null,
			[xCommissionOnly_5] [bit] null,
			[xCommissionOnly_6] [bit] null,
			[xCommissionOnly_7] [bit] null,
			[xCommissionOnly_8] [bit] null,
			[xCommissionOnly_9] [bit] null,
			[xCommissionOnly_10] [bit] null,
			[xCommissionOnly_11] [bit] null,
			[xCommissionOnly_12] [bit] null,
			[xCommissionOnly_13] [bit] null,
			[xCommissionOnly_14] [bit] null,
			[xCommissionOnly_15] [bit] null,
			
			[xIsCommission_1] [bit] null,
			[xIsCommission_2] [bit] null,
			[xIsCommission_3] [bit] null,
			[xIsCommission_4] [bit] null,
			[xIsCommission_5] [bit] null,
			[xIsCommission_6] [bit] null,
			[xIsCommission_7] [bit] null,
			[xIsCommission_8] [bit] null,
			[xIsCommission_9] [bit] null,
			[xIsCommission_10] [bit] null,
			[xIsCommission_11] [bit] null,
			[xIsCommission_12] [bit] null,
			[xIsCommission_13] [bit] null,
			[xIsCommission_14] [bit] null,
			[xIsCommission_15] [bit] null
		)

		CREATE NONCLUSTERED INDEX [x_fields] ON [#TP_Prices] 
		(
			[xTP_TOKey] ASC,
			[xTP_TIKey] ASC,
			[xTP_DateBegin] ASC,
			[xTP_DateEnd] ASC
		)

		DELETE FROM #TP_Prices
		---------------------------------------КОНЕЦ  сохраняем цены во временной таблице --------------------------------------
		

		---------------------------------------разбиваем данные в таблицах tp_prices по датам
		if (select COUNT(TP_Key) from TP_Prices with(nolock) where TP_DateBegin != TP_DateEnd and TP_TOKey = @nPriceTourKey) > 0
		begin
			
			select @numDates = COUNT(1) from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			exec GetNKeys 'TP_PRICES', @numDates, @nTP_PriceKeyMax output
			set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @numDates + 1
		
			declare datesCursor cursor local fast_forward for
			select TD_Date, TI_Key, TP_Gross from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			
			open datesCursor
			fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			while @@FETCH_STATUS = 0
			begin
				insert into #TP_Prices (xTP_Key, xTP_TOKey, xTP_TIKey, xTP_DateBegin, xTP_DateEnd, xTP_CalculatingKey) 
				values (@nTP_PriceKeyCurrent, @nPriceTourKey, @priceListKey, @priceDate, @priceDate, @nCalculatingKey)
				set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
				fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			end
			
			close datesCursor
			deallocate datesCursor
			
			begin tran tEnd
				delete from TP_Prices with(rowlock) where TP_TOKey = @nPriceTourKey
				
				insert into TP_Prices (TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, TP_CalculatingKey)
				select xTP_Key, xTP_TOKey, xTP_TIKey, xTP_Gross, xTP_DateBegin, xTP_DateEnd, @nCalculatingKey
				from #TP_Prices  
				where xTP_DateBegin = xTP_DateEnd
				
				delete from #TP_Prices
			commit tran tEnd
		end
		--------------------------------------------------------------------------------------
		
		select @TrKey = to_trkey, @nPriceFor = to_pricefor from tp_tours with(nolock) where to_key = @nPriceTourKey

		--смотрим сколько записей по текущему прайсу уже посчитано
		Set @NumCalculated = (SELECT COUNT(1) FROM tp_prices with(nolock) where tp_tokey = @nPriceTourKey)
		--считаем сколько записей надо посчитать
		set @NumPrices = (	(select count(1) from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) * 
							(select count(1) from tp_turdates with(nolock) where td_tokey = @nPriceTourKey and td_update = @nUpdate));

		if (@NumCalculated + @NumPrices) = 0
			set @NumPrices = 1

		--Set @nTotalProgress=@nTotalProgress + (CAST(@NumCalculated as money)/CAST((@NumCalculated+@NumPrices) as money) * (90-@nTotalProgress))
		set @nTotalProgress = @nTotalProgress + CAST(@NumCalculated as money) / CAST((@NumCalculated + @NumPrices) as money)
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey

		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN
		update tp_services with(rowlock) set ts_checkmargin = 1 where
		(ts_svkey in (select tm_svkey FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)
		or
		exists(select 1 FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
			and tm_svkey = 0)
		)and ts_tokey = @nPriceTourKey

		update [dbo].tp_turdates with(rowlock) set td_checkmargin = 1 where
			exists(select 1 from TurMargin with(nolock) WHERE TM_TlKey = @TrKey
			and TD_DATE Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)and td_tokey = @nPriceTourKey
		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN
		
		print 'Инициализация расчета цен: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
		
		declare @tempTO_Rate nvarchar(3), @tempTO_TRKey int
		
		select @tempTO_Rate = TO_Rate, @tempTO_TRKey = TO_TRKey from tp_tours with(nolock) where TO_Key = @nPriceTourKey

		declare serviceCursor cursor local fast_forward for
			select ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, @tempTO_Rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_days, ts_ctkey, ts_attribute, (select TL_CTDepartureKey from tbl_TurList with(nolock) where @tempTO_TRKey = TL_KEY), SV_IsDuration
			from tp_services with(nolock), tp_lists with(nolock), tp_servicelists with(nolock), tp_turdates with(nolock), [Service]
			where @nPriceTourKey = ts_tokey and @nPriceTourKey = ti_tokey and @nPriceTourKey = tl_tokey and ts_key = tl_tskey and ti_key = tl_tikey and @nPriceTourKey = td_tokey
				and ti_update = @nUpdate and td_update = @nUpdate and (@nUseHolidayRule = 0 or (case cast(datepart(weekday, td_date) as int) when 7 then 0 else cast(datepart(weekday, td_date) as int) end + ti_days) >= 8)
				and ts_svkey = SV_KEY
			order by ti_firsthdkey, td_date, ti_key, case when ti_firsthdkey = ts_code and TS_SVKey = 3 then 0 else 1 end

		open serviceCursor
		
		SELECT @round = ST_RoundService FROM Setting
		--MEG00036108 увеличил значение
		set @nProgressSkipLimit = 100

		set @nProgressSkipCounter = 0
		
		if @NumPrices <> 0
			set @nDeltaProgress = (95.0-@nTotalProgress) / @NumPrices
		else
			set @nDeltaProgress = 95.0-@nTotalProgress

		exec GetNKeys 'TP_PRICES', @NumPrices, @nTP_PriceKeyMax output
		set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
		set @dtPrevDate = '1899-12-31'
		set @nPrevVariant = -1
		set @nPrevGross = -1
		set @nPrevGrossDate = '1899-12-31'
		set @prevHdKey = -1

		delete from #TP_Prices
		declare @calcPricesCount int, @calcPriceListCount int, @calcTurDates int, @oldPriceKeyCurrent int
		
		declare @IsDuration smallint
		declare @tiCtKeyFrom int, @tiDays int
		declare @tsKey_1 int, @tsKey_2 int, @tsKey_3 int, @tsKey_4 int, @tsKey_5 int, @tsKey_6 int, @tsKey_7 int, @tsKey_8 int, @tsKey_9 int, @tsKey_10 int, @tsKey_11 int, @tsKey_12 int, @tsKey_13 int, @tsKey_14 int, @tsKey_15 int
		declare @tsSVKey_1 int, @tsSVKey_2 int, @tsSVKey_3 int, @tsSVKey_4 int, @tsSVKey_5 int, @tsSVKey_6 int, @tsSVKey_7 int, @tsSVKey_8 int, @tsSVKey_9 int, @tsSVKey_10 int, @tsSVKey_11 int, @tsSVKey_12 int, @tsSVKey_13 int, @tsSVKey_14 int, @tsSVKey_15 int
		declare @tsGross_1 money, @tsGross_2 money, @tsGross_3 money, @tsGross_4 money, @tsGross_5 money, @tsGross_6 money, @tsGross_7 money, @tsGross_8 money, @tsGross_9 money, @tsGross_10 money, @tsGross_11 money, @tsGross_12 money, @tsGross_13 money, @tsGross_14 money, @tsGross_15 money
		declare @tsAddIsCommission_1 money, @tsAddIsCommission_2 money, @tsAddIsCommission_3 money, @tsAddIsCommission_4 money, @tsAddIsCommission_5 money, @tsAddIsCommission_6 money, @tsAddIsCommission_7 money, @tsAddIsCommission_8 money, @tsAddIsCommission_9 money, @tsAddIsCommission_10 money, @tsAddIsCommission_11 money, @tsAddIsCommission_12 money, @tsAddIsCommission_13 money, @tsAddIsCommission_14 money, @tsAddIsCommission_15 money
		declare @tsAddNoCommission_1 money, @tsAddNoCommission_2 money, @tsAddNoCommission_3 money, @tsAddNoCommission_4 money, @tsAddNoCommission_5 money, @tsAddNoCommission_6 money, @tsAddNoCommission_7 money, @tsAddNoCommission_8 money, @tsAddNoCommission_9 money, @tsAddNoCommission_10 money, @tsAddNoCommission_11 money, @tsAddNoCommission_12 money, @tsAddNoCommission_13 money, @tsAddNoCommission_14 money, @tsAddNoCommission_15 money
		declare @tsMarginPercent_1 money, @tsMarginPercent_2 money, @tsMarginPercent_3 money, @tsMarginPercent_4 money, @tsMarginPercent_5 money, @tsMarginPercent_6 money, @tsMarginPercent_7 money, @tsMarginPercent_8 money, @tsMarginPercent_9 money, @tsMarginPercent_10 money, @tsMarginPercent_11 money, @tsMarginPercent_12 money, @tsMarginPercent_13 money, @tsMarginPercent_14 money, @tsMarginPercent_15 money
		declare @tsCommissionOnly_1 money, @tsCommissionOnly_2 money, @tsCommissionOnly_3 money, @tsCommissionOnly_4 money, @tsCommissionOnly_5 money, @tsCommissionOnly_6 money, @tsCommissionOnly_7 money, @tsCommissionOnly_8 money, @tsCommissionOnly_9 money, @tsCommissionOnly_10 money, @tsCommissionOnly_11 money, @tsCommissionOnly_12 money, @tsCommissionOnly_13 money, @tsCommissionOnly_14 money, @tsCommissionOnly_15 money
		declare @tsIsCommission_1 bit, @tsIsCommission_2 bit, @tsIsCommission_3 bit, @tsIsCommission_4 bit, @tsIsCommission_5 bit, @tsIsCommission_6 bit, @tsIsCommission_7 bit, @tsIsCommission_8 bit, @tsIsCommission_9 bit, @tsIsCommission_10 bit, @tsIsCommission_11 bit, @tsIsCommission_12 bit, @tsIsCommission_13 bit, @tsIsCommission_14 bit, @tsIsCommission_15 bit
		
		select @calcPriceListCount = COUNT(1) from TP_Lists with(nolock) where TI_TOKey = @nPriceTourKey and TI_UPDATE = @nUpdate
		select @calcTurDates = COUNT(1) from TP_TurDates with(nolock) where TD_TOKey = @nPriceTourKey and TD_UPDATE = @nUpdate
		select @calcPricesCount = @calcPriceListCount * @calcTurDates

		fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE, @tiCtKeyFrom, @IsDuration
		
		set @fetchStatus = @@fetch_status		
		print 'Расчет цен 0: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
		While (@fetchStatus = 0)
		BEGIN
			--данных не нашлось, выходим
			if @@fetch_status <> 0 and @nPrevVariant = -1
				break
				
			--очищаем переменные, записываем данные в таблицу #TP_Prices
			if @nPrevVariant <> @variant or @dtPrevDate <> @turdate or @@fetch_status <> 0
			BEGIN				
				--записываем данные в таблицу #TP_Prices
				if @nPrevVariant <> -1
				begin
					if exists(select 1 from #TP_Prices where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant)
					begin
						--select @nCalculatingKey
						update #TP_Prices set xtp_calculatingkey = @nCalculatingKey, xtp_key = @nTP_PriceKeyCurrent where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant and xtp_gross <> @price_brutto
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
						
					end
					else if (@isPriceListPluginRecalculation = 0)
					begin
						--select @nCalculatingKey
						insert into #TP_Prices (xtp_key, xtp_tokey, xtp_datebegin, xtp_dateend, xtp_tikey, xTP_CalculatingKey, xTP_Days, xTP_Rate, xTP_HotelKey, xTP_DepartureKey
						, xSCPId_1, xSCPId_2, xSCPId_3, xSCPId_4, xSCPId_5, xSCPId_6, xSCPId_7, xSCPId_8, xSCPId_9, xSCPId_10, xSCPId_11, xSCPId_12, xSCPId_13, xSCPId_14, xSCPId_15
						, xSvKey_1, xSvKey_2, xSvKey_3, xSvKey_4, xSvKey_5, xSvKey_6, xSvKey_7, xSvKey_8, xSvKey_9, xSvKey_10, xSvKey_11, xSvKey_12, xSvKey_13, xSvKey_14, xSvKey_15
						, xGross_1, xGross_2, xGross_3, xGross_4, xGross_5, xGross_6, xGross_7, xGross_8, xGross_9, xGross_10, xGross_11, xGross_12, xGross_13, xGross_14, xGross_15
						, xAddCostIsCommission_1, xAddCostIsCommission_2, xAddCostIsCommission_3, xAddCostIsCommission_4, xAddCostIsCommission_5, xAddCostIsCommission_6, xAddCostIsCommission_7, xAddCostIsCommission_8, xAddCostIsCommission_9, xAddCostIsCommission_10, xAddCostIsCommission_11, xAddCostIsCommission_12, xAddCostIsCommission_13, xAddCostIsCommission_14, xAddCostIsCommission_15
						, xAddCostNoCommission_1, xAddCostNoCommission_2, xAddCostNoCommission_3, xAddCostNoCommission_4, xAddCostNoCommission_5, xAddCostNoCommission_6, xAddCostNoCommission_7, xAddCostNoCommission_8, xAddCostNoCommission_9, xAddCostNoCommission_10, xAddCostNoCommission_11, xAddCostNoCommission_12, xAddCostNoCommission_13, xAddCostNoCommission_14, xAddCostNoCommission_15
						, xMarginPercent_1, xMarginPercent_2, xMarginPercent_3, xMarginPercent_4, xMarginPercent_5, xMarginPercent_6, xMarginPercent_7, xMarginPercent_8, xMarginPercent_9, xMarginPercent_10, xMarginPercent_11, xMarginPercent_12, xMarginPercent_13, xMarginPercent_14, xMarginPercent_15
						, xCommissionOnly_1, xCommissionOnly_2, xCommissionOnly_3, xCommissionOnly_4, xCommissionOnly_5, xCommissionOnly_6, xCommissionOnly_7, xCommissionOnly_8, xCommissionOnly_9, xCommissionOnly_10, xCommissionOnly_11, xCommissionOnly_12, xCommissionOnly_13, xCommissionOnly_14, xCommissionOnly_15
						, xIsCommission_1, xIsCommission_2, xIsCommission_3, xIsCommission_4, xIsCommission_5, xIsCommission_6, xIsCommission_7, xIsCommission_8, xIsCommission_9, xIsCommission_10, xIsCommission_11, xIsCommission_12, xIsCommission_13, xIsCommission_14, xIsCommission_15)
						values (@nTP_PriceKeyCurrent, @nPriceTourKey, @dtPrevDate, @dtPrevDate, @nPrevVariant, @nCalculatingKey, @tiDays, @sRate, @hdKey, @tiCtKeyFrom
						, @tsKey_1, @tsKey_2, @tsKey_3, @tsKey_4, @tsKey_5, @tsKey_6, @tsKey_7, @tsKey_8, @tsKey_9, @tsKey_10, @tsKey_11, @tsKey_12, @tsKey_13, @tsKey_14, @tsKey_15
						, @tsSVKey_1, @tsSVKey_2, @tsSVKey_3, @tsSVKey_4, @tsSVKey_5, @tsSVKey_6, @tsSVKey_7, @tsSVKey_8, @tsSVKey_9, @tsSVKey_10, @tsSVKey_11, @tsSVKey_12, @tsSVKey_13, @tsSVKey_14, @tsSVKey_15
						, @tsGross_1, @tsGross_2, @tsGross_3, @tsGross_4, @tsGross_5, @tsGross_6, @tsGross_7, @tsGross_8, @tsGross_9, @tsGross_10, @tsGross_11, @tsGross_12, @tsGross_13, @tsGross_14, @tsGross_15
						, @tsAddIsCommission_1, @tsAddIsCommission_2, @tsAddIsCommission_3, @tsAddIsCommission_4, @tsAddIsCommission_5, @tsAddIsCommission_6, @tsAddIsCommission_7, @tsAddIsCommission_8, @tsAddIsCommission_9, @tsAddIsCommission_10, @tsAddIsCommission_11, @tsAddIsCommission_12, @tsAddIsCommission_13, @tsAddIsCommission_14, @tsAddIsCommission_15
						, @tsAddNoCommission_1, @tsAddNoCommission_2, @tsAddNoCommission_3, @tsAddNoCommission_4, @tsAddNoCommission_5, @tsAddNoCommission_6, @tsAddNoCommission_7, @tsAddNoCommission_8, @tsAddNoCommission_9, @tsAddNoCommission_10, @tsAddNoCommission_11, @tsAddNoCommission_12, @tsAddNoCommission_13, @tsAddNoCommission_14, @tsAddNoCommission_15
						, @tsMarginPercent_1, @tsMarginPercent_2, @tsMarginPercent_3, @tsMarginPercent_4, @tsMarginPercent_5, @tsMarginPercent_6, @tsMarginPercent_7, @tsMarginPercent_8, @tsMarginPercent_9, @tsMarginPercent_10, @tsMarginPercent_11, @tsMarginPercent_12, @tsMarginPercent_13, @tsMarginPercent_14, @tsMarginPercent_15
						, @tsCommissionOnly_1, @tsCommissionOnly_2, @tsCommissionOnly_3, @tsCommissionOnly_4, @tsCommissionOnly_5, @tsCommissionOnly_6, @tsCommissionOnly_7, @tsCommissionOnly_8, @tsCommissionOnly_9, @tsCommissionOnly_10, @tsCommissionOnly_11, @tsCommissionOnly_12, @tsCommissionOnly_13, @tsCommissionOnly_14, @tsCommissionOnly_15
						, @tsIsCommission_1, @tsIsCommission_2, @tsIsCommission_3, @tsIsCommission_4, @tsIsCommission_5, @tsIsCommission_6, @tsIsCommission_7, @tsIsCommission_8, @tsIsCommission_9, @tsIsCommission_10, @tsIsCommission_11, @tsIsCommission_12, @tsIsCommission_13, @tsIsCommission_14, @tsIsCommission_15)
												
						set @tiDays = null
						
						set @tsKey_1 = null
						set @tsKey_2 = null
						set @tsKey_3 = null
						set @tsKey_4 = null
						set @tsKey_5 = null
						set @tsKey_6 = null
						set @tsKey_7 = null
						set @tsKey_8 = null
						set @tsKey_9 = null
						set @tsKey_10 = null
						set @tsKey_11 = null
						set @tsKey_12 = null
						set @tsKey_13 = null
						set @tsKey_14 = null
						set @tsKey_15 = null
						
						set @tsSVKey_1 = null
						set @tsSVKey_2 = null
						set @tsSVKey_3 = null
						set @tsSVKey_4 = null
						set @tsSVKey_5 = null
						set @tsSVKey_6 = null
						set @tsSVKey_7 = null
						set @tsSVKey_8 = null
						set @tsSVKey_9 = null
						set @tsSVKey_10 = null
						set @tsSVKey_11 = null
						set @tsSVKey_12 = null
						set @tsSVKey_13 = null
						set @tsSVKey_14 = null
						set @tsSVKey_15 = null
						
						set @tsGross_1 = null
						set @tsGross_2 = null
						set @tsGross_3 = null
						set @tsGross_4 = null
						set @tsGross_5 = null
						set @tsGross_6 = null
						set @tsGross_7 = null
						set @tsGross_8 = null
						set @tsGross_9 = null
						set @tsGross_10 = null
						set @tsGross_11 = null
						set @tsGross_12 = null
						set @tsGross_13 = null
						set @tsGross_14 = null
						set @tsGross_15 = null
						
						set @tsAddIsCommission_1 = null
						set @tsAddIsCommission_2 = null
						set @tsAddIsCommission_3 = null
						set @tsAddIsCommission_4 = null
						set @tsAddIsCommission_5 = null
						set @tsAddIsCommission_6 = null
						set @tsAddIsCommission_7 = null
						set @tsAddIsCommission_8 = null
						set @tsAddIsCommission_9 = null
						set @tsAddIsCommission_10 = null
						set @tsAddIsCommission_11 = null
						set @tsAddIsCommission_12 = null
						set @tsAddIsCommission_13 = null
						set @tsAddIsCommission_14 = null
						set @tsAddIsCommission_15 = null
						
						set @tsAddNoCommission_1 = null
						set @tsAddNoCommission_2 = null
						set @tsAddNoCommission_3 = null
						set @tsAddNoCommission_4 = null
						set @tsAddNoCommission_5 = null
						set @tsAddNoCommission_6 = null
						set @tsAddNoCommission_7 = null
						set @tsAddNoCommission_8 = null
						set @tsAddNoCommission_9 = null
						set @tsAddNoCommission_10 = null
						set @tsAddNoCommission_11 = null
						set @tsAddNoCommission_12 = null
						set @tsAddNoCommission_13 = null
						set @tsAddNoCommission_14 = null
						set @tsAddNoCommission_15 = null
						
						set @tsMarginPercent_1 = null
						set @tsMarginPercent_2 = null
						set @tsMarginPercent_3 = null
						set @tsMarginPercent_4 = null
						set @tsMarginPercent_5 = null
						set @tsMarginPercent_6 = null
						set @tsMarginPercent_7 = null
						set @tsMarginPercent_8 = null
						set @tsMarginPercent_9 = null
						set @tsMarginPercent_10 = null
						set @tsMarginPercent_11 = null
						set @tsMarginPercent_12 = null
						set @tsMarginPercent_13 = null
						set @tsMarginPercent_14 = null
						set @tsMarginPercent_15 = null
						
						set @tsCommissionOnly_1 = null
						set @tsCommissionOnly_2 = null
						set @tsCommissionOnly_3 = null
						set @tsCommissionOnly_4 = null
						set @tsCommissionOnly_5 = null
						set @tsCommissionOnly_6 = null
						set @tsCommissionOnly_7 = null
						set @tsCommissionOnly_8 = null
						set @tsCommissionOnly_9 = null
						set @tsCommissionOnly_10 = null
						set @tsCommissionOnly_11 = null
						set @tsCommissionOnly_12 = null
						set @tsCommissionOnly_13 = null
						set @tsCommissionOnly_14 = null
						set @tsCommissionOnly_15 = null
						
						set @tsIsCommission_1 = null
						set @tsIsCommission_2 = null
						set @tsIsCommission_3 = null
						set @tsIsCommission_4 = null
						set @tsIsCommission_5 = null
						set @tsIsCommission_6 = null
						set @tsIsCommission_7 = null
						set @tsIsCommission_8 = null
						set @tsIsCommission_9 = null
						set @tsIsCommission_10 = null
						set @tsIsCommission_11 = null
						set @tsIsCommission_12 = null
						set @tsIsCommission_13 = null
						set @tsIsCommission_14 = null
						set @tsIsCommission_15 = null
						
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
					end
				end
				
				--очищаем данные
				if @@fetch_status = 0
				begin
					if @nTP_PriceKeyCurrent > @nTP_PriceKeyMax
					BEGIN
						exec GetNKeys 'TP_PRICES', @NumPrices, @nTP_PriceKeyMax output
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
					END
					
					set @price_brutto = 0
					set @nPrevVariant = @variant
					set @dtPrevDate = @turdate
				end
				
				set @nTotalProgress = @nTotalProgress + @nDeltaProgress
				if @nProgressSkipCounter = @nProgressSkipLimit
				BEGIN
					update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_updatetime = GetDate() where to_key = @nPriceTourKey
					set @nProgressSkipCounter = 0
				END
				else
					set @nProgressSkipCounter = @nProgressSkipCounter + 1
			END

			--переписываем данные в таблицу tp_prices
			if @hdKey <> @prevHdKey or @@fetch_status <> 0
			begin
				set @prevHdKey = @hdKey
			end
			
				if @@fetch_status <> 0
					break	
										
				declare @margin float, @marginType int, @addCostValueIsCommission money, @addCostValueNoCommission money
				declare @scId int -- ключ найденой записи в таблице TP_ServiceComponents
				declare @scpId int -- ключ найденой записи в таблице TP_ServiceCalculateParametrs
				declare @spadId  int -- ключ найденой записи в тиблице TP_ServiePriceActualDate
				
				-- gorshkov поднял дату сюда т.к. она нужна при замене дефолтного перелета на подобранный
				set @servicedate = dateAdd(dd, @nDay-1, @turdate)
				
				-- gorshkov проверка на то что данную услугу вообще нужно расчитывать
				if @TS_ATTRIBUTE & @SERV_NOTCALCULATE = @SERV_NOTCALCULATE
				begin
					set @nNetto = 0
					set @nBrutto = 0
					set @nDiscount = 0
					set @nPDID = 0
					
				end
				else
				begin
					-- gorshkov здесь нужно проверить, что если это перелет, 
					-- то для него мы подменим параметры из TP_Services соответсвующие TF_TSKeyNew
					-- если перелет не дефолтный, т.е. TF_TSKeyNew != TF_TSKeyOld
					if (@nSvkey=1)
					begin
						select 
							@nServiceKey=xsKey,
							@nCode=xsCode,
							@nSubCode1=xsSubCode1,
							@nSubCode2=xsSubCode2,
							@nPrKey=xsOpPartnerKey,
							@nPacketKey=xsOpPacketKey,
							@nDay=xsDay,
							@nDays=xsDays,
							@nMen=xsMen,
							@nTempGross=xsTEMPGROSS,
							@tsCheckMargin=xsCHECKMARGIN,
							@TS_CTKey=xsCTKey,
							@TS_ATTRIBUTE=xsATTRIBUTE
						from @tpFlights join @tpService on xfTSKeyNew = xsKey
						where	xfTOKey = @nPriceTourKey
							and xfCalculatingKey = @nCalculatingKey
							and xfDate = @servicedate
							and xfTSKeyOld = @nServiceKey 
							and xfTSKeyNew != @nServiceKey;
					end
					
					set @tiDays = @TI_DAYS
					
					/*создадим структуру таблиц если ее нету*/
					exec ReCalculate_CreateServiceCalculateParametrs @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nDay, @turdate, @nMen, @nDays, @nPacketkey, @tiDays, @scId output, @scpId output
										
					declare @gross money, @addCostIsCommission money, @addCostNoCommission money, @addCostFromAdult money, @addCostFromChild money, @marginPercent money, @CommissionOnly bit, @isCommission bit, @tourRate varchar(2)
					
					/*Производим расчет стоимости услуги*/
					exec ReCalculateCosts_CalculatePriceList @scpId, @nBrutto output, @isCommission output, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @servicedate, @nDays, @sRate, @nMen, 0, @nMargin, @nMarginType, null, @nNetto, @nDiscount, @sDetailed, @sBadRate, @dtBadDate, @sDetailed, @nSPId, @TrKey, @turdate, @TI_DAYS, @IsDuration
					
					-- проверям считать ли null цены = 0					
					if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey not in (1,3)
						set @nBrutto = 0
					if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey = 1 and @nNoFlight = 0
						set @nBrutto = 0
						
					set @gross = @nBrutto
					
					/*Производим расчет наценки*/
					-- промежуточная хранимка для работы с кэшем (TP_TourMarginActualDate)
					exec ReCalculateMargins_CalculatePriceList @TrKey, @nPriceTourKey, @turdate, @margin output, @marginType output, @nSvkey, @TI_DAYS, @dtSaleDate, @nPacketkey
					set @marginPercent = @margin
					set @CommissionOnly = @marginType
					
					/*Производим расчет доплаты*/
					exec GetServiceAddCosts @TrKey, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @turdate, @TI_DAYS, @nDays, @nMen, null, null, @addCostValueIsCommission output, @addCostValueNoCommission output, @addCostFromAdult output, @addCostFromChild output, @tourRate output
					set @addCostIsCommission = @addCostValueIsCommission
					set @addCostNoCommission = @addCostValueNoCommission
				
					-- запишем ключи TS_Key в таблицу (получим список услуг из которых состоит TP_Prices)
					if (@tsKey_1 is null)
					begin
						set @tsKey_1 = @scpId
						set @tsSVKey_1 = @nSvkey
						set @tsGross_1 = @gross
						set @tsAddIsCommission_1 = @addCostIsCommission
						set @tsAddNoCommission_1 = @addCostNoCommission
						set @tsMarginPercent_1 = @marginPercent
						set @tsCommissionOnly_1 = @CommissionOnly
						set @tsIsCommission_1 = @isCommission
					end
					else if (@tsKey_2 is null)
					begin
						set @tsKey_2 = @scpId
						set @tsSVKey_2 = @nSvkey
						set @tsGross_2 = @gross
						set @tsAddIsCommission_2 = @addCostIsCommission
						set @tsAddNoCommission_2 = @addCostNoCommission
						set @tsMarginPercent_2 = @marginPercent
						set @tsCommissionOnly_2 = @CommissionOnly
						set @tsIsCommission_2 = @isCommission
					end
					else if (@tsKey_3 is null)
					begin
						set @tsKey_3 = @scpId
						set @tsSVKey_3 = @nSvkey
						set @tsGross_3 = @gross
						set @tsAddIsCommission_3 = @addCostIsCommission
						set @tsAddNoCommission_3 = @addCostNoCommission
						set @tsMarginPercent_3 = @marginPercent
						set @tsCommissionOnly_3 = @CommissionOnly
						set @tsIsCommission_3 = @isCommission
					end
					else if (@tsKey_4 is null)
					begin
						set @tsKey_4 = @scpId
						set @tsSVKey_4 = @nSvkey
						set @tsGross_4 = @gross
						set @tsAddIsCommission_4 = @addCostIsCommission
						set @tsAddNoCommission_4 = @addCostNoCommission
						set @tsMarginPercent_4 = @marginPercent
						set @tsCommissionOnly_4 = @CommissionOnly
						set @tsIsCommission_4 = @isCommission
					end
					else if (@tsKey_5 is null)
					begin
						set @tsKey_5 = @scpId
						set @tsSVKey_5 = @nSvkey
						set @tsGross_5 = @gross
						set @tsAddIsCommission_5 = @addCostIsCommission
						set @tsAddNoCommission_5 = @addCostNoCommission
						set @tsMarginPercent_5 = @marginPercent
						set @tsCommissionOnly_5 = @CommissionOnly
						set @tsIsCommission_5 = @isCommission
					end
					else if (@tsKey_6 is null)
					begin
						set @tsKey_6 = @scpId
						set @tsSVKey_6 = @nSvkey
						set @tsGross_6 = @gross
						set @tsAddIsCommission_6 = @addCostIsCommission
						set @tsAddNoCommission_6 = @addCostNoCommission
						set @tsMarginPercent_6 = @marginPercent
						set @tsCommissionOnly_6 = @CommissionOnly
						set @tsIsCommission_6 = @isCommission
					end
					else if (@tsKey_7 is null)
					begin
						set @tsKey_7 = @scpId
						set @tsSVKey_7 = @nSvkey
						set @tsGross_7 = @gross
						set @tsAddIsCommission_7 = @addCostIsCommission
						set @tsAddNoCommission_7 = @addCostNoCommission
						set @tsMarginPercent_7 = @marginPercent
						set @tsCommissionOnly_7 = @CommissionOnly
						set @tsIsCommission_7 = @isCommission
					end
					else if (@tsKey_8 is null)
					begin
						set @tsKey_8 = @scpId
						set @tsSVKey_8 = @nSvkey
						set @tsGross_8 = @gross
						set @tsAddIsCommission_8 = @addCostIsCommission
						set @tsAddNoCommission_8 = @addCostNoCommission
						set @tsMarginPercent_8 = @marginPercent
						set @tsCommissionOnly_8 = @CommissionOnly
						set @tsIsCommission_8 = @isCommission
					end
					else if (@tsKey_9 is null)
					begin
						set @tsKey_9 = @scpId
						set @tsSVKey_9 = @nSvkey
						set @tsGross_9 = @gross
						set @tsAddIsCommission_9 = @addCostIsCommission
						set @tsAddNoCommission_9 = @addCostNoCommission
						set @tsMarginPercent_9 = @marginPercent
						set @tsCommissionOnly_9 = @CommissionOnly
						set @tsIsCommission_9 = @isCommission
					end
					else if (@tsKey_10 is null)
					begin
						set @tsKey_10 = @scpId
						set @tsSVKey_10 = @nSvkey
						set @tsGross_10 = @gross
						set @tsAddIsCommission_10 = @addCostIsCommission
						set @tsAddNoCommission_10 = @addCostNoCommission
						set @tsMarginPercent_10 = @marginPercent
						set @tsCommissionOnly_10 = @CommissionOnly
						set @tsIsCommission_10 = @isCommission
					end
					else if (@tsKey_11 is null)
					begin
						set @tsKey_11 = @scpId
						set @tsSVKey_11 = @nSvkey
						set @tsGross_11 = @gross
						set @tsAddIsCommission_11 = @addCostIsCommission
						set @tsAddNoCommission_11 = @addCostNoCommission
						set @tsMarginPercent_11 = @marginPercent
						set @tsCommissionOnly_11 = @CommissionOnly
						set @tsIsCommission_11 = @isCommission
					end
					else if (@tsKey_12 is null)
					begin
						set @tsKey_12 = @scpId
						set @tsSVKey_12 = @nSvkey
						set @tsGross_12 = @gross
						set @tsAddIsCommission_12 = @addCostIsCommission
						set @tsAddNoCommission_12 = @addCostNoCommission
						set @tsMarginPercent_12 = @marginPercent
						set @tsCommissionOnly_12 = @CommissionOnly
						set @tsIsCommission_12 = @isCommission
					end
					else if (@tsKey_13 is null)
					begin
						set @tsKey_13 = @scpId
						set @tsSVKey_13 = @nSvkey
						set @tsGross_13 = @gross
						set @tsAddIsCommission_13 = @addCostIsCommission
						set @tsAddNoCommission_13 = @addCostNoCommission
						set @tsMarginPercent_13 = @marginPercent
						set @tsCommissionOnly_13 = @CommissionOnly
						set @tsIsCommission_13 = @isCommission
					end
					else if (@tsKey_14 is null)
					begin
						set @tsKey_14 = @scpId
						set @tsSVKey_14 = @nSvkey
						set @tsGross_14 = @gross
						set @tsAddIsCommission_14 = @addCostIsCommission
						set @tsAddNoCommission_14 = @addCostNoCommission
						set @tsMarginPercent_14 = @marginPercent
						set @tsCommissionOnly_14 = @CommissionOnly
						set @tsIsCommission_14 = @isCommission
					end
					else if (@tsKey_15 is null)
					begin
						set @tsKey_15 = @scpId
						set @tsSVKey_15 = @nSvkey
						set @tsGross_15 = @gross
						set @tsAddIsCommission_15 = @addCostIsCommission
						set @tsAddNoCommission_15 = @addCostNoCommission
						set @tsMarginPercent_15 = @marginPercent
						set @tsCommissionOnly_15 = @CommissionOnly
						set @tsIsCommission_15 = @isCommission
					end
				end
			fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE, @tiCtKeyFrom, @IsDuration
		END
		close serviceCursor
		deallocate serviceCursor
		
		print 'Расчет цен END: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()

		----------------------------------------------------- возвращаем обратно цены ------------------------------------------------------

		Set @nTotalProgress = 97
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
		
		--удаление из веба
		if (@nIsEnabled = 1)
		begin
			if (@isPriceListPluginRecalculation = 0)
				EXEC ClearMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
			else
				EXEC ClearMasterWebSearchFields @nPriceTourKey, null
		end

		-- удаляем старые цены
		
		-- запомним ключи цен которые потом нужно будет удалить из TP_PriceComponents
		declare @tpKeysForDelete table
		(
			xtp_key int
		)
		
		insert into @tpKeysForDelete
		select tp_key from tp_prices with(nolock)
		where tp_tokey = @nPriceTourKey and 
			tp_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tp_DateBegin in (select td_date from TP_TurDates with(nolock) where td_tokey = @nPriceTourKey and TD_Update = @nUpdate)
		union
		select tpd_tpkey from dbo.TP_PricesDeleted with(nolock)
		where tpd_tokey = @nPriceTourKey and 
			tpd_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tpd_DateBegin in (select td_date from TP_TurDates with(nolock) where td_tokey = @nPriceTourKey and TD_Update = @nUpdate)
		
		insert into TP_PricesCleaner(PC_TRKEY, PC_TOKEY, PC_TPKEY, PC_CalculatingKey)
		select @trKey, TP_TOKEY, TP_KEY, @nCalculatingKey from dbo.TP_Prices with(nolock)
		where TP_Key in (select xtp_key from @tpKeysForDelete)		

		delete from dbo.TP_Prices with(rowlock)
		where TP_Key in (select xtp_key from @tpKeysForDelete)
		
		delete from dbo.TP_PricesDeleted with(rowlock)
		where TPD_TPKey in (select xtp_key from @tpKeysForDelete)
		
		delete from dbo.TP_PriceComponents with(rowlock)
		where PC_TPKey in (select xtp_key from @tpKeysForDelete)
		
		-- удалим цены которые не посчитались
		delete #TP_Prices
		where xTP_Gross is null
			
		INSERT INTO TP_Prices with(rowlock) (tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey, TP_CalculatingKey) 
		select xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, CEILING(xTP_Gross), xTP_TIKey, xTP_CalculatingKey 
		from #TP_Prices
		
		-- заносим детализацию по посчитанному туру	
		
		insert into TP_PriceComponents with(rowlock) (PC_TIKey, PC_TOKey, PC_TRKey, PC_TourDate, PC_TPKey, PC_Days, PC_Rate, PC_HotelKey, PC_DepartureKey
		, SCPId_1, SCPId_2, SCPId_3, SCPId_4, SCPId_5, SCPId_6, SCPId_7, SCPId_8, SCPId_9, SCPId_10, SCPId_11, SCPId_12, SCPId_13, SCPId_14, SCPId_15
		, SVKey_1, SVKey_2, SVKey_3, SVKey_4, SVKey_5, SVKey_6, SVKey_7, SVKey_8, SVKey_9, SVKey_10, SVKey_11, SVKey_12, SVKey_13, SVKey_14, SVKey_15
		, Gross_1, Gross_2, Gross_3, Gross_4, Gross_5, Gross_6, Gross_7, Gross_8, Gross_9, Gross_10, Gross_11, Gross_12, Gross_13, Gross_14, Gross_15
		, AddCostIsCommission_1, AddCostIsCommission_2, AddCostIsCommission_3, AddCostIsCommission_4, AddCostIsCommission_5, AddCostIsCommission_6, AddCostIsCommission_7, AddCostIsCommission_8, AddCostIsCommission_9, AddCostIsCommission_10, AddCostIsCommission_11, AddCostIsCommission_12, AddCostIsCommission_13, AddCostIsCommission_14, AddCostIsCommission_15
		, AddCostNoCommission_1, AddCostNoCommission_2, AddCostNoCommission_3, AddCostNoCommission_4, AddCostNoCommission_5, AddCostNoCommission_6, AddCostNoCommission_7, AddCostNoCommission_8, AddCostNoCommission_9, AddCostNoCommission_10, AddCostNoCommission_11, AddCostNoCommission_12, AddCostNoCommission_13, AddCostNoCommission_14, AddCostNoCommission_15
		, MarginPercent_1, MarginPercent_2, MarginPercent_3, MarginPercent_4, MarginPercent_5, MarginPercent_6, MarginPercent_7, MarginPercent_8, MarginPercent_9, MarginPercent_10, MarginPercent_11, MarginPercent_12, MarginPercent_13, MarginPercent_14, MarginPercent_15
		, CommissionOnly_1, CommissionOnly_2, CommissionOnly_3, CommissionOnly_4, CommissionOnly_5, CommissionOnly_6, CommissionOnly_7, CommissionOnly_8, CommissionOnly_9, CommissionOnly_10, CommissionOnly_11, CommissionOnly_12, CommissionOnly_13, CommissionOnly_14, CommissionOnly_15
		, IsCommission_1, IsCommission_2, IsCommission_3, IsCommission_4, IsCommission_5, IsCommission_6, IsCommission_7, IsCommission_8, IsCommission_9, IsCommission_10, IsCommission_11, IsCommission_12, IsCommission_13, IsCommission_14, IsCommission_15)
		select xTP_TIKey, xtp_tokey, @TrKey, xtp_dateBegin, xtp_key, xTP_Days, xTP_Rate, xTP_HotelKey, xTP_DepartureKey
		, xSCPId_1, xSCPId_2, xSCPId_3, xSCPId_4, xSCPId_5, xSCPId_6, xSCPId_7, xSCPId_8, xSCPId_9, xSCPId_10, xSCPId_11, xSCPId_12, xSCPId_13, xSCPId_14, xSCPId_15
		, xSvKey_1, xSvKey_2, xSvKey_3, xSvKey_4, xSvKey_5, xSvKey_6, xSvKey_7, xSvKey_8, xSvKey_9, xSvKey_10, xSvKey_11, xSvKey_12, xSvKey_13, xSvKey_14, xSvKey_15
		, xGross_1, xGross_2, xGross_3, xGross_4, xGross_5, xGross_6, xGross_7, xGross_8, xGross_9, xGross_10, xGross_11, xGross_12, xGross_13, xGross_14, xGross_15
		, xAddCostIsCommission_1, xAddCostIsCommission_2, xAddCostIsCommission_3, xAddCostIsCommission_4, xAddCostIsCommission_5, xAddCostIsCommission_6, xAddCostIsCommission_7, xAddCostIsCommission_8, xAddCostIsCommission_9, xAddCostIsCommission_10, xAddCostIsCommission_11, xAddCostIsCommission_12, xAddCostIsCommission_13, xAddCostIsCommission_14, xAddCostIsCommission_15
		, xAddCostNoCommission_1, xAddCostNoCommission_2, xAddCostNoCommission_3, xAddCostNoCommission_4, xAddCostNoCommission_5, xAddCostNoCommission_6, xAddCostNoCommission_7, xAddCostNoCommission_8, xAddCostNoCommission_9, xAddCostNoCommission_10, xAddCostNoCommission_11, xAddCostNoCommission_12, xAddCostNoCommission_13, xAddCostNoCommission_14, xAddCostNoCommission_15
		, xMarginPercent_1, xMarginPercent_2, xMarginPercent_3, xMarginPercent_4, xMarginPercent_5, xMarginPercent_6, xMarginPercent_7, xMarginPercent_8, xMarginPercent_9, xMarginPercent_10, xMarginPercent_11, xMarginPercent_12, xMarginPercent_13, xMarginPercent_14, xMarginPercent_15
		, xCommissionOnly_1, xCommissionOnly_2, xCommissionOnly_3, xCommissionOnly_4, xCommissionOnly_5, xCommissionOnly_6, xCommissionOnly_7, xCommissionOnly_8, xCommissionOnly_9, xCommissionOnly_10, xCommissionOnly_11, xCommissionOnly_12, xCommissionOnly_13, xCommissionOnly_14, xCommissionOnly_15
		, xIsCommission_1, xIsCommission_2, xIsCommission_3, xIsCommission_4, xIsCommission_5, xIsCommission_6, xIsCommission_7, xIsCommission_8, xIsCommission_9, xIsCommission_10, xIsCommission_11, xIsCommission_12, xIsCommission_13, xIsCommission_14, xIsCommission_15
		from #TP_Prices join CalculatingPriceLists on xTP_CalculatingKey = CP_Key
				
		-----------------------------------------------------КОНЕЦ возвращаем обратно цены ------------------------------------------------------
		Set @nTotalProgress = 97
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey

		update tp_lists with(rowlock) set ti_update = 0 where ti_tokey = @nPriceTourKey
		update tp_turdates with(rowlock) set td_update = 0, td_checkmargin = 0 where td_tokey = @nPriceTourKey
		Set @nTotalProgress = 99
		update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_update = 0, to_updatetime = GetDate(),
							TO_CalculateDateEnd = GetDate(), TO_PriceCount = (Select Count(*) 
			From TP_Prices with(nolock) Where TP_ToKey = to_key) where to_key = @nPriceTourKey
		update tp_services with(rowlock) set ts_checkmargin = 0 where ts_tokey = @nPriceTourKey
		
		print 'Запись результатов: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
	END

	update CalculatingPriceLists with(rowlock) set CP_Status = 0, CP_CreateDate = GetDate(), CP_StartTime = null where CP_PriceTourKey = @nPriceTourKey

	------------------------------------

	Set @nTotalProgress = 100
	update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	set DATEFIRST @nDateFirst
	
	select @nIsEnabled = TO_IsEnabled from TP_Tours where TO_Key = @nPriceTourKey
	
	
	--Засекаем время окончания рассчета begin
	declare @endPriceCalculate datetime
	set @endPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@endPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11010, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время окончания рассчета end

	--Записываем кол-во рассчитанных цен begin
	SET @sHI_Text = CONVERT(varchar(10),@calcPricesCount)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11011, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем кол-во рассчитанных цен end

	--Записываем скорость расчета цен begin
	declare @calculatingSpeed decimal(10,2), @seconds int
	set @seconds = datediff(ss,@beginPriceCalculate,@endPriceCalculate)
	if @seconds = 0
		set @seconds = 1
	set @calculatingSpeed = @calcPricesCount / @seconds
	SET @sHI_Text = CONVERT(varchar(10),@calculatingSpeed)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11012, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем скорость расчета цен end
	

	if (@nIsEnabled = 1)
	begin
		if (@isPriceListPluginRecalculation = 0)
			EXEC FillMasterWebSearchFields @nPriceTourKey, null, null, null, @nCalculatingKey
		else
			EXEC FillMasterWebSearchFields @nPriceTourKey, null, null, null, @nCalculatingKey
	end
	
	print 'Выставление а инет: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	Return 0
END

go 

grant exec on CalculatePriceListDynamic to public

go
/*********************************************************************/
/* end sp_CalculatePriceListDynamic.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_Delete.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_Delete]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_Delete]
GO
CREATE PROCEDURE [dbo].[ReCalculate_Delete]
	(
		-- хранимка удаляет цены из TP_PricesComponents
		--<version>2009.2.01</version>
		--<data>2012-03-12</data>
		-- список ключей @pcIds для удаления цен
		@pcIds xml ([dbo].[ArrayOfLong]) = null
	)
AS
BEGIN	
	SET ARITHABORT ON;
	
	declare @tempGrossTable table
	(
		xPCId int,
		xTPKey int,
		xToKey int
	)
	
	insert into @tempGrossTable (xPCId,  xTPKey, xToKey)
	select PC_Id, PC_TPKey, PC_TOKey
	from TP_PriceComponents with(nolock)
	where PC_Id in (select tbl.res.value('.', 'bigint') from @pcIds.nodes('/ArrayOfLong/long') as tbl(res))
	
	declare currReCalculate_MigrateToPrice cursor for select distinct xToKey from @tempGrossTable
	declare @toKey int
	OPEN currReCalculate_MigrateToPrice
		FETCH NEXT FROM currReCalculate_MigrateToPrice INTO @toKey
		WHILE @@FETCH_STATUS = 0
		begin
	
			-- вставляем запись в CalculatingPriceLists
			insert into CalculatingPriceLists (CP_CreateDate,CP_PriceTourKey) values (GETDATE(),@toKey) 
			declare @cpKey int
			set @cpKey = scope_identity()
			
			-- переносим цены в таблицу для удаленных цен
			insert into tp_pricesdeleted (TPD_TPKey, TPD_TOKey, TPD_TIKey, TPD_Gross, TPD_DateBegin, TPD_DateEnd, TPD_CalculatingKey)
			select TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, @cpKey 
			from tp_prices with(nolock)
			where tp_key in (	select xTPKey
								from @tempGrossTable
								where xToKey = @toKey)
								
			-- удаляем цены из tp_prices
			delete from tp_prices
			where tp_key in (	select xTPKey
								from @tempgrosstable
								where xToKey = @toKey)
								
			-- удаляем из TP_PriceComponents
			delete TP_PriceComponents
			where PC_Id in (	select xPCId
								from @tempgrosstable
								where xToKey = @toKey)
								
			if exists (select top 1 1 from TP_Tours where to_Key = @toKey and to_isEnabled = 1)
			begin
				-- Реплицируем только если тур уже выставлен в online
				exec FillMasterWebSearchFields @tokey = @toKey, @calculatingKey = @cpKey
			end
								
		FETCH NEXT FROM currReCalculate_MigrateToPrice INTO @toKey
		end

	CLOSE currReCalculate_MigrateToPrice
	DEALLOCATE currReCalculate_MigrateToPrice
END

GO
grant exec on [dbo].[ReCalculate_Delete] to public
go
/*********************************************************************/
/* end sp_ReCalculate_Delete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceCost.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetServiceCost]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].[GetServiceCost] 
GO

CREATE PROCEDURE [dbo].[GetServiceCost] 
	(
		--<date>2012-03-12</date>
		--<version>2009.2.9.18</version>
		--.18 gorshkov 12.03.2012 - для динамического ценообразования @CS_Profit заполняется нулями
		--.17 mv 06.02.2012 (MEG00040397) обработка продолжительности а/п
		--.15 mv 27.01.2012: Изменил обвязку рядом вокруг sp "GetServiceAddCosts"
		@svKey int, @code int, @code1 int, @code2 int, @prKey int, @packetKey int, @date datetime, @days int,
		@resRate varchar(2), @men int, @discountPercent decimal(14,2), @margin decimal(14,2) = 0, @marginType int =0,
		@sellDate dateTime, @netto decimal(14,2) output, @brutto decimal(14,2) output, @discount decimal(14,2) output, 
		@nettoDetail varchar(100) = '' output, @sBadRate varchar(2) = '' output, @dtBadDate DateTime = '' output,
		@sDetailed varchar(100) = '' output,  @nSPId int = null output, @useDiscountDays int = 0 output,
		@tourKey int = 0, @tourDate datetime, @tourDays int, @includeAddCost bit = 1
	)
as
SET DATEFIRST 1
DECLARE @tourlong int


If @svKey = 1 and @days > 0
BEGIN
	Set @tourlong = @days
	Set @days = 0
END
else
	set @tourlong = 0
If ((((@days <= 0) or (@days is null)) and (@svKey != 3 and @svKey != 8)) or (@svKey = 1 and isnull(@tourDays,0) > 0))
	Set @days = 1

/*
Новый код!!!!!!
НАЧАЛО
*/
declare @rakey int, @marginCalcValue decimal(14,2), @bSPUpdate bit, @sUseServicePrices varchar(1)
Select @rakey = RA_Key from dbo.Rates with(nolock) where RA_Code = @resRate

select @sUseServicePrices = SS_ParmValue from systemsettings with(nolock) where SS_ParmName = 'UseServicePrices'
if @sUseServicePrices = '1'
BEGIN
	SET @bSPUpdate = 0
	set @netto = null

	if @nSPId is not null 
		if exists (select SP_ID from dbo.ServicePrices with(nolock) where SP_ID = @nSPId)
			Set @bSPUpdate = 1

	if @bSPUpdate = 0
	BEGIN
		select	@nSPId = SP_ID, @netto = SP_Cost, @brutto = SP_Price, @discount = SP_PriceWithCommission
		from	dbo.ServicePrices with(nolock)
		where 
				SP_SVKey = @svKey and SP_Code = @code and SP_SubCode1 = @code1 and
				SP_SubCode2 = @code2 and SP_PRKey = @prKey and SP_PKKey = @packetKey and
				SP_Long = @days and SP_Date = @date and SP_Pax = @men and
				SP_RateKey = @rakey
	END
END

if @nSPId is null or @bSPUpdate = 1
BEGIN
/*
Новый код!!!!!!
КОНЕЦ
*/

DECLARE @profitValue decimal(14,2)
Set @marginType = ISNULL(@marginType,0)
Set @packetKey = ISNULL(@packetKey,0)

DECLARE @TMP_Number_Period int, @TMP_DATE_Period datetime, @nCostByDayExists smallint, @WeekDate varchar(1), @IsFetchNormal bit, @csid int
DECLARE @TMP_Number INT, @DayOfWeek char(1), @DayOfWeeks varchar(13), @String varchar(500), @COST_ID INT, @TMP_Date DATETIME, @CS_Date DATETIME, @CS_DateEnd DATETIME, @CS_Week varchar(7), @CS_CostNetto decimal(14,4), @CS_Cost decimal(14,4)
DECLARE @CS_Discount decimal(14,4), @CS_Type INT, @CS_Rate varchar(2), @CS_LongMin int, @CS_Long int
--DECLARE @CS_ByDay INT, @CS_Profit decimal(8,4), @CS_ID INT, @TMP_Rate varchar(2), @course decimal (8,6), @sBadRate varchar(3), @dtBadDate DateTime
DECLARE @CS_ByDay INT, @CS_Profit decimal(14,4), @CS_ID INT, @TMP_Rate varchar(2), @course decimal (18,8), @CS_CheckInDateBEG datetime, @CS_CheckInDateEND datetime, @CS_DateSellBeg datetime, @CS_DateSellEnd datetime, @NotCalculatedCosts smallint, @CS_Pax smallint, @FindCostByPeriod smallint


set @NotCalculatedCosts = 1
set @WeekDate = DATEPART (weekday, @date)

--	REGION		MEG00015352 2008-02-22
	DECLARE @RealNetto decimal(14,2)	-- Сюда будем фиксировать НЕТТО, если цены в базе разделены 
	DECLARE @UseTypeDivisionMode int	-- Переменная, которая определяет ведется ли расчет отдельно по брутто и отдельно по нетто ценам
	DECLARE @TypeDivision int	-- Переменная указывает по какому типу цены ведем расчет (1-нетто, 2-брутто)
	SET @TypeDivision = 0

	SELECT @UseTypeDivisionMode = SS_ParmValue from dbo.SystemSettings with(nolock) where SS_ParmName = 'SYSUseCostTypeDivision'
	IF @UseTypeDivisionMode is not null and @UseTypeDivisionMode > 0
	BEGIN
		SELECT @UseTypeDivisionMode = COUNT(*) FROM tbl_costs with(nolock)
			WHERE	CS_TYPEDIVISION > 0 AND
					CS_SVKey = @svKey and CS_Code = @code and CS_SubCode1 = @code1 and CS_SubCode2 = @code2 and 
					CS_PrKey = @prKey and CS_PkKey = @packetKey
					and ((@date between CS_CheckInDateBEG and CS_CheckInDateEnd) or (CS_CheckInDateBEG is null)) 
					and (CS_DateEnd >= @date and CS_DATE < @date+isnull(@days,0) or CS_DATE IS NULL) 
	END
	-- Если есть разделение цен на НЕТТО и БРУТТО
	IF @UseTypeDivisionMode is not null and @UseTypeDivisionMode > 0
	BEGIN
		SET @UseTypeDivisionMode = 2
		SET @TypeDivision = 1
	END
	ELSE
	BEGIN
		SET @UseTypeDivisionMode = 0	-- там и так ноль, но для наглядности
		SET @TypeDivision = 0
	END
	
		
	WHILE @TypeDivision <= @UseTypeDivisionMode
	BEGIN
	--	ENDREGION	MEG00015352 2008-02-22 Разделение цен на НЕТТО и БРУТТО
		
		if @UseTypeDivisionMode > 0
			declare costCursor cursor local fast_forward for
			select 
			CS_DATE, CS_DATEEND, CS_WEEK, CS_COSTNETTO, CAST(CS_COST as decimal(14,2)),
			CS_DISCOUNT, isnull(CS_TYPE,0), CS_RATE, CS_LONGMIN, CS_LONG,
			CS_BYDAY, CS_PROFIT, CS_ID, CS_CheckInDateBEG, CS_CheckInDateEND, 
			ISNULL(CS_DateSellBeg, '19000101'), ISNULL(CS_DateSellEnd, '99980101')
				from tbl_costs with(nolock)           
				WHERE	CS_SVKey = @svKey and CS_Code = @code and CS_SubCode1 = @code1 and CS_SubCode2 = @code2 and 
					    CS_PrKey = @prKey and CS_PkKey = @packetKey
					--	and (CS_CheckInDateEnd >= @date or CS_CheckInDateEnd is null)
						and ((@date between CS_CheckInDateBEG and CS_CheckInDateEnd) or (CS_CheckInDateBEG is null and CS_CheckInDateEnd is null)) 
					    and (CS_DateEnd >= @date and CS_DATE <= @date+isnull(@days,0) or (CS_DATE is null and CS_DateEnd is null))
		            --    and ((GetDate() between CS_DateSellBeg and CS_DateSellEnd) or (CS_DateSellBeg is null))
						and (CS_TYPEDIVISION IN (0,@TypeDivision) OR CS_TYPEDIVISION IS NULL)	-- отбираем цены только определенного типа при использовании режима разделения цен (брутто или нетто)
			    ORDER BY
						CS_CheckInDateBEG Desc, CS_CheckInDateEnd, CS_Date Desc, CS_DATEEND, CS_LONGMIN desc, 
						CS_LONG, CS_DateSellBeg Desc, CS_DateSellEnd, CS_BYDAY,	CS_WEEK ASC
		else if ( exists( select top 1 1 from SystemSettings with(nolock) where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue = 1))
			declare costCursor cursor local fast_forward for
			select 
			CS_DATE, CS_DATEEND, CS_WEEK, CS_COSTNETTO, CAST(CS_COST as decimal(14,2)),
			CS_DISCOUNT, isnull(CS_TYPE,0), CS_RATE, CS_LONGMIN, CS_LONG,
			CS_BYDAY, 0 /* т.к. профиты конвертнулись в AddCosts */, CS_ID, CS_CheckInDateBEG, CS_CheckInDateEND, 
			ISNULL(CO_SaleDateBeg, '1900-01-01'), ISNULL(CO_SaleDateEnd, '2072-01-01')
				from tbl_costs with(nolock) join CostOffers with(nolock) on CS_COID = CO_Id
				join Seasons with(nolock) on CO_SeasonId = SN_Id
				WHERE	isnull(SN_IsActive, 0) = 1
						-- проверим активность костофера на нужную нам дату продажи
						and ((@sellDate is null and CO_State = 1) 
							or (CO_State in (1,2) and @sellDate is not null and @sellDate between isnull(convert(datetime, CONVERT(varchar(8), CO_DateActive, 112)), '1900-01-01') and isnull(convert(datetime, CONVERT(varchar(8), CO_DateClose, 112)), '2072-01-01')))
						-- проверим период продажи ценового блока
						and isnull(@sellDate, getdate()) between isnull(CO_SaleDateBeg, '1900-01-01') and isnull(CO_SaleDateEnd, '2072-01-01')
						and CS_SVKey = @svKey
						and CS_Code = @code
						and CS_SubCode1 = @code1
						and CS_SubCode2 = @code2
						and CS_PrKey = @prKey
						and CS_PkKey = @packetKey
						and @date between isnull(CS_CheckInDateBEG, '1900-01-01') and isnull(CS_CheckInDateEnd, '2072-01-01')
						-- либо дата начала услуги лежит между началом и концом цены,
						-- либо дата начала цены лежит между датой начала и концом услуги
						and (CS_DATE is null 
								or @date between CS_DATE and CS_DATEEND
								or CS_DATE between @date and dateadd(dd, isnull(@days,0), @date))
				ORDER BY
						-- если не задана дата продажи то смотрим по текущему полю последней даты активации
						-- иначе смотрим по истории активации
						isnull(CO_DateActive,'1900-01-01') desc,
						CS_CheckInDateBEG Desc, CS_CheckInDateEnd, CS_Date Desc, CS_DATEEND, CS_LONGMIN desc, 
						CS_LONG, CS_DateSellBeg Desc, CS_DateSellEnd, CS_BYDAY,	CS_WEEK ASC
		else
			declare costCursor cursor local fast_forward for
			select
			CS_DATE, CS_DATEEND, CS_WEEK, CS_COSTNETTO, CAST(CS_COST as decimal(14,2)),
			CS_DISCOUNT, isnull(CS_TYPE,0), CS_RATE, CS_LONGMIN, CS_LONG,
			CS_BYDAY, CS_PROFIT, CS_ID, CS_CheckInDateBEG, CS_CheckInDateEND,
			ISNULL(CS_DateSellBeg, '19000101'), ISNULL(CS_DateSellEnd, '99980101')
				from tbl_costs with(nolock)
				WHERE	CS_SVKey = @svKey and CS_Code = @code and CS_SubCode1 = @code1 and CS_SubCode2 = @code2 and
					    CS_PrKey = @prKey and CS_PkKey = @packetKey
						and ((@date between CS_CheckInDateBEG and CS_CheckInDateEnd) or (CS_CheckInDateBEG is null and CS_CheckInDateEnd is null))
					    and (CS_DateEnd >= @date and CS_DATE <= @date+isnull(@days,0) or (CS_DATE is null and CS_DateEnd is null))
			    ORDER BY
						CS_CheckInDateBEG Desc, CS_CheckInDateEnd, CS_Date Desc, CS_DATEEND, CS_LONGMIN desc,
						CS_LONG, CS_DateSellBeg Desc, CS_DateSellEnd, CS_BYDAY,	CS_WEEK ASC				

	Set @sellDate = ISNULL(@sellDate,GetDate())
	open costCursor
	set @nCostByDayExists = 0

	fetch next from costCursor 
		into	@CS_Date, @CS_DateEnd, @CS_Week, @CS_CostNetto, @CS_Cost, 
				@CS_Discount, @CS_Type, @CS_Rate, @CS_LongMin, @CS_Long, 
				@CS_ByDay, @CS_Profit, @CS_ID, @CS_CheckInDateBEG, @CS_CheckInDateEND, @CS_DateSellBeg, @CS_DateSellEnd

		If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
		BEGIN
			If @@fetch_status = 0
			BEGIN

				declare @TMPTable Table 
 				( CL_Date datetime,
				CL_CostNetto decimal(14,6),
				CL_Cost decimal(14,6),
				CL_Discount smallint,
				CL_Type smallint,
				CL_Rate varchar(2),
				CL_Course decimal(14,6),
				CL_Pax smallint default 1,
				CL_ByDay smallint,
				CL_Part smallint,
				CL_Profit decimal(14,6))

				DECLARE @temp_date DATETIME
				SET @temp_date = @date + @days - 1

				while @temp_date >= @date 
				BEGIN -- begin while @temp_date >= @date 
					insert into @TMPTable (CL_Date, CL_ByDay) values (@temp_date, -1 )
					set @temp_date = @temp_date - 1 
				END  -- end while @temp_date >= @date 
			END
			Else
			BEGIN
				close costCursor
				deallocate costCursor
				return 0
			END

			set @COST_ID = 1 --идетификатор уникальности цены
			If @CS_ByDay = 2
				Set @nCostByDayExists = 1

			If @CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) --or (@CS_ByDay = 0 and @days = 0)
				insert into @TMPTable (CL_Date, CL_ByDay) values (@date + @days, -1 )
		END

		set @NotCalculatedCosts = 1
		set @FindCostByPeriod = 0   --переменная контролирует поиск цены за период, точно совпадающий с периодом предоставления услуги

	While (@@fetch_status = 0) and (@NotCalculatedCosts > 0 or @FindCostByPeriod > 0)  --цены уже могут быть найдены на все даты, но возможно где-то еще есть цена на период...
	BEGIN -- While (@@fetch_status = 0)
		-- подправим продолжительность цены, чтобы было проще искать по периодам и по неделям
		Set @IsFetchNormal = 1
			-- если не указаны даты периодов, то значит указаны даты заедов
			-- в этом случае "дни недели", подразумевают дни заездов, и действуют все дни из периодов]

		If	@CS_CheckInDateBEG is not null and @CS_Date is null and @CS_Week is not null and @CS_Week != ''
			if CHARINDEX ( @WeekDate, @CS_Week ) = 0
				Set @IsFetchNormal = 0
			Else
				Set @CS_Week = ''

		If @tourlong > 0 and @svKey = 1
		Begin		
			If (@CS_LongMin is null or @tourlong >= @CS_LongMin) and (@CS_Long is null or @tourlong <= @CS_Long)
				Set @IsFetchNormal = @IsFetchNormal
			else
				Set @IsFetchNormal = 0
		end     

		If @svKey != 1
		begin
			If @CS_LongMin is not null and @CS_LongMin > @days
				Set @IsFetchNormal = 0
		end

		-- Если время не задано, то увеличиваем период продажи на один день. Иначе, смотрим точный период.
		If DATEPART(hour, @CS_DateSellEnd)+DATEPART(minute, @CS_DateSellEnd) = 0
			Set @CS_DateSellEnd = @CS_DateSellEnd + 1
		-- При переходе с 5.2 возможны цены с периодом продаж оганиченном только с одной стороны.
		If (@sellDate between ISNULL(@CS_DateSellBeg, @sellDate - 1) and ISNULL(@CS_DateSellEnd, @sellDate + 1))
			Set @IsFetchNormal = @IsFetchNormal 
		else
			Set @IsFetchNormal = 0

		If @FindCostByPeriod = 1 and ((@days between @CS_LongMin and @CS_Long) or @CS_Long is null) and @CS_DateEnd = (@date + @days - 1) -- смотрим может есть цена за период точно совпадает с периодом действия услуги
			Update @TMPTable Set CL_CostNetto = null, CL_Cost = null, CL_Discount = null, CL_Type = null, 
				CL_Rate = null, CL_Course = null, CL_Pax = 1, CL_ByDay =-1, CL_Part = null, CL_Profit = null

	--	If @CS_ByDay = 1 and @CS_Long is not null and @CS_Long < @days
	--		Set @IsFetchNormal = 0
		If @CS_Week != '' and (@days = 0 or (@days = 1 and (@CS_ByDay != 2 or (@svKey!=3 and @svKey!=8) ) ) )
		BEGIN
			If CHARINDEX ( @WeekDate, @CS_Week ) > 0
				Set @IsFetchNormal = @IsFetchNormal 
			Else
				Set @IsFetchNormal = 0
		END

		If @Days = 1 and @CS_Date > @date
			Set @IsFetchNormal = 0

		If @Days = 1 and @CS_ByDay in (3,4)
			Set @IsFetchNormal = 0

	--ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! 
	--ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! 
	/*
		If 	@CS_CheckInDateBEG is not null
		BEGIN
			Set @CS_Date = null
			Set @CS_DateEnd = null
		END
	*/
			If (@days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)) and @IsFetchNormal = 1 	-- fetch нам подходит
			BEGIN			--цены подходят для поиска
				Set @CS_Date = (isnull(@CS_Date,@date))
				Set @CS_DateEnd = isnull(@CS_DateEnd,@date+ISNULL(@CS_Long,999))

				If @nCostByDayExists = 0 and @CS_ByDay = 2 and (@svKey = 3 or @svKey = 8)
				BEGIN
					update @TMPTable Set CL_CostNetto = null, CL_Cost = null, CL_Discount = null, CL_Type = null, 
							CL_Rate = null, CL_Course = null, CL_Pax = 1, CL_ByDay =-1, CL_Part = null, CL_Profit = null
					if not exists (select * from @TMPTable where CL_Date = @date + @days)
						insert into @TMPTable (CL_Date, CL_ByDay) values (@date + @days, -1 )
					Set @nCostByDayExists = 1	
				END

				if @CS_Date < @date
					Set @CS_Date = @date
				if @CS_DateEnd > @date + @days
					Set @CS_DateEnd = @date + @days
				Set @CS_Discount = ISNULL(@CS_Discount,0)
				Set @TMP_Number_Period = null

				if @CS_ByDay = 3 and (@nCostByDayExists = 0 or (@svKey != 3 and @svKey != 8)) -- если цена за неделю
				BEGIN -- if @CS_ByDay = 3
					if (@CS_DateEnd - @CS_Date + 1) >= 7 and ((@days between @CS_LongMin and @CS_Long) or @CS_Long is null)
					BEGIN
						select @TMP_Number = count(*), @TMP_Date = MIN(CL_Date) from @TMPTable Where CL_Date between @CS_Date and @CS_DateEnd and CL_ByDay in (-1,1,4)
						while @TMP_Number >= 7
						BEGIN
							UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID, 
								CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, 
								CL_Pax = 1, CL_Profit = @CS_Profit
								WHERE CL_DATE between @TMP_Date and @TMP_Date + 6  and CL_ByDay  in (-1,1,4)
		
							UPDATE @TMPTable SET CL_Pax = 0 WHERE CL_DATE != @TMP_Date and CL_Part = @COST_ID
							SET @TMP_Number = @TMP_Number - 7
							SET @TMP_Date = @TMP_Date + 7
							SET @COST_ID = @COST_ID + 1
						END
					END
				END	-- if @CS_ByDay = 3

		--		print 'поиск'
				if @CS_ByDay = 0 and (@nCostByDayExists = 0 or (@svKey != 3 and @svKey != 8)) -- если цена за период
				BEGIN -- if @CS_ByDay = 0
		--			print 'период'
					select @TMP_Number = count(*), @TMP_Date = MIN(CL_Date) from @TMPTable 
						Where	CL_Date between @CS_Date and @CS_DateEnd and CL_ByDay != 3 and CL_ByDay != 0

					if @CS_Date < @TMP_Date and @date < @TMP_Date
					BEGIN
						select @TMP_Number_Period = CL_Part from @TMPTable where CL_Date = @TMP_Date - 1 and CL_ByDay = 0
				--		print @TMP_Number_Period
						if @TMP_Number_Period is not null
						BEGIN					
							select @TMP_Date_Period = MIN(CL_Date) from @TMPTable where CL_Part = @TMP_Number_Period
							if @CS_Date <= @TMP_Date_Period and (@CS_Long is null or @CS_Long > DATEDIFF(DAY,@TMP_Date_Period,@TMP_Date + @TMP_Number)) and (@CS_LongMin is null or @CS_LongMin <= DATEDIFF(DAY,@TMP_Date_Period,@TMP_Date + @TMP_Number))
							BEGIN
								select @TMP_Number = count(*), @TMP_Date = MIN(CL_Date) from @TMPTable 
									Where	CL_Date between @CS_Date and @CS_DateEnd and CL_ByDay != 3 and (CL_ByDay != 0 or CL_Part = @TMP_Number_Period)					
							END
						END
						Set @TMP_Number_Period = null
					END

					if @CS_Long is null or @CS_Long > @TMP_Number
					BEGIN
						--если предыдущий период захватывается полностью, то его надо включить
						--это делается только в случае, если цену указана за период
				--		print @TMP_Date + @TMP_Number
						select @TMP_Number_Period = CL_Part from @TMPTable where CL_Date = @TMP_Date + @TMP_Number and CL_ByDay = 0
			--			print @TMP_Number_Period
						if @TMP_Number_Period is not null
						BEGIN 
							select @TMP_Date_Period = MAX(CL_Date) from @TMPTable where CL_Part = @TMP_Number_Period
		--					print @TMP_Date_Period
							if (@CS_Long is null or @CS_Long > DATEDIFF(DAY,@TMP_Date,@TMP_Date_Period + 1)) and (@CS_LongMin is null or @CS_LongMin <= DATEDIFF(DAY,@TMP_Date,@TMP_Date_Period + 1)) and @TMP_Date_Period <= @CS_DateEnd
								Set @TMP_Number = DATEDIFF(DAY,@TMP_Date,@TMP_Date_Period) + 1
						END
					END

					--mv 06.02.2012 (MEG00040397) Сделал проверку только НЕ для а/п
					If @svKey != 1
					begin
						if @CS_Long is not null and @CS_Long < @TMP_Number
							set @TMP_Number = @CS_Long
					end

					--mv 06.02.2012 (MEG00040397) отдельная проверка на продолжительность а/п
					if @CS_LongMin is null or @CS_LongMin <= @TMP_Number 
						or (@svKey=1 and (@CS_LongMin is null or @tourDays >= @CS_LongMin) and (@CS_Long is null or @tourDays <= @CS_Long))
					BEGIN
						UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID, 
							CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, 
							CL_Pax = 1, CL_Profit = @CS_Profit
							WHERE CL_DATE between @TMP_Date and @TMP_Date + @TMP_Number - 1 and CL_ByDay != 3
						UPDATE @TMPTable SET CL_Pax = 0 WHERE CL_DATE != @TMP_Date and CL_Part = @COST_ID
						SET @COST_ID = @COST_ID + 1
					END
				END	-- if @CS_ByDay = 0
		
				if (@CS_ByDay = 1 and @nCostByDayExists = 0) or (@CS_ByDay = 2 and @nCostByDayExists = 1) or ((@svKey != 3 and @svKey != 8) and @CS_ByDay in (1,2))  -- если цена за ночь / день
				BEGIN -- if @CS_ByDay = 1/2
					if @CS_DateEnd > @date + @CS_Long - 1		-- если дата окончания цены действует в паре с продолжительностью
						Set @CS_DateEnd = @date + @CS_Long - 1
					if 1=1 -- временная заглушка, 
					BEGIN  -- если Цена удовлетворяет условиям
						SET @DayOfWeeks = @CS_Week
						While exists (select TOP 1 CL_Part from @TMPTable where CL_ByDay = 0 group by CL_Part having MIN(CL_Date) >= @CS_Date and MAX(CL_Date) <= @CS_DateEnd)
						BEGIN
							select TOP 1 @TMP_Number = CL_Part from @TMPTable where CL_ByDay = 0 group by CL_Part having MIN(CL_Date) >= @CS_Date and MAX(CL_Date) <= @CS_DateEnd
							update @TMPTable Set CL_CostNetto = null, CL_Cost = null, CL_Discount = null, CL_Type = null, 
								CL_Rate = null, CL_Course = null, CL_Pax = 1, CL_ByDay =-1, CL_Part = null, CL_Profit = null
								Where CL_Part = @TMP_Number
						END				

						IF @DayOfWeeks = ''
							UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
								CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, CL_Profit = @CS_Profit, CL_Course = ISNULL(@CS_Long,999)
								WHERE	CL_DATE between @CS_Date and @CS_DateEnd and (CL_ByDay in (-1,4) or (CL_ByDay in (1,2) and CL_Course < ISNULL(@CS_Long,999)))
						ELSE
							UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
								CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, CL_Profit = @CS_Profit, CL_Course = ISNULL(@CS_Long,999)
								WHERE	CL_DATE between @CS_Date and @CS_DateEnd and (CL_ByDay in (-1,4) or (CL_ByDay in (1,2) and CL_Course < ISNULL(@CS_Long,999))) AND CHARINDEX(CAST(DATEPART (weekday, CL_DATE) as varchar(1)),@DayOfWeeks) > 0

						SET @COST_ID = @COST_ID + 1
					END   -- если Цена удовлетворяет условиям
				END	-- if @CS_ByDay = 1

				if @CS_ByDay = 4 --and @nCostByDayExists = 0 -- если цена за доп.ночь
				BEGIN -- if @CS_ByDay = 4
					if @CS_DateEnd > @date + @CS_Long - 1		-- если дата окончания цены действует в паре с продолжительностью
						Set @CS_DateEnd = @date + @CS_Long - 1

					SET @DayOfWeeks = ''
					Set @CS_Week = REPLACE(@CS_Week,'.','');

					if @CS_Week != ''
					BEGIN			
						Set @TMP_Number = 1
						Set @DayOfWeeks = LEFT(@CS_Week,1)
						while @TMP_Number < LEN(@CS_Week)
						BEGIN
							Set @TMP_Number = @TMP_Number + 1
							Set @DayOfWeeks = @DayOfWeeks + ',' + SUBSTRING(@CS_Week, @TMP_Number, 1)				
						END
					END
					
					-- доп.ночи могут только добивать в конец, первый день точно не к ним
					If @CS_Date = @date
						Set @CS_Date = @CS_Date + 1

					IF @DayOfWeeks = ''
						UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
							CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate
							WHERE	CL_DATE between @CS_Date and @CS_DateEnd /*and (CL_ByDay = -1)*/
					ELSE
						UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
							CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate
							WHERE	CL_DATE between @CS_Date and @CS_DateEnd /*and (CL_ByDay = -1)*/ AND CHARINDEX(CAST(DATEPART (weekday, CL_DATE) as varchar(1)),@DayOfWeeks) > 0
					SET @COST_ID = @COST_ID + 1
				END	-- if @CS_ByDay = 4
				select @NotCalculatedCosts = Count(*) from @TMPTable where CL_CostNetto is null
			END -- цены подходят для поиска и есть продолжительность
			ELSE
				If @IsFetchNormal = 1
					Set @NotCalculatedCosts = 0

		If (@days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)) or @IsFetchNormal = 0
		BEGIN
			fetch next from costCursor 
				into	@CS_Date, @CS_DateEnd, @CS_Week, @CS_CostNetto, @CS_Cost, 
						@CS_Discount, @CS_Type, @CS_Rate, @CS_LongMin, @CS_Long, 
						@CS_ByDay, @CS_Profit, @CS_ID, @CS_CheckInDateBEG, @CS_CheckInDateEND, @CS_DateSellBeg, @CS_DateSellEnd

			If @CS_ByDay = 0 and @CS_Date = @date and @CS_DateEnd <= (@date + @days) and @days > 1 and (@sellDate between ISNULL(@CS_DateSellBeg, @sellDate - 1) and ISNULL(@CS_DateSellEnd, @sellDate + 1))
				Set @FindCostByPeriod = 1  -- отметка, что может быть эта цена за период, нам супер подойдет
			Else
				Set @FindCostByPeriod = 0
		END
	END -- While (@@fetch_status = 0)
	close costCursor
	deallocate costCursor


if @NotCalculatedCosts > 0
BEGIN
--	delete from @TMPTable
	if @bSPUpdate = 1
		delete from dbo.ServicePrices where SP_ID = @nSPId	
	return 0
END

If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
BEGIN
	Update @TMPTable set CL_Course = null
	Update @TMPTable set CL_Course = 1 Where CL_Rate = @resRate
	Update @TMPTable set CL_Course = 0 Where CL_CostNetto = 0 and ISNULL(CL_Cost,0) = 0 and ISNULL(CL_Profit,0) = 0

	set @TMP_Rate = null
	SELECT TOP 1 @TMP_Rate = CL_Rate from @TMPTable where CL_Course is null

	while @TMP_Rate is not null
	BEGIN
		Set @course = 1
		exec ExchangeCost @course output, @TMP_Rate, @resRate, @date
		if (@course is null) 
		begin 
			set @sBadRate=@TMP_Rate
			set @dtBadDate =@date
			--print 'нет курса между ' + ISNULL(@TMP_Rate,'NULL') + ' и ' + ISNULL(@resRate,'NULL') + ' на ' + CAST(@dtBadDate as varchar(12))
			if @bSPUpdate = 1
				delete from dbo.ServicePrices where SP_ID = @nSPId	
			return 0 		
		end 
		Update @TMPTable set CL_Course = @course Where CL_Rate = @TMP_Rate

		set @TMP_Rate = null
		SELECT TOP 1 @TMP_Rate = CL_Rate from @TMPTable where CL_Course is null
	END
end
else
BEGIN
	set @course=1
	If @CS_CostNetto = 0 and ISNULL(@CS_Cost,0) = 0 and ISNULL(@CS_Profit,0) = 0
		set @course = 0
	Else IF (@CS_Rate<>@resRate)
		exec ExchangeCost @course output, @CS_Rate, @resRate, @date             

	if (@course is null) 
	begin 
		set @sBadRate = @CS_Rate
		set @dtBadDate = @date
		--print 'нет курса между ' + ISNULL(@TMP_Rate,'NULL') + ' и ' + ISNULL(@resRate,'NULL') + ' на ' + CAST(@dtBadDate as varchar(12))
		--delete from @TMPTable
		if @bSPUpdate = 1
			delete from dbo.ServicePrices where SP_ID = @nSPId	
		return 0 		
	end 			
END

--select * from TMP
If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
	Update @TMPTable set CL_Pax = CL_Pax * @men Where CL_Type = 0
else
	If (isnull(@CS_Type, 0) = 0)
		Set @CS_Pax = @men
	Else
		Set @CS_Pax = 1

--Update @TMP set CL_Course = 0 Where CL_ByDay not in (0,3) and CL_DateFirst != CL_Date
--Update @TMP set CL_Course = CL_Course*(@margin + 100)/100 Where CL_Discount + (1- @marginType) != 0
If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
BEGIN	
	update @TMPTable set CL_Profit = 0 where CL_Date != @date
	if not exists (Select * from @TMPTable where CL_Cost is null)
		select	@brutto = SUM((CL_Cost + ISNULL(CL_Profit,0)) * CL_Course * CL_Pax),
				@discount = SUM((CL_Cost + ISNULL(CL_Profit,0)) * CL_Course * CL_Pax * CL_Discount) 
		from @TMPTable
	select	@netto = SUM(CL_CostNetto * CL_Course * CL_Pax) from @TMPTable
--	select	@profitValue = ISNULL(CL_Profit * CL_Course * CL_Pax * CL_Margin,0) from @TMPTable where CL_Date = @date
--	select	@profitValue = CL_Profit from @TMPTable where CL_Date = @date
	set @useDiscountDays = (select SUM(ISNULL(CL_Discount,0)) from @TMPTable)
	
END
else
BEGIN
	set @brutto = (@CS_Cost + ISNULL(@CS_Profit,0)) * @course * @CS_Pax
	set @discount = (@CS_Cost + ISNULL(@CS_Profit,0)) * @course * @CS_Pax * @CS_Discount
	set @netto = @CS_CostNetto * @course * @CS_Pax 
	set @useDiscountDays = @CS_Discount
--	set @profitValue = @CS_Profit * @course * @CS_Pax * @CS_Margin
END

/*
Новый код!!!!!!
НАЧАЛО
*/
If @sUseServicePrices = '1'
BEGIN
		if @bSPUpdate = 1
			update	dbo.ServicePrices 
					set	SP_Cost = @netto, SP_Price = @brutto, SP_PriceWithCommission = ISNULL(@discount,0)
			where SP_ID = @nSPId	
		else
		begin
			insert into dbo.ServicePrices (SP_SVKey, SP_Code, SP_SubCode1, SP_SubCode2, SP_PRKey,
				SP_PKKey, SP_Long, SP_Date, SP_Pax, SP_Cost, 
				SP_Price, SP_PriceWithCommission, SP_RateKey)
			values (@svKey, @code, @code1, @code2, @prKey,
				@packetKey, @days, @date, @men, @netto,
				@brutto, ISNULL(@discount,0), @rakey )
			Set @nSPId = SCOPE_IDENTITY()
		end
	END

--	REGION		MEG00015352 2008-02-22 Разделение цен на НЕТТО и БРУТТО		
		IF		(@TypeDivision = 1)	-- Если производили расчет по ценам НЕТТО
			BEGIN
				SET @RealNetto = @netto -- Фиксируем НЕТТО
				DELETE FROM @TMPTable	-- Подчищаем за собой для следующей итерации
			END
		ELSE IF	(@TypeDivision = 2)	-- Если производили расчет по ценам БРУТТО
			BEGIN
				SET @netto = @RealNetto	-- Восстанавливаем НЕТТО
			END
		SET @TypeDivision = @TypeDivision + 1
	END -- WHILE @TypeDivision <= @UseTypeDivisionMode
--	ENDREGION	MEG00015352 2008-02-22 Разделение цен на НЕТТО и БРУТТО

END -- Это конец основного блока !!!!!!!!!
/*
Новый код!!!!!!
КОНЕЦ
*/

--@discount на данный момент хранит сумму, с которой надо давать скидку
declare @sum_with_commission decimal(18,2)
set @sum_with_commission = @discount

/*Посчитаем доплату*/
if (@includeAddCost = 1 and exists( select top 1 1 from SystemSettings where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue = 1))
begin
	declare @addCostValueIsCommission money, @addCostValueNoCommission money, @addCostFromAdult money, @addCostFromChild money, @addCostRate nvarchar(2)
	--print @tourKey
	exec GetServiceAddCosts @tourKey, @svKey, @code, @code1, @code2, @prKey, @tourDate, @tourDays, @days, @men, @sellDate, null, @addCostValueIsCommission output, @addCostValueNoCommission output, @addCostFromAdult output, @addCostFromChild output, @addCostRate output
	/*
	print @addCostValueIsCommission
	print @addCostValueNoCommission
	*/
	--конвертируем доплаты в валюту расчета из валюты тура (в которой они задавались)
	If @addCostValueIsCommission is not null
		exec ExchangeCost @addCostValueIsCommission output, @addCostRate, @resRate, @date
	If @addCostValueNoCommission is not null
		exec ExchangeCost @addCostValueNoCommission output, @addCostRate, @resRate, @date
	
	if @addCostValueIsCommission is not null
		set @sum_with_commission = isnull(@sum_with_commission,0) + isnull(@addCostValueIsCommission, 0)
	set @brutto = @brutto + isnull(@addCostValueIsCommission, 0) + isnull(@addCostValueNoCommission, 0)
end

If @marginType = 0 -- даем наценку, вне зависмости от наличия комиссии по услуге
	Set @brutto = ISNULL(@brutto,0) * (100 + @margin) / 100 
Else -- даем наценку, только при наличии комиссии
	Set @brutto = ISNULL(@brutto,0) - ISNULL(@sum_with_commission,0) + ISNULL(@sum_with_commission,0) * (100 + @margin) / 100 

--теперь @discount это именно сумма скидки
Set @discount = @sum_with_commission * ((100 + @margin) / 100) * @discountPercent / 100

exec RoundCost @brutto output, 1

Set @brutto = ISNULL(@brutto,0) - ISNULL(@discount,0)

if (not exists( select top 1 1 from SystemSettings with(nolock) where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue = 1))
begin
	DECLARE @TMP_Number_Course decimal(12,4), @TMP_Number_Part INT, @TMP_Number_Pax int
	DECLARE @TMP_Number_CostNetto decimal(12,2), @TMP_Number_Cost decimal(12,2)

	If (@days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)) and @nSPId is null    -- Новый код !!!!!  and @useServicePrices is null
	BEGIN
		set @nettoDetail = '='
		set @sDetailed = '='
		while exists (select * from @TMPTable where CL_Course != 0)
		begin
			SELECT TOP 1	@CS_Date = CL_Date, @TMP_Number_CostNetto = CL_CostNetto, @TMP_Number_Cost = CL_Cost, @TMP_Number_Course = CL_Course, 
							@TMP_Number_Part = CL_Part, @TMP_Number_Pax = CL_Pax
			from			@TMPTable 
			where			CL_Course != 0	 
			Order By		CL_Date

			Set @TMP_Number = 0
			Select @TMP_Number = Count(*) from @TMPTable where CL_Part = @TMP_Number_Part and CL_Pax != 0
			UPDATE @TMPTable SET CL_Course = 0 WHERE ISNULL(CL_Part, 0) = ISNULL(@TMP_Number_Part, 0)
			if @nettoDetail != '='
				Set @nettoDetail = @nettoDetail + ' +'
			if @sDetailed != '='
				Set @sDetailed = @sDetailed + ' +'

			Set @nettoDetail = @nettoDetail + CAST(@TMP_Number_CostNetto as varchar(15)) 
			Set @sDetailed = @sDetailed + CAST(@TMP_Number_Cost as varchar(15)) 

			if @TMP_Number != 1
			begin
				Set @nettoDetail = @nettoDetail + '*' + CAST(@TMP_Number as varchar(15)) 
				Set @sDetailed = @sDetailed + '*' + CAST(@TMP_Number as varchar(15)) 
			end

			if @TMP_Number_Pax != 1
			begin
				Set @nettoDetail = @nettoDetail + '*' + CAST(@TMP_Number_Pax as varchar(15))
				Set @sDetailed = @sDetailed + '*' + CAST(@TMP_Number_Pax as varchar(15))
			end

			if @TMP_Number_Course != 1
			begin
				Set @nettoDetail = @nettoDetail + '*' + CAST(@TMP_Number_Course as varchar(15)) 
				Set @sDetailed = @sDetailed + '*' + CAST(@TMP_Number_Course as varchar(15)) 
			end
		end

		If ISNULL(@profitValue,0) > 0
			Set @sDetailed = @sDetailed + ' +' + CAST(@profitValue as varchar(15)) 

		if @marginCalcValue > 0
			Set @sDetailed = @sDetailed + '+' + CAST(@marginCalcValue as varchar(15)) 

		If ISNULL(@discount,0) > 0
			Set @sDetailed = @sDetailed + ' -' + CAST(@discount as varchar(15)) 
	END
end
GO
GRANT EXECUTE ON [dbo].[GetServiceCost] TO PUBLIC 
GO
/*********************************************************************/
/* end sp_GetServiceCost.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CalculatePriceList.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CalculatePriceList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CalculatePriceList]
GO
CREATE PROCEDURE [dbo].[CalculatePriceList]
  (
	@nPriceTourKey int,			-- ключ обсчитываемого тура
	@nCalculatingKey int,		-- ключ итерации дозаписи
	@dtSaleDate datetime,		-- дата продажи
	@nNullCostAsZero smallint,	-- считать отсутствующие цены нулевыми (кроме проживания) 0 - нет, 1 - да
	@nNoFlight smallint,		-- при отсутствии перелёта в расписании 0 - ничего не делать, 1 - не обсчитывать тур, 2 - искать подходящий перелёт (если не найдено - не рассчитывать)
	@nUpdate smallint,			-- признак дозаписи 0 - расчет, 1 - дозапись
	@nUseHolidayRule smallint		-- Правило выходного дня: 0 - не использовать, 1 - использовать
  )
AS
--<DATE>2012-02-29</DATE>
---<VERSION>9.2.10.2</VERSION>

--проверяем настройку со страной, если совпала - запускаем новый CalculatePriceList
declare @toCnKey varchar(30), @setting varchar(260),@newpricesetting varchar 

select @toCnKey = rtrim(ltrim(str(to_cnkey))) from tp_tours where to_key = @nPriceTourKey

select @setting = rtrim(ltrim(ss_parmvalue)) from systemsettings where ss_parmname = 'MTDynamicCountries'

select @newpricesetting = SS_ParmValue from systemsettings where ss_parmname = 'NewReCalculatePrice'

if isnull(@newpricesetting,'') = '1'
begin
	if (IsNull(@setting, '') = '' OR exists (select top 1 1 from dbo.ParseKeys(@setting) where xt_key = convert(int, @toCnKey)))
	begin
		exec [dbo].[CalculatePriceListDynamic] @nPriceTourKey,@nCalculatingKey,@dtSaleDate,@nNullCostAsZero,@nNoFlight,@nUpdate,@nUseHolidayRule
		return
	end 
end

declare @variant int
declare @pricetour int
declare @turdate datetime
declare @servicedate datetime
declare @price_brutto money
declare @TrKey int
declare @userKey int
--
declare @nServiceKey int
declare @nSvkey int
declare @nCode int
declare @nSubcode1 int
declare @nSubcode2 int
declare @nPrkey int
declare @nPacketkey int
declare @nDay int
declare @nDays int
declare @sRate varchar(3)
declare @nMen int
declare @nMargin money
declare @nMarginType int
declare @nNetto money
declare @nBrutto money
declare @nDiscount money
declare @nTempGross money
declare @tsCheckMargin smallint
declare @tdCheckMargin smallint
declare @TI_DAYS int
declare @TS_CTKEY int
declare @TS_ATTRIBUTE int
--
declare @SERV_NOTCALCULATE int
--
declare @dtPrevDate datetime
declare @nPrevVariant int
declare @nPrevGross money
declare @nPrevGrossKey int
declare @nPrevGrossDate datetime
declare @nPriceFor smallint
declare @nTP_PriceKeyCurrent int
declare @nTP_PriceKeyMax int
declare @NumPrices int, @NumCalculated int
--
declare @fetchStatus smallint
--declare @nCount int
declare @nDeltaProgress money
declare @nTotalProgress money
declare @round smallint
--
declare @hdKey int
declare @prevHdKey int
--
declare @nProgressSkipLimit smallint
declare @nProgressSkipCounter smallint
declare @weekday varchar(3)
declare @nDateFirst smallint
declare @nFlightEnabled smallint
declare @nCH_Key int
declare @CS_PRKEY int
declare @dDateBeg1 datetime -- дата начала 1го периода
declare @dDateBeg3 datetime -- дата начала 2,3го периода
declare @dDateEnd1 datetime -- дата окончания 1го периода
declare @dDateEnd3 datetime -- дата окончания 2,3го периода
--
declare @sDetailed varchar(100) -- не используется, необходима только для передачи в качестве параметра в GSC
declare @sBadRate varchar(3)
declare @nettoDetail nvarchar(max)
declare @dtBadDate DateTime
--
declare @nSPId int -- возвращается из GSC, фактически это ключ из ServicePrices
declare @nPDId int 
declare @nBruttoWithCommission money

--переменные для разбиения сгруппированных цен
declare @priceDate datetime
declare @priceListKey int
declare @numDates int
declare @priceListGross int
---------------------------------------------
declare @ROUND_NOTWITHDISC int
declare @ROUND_SERVICE_MATH int
declare @ROUND_SERVICE0_5 int
declare @ROUND_PRICE0_5 int
declare @ROUND_SERVICE int
declare @ROUND_PRICE int
declare @ROUND_NOT int

Set @ROUND_NOTWITHDISC = 64
Set @ROUND_SERVICE_MATH = 32
Set @ROUND_SERVICE0_5 = 16
Set @ROUND_PRICE0_5 = 8
Set @ROUND_SERVICE = 4
Set @ROUND_PRICE = 2
Set @ROUND_NOT = 1
---------------------------------------------
declare @nIsEnabled smallint
select @nIsEnabled = TO_IsEnabled from TP_Tours where TO_Key = @nPriceTourKey
---------------------------------------------
declare @tpPricesCount int
declare @isPriceListPluginRecalculation smallint
select @tpPricesCount = count(1) from tp_prices with(nolock) where tp_tokey = @nPriceTourKey

Set @nTotalProgress=1
	update tp_tours with(rowlock) set to_progress = @nTotalProgress, TO_UPDATETIME = GetDate() where to_key = @nPriceTourKey

--осуществляется пересчет прайса планировщиком
if (@tpPricesCount > 0 and @nUpdate = 0)
begin
	set @isPriceListPluginRecalculation = 1
	set @nCalculatingKey = null
	
	select top 1 @nCalculatingKey = CP_Key from CalculatingPriceLists where CP_PriceTourKey = @nPriceTourKey and CP_Update = 0
	update tp_turdates set td_update = 0 where td_tokey = @nPriceTourKey
	update tp_lists set ti_update = 0 where ti_tokey = @nPriceTourKey
	
	set @nUpdate = 0
end
else
	set @isPriceListPluginRecalculation = 0

--if (@nCalculatingKey is null)
--begin
--	select top 1 @nCalculatingKey = CP_Key from CalculatingPriceLists where CP_PriceTourKey = @nPriceTourKey and CP_Update = 0
--	update tp_turdates set td_update = 0 where td_tokey = @nPriceTourKey
--	update tp_lists set ti_update = 0 where ti_tokey = @nPriceTourKey
--end

declare @nSign tinyint

create table #GetServiceCost(
	tid int identity primary key,
	svkey int,
	code int,
	subcode1 int,
	subcode2 int,
	prkey int,
	pkkey int,
	date datetime,
	days int,
	rate varchar(3),
	nmen int,
	margin money,
	marginType int,
	saleDate datetime,
	netto money,
	brutto money,
	discount money,
	details varchar(100),
	badrate varchar(3),
	baddate datetime,
	details2 varchar(100),
	spid int,
	row_sign tinyint
)

create index x_getservicecost on #GetServiceCost(svkey, code, subcode1, subcode2, prkey, pkkey, date, days)

declare @calculatingPriceListsExists smallint -- 0 - CalculatingPriceLists нет, 1 - CalculatingPriceLists есть в базе

BEGIN
	set nocount on

	--koshelev
	--MEG00027550
	if @nUpdate = 0
		update tp_tours with(rowlock) set to_datecreated = GetDate() where to_key = @nPriceTourKey

	select @TrKey = to_trkey, @userKey = to_opkey from tp_tours with(nolock) where to_key = @nPriceTourKey

	delete from CalculatingPriceLists with(rowlock) where CP_PriceTourKey not in (select to_key from tp_tours with(nolock))

	if not exists (select 1 from CalculatingPriceLists with(nolock) where CP_PriceTourKey = @nPriceTourKey) and @nPriceTourKey is not null
	begin	
		insert into CalculatingPriceLists (CP_PriceTourKey, CP_SaleDate, CP_NullCostAsZero, CP_NoFlight, CP_Update, CP_TourKey, CP_UserKey, CP_Status, CP_UseHolidayRule)
		values (@nPriceTourKey, @dtSaleDate, @nNullCostAsZero, @nNoFlight, @nUpdate, @TrKey, @userKey, 1, @nUseHolidayRule)
	end
	else if @nPriceTourKey is not null
	begin
		update CalculatingPriceLists with(rowlock) set CP_Status = 1 where CP_Key = @nCalculatingKey
	end

	DECLARE @sHI_Text varchar(254), @nHIID int
	SELECT @sHI_Text=TO_Name FROM tp_tours with(nolock) where to_key = @nPriceTourKey
	EXEC @nHIID = dbo.InsHistory '', null, 11, @nPriceTourKey, 'INS', @sHI_Text, '', 0, ''

	SET @sHI_Text=CONVERT(varchar(30),@dtSaleDate,104)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11001, null, @sHI_Text, null, null, null, @dtSaleDate, 0
	If @nNullCostAsZero=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11002, null, @sHI_Text, null, @nNullCostAsZero, null, null, 0
	If @nNoFlight=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='Flight search'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11003, null, @sHI_Text, null, @nNoFlight, null, null, 0
	If @nUpdate=0
		SET @sHI_Text='First calculate'
	ELSE
		SET @sHI_Text='Add calculate'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11004, null, @sHI_Text, null, @nUpdate, null, null, 0
	If @nUseHolidayRule = 0
		SET @sHI_Text = 'NO'
	ELSE
		SET @sHI_Text = 'YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11008, null, @sHI_Text, null, @nUpdate, null, null, 0

	--Засекаем время начала рассчета begin
	declare @beginPriceCalculate datetime
	set @beginPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@beginPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11009, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время начала рассчета end
	
	-- koshelev 15.02.2011
	-- для подбора перелетов
	update tp_lists with(rowlock)
	set
		ti_totaldays = (select max(case ts_svkey 
						when 3 
						then ts_day + ts_days 
						else (case ts_days 
							when 0 
							then 1 
							else ts_days 
      							  end) + ts_day - 1 
 						   end)
				from dbo.tp_services with (nolock)
					inner join dbo.tp_servicelists with (nolock) on (tl_tskey = ts_key and TS_TOKey = @nPriceTourKey and TL_TOKey = @nPriceTourKey and (TI_CalculatingKey = @nCalculatingKey or @isPriceListPluginRecalculation = 1))
				where tl_tikey = ti_key)
	where ti_tokey = @nPriceTourKey

	select @nDateFirst = @@DATEFIRST
	set DATEFIRST 1
	set @SERV_NOTCALCULATE = 32768

	If @nUpdate=0
		insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_CalculatingKey, TF_TourDate)
		select distinct TO_Key, TD_Date + TS_Day - 1, TS_Code, TS_OpPartnerKey,
			TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, ti_totaldays, @nCalculatingKey, TD_Date
			From TP_Services with(nolock), TP_TurDates with(nolock), TP_Tours with(nolock), TP_Lists with(nolock), TP_ServiceLists with(nolock)
			where TS_TOKey = TO_Key and TS_SVKey = 1 and TD_TOKey = TO_Key and TI_TOKey = TO_Key and TL_TOKey = TO_Key and TL_TSKey = TS_Key and TL_TIKey = TI_Key and TO_Key = @nPriceTourKey
	Else
	BEGIN
		select distinct TO_Key, TD_Date + TS_Day - 1 flight_day, TS_Code , TS_OpPartnerKey,	TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, ti_totaldays, TD_Date
		into #tp_flights
		from TP_Tours with(nolock) join TP_Services with(nolock) on TO_Key = TS_TOKey and TS_SVKey = 1
			join TP_ServiceLists with(nolock) on TL_TSKey = TS_Key and TS_TOKey = TO_Key
			join TP_Lists with(nolock) on TL_TIKey = TI_Key and TI_TOKey = TO_Key
			join TP_TurDates with(nolock) on TD_TOKey = TO_Key
		where TO_Key = @nPriceTourKey
		
		delete from #tp_flights where exists (Select 1 From TP_Flights with(nolock) Where TF_TOKey=@nPriceTourKey and TF_Date=flight_day
			and TF_CodeOld=TS_Code and TF_PRKeyOld=TS_OpPartnerKey and TF_PKKey=TS_OpPacketKey
			and TF_CTKey=TS_CTKey and TF_SubCode1=TS_SubCode1 and TF_SubCode2=TS_SubCode2 and TF_Days = ti_totaldays)
	
		insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_TourDate, TF_CalculatingKey)
		select *, @nCalculatingKey  from #tp_flights
	END

--------------------------------------- ищем подходящий перелет, если стоит настройка подбора перелета --------------------------------------

	------ проверяем, а подходит ли текущий рейс, указанный в туре ----
	--Update	TP_Flights with(rowlock) Set 	TF_CodeNew = TF_CodeOld,
	--			TF_PRKeyNew = TF_PRKeyOld
	--Where	(SELECT count(*) FROM AirSeason  with(nolock) WHERE AS_CHKey = TF_CodeOld AND TF_Date BETWEEN AS_DateFrom AND AS_DateTo AND AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') > 0 
	--	and TF_TOKey = @nPriceTourKey	
	Update	TP_Flights Set 	TF_CodeNew = TF_CodeOld, TF_PRKeyNew = TF_PRKeyOld, TF_SubCode1New = TF_SubCode1, TF_CalculatingKey = @nCalculatingKey
	Where	exists (SELECT 1 FROM AirSeason WHERE AS_CHKey = TF_CodeOld AND TF_Date BETWEEN AS_DateFrom AND AS_DateTo AND AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%')
			and exists (select 1 from Costs where CS_Code = TF_CodeOld and CS_SVKey = 1 and CS_SubCode1 = TF_Subcode1 and CS_PRKey = TF_PRKeyOld and CS_PKKey = TF_PKKey 
			and TF_Date BETWEEN ISNULL(CS_Date, '1900-01-01') AND ISNULL(CS_DateEnd, '2053-01-01') 
			and TF_TourDate BETWEEN ISNULL(CS_CHECKINDATEBEG, '1900-01-01') AND ISNULL(CS_CHECKINDATEEND, '2053-01-01')
			and (ISNULL(CS_Week, '') = '' or CS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') 
			and (CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long))
			and TF_TOKey = @nPriceTourKey

	If @nNoFlight = 2
	BEGIN
		------ проверяем, а есть ли у данного парнера по рейсу, цены на другие рейсы в этом же пакете ----
		IF exists(SELECT TF_ID FROM TP_Flights with(nolock) WHERE TF_TOKey = @nPriceTourKey and TF_CodeNew is Null)
		begin
			print 'Подбираем перелет'
			
			declare @newFlightsPartnerTable table
			(
				-- идентификатор
				xId int identity(1,1),
				-- ключ услуги перелет
				xTFId int,
				-- ключ исходного партнера
				xPRKey int,
				-- ключ партнера которого подобрали
				xPRKeyNew int,
				-- ключ перелета
				xCHKey int,
				-- ключ тарифа на перелет
				xASKey int
			)
			-- подбираем подходящие нам перелеты
			insert into @newFlightsPartnerTable (xTFId, xCHKey, xASKey, xPRKey, xPRKeyNew)
			SELECT TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			FROM AirSeason with(nolock), Charter with(nolock), Costs with(nolock), TP_Flights with(nolock)
			WHERE CH_CityKeyFrom = TF_Subcode2 and
			CH_CityKeyTo = TF_CTKey and
			CS_Code = CH_Key and
			AS_CHKey = CH_Key and
			CS_SVKey = 1 and
			(	isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = CS_SubCode1), '')
				= 
				isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = TF_Subcode1), '')
			) and
			CS_PKKey = TF_PKKey and
			TF_Date BETWEEN AS_DateFrom and AS_DateTo and
			TF_Date BETWEEN CS_Date and CS_DateEnd and
			AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%' and
			(ISNULL(CS_Week, '') = '' or CS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') and
			(CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long) and
			TF_CodeNew is Null and 
			TF_TOKey = @nPriceTourKey
			group by TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			
			-- удаляем повторяющиеся (если подобралось несколько перелетов)
			delete @newFlightsPartnerTable
			from @newFlightsPartnerTable as a
			where a.xId != (select top 1 b.xId 
							from @newFlightsPartnerTable as b 
							where b.xTFId = a.xTFId
							-- и приорететнее те перелеты в которых партнеры совпадают с исходным
							order by case when b.xPRKey = b.xPRKeyNew then 0 else 1 end)
			
			-- обновляем информацию о найденом перелете
			update TP_Flights with(rowlock)
			set TF_CodeNew = xCHKey,
			TF_SubCode1New = xASKey,
			TF_PRKeyNew = xPRKeyNew,
			TF_CalculatingKey = @nCalculatingKey
			from TP_Flights with(rowlock) join @newFlightsPartnerTable on TF_Id = xTFId
			
			print 'Закончили подбор перелетов'
		end
	END
	-----если перелет так и не найден, то в поле TF_CodeNew будет NULL

	--------------------------------------- закончили поиск подходящего перелета --------------------------------------
	--if ISNULL((select to_update from [dbo].tp_tours with(nolock) where to_key = @nPriceTourKey),0) <> 1
	if (1 = 1)
	BEGIN

		update [dbo].tp_tours with(rowlock) set to_update = 1 where to_key = @nPriceTourKey
		Set @nTotalProgress=4
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	
		--------------------------------------- сохраняем цены во временной таблице --------------------------------------
		CREATE TABLE #TP_Prices
		(
			[xTP_Key] [int] PRIMARY KEY NOT NULL ,
			[xTP_TOKey] [int] NOT NULL ,
			[xTP_DateBegin] [datetime] NOT NULL ,
			[xTP_DateEnd] [datetime] NULL ,
			[xTP_Gross] [money] NULL ,
			[xTP_TIKey] [int] NOT NULL,
			[xTP_CalculatingKey] [int] NULL
		)

		CREATE NONCLUSTERED INDEX [x_fields] ON [#TP_Prices] 
		(
			[xTP_TOKey] ASC,
			[xTP_TIKey] ASC,
			[xTP_DateBegin] ASC,
			[xTP_DateEnd] ASC
		)

		DELETE FROM #TP_Prices
		--INSERT INTO #TP_Prices (xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, xTP_Gross, xTP_TIKey) select tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey from tp_prices where tp_tokey = @nPriceTourKey
		---------------------------------------КОНЕЦ  сохраняем цены во временной таблице --------------------------------------
		

		---------------------------------------разбиваем данные в таблицах tp_prices по датам
		if (select COUNT(TP_Key) from TP_Prices with(nolock) where TP_DateBegin != TP_DateEnd and TP_TOKey = @nPriceTourKey) > 0
		begin
			select @numDates = COUNT(1) from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			exec GetNKeys 'TP_PRICES', @numDates, @nTP_PriceKeyMax output
			set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @numDates + 1
		
			declare datesCursor cursor local fast_forward for
			select TD_Date, TI_Key, TP_Gross from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			
			open datesCursor
			fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			while @@FETCH_STATUS = 0
			begin
				insert into #TP_Prices (xTP_Key, xTP_TOKey, xTP_TIKey, xTP_Gross, xTP_DateBegin, xTP_DateEnd, xTP_CalculatingKey) 
				values (@nTP_PriceKeyCurrent, @nPriceTourKey, @priceListKey, @priceListGross, @priceDate, @priceDate, @nCalculatingKey)
				set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
				fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			end
			
			close datesCursor
			deallocate datesCursor
			
			begin tran tEnd
				delete from TP_Prices with(rowlock) where TP_TOKey = @nPriceTourKey
				
				insert into TP_Prices (TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, TP_CalculatingKey)
				select xTP_Key, xTP_TOKey, xTP_TIKey, xTP_Gross, xTP_DateBegin, xTP_DateEnd, @nCalculatingKey
				from #TP_Prices  
				where xTP_DateBegin = xTP_DateEnd
				
				delete from #TP_Prices
			commit tran tEnd
		end
		--------------------------------------------------------------------------------------
		
		select @TrKey = to_trkey, @nPriceFor = to_pricefor from tp_tours with(nolock) where to_key = @nPriceTourKey

		--смотрим сколько записей по текущему прайсу уже посчитано
		Set @NumCalculated = (SELECT COUNT(1) FROM tp_prices with(nolock) where tp_tokey = @nPriceTourKey)
		--считаем сколько записей надо посчитать
		set @NumPrices = ((select count(1) from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) * (select count(1) from tp_turdates with(nolock) where td_tokey = @nPriceTourKey and td_update = @nUpdate))

		if (@NumCalculated + @NumPrices) = 0
			set @NumPrices = 1

		--Set @nTotalProgress=@nTotalProgress + (CAST(@NumCalculated as money)/CAST((@NumCalculated+@NumPrices) as money) * (90-@nTotalProgress))
		set @nTotalProgress = @nTotalProgress + CAST(@NumCalculated as money) / CAST((@NumCalculated + @NumPrices) as money)
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey

		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN
		update tp_services with(rowlock) set ts_checkmargin = 1 where
		(ts_svkey in (select tm_svkey FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)
		or
		exists(select 1 FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
			and tm_svkey = 0)
		)and ts_tokey = @nPriceTourKey

		update [dbo].tp_turdates with(rowlock) set td_checkmargin = 1 where
			exists(select 1 from TurMargin with(nolock) WHERE TM_TlKey = @TrKey
			and TD_DATE Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)and td_tokey = @nPriceTourKey
		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN

--		update TP_Services set ts_tempgross = null where ts_tokey = @nPriceTourKey
		declare serviceCursor cursor local fast_forward for
			select ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, to_rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_totaldays, ts_ctkey, ts_attribute
			from tp_tours with(nolock), tp_services with(nolock), tp_lists with(nolock), tp_servicelists with(nolock), tp_turdates with(nolock)
			where to_key = @nPriceTourKey and to_key = ts_tokey and to_key = ti_tokey and to_key = tl_tokey and ts_key = tl_tskey and ti_key = tl_tikey and to_key = td_tokey
				and ti_update = @nUpdate and td_update = @nUpdate and (@nUseHolidayRule = 0 or (case cast(datepart(weekday, td_date) as int) when 7 then 0 else cast(datepart(weekday, td_date) as int) end + ti_days) >= 8)
			order by ti_firsthdkey, td_date, ti_key

		open serviceCursor
		SELECT @round = ST_RoundService FROM Setting
		--MEG00036108 увеличил значение
		set @nProgressSkipLimit = 10000

		set @nProgressSkipCounter = 0
		--Set @nTotalProgress = @nTotalProgress + 1
		--update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey

		if @NumPrices <> 0
			set @nDeltaProgress = (95.0-@nTotalProgress) / @NumPrices
		else
			set @nDeltaProgress = 95.0-@nTotalProgress

		exec GetNKeys 'TP_PRICES', @NumPrices, @nTP_PriceKeyMax output
		set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
		set @dtPrevDate = '1899-12-31'
		set @nPrevVariant = -1
		set @nPrevGross = -1
		set @nPrevGrossDate = '1899-12-31'
		set @prevHdKey = -1

		delete from #TP_Prices

		declare @calcPricesCount int, @calcPriceListCount int, @calcTurDates int
		select @calcPriceListCount = COUNT(1) from TP_Lists with(nolock) where TI_TOKey = @nPriceTourKey and TI_UPDATE = @nUpdate
		select @calcTurDates = COUNT(1) from TP_TurDates with(nolock) where TD_TOKey = @nPriceTourKey and TD_UPDATE = @nUpdate
		select @calcPricesCount = @calcPriceListCount * @calcTurDates

		insert into #TP_Prices (xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, xTP_Gross, xTP_TIKey, xTP_CalculatingKey) 
		select tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey, TP_CalculatingKey
		from tp_prices with(nolock)
		where tp_tokey = @nPriceTourKey and 
			tp_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tp_datebegin in (select td_date from tp_turdates with(nolock) where td_tokey = @nPriceTourKey and td_update = @nUpdate)
		

		fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE
		set @fetchStatus = @@fetch_status
		While (@fetchStatus = 0)
		BEGIN
		
			--данных не нашлось, выходим
			if @@fetch_status <> 0 and @nPrevVariant = -1
				break
				
			--очищаем переменные, записываем данные в таблицу #TP_Prices
			if @nPrevVariant <> @variant or @dtPrevDate <> @turdate or @@fetch_status <> 0
			BEGIN
				--записываем данные в таблицу #TP_Prices
				if @nPrevVariant <> -1
				begin
					if @price_brutto is not null
					BEGIN
						exec RoundPriceList @round, @price_brutto output

						if exists(select 1 from #TP_Prices where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant)
						begin
							--select @nCalculatingKey
							if (@isPriceListPluginRecalculation = 0)
								update #TP_Prices set xtp_gross = @price_brutto, xtp_calculatingkey = @nCalculatingKey, xtp_key = @nTP_PriceKeyCurrent where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant
							else
								update #TP_Prices set xtp_gross = @price_brutto, xtp_key = @nTP_PriceKeyCurrent where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant
							set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
						end
						else if (@isPriceListPluginRecalculation = 0)
						begin
							--select @nCalculatingKey
							
							insert into #TP_Prices (xtp_key, xtp_tokey, xtp_datebegin, xtp_dateend, xtp_gross, xtp_tikey, xTP_CalculatingKey) 
							values (@nTP_PriceKeyCurrent, @nPriceTourKey, @dtPrevDate, @dtPrevDate, @price_brutto, @nPrevVariant, @nCalculatingKey)
							
							set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
						end
					END
					ELSE
					BEGIN
						delete from #TP_Prices where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant
					END
				end
			
				--очищаем данные
				if @@fetch_status = 0
				begin
					if @nTP_PriceKeyCurrent > @nTP_PriceKeyMax
					BEGIN
						exec GetNKeys 'TP_PRICES', @NumPrices, @nTP_PriceKeyMax output
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
					END
					
					set @price_brutto = 0
					set @nPrevVariant = @variant
					set @dtPrevDate = @turdate
				end
				
				set @nTotalProgress = @nTotalProgress + @nDeltaProgress
				if @nProgressSkipCounter = @nProgressSkipLimit
				BEGIN
					update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_updatetime = GetDate() where to_key = @nPriceTourKey
					set @nProgressSkipCounter = 0
				END
				else
					set @nProgressSkipCounter = @nProgressSkipCounter + 1
			END

			--переписываем данные в таблицу tp_prices
			if @hdKey <> @prevHdKey or @@fetch_status <> 0
			begin
				set @prevHdKey = @hdKey
			end
			
			if @@fetch_status <> 0
				break
						
			---------------------------------------------------------------------------------

				if @tsCheckMargin = 1 and @tdCheckMargin = 1
					exec GetTourMargin @TrKey, @turdate, @nMargin output, @nMarginType output, @nSvkey, @TI_DAYS, @dtSaleDate, @nPacketkey
				else
				BEGIN
					set @nMargin = 0
					set @nMarginType = 0
				END
				set @servicedate = @turdate + @nDay - 1
				if @nSvkey = 1
					set @nDays = @TI_DAYS

				-- kurskih 2006/10/11
				-- добавил проверку признака нерассчитываемой услуги
				if @TS_ATTRIBUTE & @SERV_NOTCALCULATE = @SERV_NOTCALCULATE
				BEGIN
					set @nNetto = 0
					set @nBrutto = 0
					set @nDiscount = 0
					set @nPDID = 0
				END
				else
				BEGIN

					if @nSvkey = 1
					BEGIN
						SELECT 	@nCode = TF_CodeNew,
								@nPrkey = TF_PRKeyNew,
								@nSubcode1 = TF_SubCode1New
						FROM	TP_Flights with(nolock)
						WHERE	TF_TOKey = @nPriceTourKey AND
								TF_CodeOld = @nCode AND
								TF_PRKeyOld = @nPrkey AND
								TF_Date = @servicedate AND
								TF_Days = @TI_DAYS
					END	
					Set @nSPId = null		
					Set @nBrutto = null	
					if @nCode is not null
					begin
						set @nSign = null

						select
							@nNetto = netto,						
							@nBrutto = brutto,
							@nDiscount = discount,
							@sDetailed = details,
							@sBadRate = badRate,
							@dtBadDate = badDate,
							@sDetailed = details2,
							@nSPId = spid,
							@nSign = row_sign
						from
							#GetServiceCost
						where
							svkey = @nSvkey
							and code = @nCode
							and subcode1 = @nSubcode1
							and subcode2 = @nSubcode2
							and prkey = @nPrkey
							and pkkey = @nPacketkey
							and date = @servicedate
							and days = @nDays
							and rate = @sRate
							and nmen = @nMen
							and margin = @nMargin
							and marginType = @nMarginType
							and saleDate = @dtSaleDate

						if(@nSign is null) -- cost not found
						begin
							exec GetServiceCost @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @servicedate, @nDays,
							@sRate, @nMen, 0, @nMargin, @nMarginType,
							@dtSaleDate, @nNetto output, @nBrutto output, @nDiscount output,
							@nettoDetail output, @sBadRate output, @dtBadDate output,
							@sDetailed output, @nSPId output, 0, @TrKey, @turdate, @TI_DAYS, 1
							
							if @nMen > 1 and @nPriceFor = 0
								set @nBrutto = @nBrutto / @nMen
							if @nBrutto is not null and (@round = @ROUND_SERVICE or @round = @ROUND_SERVICE0_5 or @round = @ROUND_SERVICE_MATH)
								exec RoundPriceList @round, @nBrutto output

							insert into #GetServiceCost(
								svkey,
								code,
								subcode1,
								subcode2,
								prkey,
								pkkey,
								date,
								days,
								rate,
								nmen,
								margin,
								marginType,
								saleDate,
								netto,
								brutto,
								discount,
								details,
								badrate,
								baddate,
								details2,
								spid,
								row_sign)
							values(
								@nSvkey,
								@nCode,
								@nSubcode1,
								@nSubcode2,
								@nPrkey,
								@nPacketkey,
								@servicedate,
								@nDays,
								@sRate,
								@nMen,
								@nMargin,
								@nMarginType,
								@dtSaleDate,
								@nNetto,
								@nBrutto,
								@nDiscount,
								@sDetailed,
								@sBadRate,
								@dtBadDate,
								@sDetailed,
								@nSPId,
								1)
						end
					end
					else
						set @nBrutto = null

					if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey not in (1,3)
						set @nBrutto = 0
					if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey = 1 and @nNoFlight = 0
						set @nBrutto = 0	
		
				END

			set @price_brutto = @price_brutto + @nBrutto
			---------------------------------------------------------------------------------

			fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE
		END
		close serviceCursor
		deallocate serviceCursor

		----------------------------------------------------- возвращаем обратно цены ------------------------------------------------------

		Set @nTotalProgress = 97
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
		
		--удаление из веба
		if (@nIsEnabled = 1)
		begin
			--if (@isPriceListPluginRecalculation = 0)
			--EXEC ClearMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
			--else
			--koshelev временная мера
			EXEC ClearMasterWebSearchFields @nPriceTourKey, null
		end

		delete from tp_prices with(rowlock)
		where tp_tokey = @nPriceTourKey and 
			tp_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tp_DateBegin in (select td_date from TP_TurDates with(nolock) where td_tokey = @nPriceTourKey and TD_Update = @nUpdate)
			
		INSERT INTO TP_Prices with(rowlock) (tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey, TP_CalculatingKey) 
			select xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, xTP_Gross, xTP_TIKey, xTP_CalculatingKey 
			from #TP_Prices 

		-----------------------------------------------------КОНЕЦ возвращаем обратно цены ------------------------------------------------------

		update tp_lists with(rowlock) set ti_update = 0 where ti_tokey = @nPriceTourKey
		update tp_turdates with(rowlock) set td_update = 0, td_checkmargin = 0 where td_tokey = @nPriceTourKey
		Set @nTotalProgress = 99
		update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_update = 0, to_updatetime = GetDate(),
							TO_CalculateDateEnd = GetDate(), TO_PriceCount = (Select Count(*) 
			From TP_Prices with(nolock) Where TP_ToKey = to_key) where to_key = @nPriceTourKey
		update tp_services with(rowlock) set ts_checkmargin = 0 where ts_tokey = @nPriceTourKey

	END

	update CalculatingPriceLists with(rowlock) set CP_Status = 0, CP_CreateDate = GetDate(), CP_StartTime = null where CP_PriceTourKey = @nPriceTourKey
	------------------------------------		

	--Заполнение полей в таблице tp_lists
	declare @toKey int, @add int
	set @toKey = @nPriceTourKey
	set @add = @nUpdate

		update tp_lists with(rowlock)
			set ti_hotelkeys = dbo.mwGetTiHotelKeys(ti_key),
				ti_hotelroomkeys = dbo.mwGetTiHotelRoomKeys(ti_key),
				ti_hoteldays = dbo.mwGetTiHotelNights(ti_key),
				ti_hotelstars = dbo.mwGetTiHotelStars(ti_key),
				ti_pansionkeys = dbo.mwGetTiPansionKeys(ti_key),
				ti_nights = dbo.mwGetTiNights(ti_key)
		where
			ti_tokey = @toKey and ti_CalculatingKey = @nCalculatingKey
		
		update tp_lists with(rowlock)
		set
			ti_hdpartnerkey = ts_oppartnerkey,
			ti_firsthotelpartnerkey = ts_oppartnerkey,
			ti_hdday = ts_day,
			ti_hdnights = ts_days
		from tp_servicelists with (nolock)
			inner join tp_services with (nolock) on (tl_tskey = ts_key and ts_svkey = 3)
		where tl_tikey = ti_key and ts_code = ti_firsthdkey and ti_tokey = @toKey and tl_tokey = @toKey
			and ts_tokey = @toKey and ti_CalculatingKey = @nCalculatingKey
		------------------------------------------------------------------------------

	Set @nTotalProgress = 100
	update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	set DATEFIRST @nDateFirst

	set nocount off

	--Засекаем время окончания рассчета begin
	declare @endPriceCalculate datetime
	set @endPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@endPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11010, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время окончания рассчета end

	--Записываем кол-во рассчитанных цен begin
	SET @sHI_Text = CONVERT(varchar(10),@calcPricesCount)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11011, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем кол-во рассчитанных цен end

	--Записываем скорость расчета цен begin
	declare @calculatingSpeed decimal(10,2), @seconds int
	set @seconds = datediff(ss,@beginPriceCalculate,@endPriceCalculate)
	if @seconds = 0
		set @seconds = 1
	set @calculatingSpeed = @calcPricesCount / @seconds
	SET @sHI_Text = CONVERT(varchar(10),@calculatingSpeed)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11012, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем скорость расчета цен end
	
	if (@nIsEnabled = 1)
	begin
		--if (@isPriceListPluginRecalculation = 0)
		--EXEC FillMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
		--else
		--koshelev временная мера
		EXEC FillMasterWebSearchFields @nPriceTourKey, null
	end

	Return 0
END
GO

SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS ON 
GO

GRANT EXEC ON [dbo].[CalculatePriceList] TO PUBLIC
GO

/*********************************************************************/
/* end sp_CalculatePriceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_FillMasterWebSearchFields.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[FillMasterWebSearchFields]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[FillMasterWebSearchFields]
GO

CREATE procedure [dbo].[FillMasterWebSearchFields](@tokey int, @calcKey int = null, @forceEnable smallint = null, @overwritePrices bit = null)
-- if @forceEnable > 0 (by default) then make call mwEnablePriceTour @calcKey, 1 at the end of the procedure
as
begin
	-- <date>2012-07-17</date>
	-- <version>2009.2.14.1</version>
	set @forceEnable = isnull(@forceEnable, 1)
	
	declare @findByAdultChild int
	
	declare @counter int, @deleteCount int, @params nvarchar(500)
	
	set @findByAdultChild = isnull((select top 1 convert(int, SS_ParmValue) from SystemSettings where SS_ParmName = 'OnlineFindByAdultChild'), 0)

	if (@tokey is null)
	begin
		print 'Procedure does not support NULL param. You must specify @tokey parameter.'
		return
	end

	update dbo.TP_Tours set TO_Progress = 0 where TO_Key = @tokey

	if dbo.mwReplIsSubscriber() > 0
	begin
		--здесь происходит update и delete цен
		if isnull(@calcKey,0) != 0
		begin
		declare @tempSql nvarchar(4000)
		declare @source nvarchar(200)
		declare @tempCountryKey int, @tempCityKey int
		create table #cityKeys
		( cnkey int )	
		set @source = '[mt].[' + ltrim(rtrim(dbo.mwReplPublisherDB())) + '].'
	
		set @tempSql = 
			'select @tempCountryKey = to_cnkey
			 from ' + @source + 'dbo.TP_Tours with(nolock)
			 where to_key = ' + cast(@tokey as varchar)
		 
		EXEC sp_executesql @tempSql, N'@tempCountryKey int OUTPUT',
		@tempCountryKey = @tempCountryKey output; 
	
		set @tempSql = 
			'insert into #citykeys (cnkey)
			 select distinct isnull(ti_ctkeyfrom,0)
			 from ' + @source + 'dbo.TP_lists with(nolock)
			 where ti_key in (select tp_tikey from ' + @source + 'dbo.tp_prices where tp_calculatingkey = ' + cast(@calcKey as varchar) + ')' +
			 ' or ti_key in (select tpd_tikey from '+ @source + 'dbo.tp_pricesdeleted where tpd_calculatingkey = ' + cast(@calcKey as varchar) + ')'
		 
		exec (@tempSql)

		create table #updateTpPrices 
		(tp_key int, tp_gross money)
	
		set @tempSql = 
			'insert into #updateTpPrices (tp_key, tp_gross)
			 select tp_key, tp_gross
			 from ' + @source + 'dbo.TP_Prices with(nolock)
			 where tp_calculatingkey = ' 
			 + cast(@calcKey as varchar) + ' and tp_updatedate is not null'
		 
		exec (@tempSql)
	
		create table #tpKeysForDelete
		(tp_key int)
	
		set @tempSql = 
			'insert into #tpKeysForDelete (tp_key)
			 select tpd_tpkey
			 from ' + @source + 'dbo.TP_PricesDeleted with(nolock)
			 where tpd_calculatingkey = ' 
			 + cast(@calcKey as varchar)
		
		exec (@tempSql)
	
		set @tempSql = 
			'insert into #tpKeysForDelete (tp_key)
			 select PC_TPKEY
			 from ' + @source + 'dbo.TP_PricesCleaner with(nolock)
			 where PC_CalculatingKey = ' 
			 + cast(@calcKey as varchar)
		
		exec (@tempSql)

		set @tempSql = 
			'delete from' + @source + 'dbo.TP_PricesCleaner
			 where PC_CalculatingKey = ' 
			 + cast(@calcKey as varchar)
		
		exec (@tempSql)
	
		declare @tempPriceTableName varchar (200)
	
		declare curr cursor for select cnkey from #cityKeys
		OPEN curr
	    FETCH NEXT FROM curr INTO @tempCityKey
	    WHILE @@FETCH_STATUS = 0
		begin
	
		set @tempPriceTableName = dbo.mwGetPriceTableName(@tempCountryKey, @tempCityKey)
	
		/*set @tempSql = 
			'update ' + @tempPriceTableName + ', #updateTpPrices 
			 set pt_price = tp_gross
			 where pt_pricekey = tp_key'*/
		set @tempSql = 'update ' + @tempPriceTableName + ' set pt_price = (select tp_gross from #updateTpPrices where tp_key = pt_pricekey)'
		+ ' where pt_pricekey in (select tp_key from #updateTpPrices)'
		 
		exec (@tempSql)
	
		set @tempSql = 
			'delete ' + @tempPriceTableName + 
			' where pt_pricekey in (select tp_key from #tpKeysForDelete)'
		
		--print @tempSql
		--return
	
		exec (@tempSql)
	
		FETCH NEXT FROM curr INTO @tempCityKey
		end
	
		CLOSE curr
		DEALLOCATE curr
	
		drop table #cityKeys
		drop table #updateTpPrices
		drop table #tpKeysForDelete
		end
		--конец удаления и апдейта

		exec dbo.mwFillTP @tokey, @calcKey
	end

	create table #tmpHotelData (
		thd_tourkey int, 
		thd_firsthdkey int,
		thd_firstpnkey int, 
		thd_cnkey int, 
		thd_tlkey int, 
		thd_isenabled smallint, 
		thd_tourcreated datetime, 
		thd_hdstars nvarchar(15), 
		thd_ctkey int, 
		thd_rskey int, 
		thd_hdkey int, 
		thd_hdpartnerkey int, 
		thd_hrkey int, 
		thd_rmkey int, 
		thd_rckey int, 
		thd_ackey int, 
		thd_pnkey int, 
		thd_hdmain smallint,
		thd_firsthotelday int,
		thd_ctkeyfrom int, 
		thd_ctkeyto int, 
		thd_apkeyfrom int, 
		thd_apkeyto int,
		thd_tourtype int,
		thd_cnname nvarchar(200) collate database_default,
		thd_tourname nvarchar(200) collate database_default,
		thd_hdname nvarchar(200) collate database_default,
		thd_ctname nvarchar(200) collate database_default,
		thd_rsname nvarchar(200) collate database_default,
		thd_ctfromname nvarchar(200) collate database_default,
		thd_cttoname nvarchar(200) collate database_default,
		thd_tourtypename nvarchar(200) collate database_default,
		thd_pncode nvarchar(50) collate database_default,
		thd_hdorder int,
		thd_hotelkeys nvarchar(256) collate database_default,
		thd_pansionkeys nvarchar(256) collate database_default,
		thd_hotelnights nvarchar(256) collate database_default,
		thd_tourvalid datetime,
		thd_hotelurl varchar(254) collate database_default
	)

	-- создадим темповую ценовую таблицу
	select top 1 * into #tempPriceTable from mwPriceDataTable with(nolock)
	truncate table #tempPriceTable
	
	
	CREATE NONCLUSTERED INDEX [x_main] ON [dbo].[#tempPriceTable] 
	(
		pt_tourdate asc,
		pt_hdkey asc,
		pt_rmkey asc,
		pt_rckey asc,
		pt_ackey asc,
		pt_pnkey asc,
		pt_days asc,
		pt_nights asc,
		pt_tourtype asc,
		pt_ctkeyfrom asc
	)

	select top 1
		ti_key,
		ti_tokey,
		ti_firsthdkey,
		ti_firstpnkey,
		ti_firsthrkey,
		ti_firsthotelday,
		ti_lasthotelday,
		ti_totaldays,
		ti_nights,
		ti_hotelkeys,
		ti_hotelroomkeys,
		ti_hoteldays,
		ti_hotelstars,
		ti_pansionkeys,
		ti_hdpartnerkey,
		ti_firsthotelpartnerkey,
		ti_hdday,
		ti_hdnights,
		ti_chkey,
		ti_chday,
		ti_chpkkey,
		ti_chprkey,
		ti_ctkeyfrom,
		ti_chbackkey,
		ti_chbackday,
		ti_chbackpkkey,
		ti_chbackprkey,
		ti_ctkeyto,
		ti_apkeyfrom,
		ti_apkeyto,
		ti_firstctkey,
		ti_firstrskey,
		ti_firsthdstars
	into #tp_lists
	from tp_lists with(nolock)

	truncate table #tp_lists
	alter table #tp_lists add primary key(ti_key)

	if(@calcKey is not null)
	begin
		insert into #tp_lists
		select
			ti_key,
			ti_tokey,
			ti_firsthdkey,
			ti_firstpnkey,
			ti_firsthrkey,
			ti_firsthotelday,
			ti_lasthotelday,
			ti_totaldays,
			ti_nights,
			ti_hotelkeys,
			ti_hotelroomkeys,
			ti_hoteldays,
			ti_hotelstars,
			ti_pansionkeys,
			ti_hdpartnerkey,
			ti_firsthotelpartnerkey,
			ti_hdday,
			ti_hdnights,
			ti_chkey,
			ti_chday,
			ti_chpkkey,
			ti_chprkey,
			ti_ctkeyfrom,
			ti_chbackkey,
			ti_chbackday,
			ti_chbackpkkey,
			ti_chbackprkey,
			ti_ctkeyto,
			ti_apkeyfrom,
			ti_apkeyto,
			ti_firstctkey,
			ti_firstrskey,
			ti_firsthdstars
		from tp_lists with(nolock)
		where TI_CalculatingKey = @calcKey
	end
	else
	begin
		insert into #tp_lists
		select
			ti_key,
			ti_tokey,
			ti_firsthdkey,
			ti_firstpnkey,
			ti_firsthrkey,
			ti_firsthotelday,
			ti_lasthotelday,
			ti_totaldays,
			ti_nights,
			ti_hotelkeys,
			ti_hotelroomkeys,
			ti_hoteldays,
			ti_hotelstars,
			ti_pansionkeys,
			ti_hdpartnerkey,
			ti_firsthotelpartnerkey,
			ti_hdday,
			ti_hdnights,
			ti_chkey,
			ti_chday,
			ti_chpkkey,
			ti_chprkey,
			ti_ctkeyfrom,
			ti_chbackkey,
			ti_chbackday,
			ti_chbackpkkey,
			ti_chbackprkey,
			ti_ctkeyto,
			ti_apkeyfrom,
			ti_apkeyto,
			ti_firstctkey,
			ti_firstrskey,
			ti_firsthdstars
		from tp_lists with(nolock)
		where TI_TOKey = @tokey		
	end

	declare @mwAccomodationPlaces nvarchar(254)
	declare @mwRoomsExtraPlaces nvarchar(254)
	declare @mwSearchType int
	declare @sql nvarchar(4000)
	declare @countryKey int
	declare @cityFromKey int

	declare @firsthdday int
	select @firsthdday = (select min(ts_day) 
				from tp_services with (nolock)
 				where ts_svkey = 3 and ts_tokey = @tokey)

	update #tp_lists with(rowlock)
	set
		ti_firsthotelday = @firsthdday

	update dbo.TP_Tours with(rowlock) set TO_Progress = 7 where TO_Key = @tokey

	update TP_Tours with(rowlock) set TO_MinPrice = (
			select min(TP_Gross) 
			from TP_Prices with(nolock) 
				left join TP_Lists with(nolock) on ti_key = tp_tikey
				left join HotelRooms with(nolock) on hr_key = ti_firsthrkey
				
			where TP_TOKey = TO_Key and hr_main > 0 and isnull(HR_AGEFROM, 100) > 16
		)
		where TO_Key = @tokey

	update dbo.TP_Tours with(rowlock) set TO_Progress = 13 where TO_Key = @tokey

	update #tp_lists with(rowlock)
	set
		ti_lasthotelday = (select max(ts_day)
				from tp_servicelists  with (nolock)
					inner join tp_services with (nolock) on tl_tskey = ts_key
				where tl_tikey = ti_key and ts_svkey = 3 and TS_TOKey = @tokey and TL_TOKey = @tokey)

	update dbo.TP_Tours with(rowlock) set TO_Progress = 20 where TO_Key = @tokey

	update #tp_lists with(rowlock)
	set
		ti_totaldays = (select max(case ts_svkey 
						when 3 
						then ts_day + ts_days 
						else (case ts_days 
							when 0 
							then 1 
							else ts_days 
      							  end) + ts_day - 1 
 						   end)
				from dbo.tp_services with (nolock)
					inner join dbo.tp_servicelists with (nolock) on (tl_tskey = ts_key and TS_TOKey = @tokey and TL_TOKey = @tokey)
				where tl_tikey = ti_key)

	update dbo.TP_Tours with(rowlock) set TO_Progress = 30 where TO_Key = @tokey

	-- MEG00024548 Paul G 11.01.2009
	-- изменил логику подсчёта кол-ва ночей в туре
	-- раньше было сумма ночей проживания по всем отелям в туре
	-- теперь если проживания пересекаются, лишние ночи не суммируются
	update #tp_lists with(rowlock)
	set
		ti_nights = dbo.mwGetTiNights(ti_key)

	--koshelev
	--02.04.2012 MEG00040744
    declare @result nvarchar(256)
    set @result = N''
    select @result = @result + rtrim(ltrim(str(tbl.ti_nights))) + N', ' from (select distinct ti_nights from (select ti_nights from #tp_lists union select ti_nights from tp_lists where ti_tokey = @tokey ) as tbl2) tbl order by tbl.ti_nights
    declare @len int
    set @len = len(@result)
    if(@len > 0)
          set @result = substring(@result, 1, @len - 1)

    update TP_Tours with(rowlock) set TO_HotelNights = @result where TO_Key = @tokey

	update dbo.TP_Tours with(rowlock) set TO_Progress = 40 where TO_Key = @tokey

	update #tp_lists with(rowlock)
		set ti_hotelkeys = dbo.mwGetTiHotelKeys(ti_key),
			ti_hotelroomkeys = dbo.mwGetTiHotelRoomKeys(ti_key),
			ti_hoteldays = dbo.mwGetTiHotelNights(ti_key),
			ti_hotelstars = dbo.mwGetTiHotelStars(ti_key),
			ti_pansionkeys = dbo.mwGetTiPansionKeys(ti_key)

	update #tp_lists with(rowlock)
	set
		ti_hdpartnerkey = ts_oppartnerkey,
		ti_firsthotelpartnerkey = ts_oppartnerkey,
		ti_hdday = ts_day,
		ti_hdnights = ts_days
	from tp_servicelists with (nolock)
		inner join tp_services with (nolock) on (tl_tskey = ts_key and ts_svkey = 3)
	where tl_tikey = ti_key and ts_code = ti_firsthdkey and TS_TOKey = @tokey and TL_TOKey = @tokey

	-- Город отправления из свойств тура
	declare @ctdeparturekey int
	select	@ctdeparturekey = tl_ctdeparturekey
	from	tp_tours with(nolock)
		inner join tbl_turList with(nolock) on tbl_turList.tl_key = to_trkey
	where to_key = @tokey

	if (@ctdeparturekey is null or @ctdeparturekey = 0)
	begin
		-- Подбираем город вылета первого рейса
		exec GetCityDepartureKey @tokey, @ctdeparturekey output
	end

	-- город вылета
	update #tp_lists with(rowlock)
	set 
		ti_chkey = (select top 1 ts_code
			from tp_servicelists with(nolock) 
				inner join tp_services with(nolock) on tl_tskey = ts_key and ts_svkey = 1
			where tl_tikey = ti_key and ts_tokey = @tokey and tl_tokey = @tokey 
				and (ts_day <= ti_firsthotelday or (ts_day = 1 and ti_firsthotelday = 0)) and ts_subcode2 = @ctdeparturekey)

	update dbo.TP_Tours with(rowlock) set TO_Progress = 50 where TO_Key = @tokey

	-- город вылета + прямой перелет
	update #tp_lists with(rowlock)
	set 
		ti_chday = ts_day,
		ti_chpkkey = ts_oppacketkey,
		ti_chprkey = ts_oppartnerkey
	from tp_servicelists with(nolock) inner join tp_services with(nolock) on tl_tskey = ts_key and ts_svkey = 1
	where	tl_tikey = ti_key 
		and (ts_day <= ti_firsthotelday or (ts_day = 1 and ti_firsthotelday = 0))
		and ts_code = ti_chkey 
		and ts_subcode2 = @ctdeparturekey
		and TS_TOKey = @tokey and TL_TOKey = @tokey

	update #tp_lists with(rowlock)
	set 
		ti_ctkeyfrom = @ctdeparturekey

	-- Проверка наличия перелетов в город вылета
	declare @existBackCharter smallint
	select	@existBackCharter = count(ts_key)
	from	tp_services
	where	ts_tokey = @tokey
		and	ts_svkey = 1
		and ts_ctkey = @ctdeparturekey

	-- город прилета + обратный перелет
	update #tp_lists with(rowlock) 
	set 
		ti_chbackkey = ts_code,
		ti_chbackday = ts_day,
		ti_chbackpkkey = ts_oppacketkey,
		ti_chbackprkey = ts_oppartnerkey,
		ti_ctkeyto = ts_subcode2
	from tp_servicelists with(nolock)
		inner join tp_services with(nolock) on (tl_tskey = ts_key and ts_svkey = 1)
		inner join tp_tours with(nolock) on ts_tokey = to_key 
	where 
		tl_tikey = ti_key 
		and ts_day > ti_lasthotelday
		and (ts_ctkey = @ctdeparturekey or @existBackCharter = 0)
		and TI_TOKey = @tokey
		and TS_TOKey = @tokey and TL_TOKey = @tokey

	-- _ключ_ аэропорта вылета
	update #tp_lists with(rowlock)
	set 
		ti_apkeyfrom = (select top 1 ap_key from airport with(nolock), charter with(nolock) 
				where ch_portcodefrom = ap_code 
					and ch_key = ti_chkey)

	-- _ключ_ аэропорта прилета
	update #tp_lists with(rowlock)
	set 
		ti_apkeyto = (select top 1 ap_key from airport with(nolock), charter with(nolock) 
				where ch_portcodefrom = ap_code 
					and ch_key = ti_chbackkey)

	-- ключ города и ключ курорта + звезды
	update #tp_lists with(rowlock)
	set
		ti_firstctkey = hd_ctkey,
		ti_firstrskey = hd_rskey,
		ti_firsthdstars = hd_stars
	from hoteldictionary with(nolock)
	where 
		ti_firsthdkey = hd_key

	update dbo.TP_Tours with(rowlock) set TO_Progress = 60 where TO_Key = @tokey

	if dbo.mwReplIsPublisher() > 0
	begin
		declare @trkey int
		select @trkey = to_trkey from dbo.tp_tours with(nolock) where to_key = @tokey
		
		insert into dbo.mwReplTours with(rowlock) (rt_trkey, rt_tokey, rt_date, rt_CalcKey)
		values (@trkey, @tokey, getdate(), @calcKey)
		
		update CalculatingPriceLists with(rowlock) set CP_Status = 0 where CP_PriceTourKey = @tokey
		update dbo.TP_Tours with(rowlock) 
		set TO_Update = 0, 
			TO_Progress = 100,
			TO_IsEnabled = 1
		where TO_Key = @tokey
		
		--return
	end

	-- временная таблица с информацией об отелях
	insert into #tmpHotelData (
		thd_tourkey, 
		thd_firsthdkey, 
		thd_firstpnkey, 
		thd_cnkey, 
		thd_tlkey, 
		thd_isenabled, 
		thd_tourcreated, 
		thd_hdstars, 
		thd_ctkey, 
		thd_rskey, 
		thd_hdkey, 
		thd_hdpartnerkey, 
		thd_hrkey, 
		thd_rmkey, 
		thd_rckey, 
		thd_ackey, 
		thd_pnkey, 
		thd_hdmain,
		thd_firsthotelday,
		thd_ctkeyfrom, 
		thd_ctkeyto, 
		thd_apkeyfrom, 
		thd_apkeyto,
		thd_tourtype,
		thd_cnname,
		thd_tourname,
		thd_hdname,
		thd_ctname,
		thd_rsname,
		thd_ctfromname,
		thd_cttoname,
		thd_tourtypename,
		thd_pncode,
		thd_hotelkeys,
		thd_pansionkeys,
		thd_hotelnights,
		thd_tourvalid,
		thd_hotelurl
	)
	select distinct 
		to_key, 
		ti_firsthdkey, 
		ti_firstpnkey,
		to_cnkey, 
		to_trkey, 
		@forceEnable, 
		to_datecreated, 
		hd_stars, 
		hd_ctkey, 
		hd_rskey, 
		ts_code, 
		ts_oppartnerkey, 
		ts_subcode1, 
		hr_rmkey, 
		hr_rckey, 
		hr_ackey, 
		ts_subcode2, 
		(case ts_code when ti_firsthdkey then 1 else 0 end),
		ti_firsthotelday,
		isnull(ti_ctkeyfrom, 0), 
		ti_ctkeyto, 
		ti_apkeyfrom, 
		ti_apkeyto,
		tl_tip,
		cn_name,
		isnull(tl_nameweb, isnull(to_name, tl_name)),
		hd_name,
		ct_name,
		null,
		null,
		null,
		tp_name,
		pn_code,
		ti_hotelkeys,
		ti_pansionkeys,
		ti_hoteldays,
		to_datevalid,
		hd_http
	from #tp_lists with(nolock)
		inner join tp_tours with(nolock) on ti_tokey = to_key
		inner join tp_servicelists with(nolock) on tl_tikey = ti_key 
		inner join tp_services with(nolock) on (tl_tskey = ts_key and ts_svkey = 3) 
		inner join hoteldictionary with(nolock) on ts_code = hd_key
		inner join hotelrooms with(nolock) on hr_key = ts_subcode1
		inner join turList with(nolock) on turList.tl_key = to_trkey
		inner join country with(nolock) on cn_key = to_cnkey
		inner join citydictionary with(nolock) on ct_key = hd_ctkey
		inner join tiptur with(nolock) on tp_key = tl_tip
		inner join pansion with(nolock) on pn_key = ts_subcode2
	where to_key = @tokey and to_datevalid >= getdate() 
		and TS_TOKey = @tokey and TL_TOKey = @tokey

	update #tmpHotelData set thd_hdorder = (select min(ts_day) from tp_services with(nolock) where ts_tokey = thd_tourkey and ts_svkey = 3 and ts_code = thd_hdkey)
	update #tmpHotelData set thd_rsname = rs_name from resorts with(nolock) where rs_key = thd_rskey
	update #tmpHotelData set thd_ctfromname = ct_name from citydictionary with(nolock) where ct_key = thd_ctkeyfrom
	update #tmpHotelData set thd_ctfromname = '-Без перелета-' where thd_ctkeyfrom = 0
	update #tmpHotelData set thd_cttoname = ct_name from citydictionary with(nolock) where ct_key = thd_ctkeyto
	update #tmpHotelData set thd_cttoname = '-Без перелета-' where thd_ctkeyto = 0
	--

	update dbo.TP_Tours set TO_Progress = 70 where TO_Key = @tokey

	select @mwAccomodationPlaces = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings with(nolock)
	where SS_ParmName = 'MWAccomodationPlaces'

	select @mwRoomsExtraPlaces = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWRoomsExtraPlaces'

	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'

	if (@calcKey is null)
	begin
		delete from dbo.mwSpoDataTable with(rowlock) where sd_tourkey = @tokey
		delete from dbo.mwPriceHotels with(rowlock) where sd_tourkey = @tokey
		delete from dbo.mwPriceDurations with(rowlock) where sd_tourkey = @tokey
	end

	--MEG00026692 Paul G 25.03.2010
	--функции от ti_key должны вызываться на каждую запись из tp_lists
	--поэтому результаты их выполнения записываю в темповую таблицу
	--которую джоиню в последующем селекте
	create table #tempTourInfo (
		tt_tikey int,
		tt_charterto varchar(256) collate database_default,
		tt_charterback varchar(256) collate database_default,
		tt_tourhotels varchar(256) collate database_default,
		tt_directFlightAttribute int,
		tt_backFlightAttribute int
	)

	insert into #tempTourInfo
	(
		tt_tikey, 
		tt_charterto, 
		tt_charterback, 
		tt_tourhotels,
		tt_directFlightAttribute,
		tt_backFlightAttribute
	)
	select 
		ti_key, 
		dbo.mwGetTourCharters(ti_key, 1), 
		dbo.mwGetTourCharters(ti_key, 0), 
		dbo.mwGetTourHotels(ti_key),
		dbo.mwGetTourCharterAttribute(ti_key, 1),
		dbo.mwGetTourCharterAttribute(ti_key, 0)
	from #tp_lists with(nolock)
	--End MEG00026692	

	if(@calcKey is not null)
	begin
		insert into #tempPriceTable (
			[pt_mainplaces],
			[pt_addplaces],
			[pt_main],
			[pt_tourvalid],
			[pt_tourcreated],
			[pt_tourdate],
			[pt_days],
			[pt_nights],
			[pt_cnkey],
			[pt_ctkeyfrom],
			[pt_apkeyfrom],
			[pt_ctkeyto],
			[pt_apkeyto],
			[pt_ctkeybackfrom],
			[pt_ctkeybackto],
			[pt_tourkey],
			[pt_tourtype],
			[pt_tlkey],
			[pt_pricelistkey],
			[pt_pricekey],
			[pt_price],
			[pt_hdkey],
			[pt_hdpartnerkey],
			[pt_rskey],
			[pt_ctkey],
			[pt_hdstars],
			[pt_pnkey],
			[pt_hrkey],
			[pt_rmkey],
			[pt_rckey],
			[pt_ackey],
			[pt_childagefrom],
			[pt_childageto],
			[pt_childagefrom2],
			[pt_childageto2],
			[pt_hdname],
			[pt_tourname],
			[pt_pnname],
			[pt_pncode],
			[pt_rmname],
			[pt_rmcode],
			[pt_rcname],
			[pt_rccode],
			[pt_acname],
			[pt_accode],
			[pt_rsname],
			[pt_ctname],
			[pt_rmorder],
			[pt_rcorder],
			[pt_acorder],
			[pt_rate],
			[pt_toururl],
			[pt_hotelurl],
			[pt_isenabled],
			[pt_chkey],
			[pt_chbackkey],
			[pt_hdday],
			[pt_hdnights],
			[pt_chday],
			[pt_chpkkey],
			[pt_chprkey],
			[pt_chbackday],
			[pt_chbackpkkey],
			[pt_chbackprkey],
			pt_hotelkeys,
			pt_hotelroomkeys,
			pt_hotelstars,
			pt_pansionkeys,
			pt_hotelnights,
			pt_chdirectkeys,
			pt_chbackkeys,
			[pt_topricefor],
			pt_tlattribute,
			pt_hddetails,
			pt_directFlightAttribute,
			pt_backFlightAttribute
		)
		select 
				(	case when @mwAccomodationPlaces = '0'
					then isnull(rm_nplaces, 0)
					else (	case when @findByAdultChild = 1 -- искать по взрослым
							then isnull(AC_NADMAIN, 0) + isnull(AC_NADEXTRA,0)
							-- искать по основным
							else isnull(AC_NADMAIN, 0) + isnull(AC_NCHMAIN, 0)
							end)
					end),
				(	case when isnull(ac_nmenexbed, -1) = -1
					then (	case when @mwRoomsExtraPlaces <> '0' 
							then isnull(rm_nplacesex, 0)
							else isnull(ac_nmenexbed, 0)
							end)
					else (	case when @findByAdultChild = 1 -- искать по детям
							then isnull(AC_NCHMAIN, 0) + isnull(AC_NCHEXTRA, 0)
							-- искать по дополнительным местам
							else isnull(AC_NADEXTRA, 0) + isnull(AC_NCHEXTRA, 0)
							end)
					end),
			hr_main, 
			to_datevalid, 
			to_datecreated, 
			td_date,
			ti_totaldays,
			ti_nights,
			to_cnkey, 
			isnull(ti_ctkeyfrom, 0), 
			ti_apkeyfrom,
			ti_ctkeyto, 
			ti_apkeyto, 
			null,
			null,
			to_key, 
			tl_tip,
			tl_key, 
			ti_key, 
			tp_key,
			tp_gross, 
			ti_firsthdkey, 
			ti_hdpartnerkey,
			hd_rskey, 
			hd_ctkey, 
			hd_stars, 
			ti_firstpnkey,
			ti_firsthrkey, 
			hr_rmkey, 
			hr_rckey, 
			hr_ackey,
			ac_agefrom, 
			ac_ageto, 
			ac_agefrom2,
			ac_ageto2, 
			hd_name, 
			substring(tl_nameweb,1,128), 
			pn_name, 
			pn_code, 
			rm_name, 
			rm_code,
			rc_name, 
			rc_code, 
			ac_name, 
			ac_code, 
			rs_name,
			ct_name, 
			rm_order, 
			rc_order, 
			ac_order,
			to_rate,
			tl_webhttp,
			hd_http, 
			@forceEnable,
			ti_chkey,
			ti_chbackkey,
			ti_hdday,
			ti_hdnights,
			ti_chday,
			ti_chpkkey,
			ti_chprkey,
			ti_chbackday,
			ti_chbackpkkey,
			ti_chbackprkey,
			ti_hotelkeys,
			ti_hotelroomkeys,
			ti_hotelstars,
			ti_pansionkeys,
			ti_hoteldays,
			tt_charterto,
			tt_charterback,
			to_pricefor,
			tl_attribute,
			tt_tourhotels,
			tt_directFlightAttribute,
			tt_backFlightAttribute
		from tp_tours with(nolock)
			inner join turList with(nolock) on to_trkey = tl_key
			inner join #tp_lists with(nolock) on ti_tokey = to_key
			inner join tp_prices with(nolock) on tp_tikey = ti_key
			inner join tp_turdates with(nolock) on (td_tokey = to_key and td_date between tp_datebegin and tp_dateend)
			inner join hoteldictionary with(nolock) on ti_firsthdkey = hd_key
			inner join hotelrooms with(nolock) on ti_firsthrkey = hr_key
			inner join pansion with(nolock) on ti_firstpnkey = pn_key
			inner join rooms with(nolock) on hr_rmkey = rm_key
			inner join roomscategory with(nolock) on hr_rckey = rc_key
			inner join accmdmentype with(nolock) on hr_ackey = ac_key
			inner join citydictionary with(nolock) on hd_ctkey = ct_key
			left outer join resorts with(nolock) on hd_rskey = rs_key
			inner join #tempTourInfo on tt_tikey = ti_key
		where
			to_key = @tokey and TP_CalculatingKey = @calcKey
	end
	else
	begin
		insert into #tempPriceTable (
			[pt_mainplaces],
			[pt_addplaces],
			[pt_main],
			[pt_tourvalid],
			[pt_tourcreated],
			[pt_tourdate],
			[pt_days],
			[pt_nights],
			[pt_cnkey],
			[pt_ctkeyfrom],
			[pt_apkeyfrom],
			[pt_ctkeyto],
			[pt_apkeyto],
			[pt_ctkeybackfrom],
			[pt_ctkeybackto],
			[pt_tourkey],
			[pt_tourtype],
			[pt_tlkey],
			[pt_pricelistkey],
			[pt_pricekey],
			[pt_price],
			[pt_hdkey],
			[pt_hdpartnerkey],
			[pt_rskey],
			[pt_ctkey],
			[pt_hdstars],
			[pt_pnkey],
			[pt_hrkey],
			[pt_rmkey],
			[pt_rckey],
			[pt_ackey],
			[pt_childagefrom],
			[pt_childageto],
			[pt_childagefrom2],
			[pt_childageto2],
			[pt_hdname],
			[pt_tourname],
			[pt_pnname],
			[pt_pncode],
			[pt_rmname],
			[pt_rmcode],
			[pt_rcname],
			[pt_rccode],
			[pt_acname],
			[pt_accode],
			[pt_rsname],
			[pt_ctname],
			[pt_rmorder],
			[pt_rcorder],
			[pt_acorder],
			[pt_rate],
			[pt_toururl],
			[pt_hotelurl],
			[pt_isenabled],
			[pt_chkey],
			[pt_chbackkey],
			[pt_hdday],
			[pt_hdnights],
			[pt_chday],
			[pt_chpkkey],
			[pt_chprkey],
			[pt_chbackday],
			[pt_chbackpkkey],
			[pt_chbackprkey],
			pt_hotelkeys,
			pt_hotelroomkeys,
			pt_hotelstars,
			pt_pansionkeys,
			pt_hotelnights,
			pt_chdirectkeys,
			pt_chbackkeys,
			[pt_topricefor],
			pt_tlattribute,
			pt_hddetails,
			pt_directFlightAttribute,
			pt_backFlightAttribute
		)
		select
				(	case when @mwAccomodationPlaces = '0'
					then isnull(rm_nplaces, 0)
					else (	case when @findByAdultChild = 1 -- искать по взрослым
							then isnull(AC_NADMAIN, 0) + isnull(AC_NADEXTRA,0)
							-- искать по основным
							else isnull(AC_NADMAIN, 0) + isnull(AC_NCHMAIN, 0)
							end)
					end),
				(	case when isnull(ac_nmenexbed, -1) = -1
					then (	case when @mwRoomsExtraPlaces <> '0' 
							then isnull(rm_nplacesex, 0)
							else isnull(ac_nmenexbed, 0)
							end)
					else (	case when @findByAdultChild = 1 -- искать по детям
							then isnull(AC_NCHMAIN, 0) + isnull(AC_NCHEXTRA, 0)
							-- искать по дополнительным местам
							else isnull(AC_NADEXTRA, 0) + isnull(AC_NCHEXTRA, 0)
							end)
					end),
			hr_main, 
			to_datevalid, 
			to_datecreated, 
			td_date,
			ti_totaldays,
			ti_nights,
			to_cnkey, 
			isnull(ti_ctkeyfrom, 0), 
			ti_apkeyfrom,
			ti_ctkeyto, 
			ti_apkeyto, 
			null,
			null,
			to_key, 
			tl_tip,
			tl_key, 
			ti_key, 
			tp_key,
			tp_gross, 
			ti_firsthdkey, 
			ti_hdpartnerkey,
			hd_rskey, 
			hd_ctkey, 
			hd_stars, 
			ti_firstpnkey,
			ti_firsthrkey, 
			hr_rmkey, 
			hr_rckey, 
			hr_ackey,
			ac_agefrom, 
			ac_ageto, 
			ac_agefrom2,
			ac_ageto2, 
			hd_name, 
			substring(tl_nameweb,1,128), 
			pn_name, 
			pn_code, 
			rm_name, 
			rm_code,
			rc_name, 
			rc_code, 
			ac_name, 
			ac_code, 
			rs_name,
			ct_name, 
			rm_order, 
			rc_order, 
			ac_order,
			to_rate,
			tl_webhttp,
			hd_http, 
			@forceEnable,
			ti_chkey,
			ti_chbackkey,
			ti_hdday,
			ti_hdnights,
			ti_chday,
			ti_chpkkey,
			ti_chprkey,
			ti_chbackday,
			ti_chbackpkkey,
			ti_chbackprkey,
			ti_hotelkeys,
			ti_hotelroomkeys,
			ti_hotelstars,
			ti_pansionkeys,
			ti_hoteldays,
			tt_charterto,
			tt_charterback,
			to_pricefor,
			tl_attribute,
			tt_tourhotels,
			tt_directFlightAttribute,
			tt_backFlightAttribute
		from tp_tours with(nolock)
			inner join turList with(nolock) on to_trkey = tl_key
			inner join #tp_lists with(nolock) on ti_tokey = to_key
			inner join tp_prices with(nolock) on tp_tikey = ti_key
			inner join tp_turdates with(nolock) on (td_tokey = to_key and td_date between tp_datebegin and tp_dateend)
			inner join hoteldictionary with(nolock) on ti_firsthdkey = hd_key
			inner join hotelrooms with(nolock) on ti_firsthrkey = hr_key
			inner join pansion with(nolock) on ti_firstpnkey = pn_key
			inner join rooms with(nolock) on hr_rmkey = rm_key
			inner join roomscategory with(nolock) on hr_rckey = rc_key
			inner join accmdmentype with(nolock) on hr_ackey = ac_key
			inner join citydictionary with(nolock) on hd_ctkey = ct_key
			left outer join resorts with(nolock) on hd_rskey = rs_key
			inner join #tempTourInfo on tt_tikey = ti_key
		where
			to_key = @tokey and TP_TOKey = @tokey
	end	

	--чтобы не перевыставлялись удаленные цены при выставлении тура в он-лайн
	update #tempPriceTable set pt_isenabled = 0 where exists (select 1 from mwdeleted with (nolock) where del_key = pt_pricekey)

	update dbo.TP_Tours set TO_Progress = 80 where TO_Key = @tokey
	
	if dbo.mwReplIsPublisher() <= 0
	begin
		insert into dbo.mwPriceDurations with(rowlock) (
			sd_tourkey,
			sd_tlkey,
			sd_days,
			sd_nights,
			sd_hdnights
		)
		select distinct
			ti_tokey,
			to_trkey,
			ti_totaldays,
			ti_nights,
			ti_hoteldays
		from #tp_lists with(nolock) inner join tp_tours with(nolock) on ti_tokey = to_key

		-- Даты в поисковой таблице ставим как в таблице туров - чтобы не было двоений MEG00021274
		update mwspodatatable with(rowlock) 
		set sd_tourcreated = to_datecreated 
		from tp_tours with(nolock)
		where sd_tourkey = to_key 		
			and to_key = @tokey
			and sd_tourcreated != to_datecreated 

		set @counter = -1
		set @deleteCount = 50000
		set @params = '@counterOut int output'

		-- Переписываем данные из временной таблицы и уничтожаем ее
		if @mwSearchType = 0
		begin
			while(@counter <> 0)
			begin
				if (@calcKey is not null)
					set @sql = 'delete top (' + ltrim(STR(@deleteCount)) +  ') from mwPriceDataTable with(rowlock) where pt_pricekey in (select tp_key from tp_prices with(nolock) where TP_CalculatingKey = ' + cast(@calcKey as nvarchar(20)) + '); set @counterOut = @@ROWCOUNT'
				else
					set @sql = 'delete top(' + ltrim(STR(@deleteCount)) + ') from mwPriceDataTable with(rowlock) where pt_tourkey = ' + cast(@tokey as nvarchar(20)) + ';set @counterOut = @@ROWCOUNT'
				EXECUTE sp_executesql @sql, @params, @counterOut = @counter output
			end

			-- koshelev TFS 6293
			-- перенес механизм единственной цены Мостравела в хранимку
			-- делаем хранимку стандартной
			if (exists(select 1 from SystemSettings where SS_ParmName like 'mosSinglePrice' and SS_ParmValue = '1'))
			begin
			  -- начало. удаление похожих цен
				if (@overwritePrices = 1)
				begin
					declare @delSql nvarchar(4000)
					declare @delCountry int, @delCtKeyFrom int, @delTableName nvarchar(100)
					select
						@delCountry = to_cnkey,
						@delCtKeyFrom = tl_ctdeparturekey
					from
						tp_tours with(nolock)
						inner join tbl_TurList with(nolock) on to_trkey = tl_key
					where
						to_key = @tokey

					set @delTableName = dbo.mwGetPriceTableName(@delCountry, @delCtKeyFrom)
					if(len(isnull(@delTableName, '')) > 0)
					begin
						create table #delPrices(
							del_key int
						)

						set @delSql = N'
							select pt_pricekey from ' + @delTableName + N' with(nolock) where 
							pt_tourkey <> ' + ltrim(rtrim(str(@tokey))) + ' 
							and exists (
							select top 1 1
							from  tp_lists with(nolock), TP_TurDates with(nolock)
							where ISNULL(TI_CTKEYTO, 0) = isnull(PT_CTKEYTO, 0)
									and TI_FirstHdKey = pt_hdkey and TI_FirstHrKey = pt_hrkey
								   and TI_FirstPnKey = PT_PnKey and TI_TotalDays = PT_Days and TI_Nights = PT_Nights and TI_CtKeyFrom = PT_ctkeyfrom 
								   and TD_TOKey = TI_TOKey	
   								   and TI_TOKey = '	+ ltrim(rtrim(str(@tokey))) + '		
								   and TD_Date = PT_TourDate
								   and PT_TlKey not IN (select tl_key from turlist with(nolock) where tl_tip in (6, 7, 12312230)) 
							)'
					

						insert into #delPrices exec(@delSql)
						create index x_del_key on #delPrices(del_key)

						insert into mwDeleted with(rowlock) (del_key)
						select del_key from #delPrices

						set @counter = -1
						set @params = '@counterOut int output'
						while(@counter <> 0)
						begin
							set @delSql = 'update top (50000) ' + @delTableName + ' with(rowlock) set pt_isenabled = 0 where pt_isenabled > 0 and exists(select 1 from #delPrices where del_key = pt_pricekey); set @counterOut = @@ROWCOUNT'
							EXECUTE sp_executesql @delSql, @params, @counterOut = @counter output
						end

						--exec(@delSql)
					end
				end
				--окончание
			end
			
			exec dbo.mwFillPriceTable '#tempPriceTable', 0, 0
		end
		else
		begin
			
			declare cur cursor fast_forward for select distinct thd_cnkey, isnull(thd_ctkeyfrom, 0) from #tmpHotelData
			open cur
			fetch next from cur into @countryKey, @cityFromKey
			while @@fetch_status = 0
			begin
				exec dbo.mwCreateNewPriceTable @countryKey, @cityFromKey

				set @counter = -1
				set @params = '@counterOut int output'
				while(@counter <> 0)
				begin
					if (@calcKey is not null)
						set @sql = 'delete top (' + ltrim(rtrim(str(@deleteCount)))  + ') from ' + dbo.mwGetPriceTableName(@countryKey, @cityFromKey) + ' with(rowlock) where pt_pricekey in (select tp_key from tp_prices with(nolock) where TP_CalculatingKey = ' + cast(@calcKey as nvarchar(20)) + '); set @counterOut = @@ROWCOUNT'
					else
						set @sql = 'delete top (' + ltrim(rtrim(str(@deleteCount))) + ') from ' + dbo.mwGetPriceTableName(@countryKey, @cityFromKey) + ' with(rowlock) where pt_tourkey = ' + cast(@tokey as nvarchar(20)) + '; set @counterOut = @@ROWCOUNT'
					EXECUTE sp_executesql @sql, @params, @counterOut = @counter output
				end

				exec dbo.mwFillPriceTable '#tempPriceTable', @countryKey, @cityFromKey

				exec dbo.mwCreatePriceTableIndexes @countryKey, @cityFromKey
				fetch next from cur into @countryKey, @cityFromKey
			end		
			close cur
			deallocate cur
		end
	end
	
	if dbo.mwReplIsPublisher() <= 0
	begin

		update dbo.TP_Tours set TO_Progress = 90 where TO_Key = @calcKey

		insert into dbo.mwPriceHotels with(rowlock) (
			sd_tourkey,
			sd_mainhdkey,
			sd_mainpnkey,
			sd_hdkey,
			sd_hdstars,
			sd_hdctkey,
			sd_hdrskey,
			sd_hrkey,
			sd_rmkey,
			sd_rckey,
			sd_ackey,
			sd_pnkey,
			sd_hdorder)
		select distinct 
			thd_tourkey, 
			thd_firsthdkey, 
			thd_firstpnkey,
			thd_hdkey, 
			thd_hdstars, 
			thd_ctkey, 
			thd_rskey, 
			thd_hrkey, 
			thd_rmkey, 
			thd_rckey, 
			thd_ackey, 
			thd_pnkey,
			thd_hdorder
		from #tmpHotelData

		-- информация об отелях
		insert into mwSpoDataTable with(rowlock)(
			sd_tourkey, 
			sd_cnkey, 
			sd_hdkey, 
			sd_hdstars, 
			sd_ctkey, 
			sd_rskey, 
			sd_ctkeyfrom, 
			sd_ctkeyto, 
			sd_tlkey, 
			sd_isenabled, 
			sd_tourcreated,
			sd_main,
			sd_pnkey,
			sd_tourtype,
			sd_cnname,
			sd_tourname,
			sd_hdname,
			sd_ctname,
			sd_rsname,
			sd_ctfromname,
			sd_cttoname,
			sd_tourtypename,
			sd_pncode,
			sd_hotelkeys,
			sd_pansionkeys,
			sd_tourvalid,

			sd_hotelurl,
			sd_hdprkey
		) 
		select distinct 
			thd_tourkey, 
			thd_cnkey, 
			thd_hdkey, 
			thd_hdstars, 
			thd_ctkey, 
			thd_rskey, 
			thd_ctkeyfrom, 
			thd_ctkeyto, 
			thd_tlkey, 
			thd_isenabled, 
			thd_tourcreated,
			thd_hdmain,
			thd_pnkey,
			thd_tourtype,
			thd_cnname,
			thd_tourname,
			thd_hdname,
			thd_ctname,
			thd_rsname,
			thd_ctfromname,
			thd_cttoname,
			thd_tourtypename,
			thd_pncode,
			thd_hotelkeys,
			thd_pansionkeys,
			thd_tourvalid,
			thd_hotelurl,
			thd_hdpartnerkey
		from #tmpHotelData 
		where thd_hdmain > 0

		update mwPriceHotels with(rowlock) set ph_sdkey = mwsdt.sd_key
			from mwSpoDataTable mwsdt with(nolock)
			where mwsdt.sd_tourkey = mwPriceHotels.sd_tourkey and mwsdt.sd_hdkey = mwPriceHotels.sd_mainhdkey
				and mwsdt.sd_tourkey = @tokey
				and mwPriceHotels.sd_tourkey = @tokey

		-- Указываем на необходимость обновления в таблице минимальных цен отеля
		update mwHotelDetails with(rowlock)
			set htd_needupdate = 1
			where htd_hdkey in (select thd_hdkey from #tmpHotelData)
			
	end
	
	if dbo.mwReplIsSubscriber() > 0
	begin
		delete from TP_Prices with(rowlock) where tp_tokey = @tokey
		delete from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
		delete from TP_Services with(rowlock) where ts_tokey = @tokey
		delete from TP_Lists with(rowlock) where ti_tokey = @tokey
		-- don't delete from TP_Tours	
	end
	else
	begin
		update tp_lists with(rowlock)
		set
			ti_firsthdkey = ti.ti_firsthdkey,
			ti_lasthotelday = ti.ti_lasthotelday,
			ti_totaldays = ti.ti_totaldays,
			ti_nights = ti.ti_nights,
			ti_hotelkeys = ti.ti_hotelkeys,
			ti_hotelroomkeys = ti.ti_hotelroomkeys,
			ti_hoteldays = ti.ti_hoteldays,
			ti_hotelstars = ti.ti_hotelstars,
			ti_pansionkeys = ti.ti_pansionkeys,
			ti_hdpartnerkey = ti.ti_hdpartnerkey,
			ti_firsthotelpartnerkey = ti.ti_firsthotelpartnerkey,
			ti_hdday = ti.ti_hdday,
			ti_hdnights = ti.ti_hdnights,
			ti_chkey = ti.ti_chkey,
			ti_chday = ti.ti_chday,
			ti_chpkkey = ti.ti_chpkkey,
			ti_chprkey = ti.ti_chprkey,
			ti_ctkeyfrom = ti.ti_ctkeyfrom,
			ti_chbackkey = ti.ti_chbackkey,
			ti_chbackday = ti.ti_chbackday,
			ti_chbackpkkey = ti.ti_chbackpkkey,
			ti_chbackprkey = ti.ti_chbackprkey,
			ti_ctkeyto = ti.ti_ctkeyto,
			ti_apkeyfrom = ti.ti_apkeyfrom,
			ti_apkeyto = ti.ti_apkeyto,
			ti_firstctkey = ti.ti_firstctkey,
			ti_firstrskey = ti.ti_firstrskey,
			ti_firsthdstars = ti.ti_firsthdstars
		from #tp_lists ti
		where
			(tp_lists.TI_CalculatingKey = @calcKey or @calcKey is null)
			and tp_lists.TI_Key = ti.TI_Key
	end

	if(@forceEnable > 0 and @calcKey is null)
	begin
		exec mwEnablePriceTourNewSinglePrice @tokey, '#tempPriceTable'

		update tp_tours with(rowlock)
		set to_isenabled = 1
		where to_key = @tokey
	end
		
	drop table #tempPriceTable

	update dbo.TP_Tours with(rowlock)
	set TO_Update = 0,
		TO_Progress = 100,
		TO_DateCreated = GetDate(),
		TO_UpdateTime = GetDate()
	where
		TO_Key = @tokey

	EXECUTE mwFillPriceListDetails @tokey

end
GO

grant execute on [dbo].[FillMasterWebSearchFields] to public
GO

/*********************************************************************/
/* end sp_FillMasterWebSearchFields.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_AddCostsReCalculate.sql */
/*********************************************************************/
if exists ( select  *
            from    sys.triggers
            where   object_id = object_id(N'[dbo].[T_AddCostsReCalculate]') ) 
    drop trigger [dbo].[T_AddCostsReCalculate]
GO

CREATE trigger [dbo].[T_AddCostsReCalculate] on [dbo].[AddCosts]
    after insert, update
as
--<data>2012-03-22</data>
--<version>2009.02.06</version>
--.04 mv 29-02-2012 Добавил заполнение полей QAC_TourLongMin, QAC_TourLongMax
begin
	if exists ( select top 1 1 from inserted where ADC_SVKey!=3) 
	begin
	--	3. В противном случае добавим строки в очередь на перерасчет доплат в расчитанных ценах 
	--	(если им соответствуют услуги в TP_Services)
		insert into dbo.TP_QueueAddCosts 
				(QAC_ADCId, QAC_DateCreate, QAC_DateCheckIn, QAC_SVKey, QAC_SCPId, QAC_TRKey, QAC_TourLongMin, QAC_TourLongMax)
		select  ADC_Id, getdate(), SCP_DateCheckIn, ADC_SVKey, SCP_ID, ADC_TLKey, ADC_LongMin, ADC_LongMax
		from    inserted, TP_ServiceComponents, TP_ServiceCalculateParametrs
		where   
				ADC_SVKey != 3
				and SCP_SCID=SC_ID 
				and ADC_SVKey = SC_SVKey
				and (ADC_Code = 0 OR ADC_Code = SC_Code)
				and (ADC_SubCode1 = 0 OR ADC_SubCode1=SC_SubCode1)
				and (ADC_SubCode2 = 0 OR ADC_SubCode2=SC_SubCode2)
				and (ADC_PartnerKey = 0 OR ADC_PartnerKey=SC_PRKey)
				-- нам нужны только доплаты на будующие даты
				and SCP_DateCheckIn > getdate()
				and SCP_DateCheckIn between ADC_CheckInDateBeg and ADC_CheckInDateEnd
				and (SCP_TourDays between case when isnull(ADC_LongMin, 0) = 0 then -100500 else ADC_LongMin end
					and case when isnull(ADC_LongMax, 0) = 0 then 100500 else ADC_LongMax end)
	END

	if exists ( select top 1 1 from inserted where ADC_SVKey=3) 
	begin
		insert into dbo.TP_QueueAddCosts 
				(QAC_ADCId, QAC_DateCreate, QAC_DateCheckIn, QAC_SVKey, QAC_SCPId, QAC_TRKey, QAC_TourLongMin, QAC_TourLongMax)
		select  ADC_Id, getdate(), SCP_DateCheckIn, ADC_SVKey, SCP_ID, ADC_TLKey, ADC_LongMin, ADC_LongMax
		from    inserted, TP_ServiceComponents, TP_ServiceCalculateParametrs
		where   
				ADC_SVKey = 3
				and SCP_SCID=SC_ID 
				and ADC_SVKey = SC_SVKey
				and (ADC_Code = 0 OR ADC_Code = SC_Code)
				and (ADC_SubCode1 = 0 OR SC_SubCode1 in (SELECT HR_Key FROM HotelRooms WHERE HR_RMKey=ADC_SubCode1))
				and (ADC_SubCode2 = 0 OR SC_SubCode1 in (SELECT HR_Key FROM HotelRooms WHERE HR_RCKey=ADC_SubCode2))
				and (ADC_PansionKey = 0 OR SC_SubCode2=ADC_PansionKey)
				and (ADC_PartnerKey = 0 OR ADC_PartnerKey=SC_PRKey)
				and SCP_DateCheckIn between ADC_CheckInDateBeg and ADC_CheckInDateEnd
				and (SCP_TourDays between case when isnull(ADC_LongMin, 0) = 0 then -100500 else ADC_LongMin end
					and case when isnull(ADC_LongMax, 0) = 0 then 100500 else ADC_LongMax end)
	END	
end
GO
/*********************************************************************/
/* end T_AddCostsReCalculate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TourMarginReCalculate.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_TourMarginReCalculate]'))
DROP TRIGGER [dbo].[T_TourMarginReCalculate]
GO

CREATE TRIGGER [dbo].[T_TourMarginReCalculate]
   ON [dbo].[TURMARGIN]
   AFTER INSERT,DELETE,UPDATE
as
--<data>2012-02-03</data>
--<version>2009.02.05</version>
begin
	if exists (select top 1 1 from deleted)
	begin	
		-- обновим дату изменения для услуг в турах которые затронуло удаление
		-- и проставим признак необходимости перерасчета (NeddApply=1)
		update TMAD
		set    TMAD_DateLastChange = getdate(),
			   TMAD_NeedApply=1
		from   (TP_TourMarginActualDate as TMAD	join deleted as D on TMAD.TMAD_TRKey = D.TM_TlKey) 
		where 			
				((D.TM_SVKEY = 0) or (TMAD.TMAD_SvKey = D.TM_SVKEY))
			and ((D.TM_Long = 0) or (TMAD.TMAD_Long=D.TM_Long))
	end
	
	if exists (select top 1 1 from inserted)
	begin
		-- обновим дату изменения наценки для вновь добавленых наценок
		-- и проставим признак необходимости перерасчета (NeddApply=1)
		update TP_TourMarginActualDate
		set    TMAD_DateLastChange = getdate(),
			   TMAD_NeedApply=1
		from   TP_TourMarginActualDate as TMAD join inserted as I on TMAD.TMAD_TRKey = I.TM_TlKey
		where
				((I.TM_SVKEY = 0) or (TMAD.TMAD_SvKey = I.TM_SVKEY))
			and ((I.TM_Long = 0) or (TMAD.TMAD_Long=I.TM_Long))
	end
END

GO
/*********************************************************************/
/* end T_TourMarginReCalculate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_PriceChange.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_PriceChange]'))
DROP TRIGGER [dbo].[T_PriceChange]
GO

CREATE TRIGGER [dbo].[T_PriceChange] ON [dbo].[tbl_Costs] for Insert,Update,Delete
as
--<data>2012-02-17</data>
--<version>2009.02.04</version>
if @@ROWCOUNT > 0
begin
	declare @CS_SVKey int, @CS_Code int, @CS_SubCode1 int, @CS_SubCode2 int, @CS_PRKey int, @CS_PKKey int

	declare @OCS_DateBeg datetime, @OCS_DateEnd datetime, @OCS_Netto decimal(12,2), @OCS_Cost decimal(12,2)
	declare @OCS_Week varchar(7), @OCS_Discount smallint, @OCS_Type smallint, @OCS_Rate varchar(2)
	declare @OCS_Long smallint, @OCS_LongMin smallint, @OCS_ByDay smallint, @OCS_Profit decimal(12,2)
	declare @OCS_CheckInDateBeg datetime, @OCS_CheckInDateEnd datetime
	
	declare @NCS_DateBeg datetime, @NCS_DateEnd datetime, @NCS_Netto decimal(12,2), @NCS_Cost decimal(12,2)
	declare @NCS_Week varchar(7), @NCS_Discount smallint, @NCS_Type smallint, @NCS_Rate varchar(2)
	declare @NCS_Long smallint, @NCS_LongMin smallint, @NCS_ByDay smallint, @NCS_Profit decimal(12,2)
	declare @NCS_CheckInDateBeg datetime, @NCS_CheckInDateEnd datetime, @CS_ID int

	declare @minDate datetime, @maxDate datetime
	declare @sMod varchar(3), @nDelCount int, @nInsCount int
	
	declare @sWho varchar(25)

	SELECT @nDelCount = COUNT(*) FROM DELETED
	SELECT @nInsCount = COUNT(*) FROM INSERTED
	IF (@nDelCount = 0)
	BEGIN
		SET @sMod = 'INS'
		DECLARE cursorCostUpdateFull CURSOR FOR 
		select	N.CS_ID, N.CS_SVKey, N.CS_Code, N.CS_SubCode1, N.CS_SubCode2, N.CS_PRKey, N.CS_PKKey,
				null, null, null, null,
				null, null, null, null,
				null, null, null, null,
				null, null,
				N.CS_Date, N.CS_DateEnd, N.CS_CostNetto, N.CS_Cost,
				N.CS_Week, N.CS_Discount, N.CS_Type, N.CS_Rate,
				N.CS_Long, N.CS_LongMin, N.CS_ByDay, N.CS_Profit,
				N.CS_CheckInDateBeg, N.CS_CheckInDateEnd
		from	inserted N
	END
	ELSE IF (@nInsCount = 0)
	BEGIN
		SET @sMod = 'DEL'
		DECLARE cursorCostUpdateFull CURSOR FOR 
		select	O.CS_ID, O.CS_SVKey, O.CS_Code, O.CS_SubCode1, O.CS_SubCode2, O.CS_PRKey, O.CS_PKKey,
				O.CS_Date, O.CS_DateEnd, O.CS_CostNetto, O.CS_Cost,
				O.CS_Week, O.CS_Discount, O.CS_Type, O.CS_Rate,
				O.CS_Long, O.CS_LongMin, O.CS_ByDay, O.CS_Profit,
				O.CS_CheckInDateBeg, O.CS_CheckInDateEnd,
				null, null, null, null,
				null, null, null, null,
				null, null, null, null,
				null, null
		from	deleted O
	END
	ELSE 
	BEGIN
  		SET @sMod = 'UPD'
		declare cursorCostUpdateFull cursor for
		select	O.CS_ID, O.CS_SVKey, O.CS_Code, O.CS_SubCode1, O.CS_SubCode2, O.CS_PRKey, O.CS_PKKey,
				O.CS_Date, O.CS_DateEnd, O.CS_CostNetto, O.CS_Cost,
				O.CS_Week, O.CS_Discount, O.CS_Type, O.CS_Rate,
				O.CS_Long, O.CS_LongMin, O.CS_ByDay, O.CS_Profit,
				O.CS_CheckInDateBeg, O.CS_CheckInDateEnd,
				N.CS_Date, N.CS_DateEnd, N.CS_CostNetto, N.CS_Cost,
				N.CS_Week, N.CS_Discount, N.CS_Type, N.CS_Rate,
				N.CS_Long, N.CS_LongMin, N.CS_ByDay, N.CS_Profit,
				N.CS_CheckInDateBeg, N.CS_CheckInDateEnd
		from	deleted O, inserted N
		where	O.CS_ID = N.CS_ID
	END	

	open cursorCostUpdateFull
	fetch next from cursorCostUpdateFull into 
				@CS_ID, @CS_SVKey, @CS_Code, @CS_SubCode1, @CS_SubCode2, @CS_PRKey, @CS_PKKey,
				@OCS_DateBeg, @OCS_DateEnd, @OCS_Netto, @OCS_Cost,
				@OCS_Week, @OCS_Discount, @OCS_Type, @OCS_Rate,
				@OCS_Long, @OCS_LongMin, @OCS_ByDay, @OCS_Profit,
				@OCS_CheckInDateBeg, @OCS_CheckInDateEnd,
				@NCS_DateBeg, @NCS_DateEnd, @NCS_Netto, @NCS_Cost,
				@NCS_Week, @NCS_Discount, @NCS_Type, @NCS_Rate,
				@NCS_Long, @NCS_LongMin, @NCS_ByDay, @NCS_Profit,
				@NCS_CheckInDateBeg, @NCS_CheckInDateEnd

	while @@FETCH_STATUS = 0
	begin
		If @sMod = 'INS'
		BEGIN
			Set @minDate = @NCS_DateBeg
			Set @maxDate = @NCS_DateEnd
		END

		If @sMod = 'DEL'
		BEGIN
			Set @minDate = @OCS_DateBeg
			Set @maxDate = @OCS_DateEnd
		END

		If @sMod = 'UPD'
		BEGIN
			if @NCS_DateBeg <= @OCS_DateBeg and @NCS_DateBeg is not null
				Set @minDate = @NCS_DateBeg
			else if @NCS_DateBeg > @OCS_DateBeg and @OCS_DateBeg is not null
				Set @minDate = @OCS_DateBeg
			else
				Set @minDate = @OCS_CheckInDateBeg 
		
			if @NCS_DateEnd <= @OCS_DateEnd and @NCS_DateEnd is not null
				Set @maxDate = @NCS_DateEnd
			else if @NCS_DateEnd > @OCS_DateEnd and @OCS_DateEnd is not null
				Set @maxDate = @OCS_DateEnd
			else
				Set @maxDate = @OCS_CheckInDateEnd
		END

		EXEC dbo.CostChange @CS_SVKey, @CS_Code, @CS_SubCode1, @CS_SubCode2, @CS_PRKey, @CS_PKKey, @minDate, @maxDate
			
		-- если установлена настройка NewReCalculatePrice, то этот кусок выполнится 
		-- позже (одним апдейтом)
		if (not exists (select top 1 1 from SystemSettings where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue=1) and (@sMod = 'INS' or @sMod = 'UPD'))
		begin
			EXEC dbo.CurrentUser @sWho output
			update tbl_Costs set CS_UPDDATE = GETDATE(), CS_UPDUSER = @sWho where CS_ID = @CS_ID
		end

		fetch next from cursorCostUpdateFull into 
				@CS_ID, @CS_SVKey, @CS_Code, @CS_SubCode1, @CS_SubCode2, @CS_PRKey, @CS_PKKey,
				@OCS_DateBeg, @OCS_DateEnd, @OCS_Netto, @OCS_Cost,
				@OCS_Week, @OCS_Discount, @OCS_Type, @OCS_Rate,
				@OCS_Long, @OCS_LongMin, @OCS_ByDay, @OCS_Profit,
				@OCS_CheckInDateBeg, @OCS_CheckInDateEnd,
				@NCS_DateBeg, @NCS_DateEnd, @NCS_Netto, @NCS_Cost,
				@NCS_Week, @NCS_Discount, @NCS_Type, @NCS_Rate,
				@NCS_Long, @NCS_LongMin, @NCS_ByDay, @NCS_Profit,
				@NCS_CheckInDateBeg, @NCS_CheckInDateEnd
	end
	close cursorCostUpdateFull
	deallocate cursorCostUpdateFull
	
	-- Если установлена настройка NewReCalculatePrice
	if exists (select top 1 1 from SystemSettings where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue=1)
	begin
		declare @currentDateTime datetime; set @currentDateTime = getdate();  -- 2012-02-17 14:25:12
		declare @currentDate datetime; set @currentDate = dateadd(dd, 0, datediff(dd, 0, @currentDateTime));  -- 2012-02-17 00:00:00
		
		-- Добавим записи в кэш соответсвующие точкам пересечения цен - т.е. границам даты продажи
		-- CS_DateSaleEnd + 1, т.к. последний день продажи включен
		
		-- вставка строк в TP_ServicePriceactualDate возможна только в случае insert
		if not exists ( select top 1 1 from deleted ) 
		begin
			-- только нужные поля только из активных ценовых блоков
			with onlyNeedCosts as
			(
				select	CO_Id, CO_SaleDateBeg, CO_SaleDateEnd , CS_SVKey, CS_Code, CS_SubCode1, CS_Subcode2,
						CS_PrKey, CS_PkKey, CS_Date, CS_DateEnd, CS_Long, CS_LongMin, CS_Rate, CS_Cost, CS_CostNetto
				from	inserted as CS (nolock) 
						inner join CostOffers as CO (nolock) on CS.CS_COID = CO.CO_Id
						inner join Seasons as SN (nolock) on CO.CO_SeasonId = SN.SN_Id
				where	CO.CO_State = 1
						and SN.SN_IsActive = 1
			),
			-- точки пересечения по границам дат продаж (если граница в прошлом или null, то нам такая строка не нужна)
			crossPoints as
			(
				select	*, CO_SaleDateBeg as Date
				from	onlyNeedCosts
				where	CO_SaleDateBeg > @currentDate
				union
				select	*, dateadd(day, 1, CO_SaleDateEnd)
				from	onlyNeedCosts
				where	CO_SaleDateEnd > @currentDate
			)
			insert into dbo.TP_ServicePriceactualDate 
						(SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross, SPAD_DateLastChange, 
						SPAD_DateLastCalculate, SPAD_NeedApply, SPAD_Netto, SPAD_AutoOnline)
			select	SCP_Id, null, CS_Rate, crossPoints.Date, CS_Cost, @currentDateTime, 
					@currentDateTime, 0, CS_CostNetto, 0
			from	(TP_ServiceCalculateParametrs as SCP (nolock)
					inner join TP_ServiceComponents as SC (nolock) on SCP.SCP_SCId = SC.SC_Id)
					cross join crossPoints
			where	SC.SC_SVKey = CS_SvKey and SC.SC_Code = CS_CODE and SC.SC_SubCode1 = CS_SUBCODE1
					and SC.SC_SubCode2 = CS_SUBCODE2 and SC.SC_PRKey = CS_PRKEY
					and ((SCP.SCP_PKKey = CS_PKKEY) or (CS_PKKEY is null))
					and SCP.SCP_Date between CS_DATE and CS_DATEEND
					and ((isnull(SCP.SCP_Days, 0) between isnull(CS_LONGMIN, 0) and isnull(CS_LONG, 0))
						or
						(CS_LONGMIN is null and CS_LONG is null)) 
		end
		
		if exists ( select top 1 1 from deleted ) 
		begin	
			update
				SPAD
			set SPAD_DateLastChange = getdate(),
			SPAD_NeedApply = 1
			from
				(TP_ServicePriceActualDate as SPAD (rowlock)
				inner join TP_ServiceCalculateParametrs as SCP (nolock) on SPAD.SPAD_SCPId = SCP.SCP_Id
				inner join TP_ServiceComponents as SC (nolock) on SCP.SCP_SCId = SC.SC_Id)
				cross join 
				(deleted as d (nolock) 
				inner join CostOffers as CO (nolock) on d.CS_COID = CO.CO_Id
				inner join Seasons as SN on CO.CO_SeasonId = SN.SN_Id)
			where
				SC.SC_SVKey = d.CS_SvKey
				and SC.SC_Code = d.CS_CODE
				and SC.SC_SubCode1 = d.CS_SUBCODE1
				and SC.SC_SubCode2 = d.CS_SUBCODE2
				and SC.SC_PRKey = d.CS_PRKEY
				and ((SCP.SCP_PKKey = d.CS_PKKEY)
				 or (d.CS_PKKEY is null))
				and SCP.SCP_Date between d.CS_DATE and d.CS_DATEEND
				and ((isnull(SCP.SCP_Days, 0) between isnull(d.CS_LONGMIN, 0) and isnull(d.CS_LONG, 0))
					or
					(d.CS_LONGMIN is null and d.CS_LONG is null)) 
				-- не обрабатываем цены с NULLовым ценовым блоком, неактивным ценовым блоком 
				-- и ценовым блоком из неактивного сезона
				and CO.CO_State = 1
				and SN.SN_IsActive = 1
				-- не обрабатываем цены, у которых период продаж не затрагивает дату продажи
				and isnull(SPAD.SPAD_SaleDate,@currentDate) between isnull(CO.CO_SaleDateBeg,'1900-01-01') and isnull(CO.CO_SaleDateEnd,'2070-01-01');

			
			-- DEBUGGING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			insert  into dbo.Debug
					(db_Mod, db_Date, db_Text, db_n1)
			values
					('sp', getdate(), '@countD', @@ROWCOUNT) ;

			declare @countdeleted int ;
			select
				@countdeleted = count(*)
			from
				deleted ;
			insert  into dbo.Debug
					(db_Mod, db_Date, db_Text, db_n1)
			values
					('sp', getdate(), '@countdeleted', @countdeleted) ;
			-- END DEBUGGING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		end

		if exists ( select top 1 1 from inserted ) 
		begin
			-- кусочек кода, который мигрировал сюда из T_PriceChange при условии, 
			-- что установлена настройка NewReCalculatePrice
			exec dbo.CurrentUser @sWho output
			update
				tbl_Costs
			set CS_UPDDATE = getdate(), CS_UPDUSER = @sWho
			from
				dbo.tbl_Costs
				inner join inserted on dbo.tbl_Costs.CS_ID = inserted.CS_ID

			update
				SPAD
			set SPAD_DateLastChange = getdate(),
			SPAD_NeedApply = 1
			from
				(TP_ServicePriceActualDate as SPAD (rowlock)
				inner join TP_ServiceCalculateParametrs as SCP (nolock) on SPAD.SPAD_SCPId = SCP.SCP_Id
				inner join TP_ServiceComponents as SC (nolock) on SCP.SCP_SCId = SC.SC_Id)
				cross join 
				(inserted as i 
				inner join CostOffers as CO (nolock) on i.CS_COID = CO.CO_Id
				inner join Seasons as SN on CO.CO_SeasonId = SN.SN_Id)
			where
				SC.SC_SVKey = i.CS_SVKEY
				and SC.SC_Code = i.CS_CODE
				and SC.SC_SubCode1 = i.CS_SUBCODE1
				and SC.SC_SubCode2 = i.CS_SUBCODE2
				and SC.SC_PRKey = i.CS_PRKEY
				and ((SCP.SCP_PKKey = i.CS_PKKEY)
				 or (i.CS_PKKEY is null))
				and SCP.SCP_Date between i.CS_DATE and i.CS_DATEEND
				and (isnull(SCP.SCP_Days, 0) between isnull(i.CS_LONGMIN, 0) and isnull(i.CS_LONG, 0)
					or
					(i.CS_LONGMIN is null and i.CS_LONG is null))
				-- не обрабатываем цены с NULLовым ценовым блоком, неактивным ценовым блоком 
				-- и ценовым блоком из неактивного сезона
				and CO.CO_State = 1
				and SN.SN_IsActive = 1
				-- не обрабатываем цены, у которых период продаж не затрагивает дату продажи
				and isnull(SPAD.SPAD_SaleDate,@currentDate) between isnull(CO.CO_SaleDateBeg,'1900-01-01') and isnull(CO.CO_SaleDateEnd,'2070-01-01');
				
			-- DEBUGGING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			insert  into dbo.Debug
					(db_Mod, db_Date, db_Text, db_n1)
			values
					('sp', getdate(), '@countI', @@ROWCOUNT) ;

			declare @countinserted int ;
			select
				@countinserted = count(*)
			from
				inserted ;
			insert  into dbo.Debug
					(db_Mod, db_Date, db_Text, db_n1)
			values
					('sp', getdate(), '@countinserted', @countinserted) ;
			-- END DEBUGGING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		end	
	end
	
end


GO



/*********************************************************************/
/* end T_PriceChange.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_DogovorListUpdate.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_DogovorListUpdate]'))
DROP TRIGGER [dbo].[T_DogovorListUpdate]
GO
CREATE TRIGGER [dbo].[T_DogovorListUpdate]
ON [dbo].[tbl_DogovorList]
FOR UPDATE, INSERT, DELETE
AS
IF @@ROWCOUNT > 0
BEGIN
--<VERSION>2009.2.12.1</VERSION>
--<DATE>2010-04-26</DATE>
  DECLARE @ODL_DgCod varchar(10)
  DECLARE @ODL_Key int
  DECLARE @ODL_SvKey int
  DECLARE @ODL_Code int
  DECLARE @ODL_SubCode1 int
  DECLARE @ODL_SubCode2 int
  DECLARE @ODL_CnKey int
  DECLARE @ODL_CtKey int
  DECLARE @ODL_NMen smallint
  DECLARE @ODL_Day smallint
  DECLARE @ODL_NDays smallint
  DECLARE @ODL_PartnerKey int
  DECLARE @ODL_Cost money
  DECLARE @ODL_Brutto money
  DECLARE @ODL_Discount money
  DECLARE @ODL_Wait smallint
  DECLARE @ODL_Control int
  DECLARE @ODL_sDateBeg varchar(10)
  DECLARE @ODL_DateBeg datetime
  DECLARE @ODL_sDateEnd varchar(10)
  DECLARE @ODL_DateEnd datetime
  DECLARE @ODL_RealNetto money
  DECLARE @ODL_Attribute int
  DECLARE @ODL_PaketKey int
  DECLARE @ODL_Name varchar(250)
  DECLARE @ODL_Payed money
  DECLARE @ODL_DGKey int
  DECLARE @ODL_QuoteKey int
  DECLARE @ODL_TimeBeg datetime
  DECLARE @ODL_TimeEnd datetime
  DECLARE @ODL_PROVIDERSTATUSEKEY int
  DECLARE @ODL_CalculatePriceDate datetime

  DECLARE @NDL_DgCod varchar(10)
  DECLARE @NDL_Key int
  DECLARE @NDL_SvKey int
  DECLARE @NDL_Code int
  DECLARE @NDL_SubCode1 int
  DECLARE @NDL_SubCode2 int
  DECLARE @NDL_CnKey int
  DECLARE @NDL_CtKey int
  DECLARE @NDL_NMen smallint
  DECLARE @NDL_Day smallint
  DECLARE @NDL_NDays smallint
  DECLARE @NDL_PartnerKey int
  DECLARE @NDL_Cost money
  DECLARE @NDL_Brutto money
  DECLARE @NDL_Discount money
  DECLARE @NDL_Wait smallint
  DECLARE @NDL_Control int
  DECLARE @NDL_sDateBeg varchar(10)
  DECLARE @NDL_DateBeg datetime
  DECLARE @NDL_sDateEnd varchar(10)
  DECLARE @NDL_DateEnd datetime
  DECLARE @NDL_RealNetto money
  DECLARE @NDL_Attribute int
  DECLARE @NDL_PaketKey int
  DECLARE @NDL_Name varchar(250)
  DECLARE @NDL_Payed money
  DECLARE @NDL_DGKey int
  DECLARE @NDL_QuoteKey int
  DECLARE @NDL_TimeBeg datetime
  DECLARE @NDL_TimeEnd datetime
  DECLARE @NDL_PROVIDERSTATUSEKEY int
  DECLARE @NDL_CalculatePriceDate datetime
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  DECLARE @DL_Key int
  DECLARE @nDGSorGlobalCode_Old int, @nDGSorGlobalCode_New int,  @nDGSorCode_New int, @dDGTourDate datetime, @nDGKey int
  DECLARE @bNeedCommunicationUpdate smallint
  DECLARE @nSVKey int
  DECLARE @sDisableDogovorStatusChange varchar(254), @sUpdateMainDogovorStatuses varchar(254)

  DECLARE @dg_key INT

  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED

  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
    DECLARE cur_DogovorList CURSOR FOR 
    SELECT 	N.DL_Key,
			null, null, null, null, null, null, null, null, null, null, null,
			null, null, null, null, null, null, null, null, 
			null, null, null, null, null, null, null,null,null,
			N.DL_DgCod, N.DL_DGKey, N.DL_SvKey, N.DL_Code, N.DL_SubCode1, N.DL_SubCode2, N.DL_CnKey, N.DL_CtKey, N.DL_NMen, N.DL_Day, N.DL_NDays, 
			N.DL_PartnerKey, N.DL_Cost, N.DL_Brutto, N.DL_Discount, N.DL_Wait, N.DL_Control, N.DL_DateBeg, N.DL_DateEnd,
			N.DL_RealNetto, N.DL_Attribute, N.DL_PaketKey, N.DL_Name, N.DL_Payed, N.DL_QuoteKey, N.DL_TimeBeg,N.DL_PROVIDERSTATUSEKEY, N.DL_CalculatePriceDate
			
      FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
    DECLARE cur_DogovorList CURSOR FOR 
    SELECT 	O.DL_Key,
			O.DL_DgCod, O.DL_DGKey, O.DL_SvKey, O.DL_Code, O.DL_SubCode1, O.DL_SubCode2, O.DL_CnKey, O.DL_CtKey, O.DL_NMen, O.DL_Day, O.DL_NDays, 
			O.DL_PartnerKey, O.DL_Cost, O.DL_Brutto, O.DL_Discount, O.DL_Wait, O.DL_Control, O.DL_DateBeg, O.DL_DateEnd,
			O.DL_RealNetto, O.DL_Attribute, O.DL_PaketKey, O.DL_Name, O.DL_Payed, O.DL_QuoteKey, O.DL_TimeBeg, O.DL_PROVIDERSTATUSEKEY,O.DL_CalculatePriceDate,
			null, null, null, null, null, null, null, null, null, null, null,
			null, null, null, null, null, null, null, null, 
			null, null, null, null, null, null, null,null,null
    FROM DELETED O
  END
  ELSE 
  BEGIN
  	SET @sMod = 'UPD'
    DECLARE cur_DogovorList CURSOR FOR 
    SELECT 	N.DL_Key,
			O.DL_DgCod, O.DL_DGKey, O.DL_SvKey, O.DL_Code, O.DL_SubCode1, O.DL_SubCode2, O.DL_CnKey, O.DL_CtKey, O.DL_NMen, O.DL_Day, O.DL_NDays, 
			O.DL_PartnerKey, O.DL_Cost, O.DL_Brutto, O.DL_Discount, O.DL_Wait, O.DL_Control, O.DL_DateBeg, O.DL_DateEnd,
			O.DL_RealNetto, O.DL_Attribute, O.DL_PaketKey, O.DL_Name, O.DL_Payed, O.DL_QuoteKey, O.DL_TimeBeg,O.DL_PROVIDERSTATUSEKEY,O.DL_CalculatePriceDate,
	  		N.DL_DgCod, N.DL_DGKey, N.DL_SvKey, N.DL_Code, N.DL_SubCode1, N.DL_SubCode2, N.DL_CnKey, N.DL_CtKey, N.DL_NMen, N.DL_Day, N.DL_NDays, 
			N.DL_PartnerKey, N.DL_Cost, N.DL_Brutto, N.DL_Discount, N.DL_Wait, N.DL_Control, N.DL_DateBeg, N.DL_DateEnd,
			N.DL_RealNetto, N.DL_Attribute, N.DL_PaketKey, N.DL_Name, N.DL_Payed, N.DL_QuoteKey, N.DL_TimeBeg,N.DL_PROVIDERSTATUSEKEY, N.DL_CalculatePriceDate
    FROM DELETED O, INSERTED N 
    WHERE N.DL_Key = O.DL_Key
  END

    OPEN cur_DogovorList
    FETCH NEXT FROM cur_DogovorList INTO 
		@DL_Key, 
			@ODL_DgCod, @ODL_DGKey, @ODL_SvKey, @ODL_Code, @ODL_SubCode1, @ODL_SubCode2, @ODL_CnKey, @ODL_CtKey, @ODL_NMen, @ODL_Day, @ODL_NDays, 
			@ODL_PartnerKey, @ODL_Cost, @ODL_Brutto, @ODL_Discount, @ODL_Wait, @ODL_Control, @ODL_DateBeg, @ODL_DateEnd, 
			@ODL_RealNetto, @ODL_Attribute, @ODL_PaketKey, @ODL_Name, @ODL_Payed, @ODL_QuoteKey, @ODL_TimeBeg,@ODL_PROVIDERSTATUSEKEY, @ODL_CalculatePriceDate,
			@NDL_DgCod, @NDL_DGKey, @NDL_SvKey, @NDL_Code, @NDL_SubCode1, @NDL_SubCode2, @NDL_CnKey, @NDL_CtKey, @NDL_NMen, @NDL_Day, @NDL_NDays, 
			@NDL_PartnerKey, @NDL_Cost, @NDL_Brutto, @NDL_Discount, @NDL_Wait, @NDL_Control, @NDL_DateBeg, @NDL_DateEnd, 
			@NDL_RealNetto, @NDL_Attribute, @NDL_PaketKey, @NDL_Name, @NDL_Payed, @NDL_QuoteKey, @NDL_TimeBeg,@NDL_PROVIDERSTATUSEKEY, @NDL_CalculatePriceDate
    WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @NDL_sDateBeg=CONVERT( char(10), @NDL_DateBeg, 104)
		SET @ODL_sDateBeg=CONVERT( char(10), @ODL_DateBeg, 104)
		SET @NDL_sDateEnd=CONVERT( char(10), @NDL_DateEnd, 104)
		SET @ODL_sDateEnd=CONVERT( char(10), @ODL_DateEnd, 104)

    	------------Проверка, надо ли что-то писать в историю квот-------------------------------------------   
		If ISNULL(@ODL_QuoteKey, 0) != ISNULL(@NDL_QuoteKey, 0) and (ISNULL(@NDL_QuoteKey, 0)>1 or ISNULL(@ODL_QuoteKey, 0)>1)
		BEGIN
			declare @sOper varchar(25)
			EXEC dbo.CurrentUser @sOper output
			if ISNULL(@ODL_QuoteKey, 0)!=0
				INSERT INTO HistoryQuote (HQ_Date, HQ_Mod, HQ_Who, HQ_Text, HQ_QTKey, HQ_DLKey)
					VALUES (GETDATE(), 'DEL', @sOper, @sHI_Text, @ODL_QuoteKey, @DL_Key)
			if ISNULL(@NDL_QuoteKey, 0)!=0
				INSERT INTO HistoryQuote (HQ_Date, HQ_Mod, HQ_Who, HQ_Text, HQ_QTKey, HQ_DLKey)
					VALUES (GETDATE(), 'INS', @sOper, @sHI_Text, @NDL_QuoteKey, @DL_Key)
		END

    	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@ODL_DgCod, '') != ISNULL(@NDL_DgCod, '')  OR
			ISNULL(@ODL_DGKey, '') != ISNULL(@NDL_DGKey, '')  OR
			ISNULL(@ODL_SvKey, '') != ISNULL(@NDL_SvKey, '')  OR
			ISNULL(@ODL_Code, '') != ISNULL(@NDL_Code, '')  OR
			ISNULL(@ODL_SubCode1, '') != ISNULL(@NDL_SubCode1, '')  OR
			ISNULL(@ODL_SubCode2, '') != ISNULL(@NDL_SubCode2, '')  OR
			ISNULL(@ODL_CnKey, '') != ISNULL(@NDL_CnKey, '')  OR
			ISNULL(@ODL_CtKey, '') != ISNULL(@NDL_CtKey, '')  OR
			ISNULL(@ODL_NMen, '') != ISNULL(@NDL_NMen, '')  OR
			ISNULL(@ODL_Day, '') != ISNULL(@NDL_Day, '')  OR
			ISNULL(@ODL_NDays, '') != ISNULL(@NDL_NDays, '')  OR
			ISNULL(@ODL_PartnerKey, '') != ISNULL(@NDL_PartnerKey, '')  OR
			ISNULL(@ODL_Cost, 0) != ISNULL(@NDL_Cost, 0)  OR
			ISNULL(@ODL_Brutto, 0) != ISNULL(@NDL_Brutto, 0)  OR
			ISNULL(@ODL_Discount, 0) != ISNULL(@NDL_Discount, 0)  OR
			ISNULL(@ODL_Wait, '') != ISNULL(@NDL_Wait, '')  OR
			ISNULL(@ODL_Control, '') != ISNULL(@NDL_Control, '')  OR
			ISNULL(@ODL_sDateBeg, '') != ISNULL(@NDL_sDateBeg, '')  OR
			ISNULL(@ODL_sDateEnd, '') != ISNULL(@NDL_sDateEnd, '')  OR
			ISNULL(@ODL_RealNetto, 0) != ISNULL(@NDL_RealNetto, 0)  OR
			ISNULL(@ODL_Attribute, '') != ISNULL(@NDL_Attribute, '')  OR
			ISNULL(@ODL_PaketKey, '') != ISNULL(@NDL_PaketKey, '') OR
			ISNULL(@ODL_Name, '') != ISNULL(@NDL_Name, '') OR 
			ISNULL(@ODL_Payed, 0) != ISNULL(@NDL_Payed, 0) OR 
			ISNULL(@ODL_TimeBeg, 0) != ISNULL(@NDL_TimeBeg, 0) OR
			ISNULL(@ODL_PROVIDERSTATUSEKEY,0)!=ISNULL(@NDL_PROVIDERSTATUSEKEY,0) OR
			ISNULL(@ODL_CalculatePriceDate,0)!=ISNULL(@NDL_CalculatePriceDate,0)
		)
		BEGIN
		  	------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NDL_Name, '')
				SET @nDGKey=@NDL_DGKey
				SET @nSVKey=@NDL_SvKey
			END
			else if (@sMod = 'DEL')
				BEGIN
				SET @sHI_Text = ISNULL(@ODL_Name, '')
				SET @NDL_DgCod = @ODL_DgCod
				SET @nDGKey=@ODL_DGKey
				SET @nSVKey=@ODL_SvKey
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NDL_Name, '')
				SET @nDGKey=@NDL_DGKey
				SET @nSVKey=@NDL_SvKey
			END
			EXEC @nHIID = dbo.InsHistory @NDL_DgCod, @nDGKey, 2, @DL_Key, @sMod, @sHI_Text, '', 0, ''
			--SELECT @nHIID = IDENT_CURRENT('History')		
			--------Детализация--------------------------------------------------

			DECLARE @sText_Old varchar(100)
			DECLARE @sText_New varchar(100)
    
    			DECLARE @sText_AllTypeRooming varchar(20)
			SET @sText_AllTypeRooming  = 'Все типы размещения'

			If (ISNULL(@ODL_Code, '') != ISNULL(@NDL_Code, ''))
			BEGIN
				/*
				IF @NDL_SvKey=1
				BEGIN
					-- mv26.04.2010
					-- Перенес вниз см. начиная с "-- ИНДИВИДУАЛЬНАЯ ОБРАБОТКА АВИАПЕРЕЛЕТОВ"
				END
				*/
				IF @NDL_SvKey!=1
				BEGIN
					exec dbo.GetSVCodeName @ODL_SvKey, @ODL_Code, @sText_Old output, null
					exec dbo.GetSVCodeName @NDL_SvKey, @NDL_Code, @sText_New output, null
					IF @NDL_SvKey = 2
						EXECUTE dbo.InsertHistoryDetail @nHIID , 1028, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
					ELSE IF (@NDL_SvKey = 3 or @NDL_SvKey = 8)
						EXECUTE dbo.InsertHistoryDetail @nHIID , 1029, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
					ELSE IF @NDL_SvKey = 4
						EXECUTE dbo.InsertHistoryDetail @nHIID , 1030, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
					ELSE IF (@NDL_SvKey = 7 or @NDL_SvKey = 9)
						EXECUTE dbo.InsertHistoryDetail @nHIID , 1031, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
					ELSE IF (@NDL_SvKey = 6)
						EXECUTE dbo.InsertHistoryDetail @nHIID , 1146, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
					ELSE 
						EXECUTE dbo.InsertHistoryDetail @nHIID , 1032, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
				END
			END

			If (ISNULL(@ODL_SubCode1, '') != ISNULL(@NDL_SubCode1, ''))
				IF @NDL_SvKey = 1 or @ODL_SvKey = 1
				BEGIN
					Select @sText_Old = AS_Code + ' ' + AS_NameRus from AirService where AS_Key = @ODL_SubCode1
					Select @sText_New = AS_Code + ' ' + AS_NameRus from AirService where AS_Key = @NDL_SubCode1
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1033, @sText_Old, @sText_New, @ODL_SubCode1, @NDL_SubCode1, null, null, 0, @bNeedCommunicationUpdate output
				END
				ELSE IF @NDL_SvKey = 2 or @NDL_SvKey = 4 or @ODL_SvKey = 2 or @ODL_SvKey = 4
				BEGIN
					Select @sText_Old = TR_Name from Transport where TR_Key = @ODL_SubCode1
					Select @sText_New = TR_Name from Transport where TR_Key = @NDL_SubCode1
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1034, @sText_Old, @sText_New, @ODL_SubCode1, @NDL_SubCode1, null, null, 0, @bNeedCommunicationUpdate output
				END
				ELSE IF @NDL_SvKey = 3 or @NDL_SvKey = 8 or @ODL_SvKey = 3 or @ODL_SvKey = 8
				BEGIN
					Select @sText_Old = RM_Name + ',' + RC_Name + ',' + AC_Code from HotelRooms,Rooms,RoomsCategory,AccmdMenType where HR_Key = @ODL_SubCode1 and RM_Key=HR_RmKey and RC_Key=HR_RcKey and AC_Key=HR_AcKey
					Select @sText_New = RM_Name + ',' + RC_Name + ',' + AC_Code from HotelRooms,Rooms,RoomsCategory,AccmdMenType where HR_Key = @NDL_SubCode1 and RM_Key=HR_RmKey and RC_Key=HR_RcKey and AC_Key=HR_AcKey
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1035, @sText_Old, @sText_New, @ODL_SubCode1, @NDL_SubCode1, null, null, 0, @bNeedCommunicationUpdate output
				END
				ELSE IF @NDL_SvKey = 7 or @NDL_SvKey = 9 or @ODL_SvKey = 7 or @ODL_SvKey = 9
				BEGIN
					IF @ODL_SubCode1 = 0
						Set @sText_Old = @sText_AllTypeRooming
					Else
						Select @sText_Old = ISNULL(CB_Code,'') + ',' + ISNULL(CB_Category,'') + ',' + ISNULL(CB_Name,'') from Cabine where CB_Key = @ODL_SubCode1
					IF @NDL_SubCode1 = 0
						Set @sText_New = @sText_AllTypeRooming
					Else
						Select @sText_New = ISNULL(CB_Code,'') + ',' + ISNULL(CB_Category,'') + ',' + ISNULL(CB_Name,'') from Cabine where CB_Key = @NDL_SubCode1
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1035, @sText_Old, @sText_New, @ODL_SubCode1, @NDL_SubCode1, null, null, 0, @bNeedCommunicationUpdate output
				END
				ELSE
				BEGIN
					Select @sText_Old = A1_Name from AddDescript1 where A1_Key = @ODL_SubCode1
					Select @sText_New = A1_Name from AddDescript1 where A1_Key = @NDL_SubCode1
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1036, @sText_Old, @sText_New, @ODL_SubCode1, @NDL_SubCode1, null, null, 0, @bNeedCommunicationUpdate output
				END
	
			If (ISNULL(@ODL_SubCode2, '') != ISNULL(@NDL_SubCode2, ''))
				IF @NDL_SvKey = 3 or @NDL_SvKey = 7 or @ODL_SvKey = 3 or @ODL_SvKey = 7
				BEGIN
					Select @sText_Old = PN_Name from Pansion where PN_Key = @ODL_SubCode2
					Select @sText_New = PN_Name from Pansion where PN_Key = @NDL_SubCode2
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1037, @sText_Old, @sText_New, @ODL_SubCode2, @NDL_SubCode2, null, null, 0, @bNeedCommunicationUpdate output
				END
				ELSE
				BEGIN
					Select @sText_Old = A2_Name from AddDescript2 where A2_Key = @ODL_SubCode2
					Select @sText_New = A2_Name from AddDescript2 where A2_Key = @NDL_SubCode2
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1038, @sText_Old, @sText_New, @ODL_SubCode2, @NDL_SubCode2, null, null, 0, @bNeedCommunicationUpdate output
				END

			If (ISNULL(@ODL_PartnerKey, '') != ISNULL(@NDL_PartnerKey, ''))
			BEGIN
				Select @sText_Old = PR_Name from Partners where PR_Key = @ODL_PartnerKey
				Select @sText_New = PR_Name from Partners where PR_Key = @NDL_PartnerKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1039, @sText_Old, @sText_New, @ODL_PartnerKey, @NDL_PartnerKey, null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_Control, '') != ISNULL(@NDL_Control, ''))
			BEGIN
				Select @sText_Old = CR_Name from Controls where CR_Key = @ODL_Control
				Select @sText_New = CR_Name from Controls where CR_Key = @NDL_Control
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1040, @sText_Old, @sText_New, @ODL_Control, @NDL_Control, null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_CtKey, '') != ISNULL(@NDL_CtKey, ''))
			BEGIN
				Select @sText_Old = CT_Name from CityDictionary where CT_Key = @ODL_CtKey
				Select @sText_New = CT_Name from CityDictionary where CT_Key = @NDL_CtKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1041, @sText_Old, @sText_New, @ODL_CtKey, @NDL_CtKey, null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_CnKey, '') != ISNULL(@NDL_CnKey, ''))
			BEGIN
				Select @sText_Old = CN_Name from Country where CN_Key = @ODL_CnKey
				Select @sText_New = CN_Name from Country where CN_Key = @NDL_CnKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1042, @sText_Old, @sText_New, @ODL_CnKey, @NDL_CnKey, null, null, 0, @bNeedCommunicationUpdate output
			END

		 	If (ISNULL(@ODL_NMen  , '') != ISNULL(@NDL_NMen, ''))
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1043, @ODL_NMen  , @NDL_NMen, '', '', null, null, 0, @bNeedCommunicationUpdate output
			If (ISNULL(@ODL_Cost, 0) != ISNULL(@NDL_Cost, 0))
			BEGIN	
				Set @sText_Old = CAST(@ODL_Cost as varchar(100))
				Set @sText_New = CAST(@NDL_Cost as varchar(100))				
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1044, @sText_Old, @sText_New, '', '', null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_Brutto, 0) != ISNULL(@NDL_Brutto, 0))
			BEGIN	
				Set @sText_Old = CAST(@ODL_Brutto as varchar(100))
				Set @sText_New = CAST(@NDL_Brutto as varchar(100))				
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1045, @sText_Old, @sText_New, '', '', null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_sDateBeg, 0) != ISNULL(@NDL_sDateBeg, 0))
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1046, @ODL_sDateBeg, @NDL_sDateBeg, null, null, null, null, 0, @bNeedCommunicationUpdate output
			If (ISNULL(@ODL_sDateEnd, 0) != ISNULL(@NDL_sDateEnd, 0))
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1047, @ODL_sDateEnd, @NDL_sDateEnd, null, null, null, null, 0, @bNeedCommunicationUpdate output
			If (ISNULL(@ODL_NDays, 0) != ISNULL(@NDL_NDays, 0))
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1048, @ODL_NDays, @NDL_NDays, null, null, null, null, 0, @bNeedCommunicationUpdate output

			If (ISNULL(@ODL_Wait, '') != ISNULL(@NDL_Wait, '')) 
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1049, @ODL_Wait, @NDL_Wait, @ODL_Wait, @NDL_Wait, null, null, 0, @bNeedCommunicationUpdate output
			END
			--12/09/2011 oksana add Проверка на изменение пакета
			
			If ISNULL(@ODL_PaketKey,0)!=ISNULL(@NDL_PaketKey,0)
			BEGIN
				Select  @sText_Old=ISNULL( TL_NAME, '') from dbo.TurList where TL_KEY = @ODL_PaketKey
				Select  @sText_New=ISNULL( TL_NAME, '') from dbo.TurList where TL_KEY = @NDL_PaketKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 2, @sText_Old, @sText_New, @ODL_PaketKey,@NDL_PaketKey, null, null, 0, @bNeedCommunicationUpdate output
			END
			--Проверка на изменение статуса бронирования
			If ISNULL(@ODL_PROVIDERSTATUSEKEY,0)!=ISNULL(@NDL_PROVIDERSTATUSEKEY,0)
			BEGIN
				Select  @sText_Old=ISNULL( PS_NAME, '') from dbo.ProviderStatuses where PS_KEY = ISNULL(@ODL_PROVIDERSTATUSEKEY,0)
				Select  @sText_New=ISNULL( PS_NAME, '') from dbo.ProviderStatuses where PS_KEY = ISNULL(@NDL_PROVIDERSTATUSEKEY,0)
				EXECUTE dbo.InsertHistoryDetail @nHIID , 2, @sText_Old, @sText_New, @ODL_PROVIDERSTATUSEKEY,@NDL_PROVIDERSTATUSEKEY, null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_Name, 0) != ISNULL(@NDL_Name, 0))
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1050, @ODL_Name, @NDL_Name, null, null, null, null, 0, @bNeedCommunicationUpdate output
			If (ISNULL(@ODL_RealNetto, 0) != ISNULL(@NDL_RealNetto, 0))
			BEGIN
				--Set @sText_Old = CAST(@ODL_RealNetto as varchar(10))
				--Set @sText_New = CAST(@NDL_RealNetto as varchar(10))
				
				Set @sText_Old = left(convert(varchar, @ODL_RealNetto), 10)
                Set @sText_New = left(convert(varchar, @NDL_RealNetto), 10)
								
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1119, @sText_Old, @sText_New, '', '', null, null, 0, @bNeedCommunicationUpdate output
			END
			If (ISNULL(@ODL_Payed, 0) != ISNULL(@NDL_Payed, 0))
			BEGIN
				--Set @sText_Old = CAST(@ODL_Payed as varchar(10))
				--Set @sText_New = CAST(@NDL_Payed as varchar(10))	

				Set @sText_Old = left(convert(varchar, @ODL_Payed), 10)
                Set @sText_New = left(convert(varchar, @NDL_Payed), 10)
							
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1120, @sText_Old, @sText_New, '', '', null, null, 0, @bNeedCommunicationUpdate output
			END
			If @ODL_TimeBeg!=@NDL_TimeBeg
			BEGIN
				Set @sText_Old=ISNULL(CONVERT(char(5), @ODL_TimeBeg, 114), 0)
				Set @sText_New=ISNULL(CONVERT(char(5), @NDL_TimeBeg, 114), 0)
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1125, @sText_Old, @sText_New, null, null, @ODL_TimeBeg, @NDL_TimeBeg, 0, @bNeedCommunicationUpdate output
			END
			--12/09/2011 oksana add
			
			If ISNULL(@ODL_CalculatePriceDate,0)!=ISNULL(@NDL_CalculatePriceDate,0)
			BEGIN
				Select  @sText_Old = CONVERT(varchar,@ODL_CalculatePriceDate,104) + ' ' + CONVERT(varchar,@ODL_CalculatePriceDate,108)
				Select  @sText_New = CONVERT(varchar,@NDL_CalculatePriceDate,104) + ' ' + CONVERT(varchar,@NDL_CalculatePriceDate,108)
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1147, @sText_Old, @sText_New, null, null, @ODL_CalculatePriceDate, @NDL_CalculatePriceDate, 0, @bNeedCommunicationUpdate output
			END
			
			If @ODL_PaketKey!=@NDL_PaketKey
			BEGIN			    
				Select  @sText_Old=ISNULL( TL_NAME, '') from dbo.TurList where TL_KEY = @ODL_PaketKey
				Select  @sText_New=ISNULL( TL_NAME, '') from dbo.TurList where TL_KEY = @NDL_PaketKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 2, @sText_Old, @sText_New, @ODL_PaketKey,@NDL_PaketKey, null, null, 1, @bNeedCommunicationUpdate output
			END
			
			If (ISNULL(@ODL_Control, '') != ISNULL(@NDL_Control, '')  OR ISNULL(@ODL_Wait, '') != ISNULL(@NDL_Wait, ''))
			BEGIN
				/*
				Set @nDGSorGlobalCode_New = 0

				----------------Изменение статуса путевки в случае, если статусы услуг установлены в ОК
				Select @nDGSorGlobalCode_Old = OS_Global, @dDGTourDate = DG_TurDate from Dogovor, dbo.Order_Status where DG_Key=@nDGKey and DG_Sor_Code=OS_Code
				IF @dDGTourDate != '30-DEC-1899' -- путевка не должна быть аннулирована.
				BEGIN
					select @sDisableDogovorStatusChange = SS_ParmValue from SystemSettings where SS_ParmName like 'SYSDisDogovorStatusChange'
					if (@sDisableDogovorStatusChange is null or @sDisableDogovorStatusChange = '0')
					begin
						set @nDGSorCode_New = 7				--ОК
						IF exists (SELECT 1 FROM dbo.Setting WHERE ST_Version like '7%')
						BEGIN
							IF exists (Select DL_Key from DogovorList where DL_DGKey=@nDGKey and DL_Wait>0)
							BEGIN
								set @nDGSorCode_New = 3			--Wait-List
								set @nDGSorGlobalCode_New = 3	--Глобальный Wait-List
							END
						END
						IF @nDGSorGlobalCode_New!=3 
							IF exists (Select DL_Key from DogovorList where DL_DGKey=@nDGKey and DL_Control > 0)
							BEGIN
								set @nDGSorCode_New = 4			--Не подтвержден
								set @nDGSorGlobalCode_New = 1	--Глобальный "Не подтвержден"
							END

						if @nDGSorGlobalCode_Old != @nDGSorGlobalCode_New
						BEGIN
							select @sUpdateMainDogovorStatuses = SS_ParmValue from SystemSettings where SS_ParmName like 'SYSUpdateMainDogStatuses'
							if (ISNULL(@sUpdateMainDogovorStatuses, '0') = '0')
								update Dogovor set DG_Sor_Code = @nDGSorCode_New where DG_Key=@nDGKey
							else
								-- изменяем статус путевки только если он был стандартным
								update Dogovor set DG_Sor_Code = @nDGSorCode_New where DG_Key=@nDGKey and DG_Sor_Code in (1,2,3,7)
						END
					end
				END
				*/
				If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey and CM_PRKey in (@ODL_PartnerKey,@NDL_PartnerKey) )
					UPDATE Communications SET 
						CM_StatusConfirmed=(SELECT Count(1) FROM DogovorList, Controls WHERE DL_Control=CR_Key AND CR_GlobalState=1 AND DL_PartnerKey=CM_PRKey AND DL_DGKey=CM_DGKey),
						CM_StatusNotConfirmed=(SELECT Count(1) FROM DogovorList, Controls WHERE DL_Control=CR_Key AND CR_GlobalState=3 AND DL_PartnerKey=CM_PRKey AND DL_DGKey=CM_DGKey),
						CM_StatusWait=(SELECT Count(1) FROM DogovorList, Controls WHERE DL_Control=CR_Key AND CR_GlobalState=2 AND DL_PartnerKey=CM_PRKey AND DL_DGKey=CM_DGKey),
						CM_StatusUnknown=(SELECT Count(1) FROM DogovorList, Controls WHERE DL_Control=CR_Key AND CR_GlobalState is null AND DL_PartnerKey=CM_PRKey AND DL_DGKey=CM_DGKey)
					WHERE CM_DGKey=@nDGKey and CM_PRKey in (@ODL_PartnerKey,@NDL_PartnerKey)
			END
			If ( ( ISNULL(@ODL_Cost, 0) != ISNULL(@NDL_Cost, 0) ) or ( ISNULL(@ODL_RealNetto, 0) != ISNULL(@NDL_RealNetto, 0) ) )
			BEGIN	
				If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey and CM_PRKey in (@ODL_PartnerKey,@NDL_PartnerKey) )
					UPDATE Communications SET 
						CM_SumNettoPlan=(SELECT SUM(DL_Cost) FROM DogovorList WHERE DL_PartnerKey=CM_PRKey AND DL_DGKey=CM_DGKey),
						CM_SumNettoProvider=(SELECT SUM(DL_RealNetto) FROM DogovorList WHERE DL_PartnerKey=CM_PRKey AND DL_DGKey=CM_DGKey)
					WHERE CM_DGKey=@nDGKey and CM_PRKey in (@ODL_PartnerKey,@NDL_PartnerKey)
			END
			-- ИНДИВИДУАЛЬНАЯ ОБРАБОТКА АВИАПЕРЕЛЕТОВ
			If (@NDL_SvKey = 1 AND ((ISNULL(@ODL_Code, '') != ISNULL(@NDL_Code, '')) OR (ISNULL(@ODL_sDateBeg, 0) != ISNULL(@NDL_sDateBeg, 0)) OR ((ISNULL(@ODL_Name, 0) != ISNULL(@NDL_Name, 0)))))
			BEGIN
				DECLARE @APFrom_Old varchar(50), @APTo_Old varchar(50), @AL_Old varchar(50)
				IF ISNULL(@ODL_Code, '') != ''
				BEGIN
					SELECT 
						@sText_Old=CH_AirLineCode + ' ' + CH_Flight,
						@APFrom_Old=(SELECT TOP 1 AP_Name FROM AirPort WHERE AP_Code=CH_PortCodeFrom), 
						@APTo_Old=(SELECT TOP 1 AP_Name FROM AirPort WHERE AP_Code=CH_PortCodeTo), 
						@AL_Old=(SELECT TOP 1 AL_Name FROM AirLine WHERE AL_Code=CH_AirLineCode) 
						FROM Charter WHERE CH_Key=@ODL_Code
				END
				DECLARE @APFrom_New varchar(50), @APTo_New varchar(50), @AL_New varchar(50)
				IF ISNULL(@NDL_Code, '') != ''
				BEGIN
					SELECT 
						@sText_New=CH_AirLineCode + ' ' + CH_Flight,
						@APFrom_New=(SELECT TOP 1 AP_Name FROM AirPort WHERE AP_Code=CH_PortCodeFrom), 
						@APTo_New=(SELECT TOP 1 AP_Name FROM AirPort WHERE AP_Code=CH_PortCodeTo), 
						@AL_New=(SELECT TOP 1 AL_Name FROM AirLine WHERE AL_Code=CH_AirLineCode) 
						FROM Charter WHERE CH_Key=@NDL_Code
				END
				If (ISNULL(@ODL_Code, '') != ISNULL(@NDL_Code, ''))
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1027, @sText_Old, @sText_New, @ODL_Code, @NDL_Code, null, null, 0, @bNeedCommunicationUpdate output
				If (ISNULL(@APFrom_Old, '') != ISNULL(@APFrom_New, ''))
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1135, @APFrom_Old, @APFrom_New, null, null, null, null, 0, @bNeedCommunicationUpdate output
				If (ISNULL(@APTo_Old, '') != ISNULL(@APTo_New, ''))
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1136, @APTo_Old, @APTo_New, null, null, null, null, 0, @bNeedCommunicationUpdate output
				If (ISNULL(@AL_Old, '') != ISNULL(@AL_New, ''))
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1139, @AL_Old, @AL_New, null, null, null, null, 0, @bNeedCommunicationUpdate output

				DECLARE @sTimeBeg_Old varchar(5), @sTimeEnd_Old varchar(5), @sTimeBeg_New varchar(5), @sTimeEnd_New varchar(5)
				Declare @nday int
				IF (ISNULL(@ODL_Code, '') != '')
				BEGIN
					Set @nday = DATEPART(dw, @ODL_DateBeg)  + @@DATEFIRST - 1
					If @nday > 7 
		    			set @nday = @nday - 7
					SELECT	TOP 1 
						@sTimeBeg_Old=LEFT(CONVERT(varchar, AS_TimeFrom, 8),5),
						@sTimeEnd_Old=LEFT(CONVERT(varchar, AS_TimeTo, 8),5)
					FROM 	dbo.AirSeason
					WHERE 	AS_CHKey=@ODL_Code
						and CHARINDEX(CAST(@nday as varchar(1)),AS_Week)>0
						and @ODL_DateBeg between AS_DateFrom and AS_DateTo
					ORDER BY AS_TimeFrom DESC
				END

				IF (ISNULL(@NDL_Code, '') != '')
				BEGIN
					Set @nday = DATEPART(dw, @NDL_DateBeg)  + @@DATEFIRST - 1
					If @nday > 7 
						set @nday = @nday - 7
					SELECT	TOP 1 
						@sTimeBeg_New=LEFT(CONVERT(varchar, AS_TimeFrom, 8),5),
						@sTimeEnd_New=LEFT(CONVERT(varchar, AS_TimeTo, 8),5)
					FROM 	dbo.AirSeason
					WHERE 	AS_CHKey=@NDL_Code
						and CHARINDEX(CAST(@nday as varchar(1)),AS_Week)>0
						and @NDL_DateBeg between AS_DateFrom and AS_DateTo
					ORDER BY AS_TimeFrom DESC
				END
				If (ISNULL(@sTimeBeg_Old, '') != ISNULL(@sTimeBeg_New, ''))
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1137, @sTimeBeg_Old, @sTimeBeg_New, null, null, null, null, 0, @bNeedCommunicationUpdate output
				If (ISNULL(@sTimeEnd_Old, '') != ISNULL(@sTimeEnd_New, ''))
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1138, @sTimeEnd_Old, @sTimeEnd_New, null, null, null, null, 0, @bNeedCommunicationUpdate output
			END
		END
			If @bNeedCommunicationUpdate=1
			BEGIN
				If @nSVKey=1 and ( 
						(ISNULL(@ODL_Code, '') != ISNULL(@NDL_Code, '')) or 
						(ISNULL(@ODL_sDateBeg, 0) != ISNULL(@NDL_sDateBeg, 0))
						 )
				BEGIN
					If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey)
						UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@nDGKey
				END
				
				ELSE
				BEGIN
					If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey and CM_PRKey in (@ODL_PartnerKey,@NDL_PartnerKey) )
						UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@nDGKey and CM_PRKey in (@ODL_PartnerKey,@NDL_PartnerKey)
				END
			END
		------------Аннуляция полиса при удаления услуги----------------------------------
		if (@sMod = 'DEL')
		BEGIN
			UPDATE InsPolicy
			SET IP_ARKEY = 0, IP_AnnulDate = GetDate()
			WHERE IP_DLKey = @DL_KEY AND IP_ARKEY IS NULL AND IP_ANNULDATE IS NULL
		END

    	------------Для поддержки совместимости-------------------------------------------   

			If 	(ISNULL(@ODL_Code, '') != ISNULL(@NDL_Code, '')) or
				(ISNULL(@ODL_SubCode1, '') != ISNULL(@NDL_SubCode1, '')) or
				(ISNULL(@ODL_SubCode2, '') != ISNULL(@NDL_SubCode2, '')) or
				(ISNULL(@ODL_NDays, 0) != ISNULL(@NDL_NDays, 0)) or 
				(ISNULL(@ODL_Day, '') != ISNULL(@NDL_Day, ''))
				EXECUTE dbo.InsHistory @NDL_DgCod, @NDL_DGKey, 2, @DL_Key, 'MOD', @ODL_Name, '', 1, ''

			If 	(ISNULL(@ODL_Wait, '') != ISNULL(@NDL_Wait, '')) 
			BEGIN
				If (@NDL_Wait = 1)
					EXECUTE dbo.InsHistory @NDL_DgCod, @NDL_DGKey, 2, @DL_Key, '+WL', @ODL_Name, '', 0, ''
				else
					EXECUTE dbo.InsHistory @NDL_DgCod, @NDL_DGKey, 2, @DL_Key, '-WL', @ODL_Name, '', 0, ''
			END

		    FETCH NEXT FROM cur_DogovorList INTO 
		@DL_Key, 
			@ODL_DgCod, @ODL_DGKey, @ODL_SvKey, @ODL_Code, @ODL_SubCode1, @ODL_SubCode2, @ODL_CnKey, @ODL_CtKey, @ODL_NMen, @ODL_Day, @ODL_NDays, 
			@ODL_PartnerKey, @ODL_Cost, @ODL_Brutto, @ODL_Discount, @ODL_Wait, @ODL_Control, @ODL_DateBeg, @ODL_DateEnd, 
			@ODL_RealNetto, @ODL_Attribute, @ODL_PaketKey, @ODL_Name, @ODL_Payed, @ODL_QuoteKey, @ODL_TimeBeg,@ODL_PROVIDERSTATUSEKEY, @ODL_CalculatePriceDate,
			@NDL_DgCod, @NDL_DGKey, @NDL_SvKey, @NDL_Code, @NDL_SubCode1, @NDL_SubCode2, @NDL_CnKey, @NDL_CtKey, @NDL_NMen, @NDL_Day, @NDL_NDays, 
			@NDL_PartnerKey, @NDL_Cost, @NDL_Brutto, @NDL_Discount, @NDL_Wait, @NDL_Control, @NDL_DateBeg, @NDL_DateEnd, 
			@NDL_RealNetto, @NDL_Attribute, @NDL_PaketKey, @NDL_Name, @NDL_Payed, @NDL_QuoteKey, @NDL_TimeBeg,@NDL_PROVIDERSTATUSEKEY, @NDL_CalculatePriceDate
	END
  CLOSE cur_DogovorList
  DEALLOCATE cur_DogovorList
 END


GO


/*********************************************************************/
/* end T_DogovorListUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_CostOffersReCalculate.sql */
/*********************************************************************/
if exists ( select  * from    sys.triggers where   object_id = object_id(N'[dbo].[T_CostOffersReCalculate]') )
    drop trigger [dbo].[T_CostOffersReCalculate]
go

create trigger dbo.T_CostOffersReCalculate on dbo.CostOffers
    after insert, update
as
--<data>2012-03-20</data>
--<version>2009.02.10</version>
begin
	declare @currentDateTime datetime; set @currentDateTime = getdate();  -- 2012-02-17 14:25:12
	declare @currentDate datetime; set @currentDate = dateadd(dd, 0, datediff(dd, 0, @currentDateTime));  -- 2012-02-17 00:00:00
	
	-- Добавим записи в кэш соответсвующие точкам пересечения всех цен из добавленного костофера 
	-- (т.е. границам дат продаж), для которых есть соответсвующие строки в TP_SCP и TP_SC
	-- CS_DateSaleEnd + 1, т.к. последний день продажи включен
	
	-- вставка строк в TP_ServicePriceactualDate возможна только в случае insert-а активного ценового блока
	-- и активации ценового блока, т.е. изменения co_State c 0 на 1
	if update(CO_State)
	begin
		
		--insert into debug (db_Date, db_Mod, db_Text) 
		--values (getdate(), 'COR', 'Обновление затронуло активацию ценового блока')
		
		-- только нужные поля только из активных ценовых блоков
		with onlyNeedCosts as
		(
			select	CO_Id, CO_SaleDateBeg, CO_SaleDateEnd , CS_SVKey, CS_Code, CS_SubCode1, CS_Subcode2,
					CS_PrKey, CS_PkKey, CS_Date, CS_DateEnd, CS_Long, CS_LongMin, CS_Rate, CS_Cost, CS_CostNetto
			from	tbl_Costs as CS (nolock) 
					inner join inserted as i on CS.CS_COID = i.CO_Id
					inner join Seasons as SN (nolock) on i.CO_SeasonId = SN.SN_Id
			where	i.CO_State = 1
					and SN.SN_IsActive = 1
					and isnull(cs.cs_DateEnd,'2070-01-01') > @currentDate
		)
		
		--insert into debug (db_Date, db_Mod, db_Text, db_n1, db_n2, db_n3)
		--select CO_SaleDateBeg, 'COR', 'onlyNeedCosts', CO_Id, CS_Cost, CS_Code from onlyNeedCosts
		
		,
		-- точки пересечения по границам дат продаж (если граница в прошлом или null, то нам такая строка не нужна)
		crossPoints as
		(
			select	*, dateadd(dd, 0, datediff(dd, 0, CO_SaleDateBeg)) as Date
			from	onlyNeedCosts
			-- временно изменил > на >= для тестирования SaleDate
			where	CO_SaleDateBeg > @currentDate
			union
			select	*, dateadd(dd, 1, datediff(dd, 0, CO_SaleDateEnd))
			from	onlyNeedCosts
			where	CO_SaleDateEnd > @currentDate
		)
		--select * from crossPoints
		
		--insert into debug (db_Date, db_Mod, db_Text, db_n1, db_n2, db_n3)
		--select Date, 'COR', 'crossPoints', CO_Id, CS_Cost, CS_Code from crossPoints
		
		insert into	dbo.TP_ServicePriceactualDate 
					(SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross,
					SPAD_NeedApply, SPAD_Netto, SPAD_AutoOnline, SPAD_DateLastChange)
		select SCP_Id, null, CS_Rate, crossPoints.Date, CS_Cost, 
				1, CS_CostNetto, 0, @currentDateTime
		
		--insert into debug (db_Date, db_Mod, db_Text, db_n1, db_n2, db_n3)
		--select crossPoints.Date, 'COR', 'insert into SPAD', SCP_Id, CS_Cost, CS_CostNetto 
				
		from	(TP_ServiceCalculateParametrs as SCP (nolock)
				inner join TP_ServiceComponents as SC (nolock) on SCP.SCP_SCId = SC.SC_Id)
				cross join crossPoints
		where	SC.SC_SVKey = CS_SvKey and SC.SC_Code = CS_CODE and SC.SC_SubCode1 = CS_SUBCODE1
				and SC.SC_SubCode2 = CS_SUBCODE2 and SC.SC_PRKey = CS_PRKEY
				and SCP.SCP_PKKey = CS_PKKEY
				and SCP.SCP_Date between isnull(dateadd(day,isnull(-SCP.SCP_Days, 0),CS_DATE),'1900-01-01') and isnull(CS_DATEEND,'2070-01-01')
				and isnull(SCP.SCP_Days, 0) between isnull(CS_LONGMIN, -32000) and isnull(CS_LONG, 32000)
		
	end

	-- добавил проверку на необходимость выполнения этого блока. 
	-- т.е. если нет ни одной строки для которой изменился признак активации и/или даты продажи 
	-- и ни один активный ценовой блок не добавился  
	if (update(CO_State))
	begin
		--	1. нужно обновить SPAD_DateLastChange для услуг которые из добавленого/измененного костофера
		with needForUpdateIds as
		(
		-- сюда попадут Id-шники измененных костоферов (изменение которых затронуло CO_State)
		select inserted.CO_Id 
		from (inserted inner join dbo.Seasons on inserted.CO_SeasonId=dbo.Seasons.SN_Id)
			inner join deleted 
				on inserted.CO_Id=deleted.CO_Id 
		where 
			-- только те костоферы которые в активном сезоне
			dbo.Seasons.SN_IsActive=1 
			and
			deleted.CO_State != inserted.CO_State
		)
		update spad
		set    spad.SPAD_DateLastChange = @currentDateTime,
			   spad.SPAD_NeedApply = 1
		from   dbo.TP_ServicePriceActualDate as spad
			inner join dbo.TP_ServiceCalculateParametrs as scp
				on spad.SPAD_SCPId = scp.SCP_Id
			inner join dbo.TP_ServiceComponents as sc
				on scp.SCP_SCId = sc.SC_Id
		, inserted as i
			inner join dbo.CostOfferServices as [cos]
				on i.CO_Id = [cos].COS_COID
		where
			scp.SCP_PKKey = i.CO_PKKey
			and SC_SVKey = i.CO_SVKey
			and SC_PRKey = i.CO_PartnerKey
			-- не обрабатываем цены, у которых период продаж не затрагивает дату продажи
			and spad.SPAD_SaleDate is null
			and @currentDate between isnull(i.CO_SaleDateBeg, '1900-01-01') and isnull(i.CO_SaleDateEnd, '2070-01-01')
			-- временно добавил это условие для тестирования SaleDate
			--and @currentDate > CO_SaleDateBeg
			and sc.SC_Code = [cos].COS_CODE
			-- проверка по временной таблицы нужно ли обновлять дату в SPAD или нет		
			and i.CO_Id in (select CO_Id from needForUpdateIds);
	end		
		
	-- 2. Проставим признак SPAD_AutoOnline=1 для тех ценовых блоков у которых изменился CO_DateLastPublish
	
	-- т.к. нам нужны только измененные строки, а тригер на insert, update
	-- + не будем выполнять этот кусок если нет ни одной строки для которой изменилась CO_DateLastPublish
	if (exists ( select top 1 1 from deleted) and update(CO_DateLastPublish))
	begin
		update spad
		set    spad.SPAD_AutoOnline=1
		from   (dbo.TP_ServicePriceActualDate as spad 
			inner join dbo.TP_ServiceCalculateParametrs as scp on spad.SPAD_SCPId = scp.SCP_Id
			inner join dbo.TP_ServiceComponents as sc on scp.SCP_SCId = sc.SC_Id)
			cross join
		(deleted as d
			inner join inserted as i on d.CO_Id=i.CO_Id
			inner join dbo.CostOfferServices as [cos] on i.CO_Id = [cos].COS_COID
			inner join dbo.Seasons as seas on i.CO_SeasonId = seas.SN_Id)
		where
			scp.SCP_PKKey = i.CO_PKKey
			and SC_SVKey = i.CO_SVKey
			and SC_PRKey = i.CO_PartnerKey
			and isnull(spad.SPAD_SaleDate, @currentDate) 
				between isnull(i.CO_SaleDateBeg, '1900-01-01') 
				-- добавил день т.к. при создании ЦБ с будующими SaleDate - создаются точки пересечения и дата
				-- завершения сохраняется с +1 днем, т.е. день с которого ЦБ уже не действует
				and isnull(dateadd(dd, 1, datediff(dd, 0, i.CO_SaleDateEnd)), '2070-01-01')
			and sc.SC_Code = [cos].COS_CODE
			and i.CO_DateLastPublish != isnull(d.CO_DateLastPublish,'1900-01-01')
			and seas.SN_IsActive = 1;
	end
end
go
/*********************************************************************/
/* end T_CostOffersReCalculate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_CostOfferServicesReCalculate.sql */
/*********************************************************************/
if exists ( select  * from    sys.triggers where   object_id = object_id(N'[dbo].[T_CostOfferServicesReCalculate]') )
    drop trigger [dbo].[T_CostOfferServicesReCalculate]
go

create trigger dbo.T_CostOfferServicesReCalculate on dbo.CostOfferServices
    after insert, update
as
--<data>2012-02-17</data>
--<version>2009.02.04</version>
begin
	declare @currentDateTime datetime; set @currentDateTime = getdate();  -- 2012-02-17 14:25:12
	declare @currentDate datetime; set @currentDate = dateadd(dd, 0, datediff(dd, 0, @currentDateTime));  -- 2012-02-17 00:00:00

	-- Добавим записи в кэш соответсвующие точкам пересечения всех цен из добавленной услуги костофера 
	-- (т.е. границам дат продаж), для которых есть соответсвующие строки в TP_SCP и TP_SC
	-- CS_DateSaleEnd + 1, т.к. последний день продажи включен
	
	-- вставка строк в TP_ServicePriceactualDate возможна только в случае insert
	if not exists ( select top 1 1 from deleted ) 
	begin
		-- только нужные поля только из активных ценовых блоков
		with onlyNeedCosts as
		(
			select	CO_Id, CO_SaleDateBeg, CO_SaleDateEnd , CS_SVKey, CS_Code, CS_SubCode1, CS_Subcode2,
					CS_PrKey, CS_PkKey, CS_Date, CS_DateEnd, CS_Long, CS_LongMin, CS_Rate, CS_Cost, CS_CostNetto
			from	tbl_Costs as CS (nolock) 
					inner join CostOffers as CO (nolock) on CS.CS_COID = CO.CO_Id
					inner join inserted as COS (nolock) on CO.CO_Id = COS.COS_COID
					inner join Seasons as SN (nolock) on CO.CO_SeasonId = SN.SN_Id
			where	CO.CO_State = 1
					and SN.SN_IsActive = 1
					and COS.COS_SvKey = CS.CS_SvKey
					and COS.COS_Code = CS.CS_Code
		),
		-- точки пересечения по границам дат продаж (если граница в прошлом или null, то нам такая строка не нужна)
		crossPoints as
		(
			select	*, CO_SaleDateBeg as Date
			from	onlyNeedCosts
			where	CO_SaleDateBeg > @currentDate
			union
			select	*, dateadd(day, 1, CO_SaleDateEnd)
			from	onlyNeedCosts
			where	CO_SaleDateEnd > @currentDate
		)
		insert into	dbo.TP_ServicePriceactualDate 
					(SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross, SPAD_DateLastChange, 
					SPAD_DateLastCalculate, SPAD_NeedApply, SPAD_Netto, SPAD_AutoOnline)
		select	SCP_Id, null, CS_Rate, crossPoints.Date, CS_Cost, @currentDateTime, 
				@currentDateTime, 0, CS_CostNetto, 0
		from	(TP_ServiceCalculateParametrs as SCP (nolock)
				inner join TP_ServiceComponents as SC (nolock) on SCP.SCP_SCId = SC.SC_Id)
				cross join crossPoints
		where	SC.SC_SVKey = CS_SvKey and SC.SC_Code = CS_CODE and SC.SC_SubCode1 = CS_SUBCODE1
				and SC.SC_SubCode2 = CS_SUBCODE2 and SC.SC_PRKey = CS_PRKEY
				and ((SCP.SCP_PKKey = CS_PKKEY) or (CS_PKKEY is null))
				and SCP.SCP_Date between CS_DATE and CS_DATEEND
				and ((isnull(SCP.SCP_Days, 0) between isnull(CS_LONGMIN, 0) and isnull(CS_LONG, 0))
					or
					(CS_LONGMIN is null and CS_LONG is null))
	end

	-- обновим SPAD_DateLastChange в TP_ServicePriceActualDate при изменении 
	-- COS_IsDisable в CostOfferServices
	-- т.к. нужно только обновление, а тригер на insert, update
	if exists ( select top 1 1 from deleted ) 
	begin
		with needForUpdateIds as
		(
			-- сюда попадут Id-шники измененных костоферсервисов, для которых изменение 
			-- затронуло COS_IsDisable
			select inserted.COS_Id 
			from inserted 
				inner join deleted 
					on inserted.COS_Id = deleted.COS_Id
			where
				inserted.COS_IsDisable != deleted.COS_IsDisable
		)
		update spad
		set spad.SPAD_DateLastChange = @currentDateTime,
			SPAD_NeedApply = 1
		from dbo.TP_ServicePriceActualDate as spad
			inner join dbo.TP_ServiceCalculateParametrs as scp
				on spad.SPAD_SCPId = scp.SCP_Id
			inner join dbo.TP_ServiceComponents as sc
				on scp.SCP_SCId = sc.SC_Id
			,inserted as i
			inner join dbo.CostOffers as co 
				on i.COS_COID=co.CO_Id
			inner join dbo.Seasons as seas
				on co.CO_SeasonId = seas.SN_Id
		where
			i.COS_Code = sc.SC_Code
			and co.CO_PKKey = scp.SCP_PKKey
			and co.CO_PartnerKey = sc.SC_PRKey
			and co.CO_SVKey = sc.SC_SVKey
			and isnull(spad.SPAD_SaleDate, @currentDate) between isnull(co.CO_SaleDateBeg, '1900-01-01') and isnull(co.CO_SaleDateEnd, '2070-01-01')
			and seas.SN_IsActive=1
			and i.COS_Id in (select COS_Id from needForUpdateIds)
	end
end
go

/*********************************************************************/
/* end T_CostOfferServicesReCalculate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_CostOffersUpdate.sql */
/*********************************************************************/
if exists ( select  * from    sys.triggers where   object_id = object_id(N'[dbo].[T_CostOffersUpdate]') )
	DROP TRIGGER [dbo].[T_CostOffersUpdate]
GO

CREATE TRIGGER [dbo].[T_CostOffersUpdate]
ON [dbo].[CostOffers]
FOR UPDATE, INSERT, DELETE
AS
if ( update(co_name) or update(co_code) or update(co_SaleDateBeg) or update(co_SaleDateEnd) 
	or (not exists(select top 1 1 from inserted) and exists (select top 1 1 from deleted)))
BEGIN
--<VERSION>2009.2.12.1</VERSION>
--<DATE>2012-02-28</DATE>
  DECLARE @CO_Id int
  
  DECLARE @OCO_Name nvarchar(254)
  DECLARE @OCO_Code nvarchar(254)
  DECLARE @OCO_SaleDateBeg datetime
  DECLARE @OCO_SaleDateEnd datetime
  
  DECLARE @NCO_Name nvarchar(254)
  DECLARE @NCO_Code nvarchar(254)
  DECLARE @NCO_SaleDateBeg datetime
  DECLARE @NCO_SaleDateEnd datetime

  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED

  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_CostOffers CURSOR FOR 
	SELECT 	N.CO_Id,null,null,null,null,
			N.CO_Name,N.CO_Code,N.CO_SaleDateBeg,N.CO_SaleDateEnd
	  FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_CostOffers CURSOR FOR 
	SELECT 	O.CO_Id,O.CO_Name,O.CO_Code,O.CO_SaleDateBeg,O.CO_SaleDateEnd,
			null,null,null,null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_CostOffers CURSOR FOR 
	SELECT 	N.CO_Id,O.CO_Name,O.CO_Code,O.CO_SaleDateBeg,O.CO_SaleDateEnd,
			N.CO_Name,N.CO_Code,N.CO_SaleDateBeg,N.CO_SaleDateEnd
	FROM DELETED O, INSERTED N 
	WHERE N.CO_Id = O.CO_Id
  END
  
  OPEN cur_CostOffers
	FETCH NEXT FROM cur_CostOffers INTO 
		@CO_Id,@OCO_Name,@OCO_Code,@OCO_SaleDateBeg,@OCO_SaleDateEnd,
			@NCO_Name,@NCO_Code,@NCO_SaleDateBeg,@NCO_SaleDateEnd
	WHILE @@FETCH_STATUS = 0
	BEGIN
		------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OCO_Name, '') != ISNULL(@NCO_Name, '') OR
			ISNULL(@OCO_Code, '') != ISNULL(@NCO_Code, '') OR
			ISNULL(@OCO_SaleDateBeg, '') != ISNULL(@NCO_SaleDateBeg, '') OR
			ISNULL(@OCO_SaleDateEnd, '') != ISNULL(@NCO_SaleDateEnd, '')
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NCO_Name, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OCO_Name, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NCO_Name, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 44, @CO_Id, @sMod, @sHI_Text, '', 0, ''
			
			--------Детализация--------------------------------------------------
	
			If (ISNULL(@OCO_Name, '') != ISNULL(@NCO_Name, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 44001, @OCO_Name, @NCO_Name, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OCO_Code, '') != ISNULL(@NCO_Code, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 44002, @OCO_Code, @NCO_Code, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OCO_SaleDateBeg, '') != ISNULL(@NCO_SaleDateBeg, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 44003, null, null, null, null, @OCO_SaleDateBeg, @NCO_SaleDateBeg, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OCO_SaleDateEnd, '') != ISNULL(@NCO_SaleDateEnd, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 44004, null, null, null, null, @OCO_SaleDateEnd, @NCO_SaleDateEnd, 0, @bNeedCommunicationUpdate output
				END
		END
		FETCH NEXT FROM cur_CostOffers INTO 
		@CO_Id,@OCO_Name,@OCO_Code,@OCO_SaleDateBeg,@OCO_SaleDateEnd,
		@NCO_Name,@NCO_Code,@NCO_SaleDateBeg,@NCO_SaleDateEnd
	END
  CLOSE cur_CostOffers
  DEALLOCATE cur_CostOffers
END
GO



/*********************************************************************/
/* end T_CostOffersUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TurListDelete.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_TurListDelete]'))
DROP TRIGGER [dbo].[T_TurListDelete]
GO

CREATE TRIGGER [dbo].[T_TurListDelete]
ON [dbo].[tbl_TurList] 
FOR DELETE
AS
--<VERSION>2009.2.13.0</VERSION>
IF @@ROWCOUNT > 0
BEGIN
	DECLARE @TL_Key int
	DECLARE @xKey int
	DECLARE @costOfferPacketsCount int
	
    DECLARE cur_TurList CURSOR FOR SELECT TL_Key FROM DELETED 
	OPEN cur_TurList
		FETCH NEXT FROM cur_TurList INTO @TL_Key
		WHILE @@FETCH_STATUS = 0
			BEGIN 
				create table #CostOfferKeys (xKey int)
				
				insert into #CostOfferKeys
				select COP_COId from CostOfferPackets where COP_PKKey = @TL_Key
				
				DECLARE cur_CostOfferKeys CURSOR FOR SELECT xKey FROM #CostOfferKeys
				OPEN cur_CostOfferKeys  		
				FETCH NEXT FROM cur_CostOfferKeys INTO @xKey
				WHILE @@FETCH_STATUS = 0
					BEGIN 
						set @costOfferPacketsCount = (select count(*) from costofferpackets where cop_coid = @xKey and cop_pkkey = @tl_key)
						
						delete from costofferpackets where cop_coid = @xKey and cop_pkkey = @tl_key
						
						if @costOfferPacketsCount = 1
							delete from costoffers where co_id = @xKey
						else
							update costoffers set co_pkkey = (select top 1 cop_pkkey from costofferpackets where cop_coid = @xKey)
						
						FETCH NEXT FROM cur_CostOfferKeys INTO @xKey
					END
				CLOSE cur_CostOfferKeys
				DEALLOCATE cur_CostOfferKeys
				
				drop table #CostOfferKeys
				
				FETCH NEXT FROM cur_TurList INTO @TL_Key
			END
			
	CLOSE cur_TurList
	DEALLOCATE cur_TurList
END
go
/*********************************************************************/
/* end T_TurListDelete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.13)Insert_Action.sql */
/*********************************************************************/
delete from Actions where ac_key in (104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120
,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139)

-- MEG00038702. 13.02.2012. Golubinsky
-- Создание Actions на запрет доступа к справочникам
if not exists (select 1 from actions where ac_key = 104) 
INSERT INTO actions (ac_key,ac_name) VALUES ( 104, 'Скрыть справочник стран')
if not exists (select 1 from actions where ac_key = 105)
INSERT INTO actions (ac_key,ac_name) VALUES ( 105, 'Скрыть справочник городов')
if not exists (select 1 from actions where ac_key = 106)
INSERT INTO actions (ac_key,ac_name) VALUES ( 106, 'Скрыть справочник классов услуг')
if not exists (select 1 from actions where ac_key = 107)
INSERT INTO actions (ac_key,ac_name) VALUES ( 107, 'Скрыть справочник статусов путевок')
if not exists (select 1 from actions where ac_key = 108)
INSERT INTO actions (ac_key,ac_name) VALUES ( 108, 'Скрыть справочник отелей')
if not exists (select 1 from actions where ac_key = 109)
INSERT INTO actions (ac_key,ac_name) VALUES ( 109, 'Скрыть справочник паромов')
if not exists (select 1 from actions where ac_key = 110)
INSERT INTO actions (ac_key,ac_name) VALUES ( 110, 'Скрыть справочник авиаперелетов')
if not exists (select 1 from actions where ac_key = 111)
INSERT INTO actions (ac_key,ac_name) VALUES ( 111, 'Скрыть справочник трансферов')
if not exists (select 1 from actions where ac_key = 112)
INSERT INTO actions (ac_key,ac_name) VALUES ( 112, 'Скрыть справочник экскурсий')
if not exists (select 1 from actions where ac_key = 113)
INSERT INTO actions (ac_key,ac_name) VALUES ( 113, 'Скрыть справочник страховок')
if not exists (select 1 from actions where ac_key = 114)
INSERT INTO actions (ac_key,ac_name) VALUES ( 114, 'Скрыть справочник виз')
if not exists (select 1 from actions where ac_key = 115)
INSERT INTO actions (ac_key,ac_name) VALUES ( 115, 'Скрыть справочник типов номеров')
if not exists (select 1 from actions where ac_key = 116)
INSERT INTO actions (ac_key,ac_name) VALUES ( 116, 'Скрыть справочник категорий номеров')
if not exists (select 1 from actions where ac_key = 117)
INSERT INTO actions (ac_key,ac_name) VALUES ( 117, 'Скрыть справочник типов питания')
if not exists (select 1 from actions where ac_key = 118)
INSERT INTO actions (ac_key,ac_name) VALUES ( 118, 'Скрыть справочник типов кают')
if not exists (select 1 from actions where ac_key = 119)
INSERT INTO actions (ac_key,ac_name) VALUES ( 119, 'Скрыть справочник типов размещения')
if not exists (select 1 from actions where ac_key = 120)
INSERT INTO actions (ac_key,ac_name) VALUES ( 120, 'Скрыть справочник типов транспорта')
if not exists (select 1 from actions where ac_key = 121)
INSERT INTO actions (ac_key,ac_name) VALUES ( 121, 'Скрыть справочник тарифов на авиаперелеты')
--if not exists (select 1 from actions where ac_key = 122)
--INSERT INTO actions (ac_key,ac_name) VALUES ( 122, 'Скрыть справочник видов проживания')
if not exists (select 1 from actions where ac_key = 123)
INSERT INTO actions (ac_key,ac_name) VALUES ( 123, 'Скрыть справочник доп. описаний 1')
if not exists (select 1 from actions where ac_key = 124)
INSERT INTO actions (ac_key,ac_name) VALUES ( 124, 'Скрыть справочник доп. описаний 2')
if not exists (select 1 from actions where ac_key = 125)
INSERT INTO actions (ac_key,ac_name) VALUES ( 125, 'Скрыть справочник статусов услуг')
if not exists (select 1 from actions where ac_key = 126)
INSERT INTO actions (ac_key,ac_name) VALUES ( 126, 'Скрыть справочник оснований для скидок')
if not exists (select 1 from actions where ac_key = 127)
INSERT INTO actions (ac_key,ac_name) VALUES ( 127, 'Скрыть справочник валют')
if not exists (select 1 from actions where ac_key = 128)
INSERT INTO actions (ac_key,ac_name) VALUES ( 128, 'Скрыть справочник курсов валют')
if not exists (select 1 from actions where ac_key = 129)
INSERT INTO actions (ac_key,ac_name) VALUES ( 129, 'Скрыть справочник план. кросс-курсов валют')
if not exists (select 1 from actions where ac_key = 130)
INSERT INTO actions (ac_key,ac_name) VALUES ( 130, 'Скрыть справочник видов рекламы')
if not exists (select 1 from actions where ac_key = 131)
INSERT INTO actions (ac_key,ac_name) VALUES ( 131, 'Скрыть справочник постоянных клиентов')
if not exists (select 1 from actions where ac_key = 132)
INSERT INTO actions (ac_key,ac_name) VALUES ( 132, 'Скрыть справочник названий полей анкет')
if not exists (select 1 from actions where ac_key = 133)
INSERT INTO actions (ac_key,ac_name) VALUES ( 133, 'Скрыть справочник вариантов полей анкет')
if not exists (select 1 from actions where ac_key = 134)
INSERT INTO actions (ac_key,ac_name) VALUES ( 134, 'Скрыть справочник полей анкет по странам')
if not exists (select 1 from actions where ac_key = 135)
INSERT INTO actions (ac_key,ac_name) VALUES ( 135, 'Скрыть справочник причин аннуляции')
if not exists (select 1 from actions where ac_key = 136)
INSERT INTO actions (ac_key,ac_name) VALUES ( 136, 'Скрыть справочник системы оповещений')
if not exists (select 1 from actions where ac_key = 137)
INSERT INTO actions (ac_key,ac_name) VALUES ( 137, 'Скрыть справочник статусов документов')
if not exists (select 1 from actions where ac_key = 138)
INSERT INTO actions (ac_key,ac_name) VALUES ( 138, 'Скрыть справочник отелей и цен')
if not exists (select 1 from actions where ac_key = 139)
INSERT INTO actions (ac_key,ac_name) VALUES ( 139, 'Скрыть справочник реал. кросс-курсов валют')
go


if not exists(select id from syscolumns where id = OBJECT_ID('actions') and name = 'AC_IsActionForRestriction')
alter table actions add AC_IsActionForRestriction bit not null default(0)
go

update actions set ac_isactionforrestriction = 1, ac_customscript = null, ac_name = 'Справочники -> ' + ac_name where 
ac_key in (104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120
,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139)

GO

/*********************************************************************/
/* end (2012.02.13)Insert_Action.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetEndbledActions.sql */
/*********************************************************************/
-- MEG00038702. 14.02.2012. Golubinsky
-- Процедура возвращает результирующий набор - ключи включенных для текущего пользователя 
-- записей из таблицы Actions

--<VERSION>ALL</VERSION>
--<DATE>27.02.2012</DATE>

IF  EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[GetEndbledActions]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetEndbledActions]
GO

CREATE PROCEDURE [dbo].[GetEndbledActions] (@currentUserKey int)
AS
BEGIN

	-- result set
	DECLARE @result AS TABLE
	(
		actionKey INT
	)
	
	DECLARE @userid varchar(100)
	
	select @userid = us_userid from userlist where us_key = @currentUserKey

	-- Fill result set table with enabled action keys
	IF @currentUserKey = 0 or isnull(IS_ROLEMEMBER ('db_owner',@userid),0) = 1
	BEGIN
		
		-- SYSADM user
		INSERT INTO @result
		SELECT AC_Key FROM Actions where ac_isactionforrestriction = 0
		
	END
	ELSE
	BEGIN
	
		INSERT INTO @result
		
		SELECT ACA_ACKey 
		FROM ActionsAuth  	
		WHERE ACA_USKey = @currentUserKey
	                
		UNION
	                
		SELECT GRA_ACKey 
		FROM GroupAuth, UserList, sysmembers m, sysusers u, sysusers g  	
		WHERE m.memberuid = u.uid 
				AND GRA_GRKey = m.groupuid 
				AND g.uid = m.groupuid 
				AND u.name = US_UserID 
				AND US_Key = @currentUserKey

		UNION

		SELECT DISTINCT	gra_ackey				
		FROM	GroupAuth
		WHERE	GRA_GRKey = 0
	
	END
	
	SELECT * FROM @result
	WHERE actionKey is not null
	ORDER BY actionKey ASC

END

GO

grant exec on [dbo].[GetEndbledActions] to [public]
GO
/*********************************************************************/
/* end sp_GetEndbledActions.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_IsActionEnabledByScript.sql */
/*********************************************************************/
-- Golubinsky. 20.02.2012
-- Проверка удовлетворения скрипта в колонке ac_customScript таблицы Actions
-- предъявляемым условиям (результирующий набор его выполнения = 1 (колонка с именем result))

--<VERSION>ALL</VERSION>
--<DATE>28.02.2012</DATE>

IF  EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[IsActionEnabledByScript]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[IsActionEnabledByScript]
GO

CREATE PROCEDURE IsActionEnabledByScript
(
	@ActionKey INT
)
AS
BEGIN
	
	DECLARE @customScriptRowsCount AS TABLE
	(
		rowsCount INT
	)
	
	DECLARE @rethrowError AS BIT
	DECLARE @errMeg AS NVARCHAR(MAX)
	
	BEGIN TRY
	
		DECLARE @currentActionScript AS NVARCHAR(MAX)
		
		SELECT @currentActionScript = AC_CUSTOMSCRIPT
		FROM Actions
		WHERE AC_KEY = @ActionKey
	
		DECLARE @sql AS NVARCHAR(MAX)
		
		IF @currentActionScript is not null
		BEGIN
			SET @sql = 'IF (SELECT COUNT(*) 
							FROM ( ' + @currentActionScript + ' ) AS resultSet 
							WHERE resultSet.result >= 1) >= 1
					BEGIN
					
						SELECT 1
					
					END
					ELSE
					BEGIN
					
						SELECT 0
					
					END
					'
		END
		ELSE
		BEGIN
			SET @sql = 'SELECT 1'
		END
				
		EXEC (@sql)
	
	END TRY
	BEGIN CATCH
	
		-- mask current error for release resources
		-- and mark @rethrowError for rethrow error after release
		SET @errMeg = ERROR_MESSAGE()
		SET @rethrowError = 1
	
	END CATCH

	IF @rethrowError = 1
	BEGIN 
		-- there was an error during procedure execution.
		-- All resources are already released, therefore rethrow error
		SET @errMeg = 'There was an error during execution ac_customScript of action with key ' 
				+ convert(NVARCHAR(10), @ActionKey) + ' : ' + @errMeg
				
		RAISERROR (@errMeg, 18, 100);
	
	end

END
GO

GRANT EXEC ON dbo.IsActionEnabledByScript TO PUBLIC
GO
/*********************************************************************/
/* end sp_IsActionEnabledByScript.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_Create_TableExtension_Tables.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TableExtension_Tables]') AND type in (N'U'))
CREATE TABLE [dbo].[TableExtension_Tables](
	[TET_Id] [int] IDENTITY(1,1) NOT NULL,
	[TET_TableName] [nvarchar](100) NOT NULL,
	[TET_TableDescription] [nvarchar](100) NULL,
 CONSTRAINT [PK_TableExtension_Tables] PRIMARY KEY CLUSTERED 
(
	[TET_Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

GO



/*********************************************************************/
/* end (2012.03.23)_Create_TableExtension_Tables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_Create_TableExtension_ColumnTypes.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TableExtension_ColumnTypes]') AND type in (N'U'))
CREATE TABLE [dbo].[TableExtension_ColumnTypes](
	[TECT_Id] [int] IDENTITY(1,1) NOT NULL,
	[TECT_TypeName] [nvarchar](255) NOT NULL,
	[TECT_CLRType] [nvarchar](max) NOT NULL,
 CONSTRAINT [PK_TableExtension_ColumnTypes] PRIMARY KEY CLUSTERED 
(
	[TECT_Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

GO



/*********************************************************************/
/* end (2012.03.23)_Create_TableExtension_ColumnTypes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_Create_TableExtension_Columns.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_TableExtension_Columns_TableExtension_ColumnTypes]') AND parent_object_id = OBJECT_ID(N'[dbo].[TableExtension_Columns]'))
ALTER TABLE [dbo].[TableExtension_Columns] DROP CONSTRAINT [FK_TableExtension_Columns_TableExtension_ColumnTypes]
GO
IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_TableExtension_Columns_TableExtension_Tables]') AND parent_object_id = OBJECT_ID(N'[dbo].[TableExtension_Columns]'))
ALTER TABLE [dbo].[TableExtension_Columns] DROP CONSTRAINT [FK_TableExtension_Columns_TableExtension_Tables]
GO
IF not EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TableExtension_Columns]') AND type in (N'U'))
CREATE TABLE [dbo].[TableExtension_Columns](
	[TEC_Id] [int] IDENTITY(1,1) NOT NULL,
	[TEC_TETId] [int] NOT NULL,
	[TEC_TECTId] [int] NOT NULL,
	[TEC_ColumnName] [nvarchar](100) NOT NULL,
	[TEC_SortOrder] [int] NULL,
 CONSTRAINT [PK_TableExtension_Columns] PRIMARY KEY CLUSTERED 
(
	[TEC_Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
ALTER TABLE [dbo].[TableExtension_Columns]  WITH CHECK ADD  CONSTRAINT [FK_TableExtension_Columns_TableExtension_ColumnTypes] FOREIGN KEY([TEC_TECTId])
REFERENCES [dbo].[TableExtension_ColumnTypes] ([TECT_Id])
GO
ALTER TABLE [dbo].[TableExtension_Columns] CHECK CONSTRAINT [FK_TableExtension_Columns_TableExtension_ColumnTypes]
GO
ALTER TABLE [dbo].[TableExtension_Columns]  WITH CHECK ADD  CONSTRAINT [FK_TableExtension_Columns_TableExtension_Tables] FOREIGN KEY([TEC_TETId])
REFERENCES [dbo].[TableExtension_Tables] ([TET_Id])
GO
ALTER TABLE [dbo].[TableExtension_Columns] CHECK CONSTRAINT [FK_TableExtension_Columns_TableExtension_Tables]
GO
/*********************************************************************/
/* end (2012.03.23)_Create_TableExtension_Columns.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_Create_TableExtension_Values.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_TableExtension_Values_TableExtension_Columns]') AND parent_object_id = OBJECT_ID(N'[dbo].[TableExtension_Values]'))
ALTER TABLE [dbo].[TableExtension_Values] DROP CONSTRAINT [FK_TableExtension_Values_TableExtension_Columns]
GO
IF not EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TableExtension_Values]') AND type in (N'U'))
CREATE TABLE [dbo].[TableExtension_Values](
	[TEV_TECId] [int] NOT NULL,
	[TEV_TableRowId] [int] NOT NULL,
	[TEV_ColumnValue] [nvarchar](max) NULL,
 CONSTRAINT [PK_TableExtension_Values] PRIMARY KEY CLUSTERED 
(
	[TEV_TECId] ASC,
	[TEV_TableRowId] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

ALTER TABLE [dbo].[TableExtension_Values]  WITH CHECK ADD  CONSTRAINT [FK_TableExtension_Values_TableExtension_Columns] FOREIGN KEY([TEV_TECId])
REFERENCES [dbo].[TableExtension_Columns] ([TEC_Id])
GO

ALTER TABLE [dbo].[TableExtension_Values] CHECK CONSTRAINT [FK_TableExtension_Values_TableExtension_Columns]
GO



/*********************************************************************/
/* end (2012.03.23)_Create_TableExtension_Values.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.05.17)CreateTablesClientBonuses.sql */
/*********************************************************************/

--таблица счетов клиентов
IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ClientBonusAccounts]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[ClientBonusAccounts](
		CBA_Key[int] IDENTITY(1,1) NOT NULL,
		CBA_CLKey [int] not NULL,
		CBA_Bonus  float NULL,
		CBA_ActiveBonus  float NULL,
	PRIMARY KEY CLUSTERED 
	(
		CBA_Key ASC
	))
end
GO

IF NOT EXISTS (SELECT * FROM sysobjects WHERE name = 'FX_CBA_CLKey' AND type in (N'F'))
ALTER TABLE [dbo].[ClientBonusAccounts]  WITH CHECK ADD  CONSTRAINT [FX_CBA_CLKey] FOREIGN KEY([CBA_CLKey])
REFERENCES [dbo].Clients ([CL_KEY])
GO

--таблица правил начисления бонусов
IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ClientBonusRules]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[ClientBonusRules](
		CBR_Key[int] IDENTITY(1,1) NOT NULL,
		CBR_CBOKey int not null,
		CBR_DateUpdate datetime not NULL,
		CBR_UsersID  int NULL,
		CBR_MinValue  float NULL,
		CBR_MaxValue float NULL,
		CBR_Rule varchar (200) null
	PRIMARY KEY CLUSTERED 
	(
		CBR_Key ASC
	))
end
GO

--таблица действий с бонусами ClientBonusTransactions 

IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ClientBonusTransactions]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[ClientBonusTransactions](
		CBT_Key [int] IDENTITY(1,1) NOT NULL,
		CBT_CBAKey  int not NULL,
        CBT_CBOKey int not null,
        CBT_DGKey int  null,
        CBT_Description varchar(500) null,
        CBT_PassedFrom int null,
        CBT_Bonus float null,
        CBT_Money float null,
        CBT_Date datetime not null,
        CBT_DateValid datetime not null,
        CBT_USKey int not null,
        CBT_USED float null 
	PRIMARY KEY CLUSTERED 
	(
		CBT_Key ASC
	))
end
GO

IF NOT EXISTS (SELECT * FROM sysobjects WHERE name = 'FX_CBT_CBAKey' AND type in (N'F'))
ALTER TABLE [dbo].[ClientBonusTransactions]  WITH CHECK ADD  CONSTRAINT [FX_CBT_CBAKey] FOREIGN KEY([CBT_CBAKey])
REFERENCES [dbo].ClientBonusAccounts ([CBA_KEY])
GO


GO
GRANT SELECT,INSERT,UPDATE,DELETE ON [dbo].ClientBonusAccounts TO public
GO
GRANT SELECT,INSERT,UPDATE,DELETE ON [dbo].ClientBonusTransactions TO public
GO
GRANT SELECT,INSERT,UPDATE,DELETE ON [dbo].ClientBonusRules TO public
GO


/*********************************************************************/
/* end (2012.05.17)CreateTablesClientBonuses.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetPartnerCommission.sql */
/*********************************************************************/
if EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[GetPartnerCommission]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	DROP PROCEDURE [dbo].[GetPartnerCommission]
GO

CREATE PROCEDURE [dbo].[GetPartnerCommission] 
     @nTLKey int,
     @nPRKey int,
     @nBTKey int,
     @nDSKey int output,
     @nValue money output,
     @nIsPercent int output, 
	 @dCheckinDate datetime,
	 @nCNKey int=0,
	 @DGCreateDate datetime = null,
	 @nDepartureCity int = 0,
	 @sDiscountCode varchar(5) = null,
	 @sDiscountNumber varchar(10) = null,
	 @price decimal(16,6) = null,
	 @rate varchar(3) = null,
	 @dogovorCode varchar(10) = null
AS
	declare @discountSettingValue varchar(256)
	select @discountSettingValue = ISNULL(SS_ParmValue, '0') from dbo.SystemSettings where SS_ParmName like 'SYSUseDiscountCards'
	if @discountSettingValue = '1' and ISNULL(@sDiscountCode, '') != '' and ISNULL(@sDiscountNumber, '') != ''
	begin
		
		declare @discountCode varchar(5)
		declare @discountNumber varchar(10)
		declare @reservationsCount int, @cardKey int
		declare @reservationsPrice decimal(16,6)
		declare @nationalRate varchar(3)
		declare @discount money
		declare @discountId int

		if (ISNULL(@dogovorCode, '') = '')
		begin
			set @sDiscountCode = rtrim(ltrim(@sDiscountCode))
			set @sDiscountNumber = rtrim(ltrim(@sDiscountNumber))
				
			select @cardKey = CD_Key from Cards where ISNULL(CD_Code, '') = ISNULL(@sDiscountCode, '') and ISNULL(CD_Number, '') = ISNULL(@sDiscountNumber, '')
			select @reservationsCount = count(RR_ID) from ReservationsRegister where RR_CardKey = @cardKey
			select @reservationsPrice = sum(DG_NationalCurrencyPrice) from Dogovor where DG_CODE in (select RR_DGCODE  COLLATE Cyrillic_General_CI_AS from ReservationsRegister where RR_CardKey = @cardKey)
			select @nationalRate = RA_Code from dbo.Rates where RA_National = 1
			exec ExchangeCost @price output, @rate, @nationalRate, @dCheckinDate

			set @reservationsPrice = ISNULL(@reservationsPrice, 0)
		
			select top 1 @discount = cast(ISNULL(DS_DISCOUNT, 0) as money), @discountId = DS_ID  
				from dbo.DiscountScheme, dbo.TurList, dbo.TurService where 
				TL_Key = @nTLKey and 
				TS_TRKey = TL_Key and
				DS_Series like @sDiscountCode and
				((DS_CityFromKey is not null and DS_CityFromKey = TL_CTDepartureKey) or (DS_CityFromKey is null)) and
				((DS_CountryKey is not null and DS_CountryKey = TL_CNKey) or (DS_CountryKey is null)) and
				((DS_CityKey is not null and DS_CityKey = TS_CTKey) or (DS_CityKey is null)) and
				((DS_TourTypeKey is not null and DS_TourTypeKey = TL_TIP) or (DS_TourTypeKey is null)) and
				((DS_ReservationsFrom is not null and DS_ReservationsFrom <= (@reservationsCount + 1)) or (DS_ReservationsFrom is null)) and
				((DS_ReservationsTo is not null and DS_ReservationsTo >= (@reservationsCount + 1)) or (DS_ReservationsTo is null)) and
				((DS_TotalCostFrom is not null and DS_TotalCostFrom <= (@reservationsPrice + @price)) or (DS_TotalCostFrom is null)) and
				((DS_TotalCostTo is not null and DS_TotalCostTo >= (@reservationsPrice + @price)) or (DS_TotalCostTo is null)) and
				((DS_MinPrice is not null and DS_MinPrice <= @price) or (DS_MinPrice is null))
			order by DS_ID DESC

			set @nDSKey = -1
			set @nValue = @discount
			set @nIsPercent = 1
			return 1
		end
		else
		begin
			
			select @discount = DD_DiscountPercent from dbo.DogovorDetails where DD_DGCODE like @dogovorCode
			set @discount = ISNULL(@discount, 0)
			set @nDSKey = -1
			set @nValue = @discount
			set @nIsPercent = 1
			return 1
		end
		
	end

     if @nPRKey = 0
     begin
          set @nDSKey = -1     
          set @nValue = 0     
          set @nIsPercent = 1     
		  return 0
     end

	declare @nPGKey int, @nTpKey int, @nAttr int, @nCTDepartureKey int
	set @nTpKey=0
	if 	@nPRKey>0
		select @nPGKey = PR_PGKey from Partners where PR_Key = @nPRKey
	else
		set @nPGKey=0
	if @nTLKey>0
		select @nCNKey = TL_CNKey, @nTpKey=TL_TIP, @nAttr = isnull(TL_Attribute, 0) 
		from TurList where TL_Key = @nTLKey

	declare @discountAction int
	set @discountAction = 0
	if @nAttr & 16 > 0
		set @discountAction = 1

	if @dCheckinDate is null
		SET @dCheckinDate=ISNULL(@dCheckinDate,GetDate())
     if @nBTKey = 0 or @nBTKey is null
     begin
          select @nDSKey = DS_Key, @nValue = DS_Value, @nIsPercent = DS_IsPercent from Discounts
          where DS_PRKey IN(0, @nPRKey) AND DS_BTKey IN (0, @nBTKey) AND DS_PGKey IN (0, @nPGKey) 
				AND DS_TLKey IN (0, @nTLKey) AND DS_CNKey IN (0, @nCNKey) AND DS_TPKEY IN (0,@nTpKey)
				AND @dCheckinDate between ISNULL(DS_CheckInFrom,'30-DEC-1899') and ISNULL(DS_CheckInTo,'30-DEC-2200')
				AND DATEDIFF(d, GetDate(), @dCheckinDate) <= ISNULL(DS_DaysBeforeCheckIn, 99999)
				AND ISNULL(@DGCreateDate, ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899')) between ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899') and dateadd(second,-1,dateadd(day,1,CONVERT(char(10), ISNULL(DS_DogovorCreateDateTo,'30-DEC-2200'),126)))
				AND (CASE WHEN @discountAction = 0 THEN ISNULL(DS_DAKey, 0) ELSE 0 END) = 0
				AND DS_DepartureCityKey IN (0, @nDepartureCity)
          order by DS_Priority, DS_BTKey desc, DS_TLKey, DS_CNKey,DS_TPKEY, DS_PRKey, DS_PGKey, DS_DepartureCityKey, @dCheckinDate - ISNULL(DS_DaysBeforeCheckIn, 77777) asc, DS_DogovorCreateDateFrom asc, DS_DogovorCreateDateTo asc, DS_DAKey asc
     end
     else
     begin
          select @nDSKey = DS_Key, @nValue = DS_Value, @nIsPercent = DS_IsPercent from Discounts
          where DS_PRKey IN(0, @nPRKey) AND DS_BTKey IN (0, @nBTKey) AND DS_PGKey IN (0, @nPGKey) 
				AND DS_TLKey IN (0, @nTLKey) AND DS_CNKey IN (0, @nCNKey) AND DS_TPKEY IN (0,@nTpKey)
				AND @dCheckinDate between ISNULL(DS_CheckInFrom,'30-DEC-1899') and ISNULL(DS_CheckInTo,'30-DEC-2200')
				AND DATEDIFF(d, GetDate(), @dCheckinDate) <= ISNULL(DS_DaysBeforeCheckIn, 99999)
				AND ISNULL(@DGCreateDate, ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899')) between ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899') and dateadd(second,-1,dateadd(day,1,CONVERT(char(10), ISNULL(DS_DogovorCreateDateTo,'30-DEC-2200'),126)))
				AND (CASE WHEN @discountAction = 0 THEN ISNULL(DS_DAKey, 0) ELSE 0 END) = 0
				AND DS_DepartureCityKey IN (0, @nDepartureCity)
          order by DS_Priority, DS_BTKey, DS_TLKey, DS_CNKey, DS_TPKEY,DS_PRKey, DS_PGKey, DS_DepartureCityKey, @dCheckinDate - ISNULL(DS_DaysBeforeCheckIn, 77777) asc, DS_DogovorCreateDateFrom asc, DS_DogovorCreateDateTo asc, DS_DAKey asc
     end

     if @nDSKey is null
     begin
          set @nDSKey = -1     
          set @nValue = 0     
          set @nIsPercent = 1     
     end
GO

grant execute on [dbo].[GetPartnerCommission] to public
GO
/*********************************************************************/
/* end sp_GetPartnerCommission.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 02042012_CreateTable_CacheQuotas.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CacheQuotas]') AND type in (N'U'))
begin
	drop table [dbo].[CacheQuotas]
end
GO

CREATE TABLE [dbo].[CacheQuotas](
	[cq_svkey] [int] NULL,
	[cq_code] [int] NULL,
	[cq_rmkey] [int] NULL,
	[cq_rckey] [int] NULL,
	[cq_date] [datetime] NULL,
	[cq_day] [int] NULL,
	[cq_days] [int] NULL,
	[cq_prkey] [int] NULL,
	[cq_pkkey] [int] NULL,
	[cq_res] [varchar](256) NULL,
	[cq_places] [int] NULL,
	[cq_datecheck] [datetime] NULL,
	[cq_stepindex] [smallint] NULL,
	[cq_pricecorrection] [int] NULL,
	[cq_findflight] [int] NULL,
	[cq_Additional] [varchar](2000) NULL
) ON [PRIMARY]
GO

ALTER TABLE [dbo].[CacheQuotas] ADD  CONSTRAINT [DF_CacheQuotas_cq_datecheck]  DEFAULT (getdate()) FOR [cq_datecheck]
GO

grant select, insert, update, delete on [dbo].[CacheQuotas] to public
GO
/*********************************************************************/
/* end 02042012_CreateTable_CacheQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ClearQuotaCache.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects 
					where id = object_id(N'[dbo].[ClearQuotaCache]') 
					and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[ClearQuotaCache]

GO

--<DATE>2012-05-22</DATE>
--<VERSION>ALL</VERSION>
-- Очистка записей из кеша квот
CREATE procedure [dbo].[ClearQuotaCache]
as
begin
	
	declare @CacheQuotaMinute int	-- предел (в минутах) хранения записи в кеше квот
	set @CacheQuotaMinute = 10
	
	DELETE FROM CacheQuotas with(rowlock) 
	WHERE cq_datecheck < DATEADD(MINUTE, -@CacheQuotaMinute, GetDate())

	Return 0

end

GO
/*********************************************************************/
/* end sp_ClearQuotaCache.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_Paging.sql */
/*********************************************************************/
--<DATE>2012-07-24</DATE>
---<VERSION>2009.2.15</VERSION>
if exists (select * from [dbo].sysobjects where id = object_id(N'[dbo].[Paging]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[Paging]
GO

CREATE procedure [dbo].[Paging]
@pagingType	smallint=2,
@countryKey	int,
@departFromKey	int,
@filter		varchar(4000),
@sortExpr	varchar(1024),
@pageNum	int=0,		-- номер страницы(начиная с 1 или количество уже просмотренных записей для исключения при @pagingType=@ACTUALPLACES_PAGING)
@pageSize	int=9999,
@agentKey	int=0,
@hotelQuotaMask smallint=0,
@aviaQuotaMask smallint=0,
@getServices	smallint=0,
@flightGroups	varchar(256),
@checkAgentQuota smallint,
@checkCommonQuota smallint,
@checkNoLongQuota smallint,
@requestOnRelease smallint,
@expiredReleaseResult int,
@noPlacesResult int,
@findFlight smallint,
@checkFlightPacket smallint,
@checkAllPartnersQuota smallint = null,
@calculateVisaDeadLine smallint = 0,
@noSmartSearch bit = 0
AS
set nocount on

/******************************************************************************
**		Parameters:

		@filter		varchar(1024),	 - поисковый фильтр (where-фраза)
		@sortExpr	varchar(1024),	 - выражение сортировки
		@pageNum	int=1,	 - № страницы
		@pageSize	int=9999	 - размер страницы
		@transform	smallint=0	 - преобразовывать ли полученные данные для расположения продолжительностей по горизонтали
		@noSmartSearch bit = 0	- запрещает подмешивать варианты в поиск (приоритетней чем настройка в SystemSettings) - используется при недефолтной сортировке
*******************************************************************************/

---=== Если это пейджинг для пакса, то перенаправляемся в его хранимку ===---
if (@pagingType = 4)
begin
	exec PagingPax @countryKey, @departFromKey, @filter, @sortExpr, @pageNum, @pageSize
			, @agentKey, @hotelQuotaMask,  @aviaQuotaMask, @flightGroups, @checkAgentQuota, @checkCommonQuota, @checkNoLongQuota
			, @requestOnRelease, @expiredReleaseResult, @noPlacesResult, @findFlight, @checkFlightPacket
	return
end


declare @mwSearchType int
select @mwSearchType=isnull(SS_ParmValue,1) from dbo.systemsettings 
where SS_ParmName='MWDivideByCountry'

-- BEGIN Added by Allen to prevent latest price selection
declare @mwLatestPrices int
select @mwLatestPrices = isnull(SS_ParmValue,1) from dbo.systemsettings 
where SS_ParmName='MW_PACLatestPrices'

-- BEGIN Added by Allen to prevent latest price selection
declare @tableName varchar(256)
declare @viewName varchar(256)
if(@mwSearchType=0)
begin
	set @tableName='mwPriceTable'
	set @viewName='dbo.mwPriceTableView'
	set @filter=' pt_cnkey= ' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom= ' + LTRIM(STR(@departFromKey)) + ' and ' + @filter
end
else 
begin
	set @tableName=dbo.mwGetPriceViewName(@countryKey,@departFromKey)
	set @viewName=REPLACE(@tableName,'PriceTable','PriceTableView')
end

declare @MAX_ROWCOUNT int
set @MAX_ROWCOUNT=1000 -- если @pageSize больше этого числа,что пейджинг производиться не будет
declare @SIMPLE_PAGING smallint
set @SIMPLE_PAGING=1
declare @ACTUALPLACES_PAGING smallint
set @ACTUALPLACES_PAGING=2
declare @DYNAMIC_SPO_PAGING smallint
set @DYNAMIC_SPO_PAGING=3
declare @QUOTAMASK_NO smallint
set @QUOTAMASK_NO=0
declare @QUOTAMASK_ALL smallint
set @QUOTAMASK_ALL=7

-- настройка включающая SmartSearch
declare @mwUseSmartSearch int
select @mwUseSmartSearch=isnull(SS_ParmValue,0) from dbo.systemsettings 
where SS_ParmName='mwUseSmartSearch'
-- пока SmartSearch работает с только с ACTUALPLACES_PAGING
-- параметр @noSmartSearch - блокирует подмешивание
if (@pagingType <> @ACTUALPLACES_PAGING or @noSmartSearch = 1)
begin
	set @mwUseSmartSearch = 0
end

-- направление сортировки
declare @sortType smallint
set @sortType=1 -- по возр
declare @spageNum varchar(30)
declare @spageSize varchar(30)
set @spageNum=LTRIM(STR(@pageNum))
set @spageSize=LTRIM(STR(@pageSize))


if(@pagingType = @DYNAMIC_SPO_PAGING)
	set @findFlight = 0

if(@hotelQuotaMask > 0 or @aviaQuotaMask > 0)
begin
		create table #checked(
			svkey int,
			code int,
			rmkey int,
			rckey int,
			date datetime,
			day int,
			days int,
			prkey int,
			pkkey int,
			res varchar(256),
			places int,
			step_index smallint,
			price_correction int,
			find_flight bit default(0)	-- 07.02.2012. Golubinsky. Для правильного кеширования результатов при подборе перелета
		)
end

declare @sql varchar(8000)
set @sql=''
if (@pagingType = 0 or @pagingType = 5)
begin
	declare @zptPos int
	declare @prefix varchar(1024)
	set @zptPos = charindex(',',@sortExpr)
	if(@zptPos > 0)
		set @prefix = substring(@sortExpr, 1, @zptPos)
	else
	set @prefix = @sortExpr

	if(charindex('desc', @prefix) > 0)
		set @sortType=-1

	if(@sortType <= 0)
	begin
		set @viewName=replace(@viewName,'mwPriceTableView','mwPriceTableViewDesc')
	end
	else
	begin
		set @viewName=replace(@viewName,'mwPriceTableView','mwPriceTableViewAsc')
	end

	create table #days(
		days int,
		nights int
	)

	if (@pagingType = 5)
		set @sql='select distinct top 5 pt_days,pt_nights from '
	else if (@pagingType = 0)
		set @sql='select distinct top 5 pt_days,pt_nights from '


	if(@mwSearchType=0)
-- BEGIN Removed by Allen
--			set @sql=@sql + @tableName +  ' t1 with(nolock) inner join (select pt_ctkeyfrom ctkeyfrom,pt_cnkey cnkey, pt_tourtype tourtype,pt_mainplaces mainplaces, pt_addplaces addplaces, pt_tourdate tourdate,pt_pnkey pnkey,pt_pansionkeys pansionkeys,pt_days days,pt_nights nights,pt_hdkey hdkey,pt_hotelkeys hotelkeys,pt_hrkey hrkey,max(pt_key) ptkey from ' + @tableName + ' with(nolock) group by pt_ctkeyfrom,pt_cnkey,pt_tourtype,pt_mainplaces, pt_addplaces,pt_tourdate,pt_pnkey,pt_pansionkeys,pt_nights,pt_hotelnights,pt_days,pt_hdkey,pt_hotelkeys,pt_hrkey) t2
--		on t1.pt_ctkeyfrom=t2.ctkeyfrom and t1.pt_cnkey=t2.cnkey and t1.pt_tourtype = t2.tourtype and t1.pt_mainplaces=t2.mainplaces and t1.pt_addplaces=t2.addplaces and t1.pt_tourdate=t2.tourdate
--			and t1.pt_pnkey=t2.pnkey and t1.pt_nights=t2.nights and t1.pt_days=t2.days and
--				t1.pt_hdkey=t2.hdkey and t1.pt_hrkey=t2.hrkey and t1.pt_key=t2.ptkey where pt_cnkey=' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom=' + LTRIM(STR(@departFromKey)) + ' and ' + @filter
-- END Removed by Allen


-- BEGIN Added by Allen
	 begin
		if (@mwLatestPrices=0 and charindex('pt_tourkey', @filter) > 0)	
			set @sql=@sql + @tableName +  ' t1 with(nolock) where pt_cnkey=' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom=' + LTRIM(STR(@departFromKey)) + ' and ' + @filter
		else
			set @sql=@sql + @tableName +  ' t1 with(nolock) inner join (select pt_ctkeyfrom ctkeyfrom,pt_cnkey cnkey, pt_tourtype tourtype,pt_mainplaces mainplaces, pt_addplaces addplaces, pt_tourdate tourdate,pt_pnkey pnkey,pt_pansionkeys pansionkeys,pt_days days,pt_nights nights,pt_hdkey hdkey,pt_hotelkeys hotelkeys,pt_hrkey hrkey,max(pt_key) ptkey from ' + @tableName + ' with(nolock) group by pt_ctkeyfrom,pt_cnkey,pt_tourtype,pt_mainplaces, pt_addplaces,pt_tourdate,pt_pnkey,pt_pansionkeys,pt_nights,pt_hotelnights,pt_days,pt_hdkey,pt_hotelkeys,pt_hrkey) t2
		on t1.pt_ctkeyfrom=t2.ctkeyfrom and t1.pt_cnkey=t2.cnkey and t1.pt_tourtype = t2.tourtype and t1.pt_mainplaces=t2.mainplaces and t1.pt_addplaces=t2.addplaces and t1.pt_tourdate=t2.tourdate
			and t1.pt_pnkey=t2.pnkey and t1.pt_nights=t2.nights and t1.pt_days=t2.days and
				t1.pt_hdkey=t2.hdkey and t1.pt_hrkey=t2.hrkey and t1.pt_key=t2.ptkey where pt_cnkey=' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom=' + LTRIM(STR(@departFromKey)) + ' and ' + @filter
	end	
-- END Added by Allen
	else
		set @sql=@sql + @tableName + ' t1 with(nolock) inner join (select pt_ctkeyfrom ctkeyfrom,pt_cnkey cnkey, pt_tourtype tourtype,pt_mainplaces mainplaces, pt_addplaces addplaces, pt_tourdate tourdate,pt_pnkey pnkey,pt_pansionkeys pansionkeys,pt_days days,pt_nights nights,pt_hdkey hdkey,pt_hotelkeys hotelkeys,,pt_hrkey hrkey,max(pt_key) ptkey from ' + @tableName + ' with(nolock) group by pt_ctkeyfrom,pt_cnkey,pt_tourtype,pt_mainplaces, pt_addplaces,pt_tourdate,pt_pnkey,pt_pansionkeys,pt_nights,pt_hotelnights,pt_days,pt_hdkey,pt_hotelkeys,pt_hrkey) t2
	on t1.pt_ctkeyfrom=t2.ctkeyfrom and t1.pt_cnkey=t2.cnkey and t1.pt_tourtype = t2.tourtype and t1.pt_mainplaces=t2.mainplaces and t1.pt_addplaces=t2.addplaces and t1.pt_tourdate=t2.tourdate
		and t1.pt_pnkey=t2.pnkey and t1.pt_nights=t2.nights and t1.pt_days=t2.days and
			t1.pt_hdkey=t2.hdkey and t1.pt_hrkey=t2.hrkey and t1.pt_key=t2.ptkey where ' + @filter

	set @sql=@sql + ' order by pt_days,pt_nights'
	insert into #days exec(@sql)

	declare @sKeysSelect varchar(2024)
	set @sKeysSelect=''
	declare @sAlter varchar(2024)
	set @sAlter=''

	if(@hotelQuotaMask > 0 or @aviaQuotaMask > 0)
	begin
		create table #resultsTable(
			paging_id int,
			pt_key bigint,			-- MEG00038762. Golubinsky. 20.12.2011. Увеличил тип до bigint
			pt_ctkeyfrom int,
			pt_cnkey int,
			pt_tourdate datetime,
			pt_pnkey int,
			pt_hdkey int,
			pt_hrkey int,
			pt_tourkey int,
			pt_tlkey int,
			pt_tourtype int,
			pt_tourname varchar(256),
			pt_toururl varchar(256),
			pt_hdname varchar(60),
			pt_hdstars varchar(12),
			pt_ctkey int,
			pt_rskey int,
			pt_hotelurl varchar(256),
			pt_pncode varchar(30),
			pt_rate varchar(3),
			pt_rmkey int,
			pt_rckey int,
			pt_ackey int,
			-- MEG00025561 Paul G 08.02.2010
			-- чтоб возраст ребёнка можно было отображать в прайсе
			pt_childagefrom int,
			pt_childageto int,
			pt_childagefrom2 int,
			pt_childageto2 int,
			-- End MEG00025561
			pt_cnname varchar(50),
			pt_ctname varchar(50),
			pt_rsname varchar(50),		
			pt_rmname varchar(60),
			pt_rcname varchar(60),
			pt_acname varchar(30),
			pt_chkey int,
			pt_chbackkey int,
			pt_hotelkeys varchar(256),
			pt_hotelroomkeys varchar(256),
			pt_hotelnights varchar(256),
			pt_hotelstars varchar(256),
			pt_pansionkeys varchar(256),
			pt_actual smallint,
			pt_visadeadline datetime
		)

		create table #quotaCheckTable(
			pt_key bigint,			-- MEG00038762. Golubinsky. 20.12.2011. Увеличил тип до bigint
			pt_pricekey int,
			pt_tourdate datetime,			
			pt_days int,
			pt_nights int,
			pt_hdkey int,		
			pt_hdday int,
			pt_hdnights int,			
			pt_hdpartnerkey int,
			pt_rmkey int,
			pt_rckey int,
			pt_chkey int,
			pt_chday int,
			pt_chpkkey int,
			pt_chprkey int,
			pt_chbackkey int,
			pt_chbackday int,
			pt_chbackpkkey int,
			pt_chbackprkey int,
			pt_hdquota varchar(10),
			pt_chtherequota varchar(256),
			pt_chbackquota varchar(256),	
			pt_hdallquota varchar(128)
		)

	end

	declare @d int
	declare @n int
	declare @sdays varchar(10)
	declare @sWhere varchar(2024)
	set @sWhere=''
	declare @sAddSelect varchar(2024)
	set @sAddSelect=''
	declare @sAddIN varchar(2024)
	set @sAddIN=''
	declare @sAddDeclare varchar(2024)
	set @sAddDeclare=''
	declare @sJoin varchar(2024)
	set @sJoin=''
	declare @sUpdateList varchar(8000)
	set @sUpdateList=''
	declare @sTmp varchar(8000)
	set @sTmp=''
	declare @rowCount int
	declare @priceFilter nvarchar(512)
	set @priceFilter = N''
	declare @priceKeyFilter nvarchar(512)
	set @priceKeyFilter = N''

	declare @pricePart nvarchar(100)
	declare @nightsPart nvarchar(256)
	declare @hotelNightsPart nvarchar(256)

	set @pricePart = dbo.mwGetFilterPart(@filter, 'pt_price')

	declare dCur cursor for select days,nights from #days
	open dCur
	fetch next from dCur into @d,@n
	while (@@fetch_status=0)
	begin
		set @sdays=LTRIM(STR(@d)) + '_' + LTRIM(STR(@n))
		if(substring(@sortExpr, 1, 1) = '*')
		begin
			set @sortExpr = 'p_' + @sdays + substring(@sortExpr, 2, len(@sortExpr) - 1)
		end

		if(len(@sKeysSelect) > 0)
			set @sKeysSelect=@sKeysSelect + ','

		if (@pagingType = 5)
			set @sKeysSelect=@sKeysSelect + 'p_' + @sdays + ',pk_' + @sdays + ',null prk_' + @sdays + ',null hq_' + @sdays +',null cq_' + @sdays + ',null cbq_' + @sdays
		else if (@pagingType = 0)
			set @sKeysSelect=@sKeysSelect + 'p_' + @sdays + ',pk_' + @sdays 

		if(@pricePart is not null)
		begin
			if(len(@priceFilter) > 0)
				set @priceFilter = @priceFilter  + ' or '

			set @priceFilter = @priceFilter + replace(@pricePart, 'pt_price', 'p_' + @sdays)
		end

		if(len(@priceKeyFilter) > 0)
			set @priceKeyFilter = @priceKeyFilter  + ' or '

		set @priceKeyFilter = @priceKeyFilter + 'pk_' + @sdays + ' > 0'

		if(@hotelQuotaMask > 0 or @aviaQuotaMask > 0)
		begin

			if(len(@sAlter) > 0)
				set @sAlter=@sAlter + ','

			if(len(@sAddSelect) > 0)
				set @sAddSelect=@sAddSelect + ','

			if (@pagingType = 5)
			begin
				set @sAlter=@sAlter + 'p_' + @sdays + ' float,pk_' + @sdays + ' int,prk_' + @sdays + ' int,hq_' + @sdays + ' varchar(10),cq_' + @sdays + ' varchar(256),cbq_' + @sdays + ' varchar(256)'

--				if(len(@sUpdateList) > 0)
--					set @sUpdateList=@sUpdateList + ','
				set @sUpdateList=@sUpdateList + '
				if exists(select pt_key from #quotaCheckTable where pt_days = ' + LTRIM(STR(@d)) + ' and pt_nights = ' + LTRIM(STR(@n)) + ')
				update #resultsTable set'

				set @sUpdateList = @sUpdateList + '
					prk_' + @sdays + ' = (case when pk_' + @sdays + ' = tbl.pt_key then pt_pricekey end),
					hq_' + @sdays + ' = (case when pk_' + @sdays + ' = tbl.pt_key then pt_hdquota end),
					cq_' + @sdays + ' = (case when pk_' + @sdays + ' = tbl.pt_key then pt_chtherequota end),
					cbq_' + @sdays + ' = (case when pk_' + @sdays + ' = tbl.pt_key then pt_chbackquota end)' 

				set @sUpdateList=@sUpdateList + '
				from (select * from #quotaCheckTable where pt_days = ' + LTRIM(STR(@d)) + ' and pt_nights = ' + LTRIM(STR(@n)) + ') tbl
				where CURRENT OF dataCursor'

				if(len(@sAddDeclare) > 0)
					set @sAddDeclare=@sAddDeclare + ','

				set @sAddDeclare=@sAddDeclare + '@pk_' + @sdays + ' int'

				set @sAddSelect=@sAddSelect + '@pk_' + @sdays + ' = pk_' + @sdays

				if(len(@sAddIN) > 0)
					set @sAddIN=@sAddIN + ','

				set @sAddIN=@sAddIN + '@pk_' + @sdays
			end
			else if (@pagingType = 0)
			begin
				set @sAlter=@sAlter + 'p_' + @sdays + ' float,pk_' + @sdays + ' int'

				if(len(@sWhere) > 0)
					set @sWhere=@sWhere + ' or '

				set @sWhere=@sWhere + 'pt_key in (select pk_' + @sdays + ' from #resultsTable)'

				set @sAddSelect=@sAddSelect + ' t_' + @sdays + '.pt_pricekey prk_' + @sdays + ', t_' + @sdays + '.pt_hdquota hq_' + @sdays + ', t_' + @sdays + '.pt_chtherequota cq_' + @sdays + ', t_' + @sdays + '.pt_chbackquota cbq_' + @sdays

				set @sJoin=@sJoin + ' left outer join #quotaCheckTable t_' + @sdays + ' on t.pk_' + @sdays + ' = t_' + @sdays + '.pt_key'

			end
		end

		fetch next from dCur into @d,@n
	end
	close dCur
	deallocate dCur

	if(len(@sKeysSelect) > 0 and(@hotelQuotaMask > 0 or @aviaQuotaMask > 0))
	begin
		set @sTmp = 'alter table #resultsTable add ' + @sAlter
		exec(@sTmp)

		if(@pricePart is not null)
		begin
			set @filter = REPLACE(@filter, @pricePart, '1 = 1')
			set @filter = @filter + ' and (' + @priceFilter + ')'
			set @sWhere = @sWhere + ' and ' + @pricePart
		end

		set @nightsPart = dbo.mwGetFilterPart(@filter, 'pt_nights')
		if(@nightsPart is not null)
			set @filter = REPLACE(@filter, @nightsPart, '1 = 1')

		set @hotelNightsPart = dbo.mwGetFilterPart(@filter, 'pt_hotelnights')
		while(@hotelNightsPart is not null)
		begin
			set @filter = REPLACE(@filter, @hotelNightsPart, '1 = 1')
			set @hotelNightsPart = dbo.mwGetFilterPart(@filter, 'pt_hotelnights')
		end

		set @filter = @filter + ' and (' + @priceKeyFilter + ')'
		
		--MEG00038933 Tkachuk 16-02-2012
		--вызываем с последним параметром=null, иначе пытается записать в #resultsTable доп.столбец, и падает с ошибкой
		insert into #resultsTable exec PagingSelect @pagingType,@sKeysSelect,@spageNum,@spageSize,@filter,@sortExpr,@tableName,@viewName, null
		
		--MEG00038933 Tkachuk 16-02-2012
		--получаем количество строк не через output-переменную в предыдущей строке, а через select в результирующей таблице
		Set @rowCount = (select COUNT(*) from #resultsTable)
		Select @rowCount

		declare @aviaMask smallint

		if (@pagingType = 5)
		begin
			declare dataCursor cursor for
				select paging_id from #resultsTable
			for update

			open dataCursor

			declare @paging_id int, @reviewed int, @selected int, @actual smallint, @actualRow smallint

			set @aviaMask = @aviaQuotaMask
			set @reviewed = @pageNum
			set @selected = 0

			fetch next from dataCursor into @paging_id
		end
		else if (@pagingType = 0)
		begin
			set @aviaMask = null
		end
		while (@pagingType = 0 or (@@fetch_status = 0 and @selected < @pageSize))
		begin
			if (@pagingType = 5)
			begin
				set @actualRow = 0

				set @sTmp = 'declare ' + @sAddDeclare + '
							select ' + @sAddSelect + ' from #resultsTable where paging_id = ' + ltrim(str(@paging_id)) + '
							select pt_key, pt_pricekey, pt_tourdate, pt_days,	pt_nights, pt_hdkey, pt_hdday,
									pt_hdnights, pt_hdpartnerkey, pt_rmkey,	pt_rckey, pt_chkey,	pt_chday, pt_chpkkey,
									pt_chprkey, pt_chbackkey, pt_chbackday, pt_chbackpkkey, pt_chbackprkey, null, null, null, null
							from ' + @tableName + ' with(nolock)
							where pt_key in (' + @sAddIN + ')'
			end
			else if (@pagingType = 0)
			begin
				set @sTmp = 'select pt_key, pt_pricekey, pt_tourdate, pt_days,	pt_nights, pt_hdkey, pt_hdday,
									pt_hdnights, pt_hdpartnerkey, pt_rmkey,	pt_rckey, pt_chkey,	pt_chday, pt_chpkkey,
									pt_chprkey, pt_chbackkey, pt_chbackday, pt_chbackpkkey, pt_chbackprkey, null, null, null, null
							from ' + @tableName + ' with(nolock)
							where ' + @sWhere
			end

			insert into #quotaCheckTable exec(@sTmp)

			declare quotaCursor cursor for
			select pt_hdkey,pt_rmkey,pt_rckey,pt_tourdate,
				pt_chkey,pt_chbackkey,
				pt_hdday,pt_hdnights,(case when isnull(@checkAllPartnersQuota, 0) > 0 then -1 else pt_hdpartnerkey end),pt_chday,(case when @checkFlightPacket > 0 then pt_chpkkey else -1 end) as pt_chpkkey,pt_chprkey,
				pt_chbackday,(case when @checkFlightPacket > 0 then pt_chbackpkkey else -1 end) as pt_chbackpkkey, pt_chbackprkey,pt_days
			from #quotaCheckTable
			for update of pt_hdquota,pt_chtherequota,pt_chbackquota

			declare @hdkey int,@rmkey int,@rckey int,@tourdate datetime,
				@chkey int,@chbackkey int,@hdday int,@hdnights int,@hdprkey int,
				@chday int,@chpkkey int,@chprkey int,@chbackday int,
				@chbackpkkey int,@chbackprkey int,@days int

			open quotaCursor

			fetch next from quotaCursor into @hdkey,@rmkey,@rckey,
				@tourdate,@chkey,@chbackkey,@hdday,@hdnights,@hdprkey,
				@chday,@chpkkey,@chprkey,@chbackday,
				@chbackpkkey,@chbackprkey,@days

			declare @tmpHotelQuota varchar(10)
			declare @tmpThereAviaQuota varchar(256)		
			declare @tmpBackAviaQuota varchar(256)		
			declare @allPlaces int,@places int

			while(@@fetch_status=0)
			begin
				set @actual=1		
	
				if(@aviaQuotaMask > 0)
				begin
					set @tmpThereAviaQuota=null
					if(@chkey > 0)
					begin 
						select @tmpThereAviaQuota=res from #checked where svkey=1 and code=@chkey and date=@tourdate and day=@chday and days=@days and prkey=@chprkey and pkkey=@chpkkey
						if (@tmpThereAviaQuota is null)
						begin
							exec dbo.mwCheckFlightGroupsQuotes @pagingType, @chkey, @flightGroups, @agentKey, @chprkey, @tourdate, @chday, @requestOnRelease, @noPlacesResult, @checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, @findFlight, @chpkkey, @days, @expiredReleaseResult, @aviaMask, @tmpThereAviaQuota output
							insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res) values(1,@chkey,0,0,@tourdate,@chday,@days,@chprkey,@chpkkey,@tmpThereAviaQuota)
						end
						if(len(@tmpThereAviaQuota)=0)
							set @actual=0						
					end
					set @tmpBackAviaQuota=null
					if(@chbackkey > 0)
					begin
						select @tmpBackAviaQuota=res from #checked where svkey=1 and code=@chbackkey and date=@tourdate and day=@chbackday and days=@days and prkey=@chbackprkey and pkkey=@chbackpkkey
						if (@tmpBackAviaQuota is null)
						begin
							exec dbo.mwCheckFlightGroupsQuotes @pagingType, @chbackkey, @flightGroups,@agentKey,@chbackprkey, @tourdate,@chbackday,@requestOnRelease,@noPlacesResult,@checkAgentQuota,@checkCommonQuota,@checkNoLongQuota,@findFlight,@chbackpkkey,@days,@expiredReleaseResult,@aviaMask, @tmpBackAviaQuota output
							insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res) values(1,@chbackkey,0,0,@tourdate,@chbackday,@days,@chbackprkey,@chbackpkkey,@tmpBackAviaQuota)
						end
						if(len(@tmpBackAviaQuota)=0)
							set @actual=0
					end
				end
				if(@hotelQuotaMask > 0)
				begin
					set @tmpHotelQuota=null
					select @tmpHotelQuota=res,@places=places from #checked where svkey=3 and code=@hdkey and rmkey=@rmkey and rckey=@rckey and date=@tourdate and day=@hdday and days=@hdnights and prkey=@hdprkey
					if (@tmpHotelQuota is null)
					begin
						select @places=qt_places,@allPlaces=qt_allPlaces from dbo.mwCheckQuotesEx(3,@hdkey,@rmkey,@rckey, @agentKey,@hdprkey,@tourdate,@hdday,@hdnights,@requestOnRelease,@noPlacesResult,@checkAgentQuota,@checkCommonQuota,@checkNoLongQuota,0,0,0,0,0,@expiredReleaseResult)
						set @tmpHotelQuota=ltrim(str(@places)) + ':' + ltrim(str(@allPlaces))
						insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res,places) values(3,@hdkey,@rmkey,@rckey,@tourdate,@hdday,@hdnights,@hdprkey,0,@tmpHotelQuota,@places)
					end
			
					if((@places > 0 and (@hotelQuotaMask & 1)=0) or (@places=0 and (@hotelQuotaMask & 2)=0) or (@places=-1 and (@hotelQuotaMask & 4)=0))
						set @actual=0
				end
				update #quotaCheckTable set pt_hdquota=@tmpHotelQuota,
					pt_chtherequota=@tmpThereAviaQuota,
					pt_chbackquota=@tmpBackAviaQuota
				where CURRENT OF quotaCursor
				
				if (@pagingType = 5)
				begin
					if (@actual > 0)
						set @actualRow = 1
				end

				fetch next from quotaCursor into @hdkey,@rmkey,@rckey,
					@tourdate,@chkey,@chbackkey,@hdday,@hdnights,@hdprkey,
					@chday,@chpkkey,@chprkey,@chbackday,
					@chbackpkkey,@chbackprkey,@days
			end

			close quotaCursor
			deallocate quotaCursor

			if (@pagingType = 5)
			begin
				if(@actualRow > 0)
				begin
					set @sTmp = @sUpdateList--'update #resultsTable set ' + @sUpdateList + ', pt_actual = 1 from #quotaCheckTable where CURRENT OF dataCursor'
					set @sTmp = @sTmp + '
					update #resultsTable set pt_actual = 1 where CURRENT OF dataCursor
					'
--					print @sTmp
--					select * from #resultsTable
--					select * from #quotaCheckTable
					exec (@sTmp)
--					select * from #resultsTable

					set @selected = @selected + 1
				end

				truncate table #quotaCheckTable
				
				set @reviewed=@reviewed + 1

				fetch next from dataCursor into @paging_id
			end
			else if (@pagingType = 0)
			begin
				set @sTmp = 'select t.*, ' + @sAddSelect + ' from #resultsTable t ' + @sJoin + ' order by t.paging_id'
				exec(@sTmp)
				break
			end
		end

		if (@pagingType = 5)
		begin
			close dataCursor
			deallocate dataCursor
			
			select @reviewed
			select * from #resultsTable where pt_actual = 1 order by paging_id
		end
	end
	else if(len(@sKeysSelect) > 0)
		exec PagingSelect @pagingType,@sKeysSelect,@spageNum,@spageSize,@filter,@sortExpr,@tableName,@viewName, 1
	else
	begin
		select 0
		if (@pagingType = 5)
			select 0
		select * from #resultsTable
	end
end
else
begin
	-- @pageSize > @MAX_ROWCOUNT=считаем,что в этом случае пейджинг не нужен - тянется все
	if(@pageSize > @MAX_ROWCOUNT)
	begin
		set @sql=@sql + '
			select 0
			select
			'
	end
	else -- реализуем пейджинг
	begin
		create table #Paging(
			pgId int identity,
			ptKey int primary key,
			ptpricekey bigint,
			newPrice money,
			pt_hdquota varchar(10),
			pt_chtherequota varchar(256),
			pt_chbackquota varchar(256),
			chkey int,
			chbackkey int,
			stepId int,
			priceCorrection float,
			pt_hdallquota varchar(256),
			-- признак того что вариант был подмешан (нужно для выделения)
			pt_smartSearch bit default 0
		)
		
		if((@pagingType <> @ACTUALPLACES_PAGING and @pagingType <> @DYNAMIC_SPO_PAGING) or (@hotelQuotaMask <= 0 and @aviaQuotaMask <= 0))
			set @sql=@sql + ' 
			insert into #Paging(ptkey) select ' 
		else
		begin

			-- Подмешивание отелей (SmartSearch) работает только для первой страницы
			if (@mwUseSmartSearch = 1 and @pageNum = 0)
			begin
				-- максимально возможное количество результов, которые могут быть подмешаны
				declare @maxSmartSearchResult tinyint; set @maxSmartSearchResult = 3;
				declare @smaxSmartSearchResult varchar(3); set @smaxSmartSearchResult=LTRIM(STR(@maxSmartSearchResult))
				
				-- количество реально подмешанных вариантов
				declare @realDashVariantsNumber smallint;
				
				set @sql=@sql + '
				declare quotaCursor cursor fast_forward read_only for
				select pt_key,pt_tourkey,pt_pricekey
				,pt_hdkey,pt_rmkey,pt_rckey,pt_tourdate,pt_hdday,pt_hdnights, (case when ' + ltrim(str(isnull(@checkAllPartnersQuota, 0))) + ' > 0 then -1 else pt_hdpartnerkey end),pt_chday,(case when ' + ltrim(str(@checkFlightPacket)) + ' > 0 then pt_chpkkey else -1 end) as pt_chpkkey,pt_chprkey,pt_chbackday,(case when ' + ltrim(str(@checkFlightPacket)) + ' > 0 then pt_chbackpkkey else -1 end) as pt_chbackpkkey,pt_chbackprkey,pt_days, 
				pt_chkey, pt_chbackkey, 0, '''' pt_chdirectkeys, '''' pt_chbackkeys, '''' pt_hddetails
				, pt_directFlightAttribute, pt_backFlightAttribute
				from ' + @tableName + ' with(nolock) inner join hotelPriorities with(nolock) on pt_hdkey = hp_hdkey
				where ' + @filter
				-- null не может быть для ВСЕХ одновременно приоритетов присутствующих в фильтах
				-- т.к. по стране фильтруем всегда, то приоритет для страны проверяем на null тоже всегда
				set @sql = @sql + 'and (HP_CountryPriority is not null'
				-- если есть фильтр для города, то проверяем на null приоритет для города
				if (charindex('pt_ctkey',@filter) > 0)
				begin
					set @sql = @sql + ' or HP_CityPriority is not null '
				end
				-- если есть фильтр для курорта, то проверяем на null приоритет для курорта
				if (charindex('pt_rskey',@filter) > 0)
				begin
					set @sql = @sql + ' or HP_ResortPriority is not null '
				end
				set @sql = @sql + ') '
				set @sql = @sql + '
				-- фильтр по отсутсвию инфанта
				and not exists (select top 1 1 from accmdmentype where ac_key=pt_ackey and ac_name like ''%инфант%'')
				order by '
				
				-- если в фильтре есть город
				if (charindex('pt_ctkey',@filter) > 0)
				begin
					set @sql = @sql + 'case when HP_CityPriority is null then 1 else 0 end, hp_cityPriority, '
				end
				
				-- если в фильтре есть курорт
				if (charindex('pt_rskey',@filter) > 0)
				begin
					set @sql = @sql + 'case when HP_ResortPriority is null then 1 else 0 end, hp_resortPriority, '
				end
				
				-- по стране и стандартной сортировке сортируем в любом случае
				set @sql = @sql + 'case when HP_CountryPriority is null then 1 else 0 end, hp_countryPriority, ' + @sortExpr

				-- запустим mwCheckQuotesCycle с последним параметром = 1 (индикатор того, что ищем подмешанные варианты)
				-- маски квот для подмешанных вариантов:
				-- отель: 1 - есть
				-- перелет: 1 - есть
				set @sql=@sql + '
				open quotaCursor

				exec dbo.mwCheckQuotesCycle ' + ltrim(str(@pagingType))+ ', ' + @spageNum + ', ' + @smaxSmartSearchResult + ', ' + ltrim(str(@agentKey)) + ', 1, 1, ''' + @flightGroups + ''', ' + ltrim(str(@checkAgentQuota)) + ', ' + ltrim(str(@checkCommonQuota)) + ', ' + ltrim(str(@checkNoLongQuota)) + ', ' + ltrim(str(@requestOnRelease)) + ', ' + ltrim(str(@expiredReleaseResult)) + ', ' + ltrim(str(@noPlacesResult)) + ', ' + ltrim(str(@findFlight)) + ', 1

				close quotaCursor
				deallocate quotaCursor
				'
				--print @sql;
				exec (@sql);
				set @sql = '';
				-- после этого в #Paginge - хранится столько строк сколько мы подмешали (0-3)
				-- уменьшим pageSize на это число, чтобы сохранить общее кол-во выводимых строк
				select @realDashVariantsNumber = count(1) from #Paging;
				set @pageSize = @pageSize - @realDashVariantsNumber;
				set @spageSize=ltrim(str(@pageSize));
			end

			set @sql=@sql + ' 
			declare quotaCursor cursor fast_forward read_only for '
			if(@pagingType = @DYNAMIC_SPO_PAGING)
				set @sql = @sql + ' with Prices as (select '
			else
				set @sql = @sql + ' select '
		end

		if(@pageSize < @MAX_ROWCOUNT)
		begin
			if(@pagingType=@SIMPLE_PAGING)
				set @sql=@sql + ' top ' + str(@MAX_ROWCOUNT)
			else if((@pagingType=@ACTUALPLACES_PAGING or @pagingType=@DYNAMIC_SPO_PAGING) and @hotelQuotaMask=0 and @aviaQuotaMask=0)
				set @sql=@sql + ' top ' + @spageSize
		end
	
		set @sql=@sql + ' pt_key,pt_tourkey, pt_pricekey '
		if((@pagingType=@ACTUALPLACES_PAGING or @pagingType=@DYNAMIC_SPO_PAGING) and (@hotelQuotaMask > 0 or @aviaQuotaMask > 0))
		begin
			set @sql=@sql + ',pt_hdkey,pt_rmkey,pt_rckey,pt_tourdate,pt_hdday,pt_hdnights, (case when ' + ltrim(str(isnull(@checkAllPartnersQuota, 0))) + ' > 0 then -1 else pt_hdpartnerkey end),pt_chday,(case when ' + ltrim(str(@checkFlightPacket)) + ' > 0 then pt_chpkkey else -1 end) as pt_chpkkey,pt_chprkey,pt_chbackday,(case when ' + ltrim(str(@checkFlightPacket)) + ' > 0 then pt_chbackpkkey else -1 end) as pt_chbackpkkey,pt_chbackprkey,pt_days, '
			if(@pagingType <> @DYNAMIC_SPO_PAGING)
				set @sql = @sql + ' pt_chkey, pt_chbackkey, 0, pt_chdirectkeys, pt_chbackkeys, pt_hddetails '
			else
				set @sql = @sql + ' ch_key as pt_chkey, chb_key as pt_chbackkey, row_number() over(order by ' + @sortExpr + ') as rowNum '
		end
		set @sql=@sql + ' , pt_directFlightAttribute, pt_backFlightAttribute from ' + @tableName + ' with(nolock) '

		if(@pagingType = @DYNAMIC_SPO_PAGING)
			set @sql = @sql + ' left outer join 
			(select pt_tourdate as tourdate, pt_chbackday as chbackday, pt_chkey as chkey, pt_chbackkey as chbackkey, ch.ch_key as ch_key, chb.ch_key as chb_key 
				from (select distinct pt_tourdate, pt_chbackday, pt_chkey, pt_chbackkey from ' + @tableName + ' where ' + @filter + ') ptd 
				left outer join charter ptch with(nolock) on (ptch.ch_key = pt_chkey) left outer join charter ptchb with(nolock) on (ptchb.ch_key = pt_chbackkey)
				left outer join charter ch with(nolock) on (ptch.ch_citykeyfrom = ch.ch_citykeyfrom and ptch.ch_citykeyto = ch.ch_citykeyto) left outer join charter chb with(nolock) on (ptchb.ch_citykeyto = chb.ch_citykeyto and ptchb.ch_citykeyfrom = chb.ch_citykeyfrom and chb.ch_airlinecode = ch.ch_airlinecode) 
			left outer join airseason a with(nolock) on (a.as_chkey = ch.ch_key and ptd.pt_tourdate between a.as_datefrom and a.as_dateto and a.as_week like (''%'' +  ltrim(str(datepart(dw, dateadd(day, -1, ptd.pt_tourdate))))+ ''%'')) left outer join airseason ab with(nolock) on (ab.as_chkey = chb.ch_key and dateadd(day, pt_chbackday - 1, ptd.pt_tourdate) between ab.as_datefrom and ab.as_dateto and ab.as_week like (''%'' +  ltrim(str(datepart(dw, dateadd(day, pt_chbackday - 2, ptd.pt_tourdate)))) + ''%''))) pt1
		on (pt_tourdate = tourdate and pt_chkey = chkey and pt_chbackkey = chbackkey and pt_chbackday = chbackday)'

		if @aviaQuotaMask = 5 or @aviaQuotaMask = 1
		begin
			-- Соединим выборку курсора квот с кешем квот, чтобы отсеять туры с закончившимися перелетами
			set @filter = @filter + '
			and not exists 
								(
								select top 1 1 
								from CacheQuotas as directCharter with (nolock) 
								where 
									directCharter.cq_svkey = 1
									and directCharter.cq_code = pt_chkey
									and directCharter.cq_date = pt_tourdate
									and directCharter.cq_day = pt_chday
									and directCharter.cq_prkey = pt_chprkey
									and directCharter.cq_pkkey = pt_chpkkey
									and directCharter.cq_places <= 0
									and (pt_directFlightAttribute is not null 
											and 
											(
												(directCharter.cq_findFlight = 1 and (pt_directFlightAttribute & 2) = 2)
												or
												(directCharter.cq_findFlight = 0 and (pt_directFlightAttribute & 2) = 2)
											)
										)
								)
			and not exists 
								(
								select top 1 1 
								from CacheQuotas as backCharter  with (nolock) 
								where
									backCharter.cq_svkey = 1
									and backCharter.cq_code = pt_chbackkey
									and backCharter.cq_date = pt_tourdate
									and backCharter.cq_day = pt_chbackday
									and backCharter.cq_prkey = pt_chprkey
									and backCharter.cq_pkkey = pt_chpkkey
									and backCharter.cq_places <= 0
									and (pt_backFlightAttribute is not null 
											and 
											(
												(backCharter.cq_findFlight = 1 and (pt_backFlightAttribute & 2) = 2)
												or
												(backCharter.cq_findFlight = 0 and (pt_backFlightAttribute & 2) = 2)
											)
									)
								)
			'
		end

		if (@mwSearchType=0)
			set @sql=@sql + ' where pt_cnkey=' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom=' +  LTRIM(STR(@departFromKey)) + ' and ' + @filter
		else 
			set @sql=@sql + ' where ' + @filter
			

		if((@pagingType=@ACTUALPLACES_PAGING) and @pageNum > 0)
		begin
			declare @a int
--			--и еще добавим невключающее условие по количеству предварительно просмотренных записей
--			set @sql=@sql + ' and pt_key not in (select top '+@spageNum+' pt_key '
--
--			if (@mwSearchType=0)
--				set @sql=@sql + ' from dbo.mwPriceTable  with(nolock) where pt_cnkey=' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom=' + LTRIM(STR(@departFromKey)) + ' and ' + @filter
--			else
--				set @sql=@sql + ' from ' + dbo.mwGetPriceViewName (@countryKey,@departFromKey) + ' with(nolock) where ' + @filter
--
--			if len(isnull(@sortExpr,'')) > 0
--				set @sql=@sql + ' order by '+ @sortExpr
--			set @sql=@sql + ') '
		end
		else if(@pagingType = @DYNAMIC_SPO_PAGING)
			set @sql = @sql + ') select * from Prices where rowNum > ' + @spageNum
		
		if(substring(@sortExpr, 1, 1) = '*')					-- begin tkachuk 21.02.2012 Исправлена ошибка, возникающая при некотором наборе параметров
		begin
			set @sortExpr = SUBSTRING(@sortExpr, 2, LEN(@sortExpr) - 1)
			set @sortExpr = LTRIM(@sortExpr)
			
			if(SUBSTRING(@sortExpr, 1, 1) = ',')
			begin
				set @sortExpr = SUBSTRING(@sortExpr, 2, LEN(@sortExpr) - 1)
				set @sortExpr = LTRIM(@sortExpr)
			end
		end														-- end tkachuk 21.02.2012

		if (len(isnull(@sortExpr,'')) > 0 and @pagingType <> @DYNAMIC_SPO_PAGING)
			set @sql=@sql + ' order by '+ @sortExpr
	
		if(@pagingType=@ACTUALPLACES_PAGING or @pagingType=@DYNAMIC_SPO_PAGING)
		begin
			if (@pageNum=0) -- количество записей возвращаем только при запросе первой страницы
			begin
				set @sql=@sql + ' 
				select count(*) from ' + @tableName + ' with(nolock) '
				
				if(@pagingType = @DYNAMIC_SPO_PAGING)
					set @sql = @sql + ' left outer join 
						(select pt_tourdate tourdate, pt_chbackday chbackday, pt_chkey chkey, pt_chbackkey chbackkey, ch.ch_key as ch_key, chb.ch_key as chb_key 
							from (select distinct pt_tourdate, pt_chbackday, pt_chkey, pt_chbackkey from ' + @tableName + ' where ' + @filter + ') ptd 
							left outer join charter ptch with(nolock) on (ptch.ch_key = pt_chkey) left outer join charter ptchb with(nolock) on (ptchb.ch_key = pt_chbackkey) left outer join charter ch with(nolock) on (ptch.ch_citykeyfrom = ch.ch_citykeyfrom and ptch.ch_citykeyto = ch.ch_citykeyto)
						left outer join charter chb with(nolock) on (ptchb.ch_citykeyto = chb.ch_citykeyto and ptchb.ch_citykeyfrom = chb.ch_citykeyfrom and chb.ch_airlinecode = ch.ch_airlinecode) left outer join airseason a with(nolock) on (a.as_chkey = ch.ch_key and ptd.pt_tourdate between a.as_datefrom and a.as_dateto and a.as_week like (''%'' +  ltrim(str(datepart(dw, dateadd(day, -1, ptd.pt_tourdate))))+ ''%''))
						left outer join airseason ab with(nolock) on (ab.as_chkey = chb.ch_key and dateadd(day, pt_chbackday - 1, ptd.pt_tourdate) between ab.as_datefrom and ab.as_dateto and ab.as_week like (''%'' +  ltrim(str(datepart(dw, dateadd(day, pt_chbackday - 2, ptd.pt_tourdate)))) + ''%''))) pt1
					on (pt_tourdate = tourdate and pt_chkey = chkey and pt_chbackkey = chbackkey and pt_chbackday = chbackday)'
				if (@mwSearchType=0)
					set @sql = @sql + ' where pt_cnkey=' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom=' + LTRIM(STR(@departFromKey)) + ' and ' + @filter
				else
					set @sql = @sql + ' where ' + @filter
			end
			else
				set @sql=@sql + ' select 0 '

			if(@hotelQuotaMask=0 and @aviaQuotaMask=0)
				set @sql=@sql + ' 
					select ' + ltrim(str(@pageNum + @pageSize))
			else
			begin
				set @sql=@sql + '
				open quotaCursor

				exec dbo.mwCheckQuotesCycle ' + ltrim(str(@pagingType))+ ', ' + @spageNum + ', ' + @spageSize + ', ' + ltrim(str(@agentKey)) + ', ' + ltrim(str(@hotelQuotaMask)) + ', ' + ltrim(str(@aviaQuotaMask)) + ', ''' + @flightGroups + ''', ' + ltrim(str(@checkAgentQuota)) + ', ' + ltrim(str(@checkCommonQuota)) + ', ' + ltrim(str(@checkNoLongQuota)) + ', ' + ltrim(str(@requestOnRelease)) + ', ' + ltrim(str(@expiredReleaseResult)) + ', ' + ltrim(str(@noPlacesResult)) + ', ' + ltrim(str(@findFlight)) + ', 0, ''' + @tableName + '''

				close quotaCursor
				deallocate quotaCursor
				'
				if(@pagingType = @DYNAMIC_SPO_PAGING)
					set @sql = @sql + 'select dbo.GetDynamicRulesStepValue(getdate())'
			end
		end
		else
		begin

			set @sql=@sql + '
			select @@rowCount'
		end

		exec(@sql)

		declare @newpricesetting varchar(max)

		select @newpricesetting = rtrim(ltrim(SS_ParmValue)) from systemsettings where ss_parmname = 'NewReCalculatePrice'

		if isnull(@newpricesetting,'') = '1'
		begin

			SET QUOTED_IDENTIFIER OFF
		
			declare @tpPriceKeys nvarchar(4000)
			set @tpPriceKeys = ''
			-- запишем ключи tp_Price с которыми мы будем работать
			select @tpPriceKeys = @tpPriceKeys + convert(nvarchar(4000), ptpricekey) + ','
			from #Paging with(nolock)
		
			-- отправим запрос в основную базу и узнаем новое значение ключей
			--exec [mt].[avalon20120306main].[dbo].[ReCalculate_CheckActualPrice] @tpPriceKeys
			declare @dbName varchar(255)

			if ([dbo].[mwReplIsSubscriber]()=1) begin
				set @dbName = '[mt].'+ltrim(rtrim(dbo.mwReplPublisherDB()))+'.'
			end
			else begin
				set @dbName=''
			end
			
			set @tpPriceKeys = 'exec ' + @dbName + 'dbo.ReCalculate_CheckActualPrice ' + '''' + @tpPriceKeys + ''''
		
			declare @newPriceTable table
			(
				xTpKey bigint,
				xNewSummPrice money			
			)
			
			-- запишем результат в таблицу
			insert into @newPriceTable(xTpKey, xNewSummPrice)			
			exec (@tpPriceKeys)
				
			-- изменим цены в вебе, на те что к нам пришли, если пришли
			update #Paging
			set newPrice = convert(int, xNewSummPrice)
			from #Paging join @newPriceTable on xTpKey = ptpricekey
			where xNewSummPrice is not null
		
			-- удалим цены если они удалились в основной базе
			-- так делать нельзя потому что туры расчитанные по старой схеме удаляться
			if (exists (select top 1 1 from @newPriceTable where xNewSummPrice is null))
			begin
				delete #Paging
				where (	exists(select top 1 1 from @newPriceTable where xTpKey = ptpricekey and xNewSummPrice is null)
						or not exists (select top 1 1 from @newPriceTable where xTpKey = ptpricekey))
			end
		
			SET QUOTED_IDENTIFIER OFF

		end

		if(@pagingType=@SIMPLE_PAGING)
		begin
			set @sql ='
			DECLARE @firstRecord int,@lastRecord int
			SET @firstRecord=('+ @spageNum + ' - 1) * ' + @spageSize+ ' + 1
			SET @lastRecord=('+ @spageNum +' *'+ @spageSize + ') 
			select '
		end
		else
			set @sql= ' select '

	end

	set @sql=@sql + '
		pt_tourdate,
		pt_days,
		pt_nights,
		pt_cnkey,
		pt_ctkeyfrom,
		pt_ctkeyto,
		pt_tourkey,
		pt_tourtype,
		pt_tlkey,
		pt_main,
		pt_pricelistkey,
		pt_pricekey,'
	if (@pagingType = 1)
	begin
		set @sql=@sql + 'pt_price,'
	end
	else
	begin
		set @sql=@sql + 'case when newPrice is not null then newPrice else pt_price end as pt_price,'
	end		
	set @sql=@sql + 'pt_hdkey,
		pt_hdpartnerkey,
		pt_rskey,
		pt_ctkey,
		pt_hdstars,
		pt_pnkey,
		pt_hrkey,
		pt_rmkey,
		pt_rckey,
		pt_ackey,
		pt_childagefrom,
		pt_childageto,
		pt_childagefrom2,
		pt_childageto2,
		pt_hdname,
		pt_tourname,
		pt_pnname,
		pt_pncode,
		pt_rmname,
		pt_rmcode,
		pt_rcname,
		pt_rccode,
		pt_acname,
		pt_accode,
		pt_rsname,
		pt_ctname,
		pt_rmorder,
		pt_rcorder,
		pt_acorder,
		pt_rate,
		tl_webhttp pt_toururl,
		hd_http pt_hotelurl,
		[pt_hdday],
		[pt_hdnights],
		[pt_chday],
		[pt_chpkkey],
		[pt_chprkey],
		[pt_chbackday],
		[pt_chbackpkkey],
		[pt_chbackprkey],
		[pt_ctkeybackfrom],
		[pt_ctkeybackto],
		pt_hotelkeys,
		pt_hotelroomkeys,
		pt_hotelstars,
		pt_pansionkeys,
		pt_hotelnights,
		pt_key,
		pt_hddetails,
		pt_topricefor,'		-- MEG00031932. Golubinsky. 06.07.2011. Включение в результат типа цены

	if(@pagingType = @DYNAMIC_SPO_PAGING)
		set @sql = @sql + '
		chkey as	pt_chkey,
		chbackkey as pt_chbackkey,
		stepId as pt_hdstepindex,
		priceCorrection as pt_hdpricecorrection
	'
	else
		set @sql = @sql + '
		[pt_chkey],
		[pt_chbackkey]
	'

	if (@pagingType = @ACTUALPLACES_PAGING)
	begin
		set @sql = @sql + '
		,[pt_smartSearch]
	'
	end

	if(@getServices > 0)
		set @sql=@sql + ',dbo.mwGetServiceClasses(pt_pricelistkey) pt_srvClasses'
	if (@pagingType <> @SIMPLE_PAGING)
	begin
		if(@hotelQuotaMask > 0)
			set @sql=@sql + ',pt_hdquota,pt_hdallquota '
		if(@aviaQuotaMask > 0)
			set @sql=@sql + ',pt_chtherequota,pt_chbackquota '
	end
	if(@calculateVisaDeadLine > 0)
		set @sql=@sql + ',dbo.mwGetVisaDeadlineDate(pt_tlkey, pt_tourdate, pt_ctkeyfrom) pt_visadeadline '

	if(@pagingType = @DYNAMIC_SPO_PAGING)
		set @sql = @sql + ', (''<nobr><b>'' + isnull(ch.ch_airlinecode, '''') + '' '' + isnull(ch.ch_flight, '''') + ''</b>'' + ''('' + isnull(ltrim(str(datepart(hh, a.as_timefrom))), '''') + '':'' + isnull(ltrim(str(datepart(mi, a.as_timefrom))), '''') + ''-'' + isnull(ltrim(str(datepart(hh, a.as_timeto))), '''') + '':'' + isnull(ltrim(str(datepart(mi, a.as_timeto))), '''') + '')</nobr><br/>'' + isnull(ch.ch_aircraft, '''') + ''&nbsp;('' + isnull(ch.ch_portcodefrom, '''') + ''-'' + isnull(ch.ch_portcodeto, '''') + '')'') as pt_chinfo
						,(''<nobr><b>'' + isnull(chb.ch_airlinecode, '''') + '' '' + isnull(chb.ch_flight, '''') + ''</b>''  + ''('' + isnull(ltrim(str(datepart(hh, ab.as_timefrom))), '''') + '':'' + isnull(ltrim(str(datepart(mi, ab.as_timefrom))), '''') + ''-'' + isnull(ltrim(str(datepart(hh, ab.as_timeto))), '''') + '':'' + isnull(ltrim(str(datepart(mi, ab.as_timeto))), '''') + '')</nobr><br/>'' + isnull(chb.ch_aircraft, '''') + ''&nbsp;('' + isnull(chb.ch_portcodefrom, '''') + ''-'' + isnull(chb.ch_portcodeto, '''') + '')'') as pt_chbackinfo'

	if(@pagingType=@SIMPLE_PAGING and (@hotelQuotaMask > 0 or @aviaQuotaMask > 0))
		set @sql=@sql + ' into #resultsTable '

	if (@mwSearchType=0)
		set @sql=@sql + ' from mwPriceTable'
	else
		set @sql=@sql + ' from ' + dbo.mwGetPriceViewName (@countryKey,@departFromKey)
	set @sql=@sql + ' with(nolock) inner join hoteldictionary with(nolock) on pt_hdkey=hd_key inner join tbl_turlist with(nolock) on pt_tlkey=tl_key '

	if(@pageSize > @MAX_ROWCOUNT)
	begin
		set @sql=@sql + ' where ' + @filter

		if len(isnull(@sortExpr,'')) > 0
			set @sql=@sql + ' order by '+ @sortExpr

		if(@pagingType=@SIMPLE_PAGING)
		begin
			set @sql=@sql + '
			select * from #resultsTable
			'
		end
	end
	else
	begin
		set @sql=@sql + ' inner join #Paging on (pt_key=ptKey) '
		if(@pagingType = @DYNAMIC_SPO_PAGING)
			set @sql = @sql + ' left outer join Charter ch with(nolock) on chkey = ch.ch_key left outer join airseason a with(nolock) on (pt_chkey = a.as_chkey and pt_tourdate between a.as_datefrom and a.as_dateto and charindex(cast(datepart(dw, dateadd(day, -1, pt_tourdate)) as varchar(1)), a.as_week) > 0)
					left outer join Charter chb with(nolock) on chbackkey = chb.ch_key left outer join airseason ab with(nolock) on (pt_chbackkey = ab.as_chkey and dateadd(day, pt_chbackday - 1, pt_tourdate) between ab.as_datefrom and ab.as_dateto and charindex(cast(datepart(dw, dateadd(day, pt_chbackday-2, pt_tourdate)) as varchar(1)), ab.as_week) > 0)'
		if(@pagingType=@SIMPLE_PAGING)
		begin
			set @sql=@sql + ' where pgId between @firstRecord and @lastRecord order by pgId'

			if(@hotelQuotaMask > 0 or @aviaQuotaMask > 0)
				set @sql=@sql + '

					declare quotaCursor cursor for
					select pt_hdkey,pt_rmkey,pt_rckey,pt_tourdate,
						pt_chkey,pt_chbackkey,
						pt_hdday,pt_hdnights,(case when ' + ltrim(str(isnull(@checkAllPartnersQuota, 0)))+ ' > 0 then -1 else pt_hdpartnerkey end),pt_chday,(case when ' + ltrim(str(@checkFlightPacket))+ ' > 0 then pt_chpkkey else -1 end) as pt_chpkkey,pt_chprkey,
						pt_chbackday,(case when ' + ltrim(str(@checkFlightPacket))+ ' > 0 then pt_chbackpkkey else -1 end) as pt_chbackpkkey,pt_chbackprkey,pt_days
					from #resultsTable
					for update of pt_hdquota,pt_chtherequota,pt_chbackquota
	
					declare @hdkey int,@rmkey int,@rckey int,@tourdate datetime,
						@chkey int,@chbackkey int,@hdday int,@hdnights int,@hdprkey int,
						@chday int,@chpkkey int,@chprkey int,@chbackday int,
						@chbackpkkey int,@chbackprkey int,@days int
	
					open quotaCursor
	
					fetch next from quotaCursor into @hdkey,@rmkey,@rckey,
						@tourdate,@chkey,@chbackkey,@hdday,@hdnights,@hdprkey,
						@chday,@chpkkey,@chprkey,@chbackday,
						@chbackpkkey,@chbackprkey,@days
	
					declare @tmpHotelQuota varchar(10)
					declare @tmpThereAviaQuota varchar(256)		
					declare @tmpBackAviaQuota varchar(256)		
					declare @allPlaces int,@places int
	
					while(@@fetch_status=0)
					begin
						'				
					if(@hotelQuotaMask > 0)
						set @sql=@sql + ' 
						set @tmpHotelQuota=null
						select @tmpHotelQuota=res from #checked where svkey=3 and code=@hdkey and rmkey=@rmkey and rckey=@rckey and date=@tourdate and day=@hdday and days=@hdnights and prkey=@hdprkey
						if (@tmpHotelQuota is null)
						begin
							select @places=qt_places,@allPlaces=qt_allPlaces from dbo.mwCheckQuotesEx(3,@hdkey,@rmkey,@rckey,' + ltrim(str(@agentKey)) + ',@hdprkey,@tourdate,@hdday,@hdnights,' + ltrim(str(@requestOnRelease))+ ',' + ltrim(str(@noPlacesResult))+ ',' + ltrim(str(@checkAgentQuota)) + ',' + ltrim(str(@checkCommonQuota)) + ',' + ltrim(str(@checkNoLongQuota)) + ',0,0,0,0,0,' + ltrim(str(@expiredReleaseResult)) +')
							set @tmpHotelQuota=ltrim(str(@places)) + '':'' + ltrim(str(@allPlaces))
							insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res) values(3,@hdkey,@rmkey,@rckey,@tourdate,@hdday,@hdnights,@hdprkey,0,@tmpHotelQuota)
						end
						'
					if(@aviaQuotaMask > 0)
						set @sql=@sql + ' 
						set @tmpThereAviaQuota=null
						if(@chkey > 0)
						begin
							select @tmpThereAviaQuota=res from #checked where svkey=1 and code=@chkey and date=@tourdate and day=@chday and days=@days and prkey=@chprkey and pkkey=@chpkkey
							if (@tmpThereAviaQuota is null)
							begin
								exec dbo.mwCheckFlightGroupsQuotes ' + ltrim(str(@pagingType)) + ',@chkey,''' + @flightGroups + ''',' + ltrim(str(@agentKey)) + ',@chprkey, @tourdate,@chday,' + ltrim(str(@requestOnRelease))+ ',' + ltrim(str(@noPlacesResult))+ ',' + ltrim(str(@checkAgentQuota)) + ',' + ltrim(str(@checkCommonQuota)) + ',' + ltrim(str(@checkNoLongQuota)) + ',' + ltrim(str(@findFlight)) + ',@chpkkey,@days,' + ltrim(str(@expiredReleaseResult)) +',null, @tmpThereAviaQuota output
								insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res) values(1,@chkey,0,0,@tourdate,@chday,@days,@chprkey,@chpkkey,@tmpThereAviaQuota)
							end
						end

						set @tmpBackAviaQuota=null
						if(@chbackkey > 0)
						begin
							select @tmpBackAviaQuota=res from #checked where svkey=1 and code=@chbackkey and date=@tourdate and day=@chbackday and days=@days and prkey=@chbackprkey and pkkey=@chbackpkkey
							if (@tmpBackAviaQuota is null)
							begin
								exec dbo.mwCheckFlightGroupsQuotes ' + ltrim(str(@pagingType)) + ',@chbackkey,''' + @flightGroups + ''',' + ltrim(str(@agentKey)) + ',@chbackprkey, @tourdate,@chbackday,' + ltrim(str(@requestOnRelease))+ ',' + ltrim(str(@noPlacesResult))+ ',' + ltrim(str(@checkAgentQuota)) + ',' + ltrim(str(@checkCommonQuota)) + ',' + ltrim(str(@checkNoLongQuota)) + ',' + ltrim(str(@findFlight)) + ',@chbackpkkey,@days,' + ltrim(str(@expiredReleaseResult)) +',null, @tmpBackAviaQuota output
								insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res) values(1,@chbackkey,0,0,@tourdate,@chbackday,@days,@chbackprkey,@chbackpkkey,@tmpBackAviaQuota)
							end
						end
						'

					set @sql=@sql + '
						update #resultsTable set pt_hdquota=@tmpHotelQuota,
							pt_chtherequota=@tmpThereAviaQuota,
							pt_chbackquota=@tmpBackAviaQuota
						where CURRENT OF quotaCursor


						fetch next from quotaCursor into @hdkey,@rmkey,@rckey,
							@tourdate,@chkey,@chbackkey,@hdday,@hdnights,@hdprkey,
							@chday,@chpkkey,@chprkey,@chbackday,
							@chbackpkkey,@chbackprkey,@days
					end

					close quotaCursor
					deallocate quotaCursor

					if (@calculateVisaDeadLine > 0)
					begin
						update #resultsTable
						set pt_visadeadline = dbo.mwGetVisaDeadlineDate(pt_tlkey, pt_tourdate, pt_ctkeyfrom)
					end

					select * from #resultsTable
				'
			end
			else
				set @sql=@sql + ' order by pgId '

	end

exec (@sql)

end
Go

GRANT  exec ON [dbo].[Paging] TO PUBLIC
GO

/*********************************************************************/
/* end sp_Paging.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCheckQuotesCycle.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwCheckQuotesCycle]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwCheckQuotesCycle]
GO

CREATE procedure [dbo].[mwCheckQuotesCycle]
--<VERSION>ALL</VERSION>
--<DATE>2012-06-16</DATE>
@pagingType	smallint,
@pageNum	int,		-- номер страницы(начиная с 1 или количество уже просмотренных записей для исключения при @pagingType=@ACTUALPLACES_PAGING)
@pageSize	int,
@agentKey	int,
@hotelQuotaMask smallint,
@aviaQuotaMask smallint,
@flightGroups	varchar(256),
@checkAgentQuota smallint,
@checkCommonQuota smallint,
@checkNoLongQuota smallint,
@requestOnRelease smallint,
@expiredReleaseResult int,
@noPlacesResult int,
@findFlight smallint = 0,	-- параметр устарел, вместо него используется признак подбора перелета. Оставлен для совместимости.
-- 4864 gorshkov
-- признак того, что мы подбираем варианты для подмешивания в поиск
@smartSearch bit = 0,
@tableName varchar(256) = null
as
begin

	declare @sAviaTariffFirst varchar(10), @sAviaTariffSecond varchar(10), 
	@nAviaTariffFirst smallint, @nAviaTariffSecond smallint
	
	declare @initialFindflight int
	set @initialFindflight = @findFlight

	declare @GREEN_LABEL smallint, @YELLOW_LABEL smallint, @RED_LABEL smallint
	set @GREEN_LABEL = 1
	set @YELLOW_LABEL = 4
	set @RED_LABEL = 2

	declare @step_index smallint, @price_correction int, @additional varchar(2000)
	
	if (@smartSearch = 1)
	begin
		-- хранит ключи отелей которые были подмешаны в поиск
		declare @smartSearchKeys table (hdKey int);
	end
	else
	begin
		-- настройка включающая SmartSearch
		declare @mwUseSmartSearch int
		select @mwUseSmartSearch=isnull(SS_ParmValue,0) from dbo.systemsettings 
		where SS_ParmName='mwUseSmartSearch'
		-- пока SmartSearch работает с только с ACTUALPLACES_PAGING
		if (@pagingType <> 2)
		begin
			set @mwUseSmartSearch = 0
		end
	end

	declare @mwCheckInnerAviaQuotes int
	select @mwCheckInnerAviaQuotes = isnull(SS_ParmValue,0) from dbo.systemsettings 
	where SS_ParmName = 'mwCheckInnerAviaQuotes'

	declare @DYNAMIC_SPO_PAGING smallint
	set @DYNAMIC_SPO_PAGING=3

	declare @tmpHotelQuota varchar(10), @tmpThereAviaQuota varchar(256), @tmpBackAviaQuota varchar(256), @allPlaces int,@places int,@actual smallint,@tmp varchar(256),
			@ptkey int,@pttourkey int, @ptpricekey bigint, @hdkey int,@rmkey int,@rckey int,@tourdate datetime,@chkey int,@chbackkey int,@hdday int,@hdnights int,@hdprkey int,	@chday int,@chpkkey int,@chprkey int,@chbackday int,
		@chbackpkkey int,@chbackprkey int,@days int, @rowNum int, @hdStep smallint, @reviewed int,@selected int, @hdPriceCorrection int, @pt_directFlightAttribute int, @pt_backFlightAttribute int, @sql varchar(max)

	declare @pt_chdirectkeys varchar(256), @pt_chbackkeys varchar(256)
	declare @tmpAllHotelQuota varchar(128),@pt_hddetails varchar(256)

	set @reviewed= @pageNum
	set @selected=0

	declare @now datetime, @percentPlaces float, @pos int
	set @now = getdate()
	set @pos = 0

	fetch next from quotaCursor into
	@ptkey,	
	@pttourkey,
	@ptpricekey,
	@hdkey,
	@rmkey,
	@rckey,
	@tourdate,
	@hdday,
	@hdnights,
	@hdprkey,
	@chday,
	@chpkkey,
	@chprkey,
	@chbackday,
	@chbackpkkey,
	@chbackprkey,
	@days,
	@chkey,
	@chbackkey,
	@rowNum, 
	@pt_chdirectkeys, 
	@pt_chbackkeys, 
	@pt_hddetails, 
	@pt_directFlightAttribute, 
	@pt_backFlightAttribute


	while(@@fetch_status=0 and @selected < @pageSize)
	begin 
	
		if (@pos >= @pageNum 
		-- для подмешиваемых вариантов - интересует только одно размещение для каждого отеля
		and (@smartSearch = 0 or not exists (select top 1 1 from @smartSearchKeys where hdKey = @hdkey)))
		begin
			set @actual=1
			if(@aviaQuotaMask > 0)
			begin		
				declare @editableCode int
				set @editableCode = 2
				declare @isEditableService bit
				set @tmpThereAviaQuota=null
				if(@chkey > 0)
				begin 
					if @pt_directFlightAttribute is null
					begin
						--kadraliev MEG00025990 03.11.2010 Если в туре запрещено менять рейс, устанавливаем @findFlight = 0
						exec dbo.mwGetServiceIsEditableAttribute @pttourkey, @chkey, @chday, @days, @chprkey, @chpkkey, @isEditableService output
						if (@isEditableService = 0)
							set @pt_directFlightAttribute = 0
						else
							set @pt_directFlightAttribute = 1
						if (@tableName is not null)
						begin
							set @sql = 'update ' + @tableName + ' set pt_directFlightAttribute = ' + ltrim(str(@pt_directFlightAttribute*2)) + ' where pt_key = ' + ltrim(str(@ptkey))
							exec (@sql)
						end
					end
					set @findFlight = @pt_directFlightAttribute
					
					set @places=0
					EXEC [dbo].[mwCacheQuotaSearch] 1, @chkey, 0, 0, @tourdate, @chday, @days, @chprkey, @chpkkey, 
						@tmpThereAviaQuota OUTPUT, @places output, @step_index output, @price_correction output, @additional output, @findFlight
--						select @tmpThereAviaQuota=res from #checked where svkey=1 and code=@chkey and date=@tourdate 
--										and day=@chday and days=@days and prkey=@chprkey and pkkey=@chpkkey
--										and find_flight = @findFlight
					if (@tmpThereAviaQuota is null)
					begin		
								
						exec dbo.mwCheckFlightGroupsQuotes @pagingType, @chkey, @flightGroups, @agentKey, @chprkey, @tourdate, @chday, @requestOnRelease, @noPlacesResult, @checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, @findFlight, @chpkkey, @days, @expiredReleaseResult, @aviaQuotaMask, @tmpThereAviaQuota output, @chbackday
						
--							insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res, find_flight) 
--								values(1,@chkey,0,0,@tourdate,@chday,@days,@chprkey, @chpkkey, @tmpThereAviaQuota, @findFlight)

						set @nAviaTariffFirst=0
						set @nAviaTariffSecond=0
						if len(@tmpThereAviaQuota)!=0
						BEGIN
							select 
								@sAviaTariffFirst = LEFT(@tmpThereAviaQuota,PATINDEX('%:%',@tmpThereAviaQuota)-1),
								@sAviaTariffSecond = LEFT(
								SUBSTRING(@tmpThereAviaQuota,PATINDEX('%|%',@tmpThereAviaQuota)+1,LEN(@tmpThereAviaQuota)-PATINDEX('%|%',@tmpThereAviaQuota)),
								PATINDEX('%:%',SUBSTRING(@tmpThereAviaQuota,PATINDEX('%|%',@tmpThereAviaQuota)+1,LEN(@tmpThereAviaQuota)-PATINDEX('%|%',@tmpThereAviaQuota)))-1)
							IF ISNUMERIC(@sAviaTariffFirst)=1
								set @nAviaTariffFirst=CAST(@sAviaTariffFirst as smallint)
							IF ISNUMERIC(@sAviaTariffSecond)=1
								set @nAviaTariffSecond=CAST(@sAviaTariffSecond as smallint)
							SET @places = @nAviaTariffFirst+@nAviaTariffSecond
						END

						EXEC [dbo].[mwCacheQuotaInsert] 1,@chkey,0,0,@tourdate,@chday,@days,@chprkey,@chpkkey,@tmpThereAviaQuota, @places, 0, 0, @additional, @findFlight
					end		
								
					if((len(@tmpThereAviaQuota)=0) OR (@places=0 and (@aviaQuotaMask & @RED_LABEL) <> @RED_LABEL))
						set @actual=0
				end
				if(@actual > 0)
				begin
					set @tmpBackAviaQuota=null
					if(@chbackkey > 0)
					begin
						if @pt_backFlightAttribute is null
						begin

							--karimbaeva MEG00038768 17.11.2011 получаем редактируемый атрибут услуги
							exec dbo.mwGetServiceIsEditableAttribute @pttourkey, @chbackkey, @chbackday, @days, @chbackprkey, @chbackpkkey, @isEditableService output
							if (@isEditableService = 0)
								set @pt_backFlightAttribute = 0
							else
								set @pt_backFlightAttribute = 1
							if (@tableName is not null)
							begin
								set @sql = 'update ' + @tableName + ' set pt_backFlightAttribute = ' + ltrim(str(@pt_backFlightAttribute*2)) + ' where pt_key = ' + ltrim(str(@ptkey))
								exec (@sql)
							end
		
						end	

						set @findFlight = @pt_backFlightAttribute
--							select @tmpBackAviaQuota=res from #checked where svkey=1 and code=@chbackkey and date=@tourdate 
--											and day=@chbackday and days=@days and prkey=@chbackprkey and pkkey=@chbackpkkey
--											and find_flight = @findFlight
						EXEC [dbo].[mwCacheQuotaSearch] 1, @chbackkey, 0, 0, @tourdate, @chbackday, @days, @chbackprkey, @chbackpkkey, 
							@tmpBackAviaQuota OUTPUT, @places output, @step_index output, @price_correction output, @additional output, @findFlight
							
						if (@tmpBackAviaQuota is null)
						begin

							exec dbo.mwCheckFlightGroupsQuotes @pagingType, @chbackkey, @flightGroups, @agentKey, @chbackprkey, @tourdate,@chbackday, @requestOnRelease, @noPlacesResult, @checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, @findFlight, @chbackpkkey, @days, @expiredReleaseResult, @aviaQuotaMask, @tmpBackAviaQuota output, @chday
--							insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res, find_flight) 
--								values(1,@chbackkey,0,0,@tourdate,@chbackday,@days,@chbackprkey,@chbackpkkey, @tmpBackAviaQuota, @findFlight)

							set @nAviaTariffFirst=0
							set @nAviaTariffSecond=0
							if len(@tmpBackAviaQuota)!=0
							BEGIN
								select 
								@sAviaTariffFirst = LEFT(@tmpBackAviaQuota,PATINDEX('%:%',@tmpBackAviaQuota)-1),
								@sAviaTariffSecond = LEFT(
								SUBSTRING(@tmpBackAviaQuota,PATINDEX('%|%',@tmpBackAviaQuota)+1,LEN(@tmpBackAviaQuota)-PATINDEX('%|%',@tmpBackAviaQuota)),
								PATINDEX('%:%',SUBSTRING(@tmpBackAviaQuota,PATINDEX('%|%',@tmpBackAviaQuota)+1,LEN(@tmpBackAviaQuota)-PATINDEX('%|%',@tmpBackAviaQuota)))-1)
								IF ISNUMERIC(@sAviaTariffFirst)=1
									set @nAviaTariffFirst=CAST(@sAviaTariffFirst as smallint)
								IF ISNUMERIC(@sAviaTariffSecond)=1
									set @nAviaTariffSecond=CAST(@sAviaTariffSecond as smallint)
								SET @places = @nAviaTariffFirst+@nAviaTariffSecond
							END

							EXEC [dbo].[mwCacheQuotaInsert] 1,@chbackkey,0,0,@tourdate,@chbackday,@days,@chbackprkey,@chbackpkkey,@tmpBackAviaQuota, @places, 0, 0, @additional, @findFlight
						end

						if((len(@tmpBackAviaQuota)=0) or (@places=0 and (@aviaQuotaMask & @RED_LABEL) <> @RED_LABEL))
							set @actual=0				
							
					end
				end
			end			
			if(@hotelQuotaMask > 0)
			begin
				if(@actual > 0)
				begin
					set @tmpHotelQuota=null
					set @hdStep = 0
					set @hdPriceCorrection = 0
					set @places = 0
--					select @tmpHotelQuota=res,@places=places,@hdStep=step_index,@hdPriceCorrection=price_correction from #checked where svkey=3 and code=@hdkey and rmkey=@rmkey and rckey=@rckey and date=@tourdate and day=@hdday and days=@hdnights and prkey=@hdprkey
					EXEC [dbo].[mwCacheQuotaSearch] 3, @hdkey, @rmkey, @rckey, @tourdate, @hdday, @hdnights, @hdprkey, 0, 
						@tmpHotelQuota OUTPUT, @places output, @hdStep output, @hdPriceCorrection output, @additional output, 0
					if (@tmpHotelQuota is null)
					begin

						select @places=qt_places,@allPlaces=qt_allPlaces,@additional=qt_additional from dbo.mwCheckQuotesEx(3,@hdkey,@rmkey,@rckey, @agentKey, @hdprkey,@tourdate,@hdday,@hdnights, @requestOnRelease, @noPlacesResult, @checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, 0, 0, 0, 0, 0, @expiredReleaseResult)
						set @tmpHotelQuota=ltrim(str(@places)) + ':' + ltrim(str(@allPlaces))
						if(@pagingType = @DYNAMIC_SPO_PAGING and @places > 0)
						begin
							exec dbo.GetDynamicCorrections @now,@tourdate,3,@hdkey,@rmkey,@rckey,@places, @hdStep output, @hdPriceCorrection output
						end

--						insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res,places,step_index,price_correction) values(3,@hdkey,@rmkey,@rckey,@tourdate,@hdday,@hdnights,@hdprkey,0,@tmpHotelQuota,@places,@hdStep,@hdPriceCorrection)
						EXEC [dbo].[mwCacheQuotaInsert] 3,@hdkey,@rmkey,@rckey,@tourdate,@hdday,@hdnights,@hdprkey,0,@tmpHotelQuota,@places,@hdStep,@hdPriceCorrection, @additional, 0
					end

					-----------------------------------------------
					--=== Check quotes for all hotels in tour ===--
					--===              [BEGIN]                -----
					if (1 = 1 and @pt_hddetails is not null and charindex(',', @pt_hddetails, 0) > 0)
					begin
						set @tmpAllHotelQuota = ''
						-- Mask for hotel details column :
						-- [HotelKey]:[RoomKey]:[RoomCategoryKey]:[HotelDay]:[HotelDays]:[HotelPartnerKey],...
						declare @curHotelKey int, @curRoomKey int , @curRoomCategoryKey int , @curHotelDay int , @curHotelDays int , @curHotelPartnerKey int

						declare @curHotelDetails varchar(256)
						declare @tempPlaces int
						declare @tempAllPlaces int
						declare @curPosition int
							set @curPosition = 0
						declare @prevPosition int
							set @prevPosition = 0
						declare @curHotelQuota  varchar(256)
						while (1 = 1)
						begin
							set @curPosition = charindex(',', @pt_hddetails, @curPosition + 1)
							if (@curPosition = 0)
								set @curHotelDetails  = substring(@pt_hddetails, @prevPosition, 256)
							else
								set @curHotelDetails  = substring(@pt_hddetails, @prevPosition, @curPosition - @prevPosition)
							
							-- Get details by current hotel
							begin try
								exec mwParseHotelDetails @curHotelDetails, @curHotelKey output, @curRoomKey output, @curRoomCategoryKey output, @curHotelDay output, @curHotelDays output, @curHotelPartnerKey output
							end try
							begin catch
								--произошла ошибка, последующие отели просто не будут проверяться на наличие мест
								break
							end catch
							-----
							set @curHotelQuota = null
--											select @curHotelQuota=res from #checked where svkey=3 and code=@curHotelKey and rmkey=@curRoomKey and rckey=@curRoomCategoryKey and date=@tourdate and day=@curHotelDay and days=@curHotelDays and prkey=@curHotelPartnerKey
							EXEC [dbo].[mwCacheQuotaSearch] 3, @curHotelKey, @curRoomKey, @curRoomCategoryKey, @tourdate, @curHotelDay, @curHotelDays, @curHotelPartnerKey, 0, 
								@curHotelQuota OUTPUT, @places output, @hdStep output, @hdPriceCorrection output, @additional output, 0
							if (@curHotelQuota is null)
							begin
								select @tempPlaces=qt_places,@tempAllPlaces=qt_allPlaces,@additional=qt_additional from dbo.mwCheckQuotesEx(3,@curHotelKey,@curRoomKey,@curRoomCategoryKey, @agentKey, @hdprkey,@tourdate,@hdday,@hdnights, @requestOnRelease, @noPlacesResult, @checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, 0, 0, 0, 0, 0, @expiredReleaseResult)
								set @curHotelQuota=ltrim(str(@tempPlaces)) + ':' + ltrim(str(@tempAllPlaces))

--												insert into #checked(svkey,code,rmkey,rckey,date,day,days,prkey,pkkey,res,places) values(3,@curHotelKey,@curRoomKey,@curRoomCategoryKey,@tourdate,@curHotelDay,@curHotelDays,@curHotelPartnerKey,0,@curHotelQuota,@tempPlaces)
								EXEC [dbo].[mwCacheQuotaInsert] 3,@curHotelKey,@curRoomKey,@curRoomCategoryKey,@tourdate,@curHotelDay,@curHotelDays,@curHotelPartnerKey,0,@curHotelQuota,@tempPlaces,0,0, @additional, 0
							end
							-----
							set @tmpAllHotelQuota = @tmpAllHotelQuota + @curHotelQuota + '|'

							if (@curPosition = 0)
								break
							set @prevPosition = @curPosition + 1
						end
						
						-- Remove comma at the end of string
						if(len(@tmpAllHotelQuota) > 0)
							set @tmpAllHotelQuota = substring(@tmpAllHotelQuota, 1, len(@tmpAllHotelQuota) - 1)
					end
					--===                [END]                -----
					--=== Check quotes for all hotels in tour ===--
					-----------------------------------------------
					
					if((@places > 0 and (@hotelQuotaMask & 1)=0) or (@places=0 and (@hotelQuotaMask & 2)=0) or (@places=-1 and (@hotelQuotaMask & 4)=0))
						set @actual=0
				end
			end



	------==============================================================================================------
	--============================ Check inner avia quotes if needed by settings ===========================--
	--========																						========--
			if(@actual > 0 and @mwCheckInnerAviaQuotes > 0)
			begin
				-- Direct flights
				if (@pt_chdirectkeys is not null and charindex(',', @pt_chdirectkeys, 0) > 0)
				begin
					set @findFlight = @initialFindflight
					exec dbo.mwCheckFlightGroupsQuotesWithInnerFlights @pagingType, @pt_chdirectkeys, 
							@flightGroups, @agentKey, @tourdate, @requestOnRelease, @noPlacesResult, 
							@checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, @findFlight, 
							@days, @expiredReleaseResult, @aviaQuotaMask, @tmpThereAviaQuota output, @pt_chbackkeys
					if (len(@tmpThereAviaQuota) = 0)
						set @actual = 0
				end 

				-- Back flights
				if(@actual > 0)
				begin
					if (@pt_chbackkeys is not null and charindex(',', @pt_chbackkeys, 0) > 0)
					begin
						set @findFlight = @initialFindflight
						exec dbo.mwCheckFlightGroupsQuotesWithInnerFlights @pagingType, @pt_chbackkeys,   
							@flightGroups, @agentKey, @tourdate, @requestOnRelease, @noPlacesResult, 
							@checkAgentQuota, @checkCommonQuota, @checkNoLongQuota, @findFlight, 
							@days, @expiredReleaseResult, @aviaQuotaMask, @tmpBackAviaQuota output, @pt_chdirectkeys
						if (len(@tmpBackAviaQuota) = 0)
							set @actual = 0
					end 
				end
			end
	--========																						========--
	--============================                                               ===========================--
	------==============================================================================================------
			
			if(@actual > 0)
			begin
				if (@smartSearch = 1)
				begin
					-- сохраним ключ отеля для которого уже было добавлено размещение
					insert into @smartSearchKeys(hdKey) values (@hdkey)
					set @selected=@selected + 1
					-- pt_smartSearch = 1 (для выделения подмешанных вариантов)
					insert into #Paging(ptKey,pt_hdquota,pt_chtherequota,pt_chbackquota,chkey,chbackkey,stepId,priceCorrection, pt_hdallquota, pt_smartSearch)
					values(@ptkey,@tmpHotelQuota,@tmpThereAviaQuota,@tmpBackAviaQuota,@chkey,@chbackkey,@hdStep,@hdPriceCorrection, @tmpAllHotelQuota, 1)
				end
				-- если используется SmartSearch (глобально - включена настройка, но mwCheckQuotesCycle вызвана НЕ для подмешанных вариантов) 
				-- то возможна ситуация когда данный ptKey уже был добавлен в #Paging как подмешанный
				else if (@mwUseSmartSearch = 0 or not exists (select top 1 1 from #Paging where ptKey = @ptkey))
				begin
					set @selected=@selected + 1
					insert into #Paging(ptKey,ptpricekey,pt_hdquota,pt_chtherequota,pt_chbackquota,chkey,chbackkey,stepId,priceCorrection, pt_hdallquota)
					values(@ptkey,@ptpricekey,@tmpHotelQuota,@tmpThereAviaQuota,@tmpBackAviaQuota,@chkey,@chbackkey,@hdStep,@hdPriceCorrection, @tmpAllHotelQuota)
				end
			end

			set @reviewed=@reviewed + 1
		end
		fetch next from quotaCursor into @ptkey,@pttourkey,@ptpricekey,@hdkey,@rmkey,@rckey,@tourdate,@hdday,@hdnights,@hdprkey,@chday,@chpkkey,@chprkey,@chbackday,@chbackpkkey,@chbackprkey,@days,@chkey,@chbackkey,@rowNum, @pt_chdirectkeys, @pt_chbackkeys, @pt_hddetails, @pt_directFlightAttribute, @pt_backFlightAttribute
		set @pos = @pos + 1
	end

	if (@smartSearch=0)
	begin
		select @reviewed
	end
end
GO

grant execute on [dbo].[mwCheckQuotesCycle] to public
GO
/*********************************************************************/
/* end sp_mwCheckQuotesCycle.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 2012.05.12_CREATE_Columns_UserActionType.sql */
/*********************************************************************/
-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-12</DATE>	
-- =============================================
IF Not EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[UserActionType]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1) BEGIN

CREATE TABLE [dbo].[UserActionType](
	[UA_ID] [int] IDENTITY(1,1) NOT NULL,
	[UA_Name] [nvarchar](50) NOT NULL,
 CONSTRAINT [PK_UserActionType] PRIMARY KEY CLUSTERED 
(
	[UA_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

END
GO

GRANT  SELECT ,  UPDATE ,  INSERT ,  DELETE  ON [dbo].[UserActionType] TO PUBLIC
GO
/*********************************************************************/
/* end 2012.05.12_CREATE_Columns_UserActionType.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 2012.05.12_Insert_UserActionType.sql */
/*********************************************************************/
-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-12</DATE>	
-- =============================================
IF Not EXISTS (select * from [dbo].[UserActionType] WHERE [UA_ID]=1)
INSERT INTO [dbo].[UserActionType]([UA_Name]) VALUES ('Создание')
GO

IF Not EXISTS (select * from [dbo].[UserActionType] WHERE [UA_ID]=2)
INSERT INTO [dbo].[UserActionType]([UA_Name]) VALUES ('Изменение')
GO

IF Not EXISTS (select * from [dbo].[UserActionType] WHERE [UA_ID]=3)
INSERT INTO [dbo].[UserActionType]([UA_Name]) VALUES ('Удаление')
GO
/*********************************************************************/
/* end 2012.05.12_Insert_UserActionType.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 2012.05.12_CREATE_Columns_ActionsLog.sql */
/*********************************************************************/
-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-12</DATE>	
-- =============================================
IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ActionsLog]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1) BEGIN

	CREATE TABLE [dbo].[ActionsLog](
		[ACL_ID] [int] IDENTITY(1,1) NOT NULL,
		[ACL_DateAction] [datetime] NOT NULL,
		[ACL_OldValue] [nvarchar](max) NULL,
		[ACL_NewValue] [nvarchar](max) NULL,
		[ACL_UserLogin] [nvarchar](50) NOT NULL,
		[ACL_Host] [nvarchar](max) NOT NULL,
		[ACL_Name] [nvarchar](max) NOT NULL,
		[ACL_ChangeType] [int] NOT NULL,
		[ACL_ChangeSubject] [nvarchar](50) NOT NULL,
	CONSTRAINT [PK_ActionsLog] PRIMARY KEY CLUSTERED 
	(
		[ACL_ID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Дата совершения действия' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_DateAction'

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Значение таблицы ДО совершения действия ' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_OldValue'

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Значение таблицы ПОСЛЕ совершения действия ' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_NewValue'

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Логин пользователя, совершившего изменение' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_UserLogin'

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Хост пользователя, совершившего изменение' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_Host'

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Название измененного экшона' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_Name'

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Тип действия пользователя' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'ActionsLog', @level2type=N'COLUMN',@level2name=N'ACL_ChangeType'

ALTER TABLE [dbo].[ActionsLog]  WITH CHECK ADD  CONSTRAINT [FK_ActionsLog_UserActionType] FOREIGN KEY([ACL_ChangeType])
REFERENCES [dbo].[UserActionType] ([UA_ID])

ALTER TABLE [dbo].[ActionsLog] CHECK CONSTRAINT [FK_ActionsLog_UserActionType]

END
GO

GRANT  SELECT ,  UPDATE ,  INSERT ,  DELETE  ON [dbo].[ActionsLog] TO PUBLIC
GO

/*********************************************************************/
/* end 2012.05.12_CREATE_Columns_ActionsLog.sql */
/*********************************************************************/

/*********************************************************************/
/* begin t_Delete_T_ActionsAuthDelete.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_ActionsAuthDelete]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop TRIGGER [dbo].[T_ActionsAuthDelete]
GO

-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-12</DATE>	
-- =============================================
CREATE TRIGGER [dbo].[T_ActionsAuthDelete]
   ON  [dbo].[ActionsAuth]
   AFTER DELETE
AS 
BEGIN
	SET NOCOUNT ON;
	DECLARE @deletedValue table(id int identity(1,1), NewValue nvarchar(max), UserLogin nvarchar(50))
	
	INSERT INTO @deletedValue
		SELECT distinct 'Для пользователя '''+UserList.US_UserId+''' удалено разрешение на действие '+Actions.AC_Name  as NewValue,
		UserList.US_UserId as UserLogin 
		FROM (deleted inner join UserList On deleted.ACA_USKey=UserList.US_KEY) inner join Actions on deleted.ACA_ACKey=Actions.AC_Key
	
	DECLARE @i int
	SET @i=1
	
	DECLARE @count int
	SET @count=(select COUNT(*) from @deletedValue)
		
	DECLARE @message nvarchar(max)
	DECLARE @SubjectName nvarchar(50)
		
	WHILE @i<=@count
	BEGIN
		
		set @message=(select NewValue from @deletedValue where id=@i)
		set @SubjectName=(select UserLogin from @deletedValue where id=@i)
		
		INSERT INTO ActionsLog([ACL_DateAction], [ACL_OldValue], [ACL_NewValue], [ACL_UserLogin], [ACL_Host], [ACL_Name],[ACL_ChangeType],[ACL_ChangeSubject])
		VALUES (GETDATE(),'Включено','Выключено', Upper(SYSTEM_USER), HOST_NAME(), @message, 3,@SubjectName)	

		SET @i=@i+1
	END
END

GO



/*********************************************************************/
/* end t_Delete_T_ActionsAuthDelete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin t_Delete_T_GroupAuthDelete.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_GroupAuthDelete]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop TRIGGER [dbo].[T_GroupAuthDelete]
GO

-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-12</DATE>	
-- =============================================
CREATE TRIGGER [dbo].[T_GroupAuthDelete]
   ON  [dbo].[GroupAuth]
   AFTER DELETE
AS 
BEGIN
	SET NOCOUNT ON;
	DECLARE @deletedValue table(id int identity(1,1), MessageName nvarchar(max),GroupName nvarchar(50))
	
	INSERT INTO @deletedValue
		SELECT 'Для группы '''+sys.database_principals.name+''' удалено разрешение на действие '+Actions.AC_Name  as MessageName,
		sys.database_principals.name as GroupName
		FROM ((deleted left join Synonyms ON deleted.GRA_SYKEY=Synonyms.sy_key) inner join sys.database_principals On deleted.GRA_GRKey=principal_id) inner join Actions On deleted.GRA_ACKey=Actions.AC_Key	
		
	DECLARE @i int
	SET @i=1
	
	DECLARE @count int
	SET @count=(select COUNT(*) from @deletedValue)
	
	DECLARE @message nvarchar(max)
	DECLARE @SubjectName nvarchar(50)
	
	WHILE @i<=@count
	BEGIN
	
		set @message=(select MessageName from @deletedValue where id=@i)
		set @SubjectName=(select GroupName from @deletedValue where id=@i)
		
		INSERT INTO ActionsLog([ACL_DateAction], [ACL_OldValue], [ACL_NewValue], [ACL_UserLogin], [ACL_Host], [ACL_Name],[ACL_ChangeType], [ACL_ChangeSubject])
		VALUES (GETDATE(),'Включено','Выключено', Upper(SYSTEM_USER), HOST_NAME(), @message, 3,@SubjectName)	
			
		SET @i=@i+1
	END
END

GO



/*********************************************************************/
/* end t_Delete_T_GroupAuthDelete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin t_Insert_T_ActionsAuthInsert.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_ActionsAuthInsert]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop TRIGGER [dbo].[T_ActionsAuthInsert]
GO

-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-17</DATE>	
-- =============================================
CREATE TRIGGER [dbo].[T_ActionsAuthInsert]
   ON  [dbo].[ActionsAuth]
   AFTER INSERT
AS 
BEGIN
	SET NOCOUNT ON;
	DECLARE @insertedValue table(id int identity(1,1), NewValue nvarchar(max), UserLogin nvarchar(50))
	
	INSERT INTO @insertedValue
		SELECT distinct 'Для пользователя '''+UserList.US_UserId+''' создано разрешение на действие '+Actions.AC_Name  as NewValue,
		UserList.US_UserId as UserLogin
		FROM (inserted inner join UserList On inserted.ACA_USKey=UserList.US_KEY) inner join Actions on inserted.ACA_ACKey=Actions.AC_Key
	
	DECLARE @i int
	SET @i=1
	
	DECLARE @count int
	SET @count=(select COUNT(*) from @insertedValue)
	
	DECLARE @message nvarchar(max)
	DECLARE @SubjectName nvarchar(50)
	
	WHILE @i<=@count
	BEGIN
	
		set @message=(select NewValue from @insertedValue where id=@i)
		set @SubjectName=(select UserLogin from @insertedValue where id=@i)
		
		INSERT INTO ActionsLog([ACL_DateAction], [ACL_OldValue], [ACL_NewValue], [ACL_UserLogin], [ACL_Host], [ACL_Name],[ACL_ChangeType],[ACL_ChangeSubject])
		VALUES (GETDATE(),'Выключено', 'Включено', Upper(SYSTEM_USER), HOST_NAME(), @message, 1,@SubjectName)	
			
		SET @i=@i+1
	END
END

GO



/*********************************************************************/
/* end t_Insert_T_ActionsAuthInsert.sql */
/*********************************************************************/

/*********************************************************************/
/* begin t_Insert_T_GroupAuthInsert.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_GroupAuthInsert]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop TRIGGER [dbo].[T_GroupAuthInsert]
GO

-- =============================================
--<VERSION>9.2.12.1</VERSION>
--<DATE>2012-05-17</DATE>	
-- =============================================
CREATE TRIGGER [dbo].[T_GroupAuthInsert]
   ON  [dbo].[GroupAuth]
   AFTER INSERT
AS 
BEGIN
	SET NOCOUNT ON;
	DECLARE @insertedValue table(id int identity(1,1), MessageName nvarchar(max),GroupName nvarchar(50))
	
	INSERT INTO @insertedValue
		SELECT 'Для группы '''+sys.database_principals.name+''' создано разрешение на действие '+Actions.AC_Name as MessageName,
		sys.database_principals.name as GroupName
		FROM ((inserted left join Synonyms ON inserted.GRA_SYKEY=Synonyms.sy_key) inner join sys.database_principals On inserted.GRA_GRKey=principal_id) inner join Actions On inserted.GRA_ACKey=Actions.AC_Key	


	DECLARE @i int
	SET @i=1
	
	DECLARE @count int
	SET @count=(select COUNT(*) from @insertedValue)
	
	DECLARE @message nvarchar(max)
	DECLARE @SubjectName nvarchar(50)
	WHILE @i<=@count
	BEGIN
		
		set @message=(select MessageName from @insertedValue where id=@i)
		set @SubjectName=(select GroupName from @insertedValue where id=@i)
		
		INSERT INTO ActionsLog([ACL_DateAction], [ACL_OldValue], [ACL_NewValue], [ACL_UserLogin], [ACL_Host], [ACL_Name],[ACL_ChangeType],[ACL_ChangeSubject])
		VALUES (GETDATE(),'Выключено', 'Включено', Upper(SYSTEM_USER), HOST_NAME(), @message, 1,@SubjectName)	
			
		SET @i=@i+1
	END
END

GO



/*********************************************************************/
/* end t_Insert_T_GroupAuthInsert.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_LogApplicationEvents.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[LogApplicationEvents]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[LogApplicationEvents]
GO


CREATE PROCEDURE [dbo].[LogApplicationEvents]
-- <Version>1.0.0.1 </Version>
-- <CreateDate> 21.05.2012 </CreateDate>
(
@Actionid int,
@Succeed bit,
@UserId nvarchar(50),
@Name nvarchar(200)  
)
AS
begin
	insert into dbo.ApplicationLogs(AL_CreateDate,AL_ACTionID,AL_Succeed,AL_USERID,AL_NAME,AL_Host)
	values (GETDATE(),@Actionid,@Succeed,Upper(@UserId),@Name,HOST_NAME())
end
GO


GRANT EXEC ON [dbo].[LogApplicationEvents] TO PUBLIC
GO
/*********************************************************************/
/* end sp_LogApplicationEvents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.05.23)_CREATE_TransferDirection.sql */
/*********************************************************************/
if not exists ( select * from sysobjects where id = object_id(N'[dbo].[TransfertDirection]') and objectproperty(id, N'IsUserTable') = 1 ) 
	CREATE TABLE [dbo].[TransfertDirection](
		[TFD_Id] [int] IDENTITY(1,1) NOT NULL,
		[TFD_Name] [nvarchar](128) NOT NULL		
	CONSTRAINT [PK_TransfertDirection] PRIMARY KEY CLUSTERED 
	(
		[TFD_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

grant select, update, insert, delete on dbo.TransfertDirection to public
go
/*********************************************************************/
/* end (2012.05.23)_CREATE_TransferDirection.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.05.23)_Data_TransfertDirection.sql */
/*********************************************************************/
if not exists (select top 1 1 from dbo.TransfertDirection where TFD_Id = 0)
begin
	SET IDENTITY_INSERT dbo.TransfertDirection ON
	insert into TransfertDirection (TFD_Id, TFD_Name)
	values (0, 'Не выбран')
	SET IDENTITY_INSERT dbo.TransfertDirection OFF
end

if not exists (select top 1 1 from dbo.TransfertDirection where TFD_Id = 1)
begin
	SET IDENTITY_INSERT dbo.TransfertDirection ON
	insert into TransfertDirection (TFD_Id, TFD_Name)
	values (1, 'Прямой')
	SET IDENTITY_INSERT dbo.TransfertDirection OFF
end

go
if not exists (select top 1 1 from dbo.TransfertDirection where TFD_Id = 2)
begin
	SET IDENTITY_INSERT dbo.TransfertDirection ON
	insert into TransfertDirection (TFD_Id, TFD_Name)
	values (2, 'Обратный')
	SET IDENTITY_INSERT dbo.TransfertDirection OFF
end
go

if not exists (select top 1 1 from dbo.TransfertDirection where TFD_Id = 3)
begin
	SET IDENTITY_INSERT dbo.TransfertDirection ON
	insert into TransfertDirection (TFD_Id, TFD_Name)
	values (3, 'Промежуточный')
	SET IDENTITY_INSERT dbo.TransfertDirection OFF
end
go
/*********************************************************************/
/* end (2012.05.23)_Data_TransfertDirection.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.05.24)_ADD_TF_Direction_Transfer.sql */
/*********************************************************************/
if not exists (select * from syscolumns where name='TF_Direction' and id=object_id('dbo.Transfer'))
begin
	alter table dbo.[Transfer] add TF_Direction int not null default(0);
end
go
/*********************************************************************/
/* end (2012.05.24)_ADD_TF_Direction_Transfer.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetPolicyIdsByDogovor.sql */
/*********************************************************************/
--<VERSION>ALL</VERSION>
--<DATE>2012-01-23</DATE>
-- MEG00039504. Golubinsky. 23.01.2012.
-- Изменил название хранимой процедуры, расширил функциональность: теперь тип возвращаемых полисов
-- (корректный или некорректный) регулируется параметром @onlyCorrectPolicies

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetIncorrectPolicyIds]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetIncorrectPolicyIds]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetPolicyIdsByDogovor]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetPolicyIdsByDogovor]
GO

-- Возвращает ID страховых полисов, данные по путевкам которых изменились, если не указан
-- параметр @onlyCorrectPolicies. Если @onlyCorrectPolicies = 1, то возвращает ID корректных полисов.
-- По некорректным полисам тслеживаются слудующие изменения в путевках:
-- 1. Изменение набора рисков
-- 2. Изменение количества Застрахованных
-- 3. Изменение периода действия полиса
-- Если с при передаче параметра @onlyCorrectPolicies = 0 возвращается -1, это значит, что
-- существуют данные (туристы, услуги), по которым полиса не сформированы
CREATE PROCEDURE [dbo].[GetPolicyIdsByDogovor]
	@DogovorKey int						-- Ключ путевки по которой ищются неактуальные полисы
	, @onlyCorrectPolicies bit = 0		-- Признак включения в результат ИД корректных полисов по путевке
AS
BEGIN

DECLARE @ServiceInsurance int
SET @ServiceInsurance = 6;

WITH 
-- Кортежи с комбинациями ключей туристов, услуг, и периодов услуг из путевки
TupleFromDogs AS
(
	select distinct
	DL_KEY AS TD_DLKEY
	,TU_TUKEY AS TD_TUKey
	,DL_DATEBEG AS TD_DATEBEG
	,DL_DATEEND AS TD_DATEEND
	,TP_IPID =			ISNull((
							select ip_id from inspolicy 
							join inspolicylist on ip_id = ipl_ipid
							join insturists on ip_id = it_ipid
							where ip_commisprice = dl_dgkey and it_tukey = tu_tukey and ipl_koefvalue = dl_key and ip_annuldate is null
						),-1)
	from Dogovorlist
	join TuristService on TU_DLKEY = DL_KEY
	where DL_SVKEY = @ServiceInsurance and DL_DGKEY = @DogovorKey 
),
-- Кортежи с комбинациями ключей туристов, услуг, и периодов услуг восстановленные из полисов
TupleFromPolicy AS
(
	select distinct
	       CAST(InsPolicyList.IPL_KoefValue AS INT) AS TP_DLKEY
	      ,InsTurists.IT_TUKey AS TP_TUKey
	      ,IP_DateBeg AS TP_DATEBEG
	      ,TP_DATEEND = DateAdd(d,(Case IPL_NDays When 0 Then IPL_NDays Else IPL_NDays - 1 END),IP_DateBeg)
	      ,IP_ID AS TP_IPID
	from InsPolicy
	join InsPolicyList ON IPL_IPID = IP_ID
	left join InsTurists on IT_IPID = IP_ID
	where IP_CommisPrice = @DogovorKey and InsPolicy.IP_AnnulDate IS NULL

),
-- Разница между TupleFromDogs и TupleFromPolicy
Incorrect AS
(
   (
	   SELECT  TP_DLKEY AS I_DLKEY
			  ,TP_TUKey AS I_TUKey
			  ,TP_DATEBEG AS I_DATEBEG
			  ,TP_DATEEND AS I_DATEEND
			  ,TP_IPID AS I_IPID 
		FROM TupleFromPolicy
		EXCEPT
		SELECT * FROM TupleFromDogs
	)
	UNION
	(
		SELECT * FROM TupleFromDogs
		EXCEPT
		SELECT * FROM TupleFromPolicy
	)
),
Correct AS
(
		SELECT TP_DLKEY AS I_DLKEY
			  ,TP_TUKey AS I_TUKey
			  ,TP_DATEBEG AS I_DATEBEG
			  ,TP_DATEEND AS I_DATEEND
			  ,TP_IPID AS I_IPID
		FROM TupleFromPolicy
		INTERSECT
		SELECT * FROM TupleFromDogs
)
SELECT DISTINCT I_IPID
FROM Incorrect
WHERE @onlyCorrectPolicies = 0
UNION
SELECT DISTINCT I_IPID
FROM Correct
WHERE @onlyCorrectPolicies = 1

END

GO

grant exec on [dbo].[GetPolicyIdsByDogovor] to public

go
/*********************************************************************/
/* end sp_GetPolicyIdsByDogovor.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_ServiceByDateChanged.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_ServiceByDateChanged]'))
DROP TRIGGER [dbo].[T_ServiceByDateChanged]
GO

CREATE TRIGGER [dbo].[T_ServiceByDateChanged] ON [dbo].[ServiceByDate]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2012-06-28</DATE>
--<VERSION>2009.2.14</VERSION>
DECLARE @sMod varchar(3), @nHIID int, @sDGCode varchar(10), @nDGKey int, @sDLName varchar(150), @sTemp varchar(25), @sTemp2 varchar(255), @sTuristName varchar(55)
DECLARE @sOldValue varchar(255), @sNewValue varchar(255), @nOldValue int, @nNewValue int, @SDDate datetime
DECLARE @nRowsCount int, @sServiceStatusToHistory varchar(255)

DECLARE @SDID int, @N_SD_DLKey int, @N_SD_RLID int, @N_SD_TUKEY int, @N_SD_QPID int, @N_SD_State int, @N_SD_Date datetime,
		@O_SD_DLKey int, @O_SD_RLID int, @O_SD_TUKEY int, @O_SD_QPID int, @O_SD_State int, @O_SD_Date datetime, @QT_ByRoom bit,
		@nDelCount int, @nInsCount int, @DLDateBeg datetime, @DLNDays int, @QState int, @NewQState int

SELECT @nDelCount = COUNT(*) FROM DELETED
SELECT @nInsCount = COUNT(*) FROM INSERTED
IF (@nInsCount = 0)
BEGIN
    DECLARE cur_ServiceByDateChanged CURSOR FOR 
    SELECT 	O.SD_ID,
			O.SD_DLKey, O.SD_RLID, O.SD_TUKey, O.SD_QPID, O.SD_State, O.SD_Date,
			null, null, null, null, null, null
    FROM DELETED O
END
ELSE IF (@nDelCount = 0)
BEGIN
    DECLARE cur_ServiceByDateChanged CURSOR FOR 
    SELECT 	N.SD_ID,
			null, null, null, null, null, null,
			N.SD_DLKey, N.SD_RLID, N.SD_TUKey, N.SD_QPID, N.SD_State, N.SD_Date
			--DL_DateBeg, DL_NDays
    FROM	INSERTED N
	--LEFT OUTER JOIN tbl_DogovorList ON N.SD_DLKey = DL_Key
	-- CRM01871H3T9 30.05.2012 kolbeshkin: отсеиваем неквотируемые услуги, для них триггер не должен отрабатывать
	where exists (select 1 from DogovorList,Service where DL_KEY=N.SD_DLKey and DL_SVKEY=SV_KEY 
    and ISNULL(SV_QUOTED,0)<>0)
END
ELSE 
BEGIN
    DECLARE cur_ServiceByDateChanged CURSOR FOR 
    SELECT 	N.SD_ID,
			O.SD_DLKey, O.SD_RLID, O.SD_TUKey, O.SD_QPID, O.SD_State, O.SD_Date,
	  		N.SD_DLKey, N.SD_RLID, N.SD_TUKey, N.SD_QPID, N.SD_State, N.SD_Date
			--DL_DateBeg, DL_NDays
    FROM DELETED O, INSERTED N
	--LEFT OUTER JOIN tbl_DogovorList ON N.SD_DLKey = DL_Key 
    WHERE N.SD_ID = O.SD_ID
	-- CRM01871H3T9 30.05.2012 kolbeshkin: отсеиваем неквотируемые услуги, для них триггер не должен отрабатывать
	and exists (select 1 from DogovorList,Service where DL_KEY=N.SD_DLKey and DL_SVKEY=SV_KEY 
    and ISNULL(SV_QUOTED,0)<>0)
END

select @sServiceStatusToHistory = SS_ParmValue from SystemSettings where SS_ParmName like 'SYSServiceStatusToHistory'

OPEN cur_ServiceByDateChanged
FETCH NEXT FROM cur_ServiceByDateChanged 
	INTO @SDID, @O_SD_DLKey, @O_SD_RLID, @O_SD_TUKEY, @O_SD_QPID, @O_SD_State, @O_SD_Date,
				@N_SD_DLKey, @N_SD_RLID, @N_SD_TUKEY, @N_SD_QPID, @N_SD_State, @N_SD_Date
				--@DLDateBeg, @DLNDays
WHILE @@FETCH_STATUS = 0
BEGIN
	IF ISNULL(@O_SD_QPID,0)!=ISNULL(@N_SD_QPID,0) OR ISNULL(@O_SD_RLID,0)!=ISNULL(@N_SD_RLID,0)
	BEGIN
		If @O_SD_QPID is not null
		BEGIN			
			SELECT @QT_ByRoom=QT_ByRoom FROM Quotas,QuotaDetails,QuotaParts WHERE QD_QTID=QT_ID and QD_ID=QP_QDID and QP_ID=@O_SD_QPID
			IF @QT_ByRoom = 1
			BEGIN
				UPDATE	QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=(SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate WHERE SD_QPID=@O_SD_QPID) WHERE QP_ID=@O_SD_QPID
				UPDATE  QuotaDetails SET QD_Busy=(SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate,QuotaParts WHERE SD_QPID=QP_ID and QP_QDID=QD_ID) WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@O_SD_QPID)
				--IF @O_SD_Date = @DLDateBeg
					UPDATE	QuotaParts SET QP_CheckInPlacesBusy=(
						SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate, tbl_DogovorList join [Service] on DL_SVKey = SV_KEY WHERE SD_QPID=@O_SD_QPID AND SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key and isnull(SV_IsDuration, 0) = 1) 
					WHERE QP_ID=@O_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
			ELSE
			BEGIN
				UPDATE	QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_QPID=@O_SD_QPID) WHERE QP_ID=@O_SD_QPID
				UPDATE  QuotaDetails SET QD_Busy=(SELECT COUNT(*) FROM ServiceByDate,QuotaParts WHERE SD_QPID=QP_ID and QP_QDID=QD_ID) WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@O_SD_QPID)
				--IF @O_SD_Date = @DLDateBeg
					UPDATE	QuotaParts SET QP_CheckInPlacesBusy=(
						SELECT COUNT(*) FROM ServiceByDate, tbl_DogovorList join [Service] on DL_SVKey = SV_KEY WHERE SD_QPID=@O_SD_QPID AND SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key and isnull(SV_IsDuration, 0) = 1) 
					WHERE QP_ID=@O_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
		END
		If @N_SD_QPID is not null
		BEGIN
			SELECT @QT_ByRoom=QT_ByRoom FROM Quotas,QuotaDetails,QuotaParts WHERE QD_QTID=QT_ID and QD_ID=QP_QDID and QP_ID=@N_SD_QPID
			IF @QT_ByRoom = 1
			BEGIN
				UPDATE	QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=(SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate WHERE SD_QPID=@N_SD_QPID) WHERE QP_ID=@N_SD_QPID
				UPDATE  QuotaDetails SET QD_Busy=(SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate,QuotaParts WHERE SD_QPID=QP_ID and QP_QDID=QD_ID) WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@N_SD_QPID)
				--IF @N_SD_Date = @DLDateBeg
					UPDATE	QuotaParts SET QP_CheckInPlacesBusy=(
						SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate, tbl_DogovorList join [Service] on DL_SVKey = SV_KEY WHERE SD_QPID=@N_SD_QPID AND SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key and isnull(SV_IsDuration, 0) = 1) 
					WHERE QP_ID=@N_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
			ELSE
			BEGIN
				UPDATE	QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_QPID=@N_SD_QPID) WHERE QP_ID=@N_SD_QPID
				UPDATE  QuotaDetails SET QD_Busy=(SELECT COUNT(*) FROM ServiceByDate,QuotaParts WHERE SD_QPID=QP_ID and QP_QDID=QD_ID) WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@N_SD_QPID)
				--IF @N_SD_Date = @DLDateBeg
					UPDATE	QuotaParts SET QP_CheckInPlacesBusy=(
						SELECT COUNT(*) FROM ServiceByDate, tbl_DogovorList join [Service] on DL_SVKey = SV_KEY WHERE SD_QPID=@N_SD_QPID AND SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key and isnull(SV_IsDuration, 0) = 1) 
					WHERE QP_ID=@N_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
		END
	END
	IF (ISNULL(@O_SD_STATE, 0) != ISNULL(@N_SD_STATE, 0) or 
		ISNULL(@O_SD_TUKEY,0)!=ISNULL(@N_SD_TUKEY,0)) and ISNULL(@sServiceStatusToHistory, '0') != '0'
	BEGIN
		Select @QState = QS_STATE from QuotedState 
		where QS_DLID = @N_SD_DLKey and ISNULL(QS_TUID,0) = ISNULL(@N_SD_TUKEY,0)
		IF @QState is NULL and @N_SD_DLKey is not NULL
		BEGIN
			Set @QState = 4
			Insert into QuotedState (QS_DLID, QS_TUID, QS_STATE) values (@N_SD_DLKey, @N_SD_TUKEY, @QState)
		END

		Select @NewQState = MAX(SD_STATE) from ServiceByDate 
		where SD_DLKey = @N_SD_DLKey and ISNULL(SD_TUKEY,0) = ISNULL(@N_SD_TUKEY,0)
		
		if @NewQState is null
		 	set @NewQState = 4
		IF @QState <> @NewQState
			IF @N_SD_DLKey is not NULL
				Update QuotedState set QS_STATE = @NewQState where QS_DLID=@N_SD_DLKey and ISNULL(QS_TUID,0)=ISNULL(@N_SD_TUKEY,0)
			ELSE
				IF @O_SD_DLKey is not NULL
					Update QuotedState set QS_STATE = @NewQState where QS_DLID=@O_SD_DLKey and ISNULL(QS_TUID,0)=ISNULL(@N_SD_TUKEY,0)
	END
	FETCH NEXT FROM cur_ServiceByDateChanged 
		INTO @SDID, @O_SD_DLKey, @O_SD_RLID, @O_SD_TUKEY, @O_SD_QPID, @O_SD_State, @O_SD_Date,
					@N_SD_DLKey, @N_SD_RLID, @N_SD_TUKEY, @N_SD_QPID, @N_SD_State, @N_SD_Date
					--@DLDateBeg, @DLNDays
END
IF @O_SD_DLKey is not null and @N_SD_DLKey is null
	IF exists (SELECT 1 FROM RoomNumberLists WHERE RL_ID not in (SELECT SD_RLID FROM ServiceByDate) )
		DELETE FROM RoomNumberLists WHERE RL_ID not in (SELECT SD_RLID FROM ServiceByDate)

CLOSE cur_ServiceByDateChanged
DEALLOCATE cur_ServiceByDateChanged

GO



/*********************************************************************/
/* end T_ServiceByDateChanged.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_RefreshViewForAll.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sp_RefreshViewForAll]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_RefreshViewForAll]
GO

CREATE PROCEDURE [dbo].[sp_RefreshViewForAll]
@ViewName varchar(50)
AS
BEGIN
	DECLARE @UserName		varchar(128)
	DECLARE @UserID		smallint
	DECLARE @ViewFullName	varchar(128)

	DECLARE curSelectUser CURSOR FOR SELECT UID, Name FROM SYSUsers ORDER BY UID
	OPEN curSelectUser

	FETCH NEXT FROM curSelectUser INTO @UserID, @UserName

	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- 01.06.2012 kolbeshkin ищем все вьюхи не в SYSObjects (там не на всех юзеров), а в sysviews
		-- IF EXISTS (SELECT * FROM SYSObjects WHERE Name = @ViewName AND UID=@UserID AND XType='V')
		IF EXISTS (select 1 from sysviews where name like @ViewName and creator like @UserName)
		BEGIN
			SET @ViewFullName = @UserName + '.' + @ViewName
			if OBJECT_ID(@ViewFullName) is not null
				EXEC sp_refreshview @ViewFullName
		END

		FETCH NEXT FROM curSelectUser INTO @UserID, @UserName
	END

	CLOSE curSelectUser
	DEALLOCATE curSelectUser
END
GO

GRANT EXEC ON [dbo].[sp_RefreshViewForAll] TO PUBLIC
GO
/*********************************************************************/
/* end sp_RefreshViewForAll.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120424)_CreateTable_FixedDiscounts.sql */
/*********************************************************************/
-- CRM01262F1S6 kolbeshkin Создание таблицы Фиксированные комиссии
--<DATE>2012-04-24</DATE>
--<VERSION>2007.2.40.1</VERSION>
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[FixedDiscounts]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[FixedDiscounts](
	[FD_ID] [int] IDENTITY(1,1) NOT NULL,
	[FD_PGKey] [int] NULL,
	[FD_TPKey] [int] NULL,
	[FD_DepCTKey] [int] NULL,
	[FD_CNKey] [int] NULL,
	[FD_CTKey] [int] NULL,
	[FD_HDKey] [int] NULL,
	[FD_DaysBeforeCheckinMin] [int] NULL,
	[FD_CheckInFrom] [datetime] NULL,
	[FD_CheckInTo] [datetime] NULL,
	[FD_DurationFrom] [int] NULL,
	[FD_DurationTo] [int] NULL,
	[FD_Value] [int] NULL,
	[FD_CreateDate] [datetime] NULL
 CONSTRAINT [PK_FixedDiscounts] PRIMARY KEY CLUSTERED 
(
	[FD_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.FixedDiscounts TO PUBLIC

ALTER TABLE [dbo].[FixedDiscounts] ADD CONSTRAINT [FK_FixedDiscounts_PrtGroups] 
FOREIGN KEY([FD_PGKey]) REFERENCES [dbo].[PrtGroups] ([PG_KEY]) ON DELETE CASCADE

ALTER TABLE [dbo].[FixedDiscounts] ADD CONSTRAINT [FK_FixedDiscounts_TipTur] 
FOREIGN KEY([FD_TPKey]) REFERENCES [dbo].[TipTur] ([TP_KEY]) ON DELETE CASCADE

ALTER TABLE [dbo].[FixedDiscounts] ADD CONSTRAINT [FK_FixedDiscounts_tbl_Country] 
FOREIGN KEY([FD_CNKey]) REFERENCES [dbo].[tbl_Country] ([CN_KEY]) ON DELETE CASCADE

ALTER TABLE [dbo].[FixedDiscounts] ADD CONSTRAINT [FK_FixedDiscounts_CityDictionary] 
FOREIGN KEY([FD_CTKey]) REFERENCES [dbo].[CityDictionary] ([CT_KEY])

ALTER TABLE [dbo].[FixedDiscounts] ADD CONSTRAINT [FK_FixedDiscounts_HotelDictionary] 
FOREIGN KEY([FD_HDKey]) REFERENCES [dbo].[HotelDictionary] ([HD_KEY]) 

END
GO
/*********************************************************************/
/* end (20120424)_CreateTable_FixedDiscounts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CollapsePartnerUpdateSearchTables.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sp_CollapsePartnerUpdateSearchTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[sp_CollapsePartnerUpdateSearchTables]
GO

-- Обновляет партнера в поисковых таблицах на сервере, переданном в третьем параметре. 
-- Если параметр не указан - обновляет поисковые таблицы на всех серверах-подписчиках.
CREATE PROCEDURE [dbo].[sp_CollapsePartnerUpdateSearchTables]
(

--<VERSION>2007.2.40.1</VERSION>
--<DATE>17.05.2012</DATE>

--Ключ партнера, которого удаляем
	@fromPartnerKey int,
	
--Ключ партнера, на которого переносим записи
	@toPartnerKey int,

--Имена поисковых серверов через запятую
	@searchServerNames nvarchar(100) = null
	
) AS

BEGIN

	-- 1. получим базы-подписчики		
	create table #Subscribers
	(
		serverName nvarchar(50),
		databaseName nvarchar(50)
	)
	
	if exists(select top 1 1 from sys.tables
			where name = 'syssubscriptions')
	begin
	
		set @searchServerNames = ',' + @searchServerNames + ','
	
		insert into #Subscribers
		select distinct srvname as serverName, dest_db as databaseName
		from syssubscriptions where len(srvname) > 0
		and ((@searchServerNames is not null and @searchServerNames like '%,' + srvname + ',%')
				or @searchServerNames is null 
			)

	end
	else
	begin
	
		-- если нет репликации
		insert into #Subscribers
		select null as serverName, db_name() as databaseName
	
	end

	-- 2. update mwPriceDataTable
	declare @srvName as nvarchar(50)
	declare @databaseName as nvarchar(50)
	
	declare subscriptionCur cursor for
	select * from #Subscribers
	
	declare @rethrowError as bit
	set @rethrowError = 0
	
	declare @errMeg as nvarchar(250)
	
	begin try
	
		open subscriptionCur
		
		fetch next from subscriptionCur
		into @srvName, @databaseName
	
		-- пройдемся по каждому подписчику
		while @@fetch_status = 0
		begin
		
			declare @sourceName as nvarchar(150)	-- полноквалифицированное имя источника (без имени таблицы)
			declare @sourceNameWithoutSchema as nvarchar(150)
			declare @linkedServerName as nvarchar(50)
			
			if @srvName = @@SERVERNAME
			begin
				
				-- для избежания проблемы Loopback Linked Servers (http://msdn.microsoft.com/en-us/library/ms188716.aspx)
				set @sourceName = '[' + @databaseName + '].dbo'
				set @sourceNameWithoutSchema = '[' + @databaseName + ']'
			
			end
			else
			begin

				-- если это не текущий сервер, найдем linked-server
				if @srvName is not null
				begin
					declare @linkedServersTable table 
								(
									srv_name sysname, 
									SRV_PROVIDERNAME nvarchar(128),
									SRV_PRODUCT nvarchar(128),
									SRV_DATASOURCE nvarchar(4000),
									SRV_PROVIDERSTRING nvarchar(4000),
									SRV_LOCATION nvarchar(4000),
									SRV_CAT sysname null
								)
								
					insert into @linkedServersTable exec sp_linkedservers
					
					select top 1 @linkedServerName = srv_name from @linkedServersTable
					where SRV_DATASOURCE = @srvName
				end
				else
				begin
				
					set @linkedServerName = @@SERVERNAME
				
				end
			
				set @sourceName = '[' + @linkedServerName + '].[' + @databaseName + '].dbo'
				set @sourceNameWithoutSchema = '[' + @linkedServerName + '].[' + @databaseName + ']'
			
			end
			
			-- пройдемся по всем ценовым таблицам
			print @sourceNameWithoutSchema + ':'
			
			declare @sql as nvarchar(max)
			
			set @sql = '
			
				declare @errMeg as nvarchar(250)
			
				BEGIN TRY
							
					declare @rethrowError as bit
					set @rethrowError = 0
								
					declare @priceTableName as nvarchar(100)
				
					declare priceTableCursor cursor for
					select name from #sourceNameWithoutSchema.sys.tables
					where name like ''mwPriceDataTable%''
					
					open priceTableCursor
					
					fetch next from priceTableCursor into @priceTableName
					while @@fetch_status = 0
					begin 
					
						set @priceTableName = ''#sourceNameWithSchema.'' + @priceTableName 
						print @priceTableName
						
						declare @sql as nvarchar(max)
						
						-- само обновление полей
						set @sql = ''
								update '' + @priceTableName + ''
								set pt_hdpartnerkey = #toPartnerKey
								where pt_hdpartnerkey = #fromPartnerKey
								
								update '' + @priceTableName + ''
								set pt_chprkey = #toPartnerKey
								where pt_chprkey = #fromPartnerKey
								
								update '' + @priceTableName + ''
								set pt_chbackprkey = #toPartnerKey
								where pt_chbackprkey = #fromPartnerKey
									''
						
						exec (@sql)
					
						fetch next from priceTableCursor into @priceTableName
					
					end
				
				END TRY
				BEGIN CATCH
				
					set @errMeg = ''update subscriber ' +  @srvName +  ' error: '' + ERROR_MESSAGE()
					print @errMeg
					set @rethrowError = 1
				
				END CATCH
				
				close priceTableCursor
				deallocate priceTableCursor
				
				if @rethrowError = 1
				begin
					
					-- при обновлении таблиц произошла ошибка, поэтому
					-- после освобождения ресурсов отдадим её выше
					RAISERROR (@errMeg, 18, 100);
				
				end
			
			'
			
			-- замена спец. последовательностей на реальные значения
			set @sql = replace(@sql, '#sourceNameWithSchema', @sourceName)
			set @sql = replace(@sql, '#sourceNameWithoutSchema', @sourceNameWithoutSchema)
			set @sql = replace(@sql, '#toPartnerKey', @toPartnerKey)
			set @sql = replace(@sql, '#fromPartnerKey', @fromPartnerKey)
			
			--print @sql
			exec (@sql)
		
			fetch next from subscriptionCur
			into @srvName, @databaseName
		
		end
	
	end try
	begin catch
	
		set @errMeg = 'update subscripbers error: ' + ERROR_MESSAGE()
		set @rethrowError = 1
			
	end catch
	
	close subscriptionCur
	deallocate subscriptionCur
	
	drop table #Subscribers
	
	if @rethrowError = 1
	begin 
		-- при выполнении произошла ошибка, поэтому
		-- после освобождения ресурсов отдадим её выше
		RAISERROR (@errMeg, 18, 100);
	
	end

end

GRANT EXECUTE ON sp_CollapsePartnerUpdateSearchTables TO PUBLIC

GO

/*********************************************************************/
/* end sp_CollapsePartnerUpdateSearchTables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CollapsePartner.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sp_CollapsePartner]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[sp_CollapsePartner]
GO
-- Переносит данные с партнера, ключ которого передается в первый параметр
-- на партнера, ключ которого передается во второй параметр.
-- Удаляет партнера, ключ которого передается в первый параметр.
-- Обновляет партнера в поисковых таблицах на сервере, переданном в третьем параметре. 
-- Если параметр не указан - обновляет поисковые таблицы на всех серверах-подписчиках.
CREATE PROCEDURE [dbo].[sp_CollapsePartner]
(

--<VERSION>2007.2.40.1</VERSION>
--<DATE>17.05.2012</DATE>

--Ключ партнера, которого удаляем
	@fromPartnerKey int,
	
--Ключ партнера, на которого переносим записи
	@toPartnerKey int,
	
--Имена поисковых серверов через запятую
	@searchServerNames nvarchar(100) = null
	
) AS

BEGIN
	DECLARE @transactionName varchar(20)
	SET @transactionName = 'MyTransaction'
		
	BEGIN TRY
	
		BEGIN TRANSACTION @transactionName
		-- Переносим данные с первого партнера на второго
		-- Переносим квоты 
		print 'QuotaPriorities'
			update QuotaPriorities set QPR_PRKey = @toPartnerKey where QPR_PRKey = @fromPartnerKey	
			--update QuotaPriorities set QT_AGENT = @toPartnerKey where QT_AGENT = @fromPartnerKey
			
		print 'QuotaParts'
			update QuotaParts set QP_AgentKey = @toPartnerKey where QP_AgentKey = @fromPartnerKey	
			
		print 'Quotas'
			update Quotas set QT_PRKey = @toPartnerKey where QT_PRKey = @fromPartnerKey	
			
		-- Переносим discounts
		print 'Discounts'
			update Discounts set DS_PRKEY = @toPartnerKey where DS_PRKEY = @fromPartnerKey	
			
		-- Переносим dup_users
		print 'DUP_USER'
			update DUP_USER set US_PRKEY = @toPartnerKey where US_PRKEY = @fromPartnerKey	
			
		-- Переносим dogovors
		print '[tbl_Dogovorlist]'
			ALTER TABLE [dbo].[tbl_Dogovorlist] DISABLE TRIGGER [T_UpdateDogList] -- MEG00038742 07.12.2011 Kolbeshkin Отключим триггер на договорлисте, иначе поменяется статус услуг
			update tbl_dogovor set DG_PARTNERKEY = @toPartnerKey where DG_PARTNERKEY = @fromPartnerKey	
			update tbl_dogovor set DG_FilialKey = @toPartnerKey where DG_FilialKey = @fromPartnerKey
			ALTER TABLE [dbo].[tbl_Dogovorlist] ENABLE TRIGGER [T_UpdateDogList]	
			
		-- Переносим partner dogovors
		print 'PrtDogs'
			update PrtDogs set PD_PRKey = @toPartnerKey where PD_PRKey = @fromPartnerKey	
			update PrtDogs set PD_Abonent = @toPartnerKey where PD_Abonent = @fromPartnerKey
			
		-- Переносим partner warnings
		print 'PrtWarns'
			update PrtWarns set PW_PRKey = @toPartnerKey where PW_PRKey = @fromPartnerKey		
			
		-- Переносим price tours 
		print 'TP_Tours'
			update TP_Tours set TO_PRKey = @toPartnerKey where TO_PRKey = @fromPartnerKey	
			
		-- Переносим calls 
		print 'Calls'
			update Calls set CS_PrKey = @toPartnerKey where CS_PrKey = @fromPartnerKey	
			
		-- Переносим bills
		print 'Bills'
			update Bills set BL_PRKEY = @toPartnerKey where BL_PRKEY = @fromPartnerKey	
			
		-- Переносим costs
		print 'tbl_Costs'
			update tbl_Costs set CS_PRKEY = @toPartnerKey where CS_PRKEY = @fromPartnerKey	
			
		-- Переносим mappings
		print 'Mappings'
			update Mappings set MP_PRKey = @toPartnerKey where MP_PRKey = @fromPartnerKey	
			
		-- Переносим partner departments
		print 'PrtDeps'
			update PrtDeps set PDP_PRKey = @toPartnerKey where PDP_PRKey = @fromPartnerKey	
			
		-- Переносим profiles
		print 'Profiles'
			update Profiles set PF_PRKey = @toPartnerKey where PF_PRKey = @fromPartnerKey	
			
		-- Переносим report templates
		print 'reporttemplates'
			update reporttemplates set RT_PRKEY = @toPartnerKey where RT_PRKEY = @fromPartnerKey	
			
		-- Переносим service links
		print 'ServiceLink'
			update ServiceLink set LS_PRKEY = @toPartnerKey where LS_PRKEY = @fromPartnerKey	
			update ServiceLink set LS_PRKE2 = @toPartnerKey where LS_PRKE2 = @fromPartnerKey	
			
		-- Переносим tour service lists
		print 'TourServiceList'
			update TourServiceList set TO_PrKey = @toPartnerKey where TO_PrKey = @fromPartnerKey
			
		-- Переносим userlist
		print 'UserList'
			update UserList set US_PRKEY = @toPartnerKey where US_PRKEY = @fromPartnerKey
			
		-- Переносим visitors
		print 'Visitors'
			update Visitors set VS_PrKey = @toPartnerKey where VS_PrKey = @fromPartnerKey
			
		-- Переносим dogovorlists
		print '[tbl_Dogovorlist]'
			ALTER TABLE [dbo].[tbl_Dogovorlist] DISABLE TRIGGER [T_UpdateDogList] -- MEG00038742 07.12.2011 Kolbeshkin Отключим триггер на договорлисте, иначе поменяется статус услуг
			update tbl_DogovorList set DL_PARTNERKEY = @toPartnerKey where DL_PARTNERKEY = @fromPartnerKey
			ALTER TABLE [dbo].[tbl_Dogovorlist] ENABLE TRIGGER [T_UpdateDogList]	
			
		-- Переносим tur service
		print 'TurService'
			update TurService set TS_PARTNERKEY = @toPartnerKey where TS_PARTNERKEY = @fromPartnerKey
			
		-- Переносим payments
		print 'Payments'
			update Payments set PM_PRKey = @toPartnerKey where PM_PRKey = @fromPartnerKey	
			
		-- Переносим blank ranges
		print 'BlankRanges'
			update BlankRanges set BR_PRKEY = @toPartnerKey where BR_PRKEY = @fromPartnerKey	
			
		-- Переносим prt bonuses
		print 'PrtBonuses'
			update PrtBonuses set PB_PRKey = @toPartnerKey where PB_PRKey = @fromPartnerKey	
			
		-- Переносим ins borderaus
		print 'InsBordero'
			update InsBordero set IBR_PRKEY = @toPartnerKey where IBR_PRKEY = @fromPartnerKey	
			
		-- Переносим send mails
		print 'SendMail'
			update SendMail set SM_PRKEY = @toPartnerKey where SM_PRKEY = @fromPartnerKey	
			
		-- Переносим partner accounts
		print 'PrtAccounts'
			update PrtAccounts set PA_PRKey = @toPartnerKey where PA_PRKey = @fromPartnerKey	
			
		-- Переносим cost ships
		print 'COSTSSHIP'
			update COSTSSHIP set CS_PRKEY = @toPartnerKey where CS_PRKEY = @fromPartnerKey	
			
		-- Переносим ins policy
		print 'InsPolicy'
			update InsPolicy set IP_PRKey = @toPartnerKey where IP_PRKey = @fromPartnerKey	
			
		-- Переносим ins agents
		print 'InsAgents'
			update InsAgents set IAG_PRKEY = @toPartnerKey where IAG_PRKEY = @fromPartnerKey	
			update InsAgents set IAG_AGENTKEY = @toPartnerKey where IAG_AGENTKEY = @fromPartnerKey	
			
		-- Переносим prt types to partners (признаки партнера)
		print 'PrtTypesToPartners'
			update PrtTypesToPartners set PTP_PRKey = @toPartnerKey where PTP_PRKey = @fromPartnerKey 
			and not exists (select 1 from PrtTypesToPartners old where old.PTP_PRKey = @toPartnerKey and old.PTP_PTId = PTP_PTId)	
		
		-- 06.02.2012. MEG00038742. Golubinsky
		-- обновляем данные в таблицах TP 
		print 'TP_Services'
			update TP_Services set ts_oppartnerkey = @toPartnerKey where ts_oppartnerkey = @fromPartnerKey
			
		print 'tp_lists'
			update tp_lists set ti_hdpartnerkey = @toPartnerKey where ti_hdpartnerkey = @fromPartnerKey
			update tp_lists set ti_chprkey = @toPartnerKey where ti_chprkey = @fromPartnerKey
			update tp_lists set ti_chbackprkey = @toPartnerKey where ti_chbackprkey = @fromPartnerKey
			
		print 'tp_flights'
			update tp_flights set tf_prkeyold = @toPartnerKey where tf_prkeyold = @fromPartnerKey
			update tp_flights set tf_prkeynew = @toPartnerKey where tf_prkeynew = @fromPartnerKey
										
		-- Удаляем первого партнера
		print 'DELETE from tbl_Partners'
			delete from tbl_Partners where PR_KEY = @fromPartnerKey
						
		COMMIT TRANSACTION @transactionName
		
	END TRY	
	BEGIN CATCH
		SELECT 
			ERROR_NUMBER() AS ErrorNumber
			,ERROR_MESSAGE() AS ErrorMessage;
		ROLLBACK TRANSACTION @transactionName	 
	END CATCH


	BEGIN TRY
	
		-- обновляем данные на поисковых базах
		print 'sp_CollapsePartnerUpdateSearchTables'
			exec sp_CollapsePartnerUpdateSearchTables @fromPartnerKey, @toPartnerKey, @searchServerNames
	
	END TRY	
	BEGIN CATCH
		SELECT 
			ERROR_NUMBER() AS ErrorNumber
			,ERROR_MESSAGE() AS ErrorMessage;
	END CATCH		
	
END

GO

GRANT EXECUTE ON sp_CollapsePartner TO PUBLIC

GO

/*********************************************************************/
/* end sp_CollapsePartner.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120402)_CreateTable_SendPartnerStatuses.sql */
/*********************************************************************/
-- MEG00040573 Создание таблицы Статусы отправки партнеру
--<DATE>2012-04-02</DATE>
--<VERSION>2007.2.40.1</VERSION>
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SendPartnerStatuses]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[SendPartnerStatuses](
	[SPS_ID] [int] IDENTITY(0,1) NOT NULL,
	[SPS_Name] [nvarchar](250) NULL,
	[SPS_NameLat] [nvarchar](250) NULL
 CONSTRAINT [PK_SendPartnerStatuses] PRIMARY KEY CLUSTERED 
(
	[SPS_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.SendPartnerStatuses TO PUBLIC

INSERT INTO [dbo].[SendPartnerStatuses](SPS_Name,SPS_NameLat)
VALUES ('Не отправлено партнеру','Not sent to partner')

INSERT INTO [dbo].[SendPartnerStatuses](SPS_Name,SPS_NameLat)
VALUES ('Отправлено партнеру','Sent to partner')
END
GO


/*********************************************************************/
/* end (20120402)_CreateTable_SendPartnerStatuses.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_GetReservationProviderStatuses.sql */
/*********************************************************************/
/****** Object:  UserDefinedFunction [dbo].[GetReservationProviderStatuses]    Script Date: 03/23/2012 17:30:47 ******/
--<DATE>2012-04-02</DATE>
--<VERSION>2007.2.40.1</VERSION>
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetReservationProviderStatuses]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetReservationProviderStatuses]
GO
create function [dbo].[GetReservationProviderStatuses](@dgCode varchar(10)) 
 returns varchar(254)
as
begin
	declare @res varchar(254)
	set @res=(select distinct PS_NAME + ', ' as 'data()' 
		from DogovorList,ProviderStatuses 
		where DL_DGCOD=@dgCode and DL_SVKEY=3 and PS_KEY=DL_PROVIDERSTATUSEKEY
		for xml path(''))
	set @res = SUBSTRING(@res,0,LEN(@res))
	return @res
end
go
grant exec on [dbo].[GetReservationProviderStatuses] to public
go

/*********************************************************************/
/* end fn_GetReservationProviderStatuses.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_GetReservationIsSendPartner.sql */
/*********************************************************************/
/****** Object:  UserDefinedFunction [dbo].[GetReservationIsSendPartner]    Script Date: 03/23/2012 17:30:47 ******/
--<DATE>2012-04-02</DATE>
--<VERSION>2007.2.40.1</VERSION>
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetReservationIsSendPartner]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetReservationIsSendPartner]
GO
create function [dbo].[GetReservationIsSendPartner](@dgCode varchar(10)) 
	 returns varchar(254)
	as
begin
	declare @res varchar(254)
	if exists (select 1 from dbo.syscolumns 
	   where name = 'DL_ISSENDPARTNER' and id = OBJECT_ID('tbl_DogovorList') )
	begin
		set @res=(select distinct SPS_Name + ', '
			as 'data()' from DogovorList, SendPartnerStatuses
			where DL_DGCOD=@dgCode and DL_SVKEY=3 and ISNULL(DL_ISSENDPARTNER,0) = SPS_ID
			for xml path(''))
		set @res = SUBSTRING(@res,0,LEN(@res))
	end
	return @res
end
go
grant exec on [dbo].[GetReservationIsSendPartner] to public
go

/*********************************************************************/
/* end fn_GetReservationIsSendPartner.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120330)_AlterTable_tbl_Dogovorlist_AddColumn_DL_RejectComment.sql */
/*********************************************************************/
-- MEG00040573 Kolbeshkin добавление колонки "Отказ" в услуги
--<DATE>2012-04-02</DATE>
--<VERSION>2007.2.40.1</VERSION>
if not exists (select * from dbo.syscolumns where id = object_id(N'[dbo].[tbl_DogovorList]') and name = 'DL_RejectComment')
ALTER TABLE dbo.tbl_DogovorList ADD	DL_RejectComment varchar(254)
GO
exec sp_refreshviewforall 'DogovorList'
GO



/*********************************************************************/
/* end (20120330)_AlterTable_tbl_Dogovorlist_AddColumn_DL_RejectComment.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_SPOListResults.sql */
/*********************************************************************/
--<VERSION>2009.2</VERSION>
--<DATE>2012-06-21</DATE>

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SPOListResults]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SPOListResults]
GO

Create PROCEDURE [dbo].[SPOListResults] 
(
	@filter varchar(1024),
	@searchType varchar (10),
	@dateFrom varchar (10),
	@dateTo varchar (10),
	@top varchar(10)
)
AS
DECLARE @additionalQuery varchar (1024)

if (@searchType = 'SPO')
	BEGIN
		SET @additionalQuery = 'AND SD_TOURKEY IN (SELECT TO_KEY FROM TP_TOURS WITH(NOLOCK) WHERE (TO_ATTRIBUTE & 1) > 0)'
	END
else if (@searchType = 'Leader')
	BEGIN
		SET @additionalQuery = 'AND SD_TOURKEY IN (SELECT TO_KEY FROM TP_TOURS WITH(NOLOCK) WHERE (TO_ATTRIBUTE & 2) > 0)'
	END
else
	BEGIN
		SET @additionalQuery = 'AND SD_TOURKEY IN (SELECT TO_KEY FROM TP_TOURS WITH(NOLOCK) WHERE (TO_ATTRIBUTE & 3) > 0)'
	END

declare @source as varchar(100)
set @source = ''

if ([dbo].[mwReplIsSubscriber]()=1)
begin
	set @source = '[mt].' + ltrim(rtrim(dbo.mwReplPublisherDB()))+'.'
end

DECLARE @command varchar (8000)
SET @command =
'
CREATE TABLE #resultsTable (
	[createdate] [datetime],
	[tourname] [varchar] (128) COLLATE Cyrillic_General_CI_AS,
	[tourhttp] [varchar] (128) COLLATE Cyrillic_General_CI_AS,
	[resort] [varchar] (1024) COLLATE Cyrillic_General_CI_AS,
	[city] [varchar] (1024) COLLATE Cyrillic_General_CI_AS,
	[hotels] [varchar] (7000) COLLATE Cyrillic_General_CI_AS, 
	[tourdates] [varchar] (1024),
	[countryName] [varchar] (25) COLLATE Cyrillic_General_CI_AS,
	[countryNameLat] varchar (25),
	[countryKey] int, 
	[tourKey] int,
	[tourListKey] int,
	[minTourPrice] decimal,	-- минимальная цена тура
	[Rate] varchar(3)		-- валюта цены тура
) 

DECLARE @tourkey  int
DECLARE @hotelkey  int
DECLARE @tourdate datetime
DECLARE @resortkey  int
DECLARE @citykey  int
DECLARE @countrykey  int
DECLARE @createdate datetime
DECLARE @tourlistkey int

DECLARE @lastTourkey int
DECLARE @lastTourListKey int
DECLARE @lastHotelkey int
DECLARE @lastResortkey int
DECLARE @lastCountrykey int
DECLARE @lastCreateDate datetime
DECLARE @exit bit
DECLARE @resortKeys varchar(8000);
DECLARE @cityKeys varchar(8000);

DECLARE @hotelNames varchar (7000)
DECLARE @tourDates varchar (1024)
DECLARE @resorts varchar (1024)
DECLARE @cities varchar (1024)

SET @lastTourkey = -1
SET @lastHotelkey = -1
SET @lastResortkey = -1
SET @exit = 0
SET @resortKeys = ''''
SET @cityKeys = ''''

SELECT distinct top '+ @top +' sd_tourkey, SD_TOURCREATED into #tempSpoTable from MWSPoDataTable ' + @filter +' '+ @additionalQuery + ' ORDER BY SD_TOURCREATED DESC 

DECLARE SPO_Cursor CURSOR FOR
SELECT SD_TOURCREATED, SD_TOURKEY, SD_HDKEY, td_date, SD_RSKEY, SD_CTKEY, SD_CNKEY, SD_TLKEY
FROM MWSPoDataTable inner join tp_turdates on (sd_tourkey = td_tokey)
WHERE sd_tourkey in (select sd_tourkey from  #tempSpoTable) ORDER BY sd_CNKEY,sd_tourkey, sd_hdkey, sd_rskey

OPEN SPO_Cursor

if (@@CURSOR_ROWS > 0)
Begin'	
	set @command = replace(@command, '	', '')
		
	set @command = @command + '
FETCH NEXT FROM SPO_Cursor INTO @createdate, @tourkey, @hotelkey, @tourdate, @resortkey, @citykey, @countrykey, @tourlistkey
WHILE 1=1
BEGIN
    
    if (((@lastTourkey = -1) OR (@lastTourkey = @tourkey)) AND (@@FETCH_STATUS = 0))
	BEGIN
		--Отели
		IF (@lastHotelkey <> @hotelkey)
			BEGIN
				declare @hdName varchar (1024)
				declare @hdUrl varchar (1024)
				SELECT @hdName = (isnull (HD_NAME,'''') + '' '' + ltrim(rtrim(isnull(HD_STARS,'''')))), @hdUrl = isnull (HD_HTTP,'''') from hoteldictionary where HD_KEY = @hotelkey
				if (@lastTourkey = -1)
					BEGIN
						SET @hotelNames = @hdName + ''|'' + @hdUrl
					END
				else
					BEGIN
						SET @hotelNames = @hotelNames + '', '' + @hdName + ''|'' + @hdUrl
					END
				SET @lastHotelkey = @hotelkey
			END
		
		if (@lastTourkey = -1)
			BEGIN
				if (@resortkey is NULL)
					SET @resorts = ''нет''
			END
		
		IF (@resortkey is not null)
		BEGIN
			declare @rsName varchar (50)
			set @rsName = ''''						

			if (CHARINDEX(''|''+CAST(@resortkey as varchar)+''|'',@resortKeys) = 0)
			BEGIN
				SET @resortKeys = @resortKeys + ''|'' + CAST(@resortkey as varchar) +''|''
				SELECT @rsName = RS_NAME from resorts where RS_KEY = @resortkey				

				if (@lastTourkey = -1)
					BEGIN
						SET @resorts = @rsName
					END
				else
					BEGIN
						if @resortKey > 0 and len(@resorts) > 0 and @resorts != ''нет''
							set @resorts = @resorts + '',''
						if @resorts != ''нет''
							SET @resorts = @resorts + @rsName
						else
							SET @resorts = @rsName
					END
			END

		END'	
	set @command = replace(@command, '	', '')
		
	set @command = @command + '
		IF (@citykey is not null)
		BEGIN
			declare @ctName varchar (50)
														
			if (CHARINDEX(''|''+CAST(@citykey as varchar)+''|'',@cityKeys) = 0)
				BEGIN
					SET @cityKeys = @cityKeys + ''|'' + CAST(@citykey as varchar) +''|''
					SELECT @ctName = CT_NAME from citydictionary where CT_KEY = @citykey
					if (@lastTourkey = -1)
						BEGIN
							SET @cities = @ctName
						END
					else
						BEGIN
							SET @cities = @cities + '', '' + @ctName
					END
				END
	
		END

		SET @lastCountrykey = @countrykey
		SET @lastCreateDate = @createdate
		SET @lastTourListKey = @tourlistkey

	Set @lastResortKey = @resortkey
		
	END
    else
	BEGIN
		
		if @@FETCH_STATUS <> 0
			SET @exit = 1
		
		DECLARE @tourName varchar(128)
		DECLARE @tourHttp varchar(128)
		SELECT @tourName = TL_NAMEWEB, @tourHttp = TL_WEBHTTP from TURLIST where TL_KEY = @lastTourListKey
		
		DECLARE @countryName varchar(25)
		DECLARE @countryNameLat varchar(25)

		SELECT @countryName = CN_NAME, @countryNameLat = CN_NAMELAT FROM tbl_Country WHERE CN_KEY = @lastCountrykey
		
		DECLARE @currentDate dateTime
		DECLARE @lastDate dateTime
		DECLARE @lastWriteDate dateTime
		DECLARE @first int
		DECLARE @datesInInterval int

		SET @first = 0

		DECLARE SPODate_Cursor CURSOR FOR
		SELECT DISTINCT td_date FROM tp_turdates
		WHERE td_tokey = @lastTourkey AND td_date >= ''' + @dateFrom + ''' AND td_date <= ''' + @dateTo + '''  ORDER BY td_date
		
		OPEN SPODate_Cursor

		FETCH NEXT FROM SPODate_Cursor INTO @currentDate

		WHILE @@FETCH_STATUS = 0
			BEGIN
					
					if (@first = 0)
						BEGIN 
							SET @datesInInterval = 0
							SET @first = 1
							SET @lastWriteDate = @currentDate
							SET @tourDates = CONVERT (char(5),@currentDate, 4)
						END
					else
						BEGIN
							if (@currentDate <> DATEADD (day,1,@lastDate))
								BEGIN
									SET @datesInInterval = 0
									if (@lastWriteDate = @lastDate)
										SET @tourDates = @tourDates + '', '' + CONVERT (char(5),@currentDate, 4)
									else
										SET @tourDates = @tourDates + '' - '' + CONVERT (char(5),@lastDate, 4) + '', '' + CONVERT (char(5),@currentDate, 4)
									SET @lastWriteDate = @currentDate
								END
						END
						SET @datesInInterval = @datesInInterval + 1
						SET @lastDate = @currentDate
						FETCH NEXT FROM SPODate_Cursor INTO @currentDate
				
			END
		CLOSE SPODate_Cursor
		DEALLOCATE SPODate_Cursor'	
	set @command = replace(@command, '	', '')
		
	set @command = @command + '

		if (@lastWriteDate <> @currentDate)
			BEGIN
				if (@datesInInterval > 1)
					SET @tourDates = @tourDates + '' - '' + CONVERT (char(5),@currentDate, 4)
				else
					BEGIN
						if (@currentDate <> DATEADD (day,1,@lastWriteDate))
							SET @tourDates = @tourDates + '', '' + CONVERT (char(5),@currentDate, 4)
						else
							SET @tourDates = @tourDates + '' - '' + CONVERT (char(5),@currentDate, 4)
					END
			END

		if len(@resorts) = 0 
			set @resorts = ''нет'' 

		INSERT #resultsTable 
					([createdate] ,
					[tourname],
					[tourhttp],
					[resort],
					[city],
					[hotels],
					[tourdates],
					[countryName],
					[countryNameLat],
					[countryKey],
					[tourKey],
					[tourListKey])
		Values (@lastCreateDate, @tourName, @tourHttp, @resorts, @cities, @hotelNames, @tourDates, @countryName, @countryNameLat, @lastCountrykey,  @lastTourkey, @lastTourListKey)
		
		if (@exit = 1)
			BREAK
		
		if @lastResortKey = 0
			begin 
				set @resorts = ''''
				set @resortKeys = ''''
			end

		SELECT @hdName = (isnull (HD_NAME,'''') + '' '' + ltrim(rtrim(isnull(HD_STARS,'''')))), @hdUrl = isnull (HD_HTTP,'''') from hoteldictionary where HD_KEY = @hotelkey
		SET @hotelNames = @hdName + ''|'' + @hdUrl
		if (@resortkey is not NULL and @resortkey != 0)
			BEGIN
				SET @resortKeys = ''|'' + CAST (@resortkey as varchar) + ''|''
				SELECT @resorts = RS_NAME from resorts where RS_KEY = @resortkey				
			END
		else
			SET @resorts = ''нет''

		if (@cityKey is not NULL)
			BEGIN
				SET @cityKeys = ''|'' + CAST (@cityKey as varchar) + ''|''
				SELECT @cities = ct_NAME from citydictionary where ct_KEY = @cityKey
			END
		else
			SET @cities = ''нет''

		SET @lastHotelkey = @hotelkey
		SET @lastCountrykey = @countrykey
		SET @lastCreateDate = @createdate
		SET @lastTourListKey = @tourlistkey

		SET @lastResortKey = @resortkey
	
	END'	
	set @command = replace(@command, '	', '')
		
	set @command = @command + '
	
	SET @lastTourkey = @tourkey
	
	FETCH NEXT FROM SPO_Cursor INTO @createdate, @tourkey, @hotelkey, @tourdate, @resortkey, @citykey, @countrykey, @tourlistkey
END
end

CLOSE SPO_Cursor
DEALLOCATE SPO_Cursor

update #resultsTable 
set [minTourPrice] = TO_MinPrice,
[Rate] = TO_Rate
from tp_tours r
where r.to_key = [tourKey]

SELECT * FROM #resultsTable order by [countryName],[createdate]
DROP TABLE #tempSpoTable
DROP TABLE  #resultsTable'

set @command = REPLACE(@command, '#source', @source)
exec (@command)


go 

grant exec on SPOListResults to public 

go

/*********************************************************************/
/* end sp_SPOListResults.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120222)_Insert_ObjectAliases.sql */
/*********************************************************************/
-- MEG00038973 22.02.2012 Kolbeshkin добавление алиаса для записи в историю при ошибке в шаблоне отчетов
IF NOT EXISTS (SELECT 1 FROM ObjectAliases WHERE OA_Id=45)
INSERT INTO ObjectAliases (OA_Id,OA_Alias,OA_Name,OA_TABLEID) VALUES (45,'ErrorInReportTemplate','Ошибка в шаблоне при печати отчета',0)
GO
/*********************************************************************/
/* end (20120222)_Insert_ObjectAliases.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TuristUpdate.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_TuristUpdate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
drop trigger [dbo].[T_TuristUpdate]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

Create TRIGGER [dbo].[T_TuristUpdate]
ON [dbo].[tbl_Turist] 
FOR UPDATE, INSERT, DELETE
AS
--<DATE>2012-06-28</DATE>
--<VERSION>2009.2.14.1</VERSION>
IF @@ROWCOUNT > 0
BEGIN
    DECLARE @OTU_DGCod 		varchar(10)
    DECLARE @OTU_NameRus 		varchar(25)
    DECLARE @OTU_NameLat 		varchar(25)
    DECLARE @OTU_FNameRus 	varchar(15)
    DECLARE @OTU_FNameLat 		varchar(15)
    DECLARE @OTU_SNameRus 	varchar(15)
    DECLARE @OTU_SNameLat 		varchar(15)
    DECLARE @OTU_BirthDay 		varchar(10)
    DECLARE @OTU_PasportType 	varchar(10)
    DECLARE @OTU_PasportNum 	varchar(20)
    DECLARE @OTU_PaspRuSer 	varchar(10)
    DECLARE @OTU_PaspRuNum 	varchar(20)
    DECLARE @OTU_PasportDate 	varchar(10)
    DECLARE @OTU_PasportDateEnd 	varchar(10)
    DECLARE @OTU_PasportByWhoM 	varchar(20)
    DECLARE @OTU_PaspRuDate 	varchar(10)
    DECLARE @OTU_PaspRuByWhoM 	varchar(50)
    DECLARE @OTU_Sex 	int
    DECLARE @OTU_RealSex 	int
	DECLARE @OTU_DGKey		int
-- 
	DECLARE @OTU_BIRTHCOUNTRY varchar(25)
	DECLARE @OTU_BIRTHCITY varchar(25)
    DECLARE @OTU_CITIZEN varchar(50)
	DECLARE @OTU_POSTINDEX varchar(8)
	DECLARE @OTU_POSTCITY varchar(15)
	DECLARE @OTU_POSTSTREET varchar(25)
	DECLARE @OTU_POSTBILD varchar(6)
	DECLARE @OTU_POSTFLAT varchar(4)

	DECLARE @OTU_ISMAIN smallint
	DECLARE @OTU_PHONE varchar(30)
    
    DECLARE @NTU_DGCod 		varchar(10)
    DECLARE @NTU_NameRus 		varchar(25)
    DECLARE @NTU_NameLat 		varchar(25)
    DECLARE @NTU_FNameRus 	varchar(15)
    DECLARE @NTU_FNameLat 		varchar(15)
    DECLARE @NTU_SNameRus 	varchar(15)
    DECLARE @NTU_SNameLat 		varchar(15)
    DECLARE @NTU_BirthDay 		varchar(10)
    DECLARE @NTU_PasportType 	varchar(10)
    DECLARE @NTU_PasportNum 	varchar(20)
    DECLARE @NTU_PaspRuSer 	varchar(10)
    DECLARE @NTU_PaspRuNum 	varchar(20)
    DECLARE @NTU_PasportDate 	varchar(10)
    DECLARE @NTU_PasportDateEnd 	varchar(10)
    DECLARE @NTU_PasportByWhoM 	varchar(20)
    DECLARE @NTU_PaspRuDate 	varchar(10)
    DECLARE @NTU_PaspRuByWhoM 	varchar(50)
    DECLARE @NTU_Sex 	int
    DECLARE @NTU_RealSex 	int
	DECLARE @NTU_DGKey		int
--
	DECLARE @NTU_BIRTHCOUNTRY varchar(25)
	DECLARE @NTU_BIRTHCITY varchar(25)
    DECLARE @NTU_CITIZEN varchar(50)
	DECLARE @NTU_POSTINDEX varchar(8)
	DECLARE @NTU_POSTCITY varchar(15)
	DECLARE @NTU_POSTSTREET varchar(25)
	DECLARE @NTU_POSTBILD varchar(6)
	DECLARE @NTU_POSTFLAT varchar(4)

	DECLARE @NTU_ISMAIN smallint
	DECLARE @NTU_PHONE varchar(30)

	DECLARE @TU_Key int

	DECLARE @sTU_ShortName varchar(8)
	DECLARE @sMod varchar(3)
	DECLARE @nDelCount int
	DECLARE @nInsCount int
	DECLARE @nHIID int
	DECLARE @sHI_Text varchar(254)

	DECLARE @sText_Old varchar(254)
	DECLARE @sText_New varchar(254)
	DECLARE @bNeedCommunicationUpdate smallint
	DECLARE @nDGKey int
	DECLARE @sDGCod	varchar(10)

  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
    DECLARE cur_Turist CURSOR FOR 
      SELECT N.TU_Key, N.TU_ShortName,
			 N.TU_DGCod, N.TU_DGKey, null, null, null, null, 
	  	     null, null, null, null, null, null,
			 null, null, null, null, null, null,
			 null, null,
			 null, null, null, null,
			 null, null, null, null, null, null,
		  	 N.TU_DGCod, N.TU_DGKey, N.TU_NameRus, N.TU_NameLat, N.TU_FNameRus, N.TU_FNameLat,
			 N.TU_SNameRus, N.TU_SNameLat, CONVERT( char(10),N.TU_BirthDay, 104), N.TU_PasportType, N.TU_PasportNum, N.TU_PaspRuSer,
			 N.TU_PaspRuNum, CONVERT( char(10),N.TU_PasportDate, 104), CONVERT( char(10),N.TU_PasportDateEnd, 104), N.TU_PasportByWhoM, CONVERT( char(10),N.TU_PaspRuDate, 104), N.TU_PaspRuByWhoM,
			 N.TU_Sex, N.TU_RealSex, 
				N.TU_BIRTHCOUNTRY,
				N.TU_BIRTHCITY,
				N.TU_CITIZEN,
				N.TU_POSTINDEX,
				N.TU_POSTCITY,
				N.TU_POSTSTREET,
				N.TU_POSTBILD,
				N.TU_POSTFLAT,
				N.TU_ISMAIN,
				N.TU_PHONE
      FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
    DECLARE cur_Turist CURSOR FOR 
      SELECT O.TU_Key, O.TU_ShortName,
			 O.TU_DGCod, O.TU_DGKey, O.TU_NameRus, O.TU_NameLat, O.TU_FNameRus, O.TU_FNameLat,
			 O.TU_SNameRus, O.TU_SNameLat, CONVERT( char(10),O.TU_BirthDay, 104), O.TU_PasportType, O.TU_PasportNum, O.TU_PaspRuSer,
			 O.TU_PaspRuNum, CONVERT( char(10), O.TU_PasportDate, 104), CONVERT( char(10), O.TU_PasportDateEnd, 104), O.TU_PasportByWhoM, CONVERT( char(10), O.TU_PaspRuDate, 104), O.TU_PaspRuByWhoM, 
			 O.TU_Sex, O.TU_RealSex, 
				O.TU_BIRTHCOUNTRY,
				O.TU_BIRTHCITY,
				O.TU_CITIZEN,
				O.TU_POSTINDEX,
				O.TU_POSTCITY,
				O.TU_POSTSTREET,
				O.TU_POSTBILD,
				O.TU_POSTFLAT,
				O.TU_ISMAIN,
				O.TU_PHONE,
		  	 O.TU_DGCod, O.TU_DGKey, null, null, null, null,
			 null, null, null, null, null, null,
			 null, null, null, null, null, null,
			 null, null,
			 null, null, null, null,
			 null, null, null, null, null, null
      FROM DELETED O 
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
    DECLARE cur_Turist CURSOR FOR 
      SELECT N.TU_Key, N.TU_ShortName,
			 O.TU_DGCod, O.TU_DGKey, O.TU_NameRus, O.TU_NameLat, O.TU_FNameRus, O.TU_FNameLat,
			 O.TU_SNameRus, O.TU_SNameLat, CONVERT( char(10),O.TU_BirthDay, 104), O.TU_PasportType, O.TU_PasportNum, O.TU_PaspRuSer,
			 O.TU_PaspRuNum, CONVERT( char(10), O.TU_PasportDate, 104), CONVERT( char(10), O.TU_PasportDateEnd, 104), O.TU_PasportByWhoM, CONVERT( char(10), O.TU_PaspRuDate, 104), O.TU_PaspRuByWhoM, 
			 O.TU_Sex, O.TU_RealSex, 
				O.TU_BIRTHCOUNTRY,
				O.TU_BIRTHCITY,
				O.TU_CITIZEN,
				O.TU_POSTINDEX,
				O.TU_POSTCITY,
				O.TU_POSTSTREET,
				O.TU_POSTBILD,
				O.TU_POSTFLAT,
				O.TU_ISMAIN,
				O.TU_PHONE,
		  	 N.TU_DGCod, N.TU_DGKey, N.TU_NameRus, N.TU_NameLat, N.TU_FNameRus, N.TU_FNameLat, 
			 N.TU_SNameRus, N.TU_SNameLat, CONVERT( char(10),N.TU_BirthDay, 104), N.TU_PasportType, N.TU_PasportNum, N.TU_PaspRuSer,
			 N.TU_PaspRuNum, CONVERT( char(10),N.TU_PasportDate, 104), CONVERT( char(10),N.TU_PasportDateEnd, 104), N.TU_PasportByWhoM, CONVERT( char(10),N.TU_PaspRuDate, 104), N.TU_PaspRuByWhoM,
			 N.TU_Sex, N.TU_RealSex, 
				N.TU_BIRTHCOUNTRY,
				N.TU_BIRTHCITY,
				N.TU_CITIZEN,
				N.TU_POSTINDEX,
				N.TU_POSTCITY,
				N.TU_POSTSTREET,
				N.TU_POSTBILD,
				N.TU_POSTFLAT,
				N.TU_ISMAIN,
				N.TU_PHONE
      FROM DELETED O, INSERTED N 
      WHERE N.TU_Key = O.TU_Key
  END

  OPEN cur_Turist
    FETCH NEXT FROM cur_Turist INTO @TU_Key, @sTU_ShortName,
				@OTU_DGCod, @OTU_DGKey, @OTU_NameRus, @OTU_NameLat, @OTU_FNameRus, @OTU_FNameLat,
				@OTU_SNameRus, @OTU_SNameLat, @OTU_BirthDay, @OTU_PasportType, @OTU_PasportNum,	@OTU_PaspRuSer,
				@OTU_PaspRuNum, @OTU_PasportDate, @OTU_PasportDateEnd, @OTU_PasportByWhoM, @OTU_PaspRuDate, @OTU_PaspRuByWhoM, 
				@OTU_Sex, @OTU_RealSex, 
				@OTU_BIRTHCOUNTRY,
				@OTU_BIRTHCITY,
				@OTU_CITIZEN,
				@OTU_POSTINDEX,
				@OTU_POSTCITY,
				@OTU_POSTSTREET,
				@OTU_POSTBILD,
				@OTU_POSTFLAT,
				@OTU_ISMAIN,
				@OTU_PHONE,
				@NTU_DGCod, @NTU_DGKey, @NTU_NameRus, @NTU_NameLat,	@NTU_FNameRus, @NTU_FNameLat,
				@NTU_SNameRus, @NTU_SNameLat, @NTU_BirthDay, @NTU_PasportType, @NTU_PasportNum,	@NTU_PaspRuSer,
				@NTU_PaspRuNum, @NTU_PasportDate, @NTU_PasportDateEnd, @NTU_PasportByWhoM, @NTU_PaspRuDate, @NTU_PaspRuByWhoM,
				@NTU_Sex, @NTU_RealSex,
				@NTU_BIRTHCOUNTRY,
				@NTU_BIRTHCITY,
				@NTU_CITIZEN,
				@NTU_POSTINDEX,
				@NTU_POSTCITY,
				@NTU_POSTSTREET,
				@NTU_POSTBILD,
				@NTU_POSTFLAT,
				@NTU_ISMAIN,
				@NTU_PHONE
    WHILE @@FETCH_STATUS = 0
    BEGIN 
	  ------------Проверка, надо ли что-то писать в историю-------------------------------------------   
	  If ((((@sMod = 'UPD') AND (@OTU_DGCod = @NTU_DGCod)) OR (@sMod = 'INS') OR (@sMod = 'DEL')) AND
		(
			ISNULL(@OTU_NameRus, '') != ISNULL(@NTU_NameRus, '') OR
			ISNULL(@OTU_NameLat, '') != ISNULL(@NTU_NameLat, '') OR
			ISNULL(@OTU_FNameRus, '') != ISNULL(@NTU_FNameRus, '') OR
			ISNULL(@OTU_FNameLat, '') != ISNULL(@NTU_FNameLat, '') OR
			ISNULL(@OTU_SNameRus, '') != ISNULL(@NTU_SNameRus, '') OR
			ISNULL(@OTU_SNameLat, '') != ISNULL(@NTU_SNameLat, '') OR
			ISNULL(@OTU_BirthDay, 0) != ISNULL(@NTU_BirthDay, 0) OR
			ISNULL(@OTU_PasportType, 0) != ISNULL(@NTU_PasportType, 0) OR
			ISNULL(@OTU_PasportNum, 0) != ISNULL(@NTU_PasportNum, 0) OR
			ISNULL(@OTU_PaspRuSer, 0) != ISNULL(@NTU_PaspRuSer, 0) OR
			ISNULL(@OTU_PaspRuNum, 0) != ISNULL(@NTU_PaspRuNum, 0) OR
			ISNULL(@OTU_PasportDate, 0) != ISNULL(@NTU_PasportDate, 0) OR
			ISNULL(@OTU_PasportDateEnd, 0) != ISNULL(@NTU_PasportDateEnd, 0) OR
			ISNULL(@OTU_PasportByWhoM, 0) != ISNULL(@NTU_PasportByWhoM, 0) OR
			ISNULL(@OTU_PaspRuDate, 0) != ISNULL(@NTU_PaspRuDate, 0) OR
			ISNULL(@OTU_PaspRuByWhoM, 0) != ISNULL(@NTU_PaspRuByWhoM, 0)  OR
			ISNULL(@OTU_Sex, 0) != ISNULL(@NTU_Sex, 0)  OR
			ISNULL(@OTU_RealSex, 0) != ISNULL(@NTU_RealSex, 0) OR
--
			ISNULL(@OTU_BIRTHCOUNTRY, '') != ISNULL(@NTU_BIRTHCOUNTRY, '') OR
			ISNULL(@OTU_BIRTHCITY, '') != ISNULL(@NTU_BIRTHCITY, '') OR
			ISNULL(@OTU_CITIZEN, '') != ISNULL(@NTU_CITIZEN, '') OR
			ISNULL(@OTU_POSTINDEX, '') != ISNULL(@NTU_POSTINDEX, '') OR
			ISNULL(@OTU_POSTCITY, '') != ISNULL(@NTU_POSTCITY, '') OR
			ISNULL(@OTU_POSTSTREET, '') != ISNULL(@NTU_POSTSTREET, '') OR
			ISNULL(@OTU_POSTBILD, '') != ISNULL(@NTU_POSTBILD, '') OR
			ISNULL(@OTU_POSTFLAT, '') != ISNULL(@NTU_POSTFLAT, '') OR
			ISNULL(@OTU_ISMAIN, 0) != ISNULL(@NTU_ISMAIN, 0)
		))
	  BEGIN
	  	------------Запись в историю--------------------------------------------------------------------
		
		SET @nDGKey=@NTU_DGKey
		SET @sHI_Text = ISNULL(@NTU_NameRus, '') + ' ' + ISNULL(@sTU_ShortName, '')
		SET @sDGCod=@NTU_DGCod
		if (@sMod = 'DEL')
		BEGIN
			SET @nDGKey=@OTU_DGKey
			SET @sHI_Text = ISNULL(@OTU_NameRus, '') + ' ' + ISNULL(@sTU_ShortName, '')
			SET @sDGCod=@OTU_DGCod
		END
		EXEC @nHIID = dbo.InsHistory @sDGCod, @nDGKey, 3, @TU_Key, @sMod, @sHI_Text, '', 0, ''
		--SELECT @nHIID = IDENT_CURRENT('History')
		--------Детализация--------------------------------------------------
		if (ISNULL(@OTU_NameRus, '') != ISNULL(@NTU_NameRus, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1051, @OTU_NameRus, @NTU_NameRus, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_NameLat, '') != ISNULL(@NTU_NameLat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1052, @OTU_NameLat, @NTU_NameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_FNameRus, '') != ISNULL(@NTU_FNameRus, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1053, @OTU_FNameRus, @NTU_FNameRus, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_FNameLat, '') != ISNULL(@NTU_FNameLat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1054, @OTU_FNameLat, @NTU_FNameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_SNameRus, '') != ISNULL(@NTU_SNameRus, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1055, @OTU_SNameRus, @NTU_SNameRus, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_SNameLat, '') != ISNULL(@NTU_SNameLat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1056, @OTU_SNameLat, @NTU_SNameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_BirthDay, 0) != ISNULL(@NTU_BirthDay, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1057, @OTU_BirthDay, @NTU_BirthDay, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportType, '') != ISNULL(@NTU_PasportType, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1058, @OTU_PasportType, @NTU_PasportType, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportNum, '') != ISNULL(@NTU_PasportNum, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1059, @OTU_PasportNum, @NTU_PasportNum, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuSer, '') != ISNULL(@NTU_PaspRuSer, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1060, @OTU_PaspRuSer, @NTU_PaspRuSer, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuNum, '') != ISNULL(@NTU_PaspRuNum, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1061, @OTU_PaspRuNum, @NTU_PaspRuNum, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportDate, 0) != ISNULL(@NTU_PasportDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1062, @OTU_PasportDate, @NTU_PasportDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportDateEnd, 0) != ISNULL(@NTU_PasportDateEnd, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1063, @OTU_PasportDateEnd, @NTU_PasportDateEnd, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportByWhoM, '') != ISNULL(@NTU_PasportByWhoM, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1064, @OTU_PasportByWhoM, @NTU_PasportByWhoM, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuDate, 0) != ISNULL(@NTU_PaspRuDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1065, @OTU_PaspRuDate, @NTU_PaspRuDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuByWhoM, '') != ISNULL(@NTU_PaspRuByWhoM, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1066, @OTU_PaspRuByWhoM, @NTU_PaspRuByWhoM, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_Sex, 0) != ISNULL(@NTU_Sex, 0))
			BEGIN
				IF not ((ISNULL(@OTU_Sex, 0) = 1 and ISNULL(@NTU_Sex, 0) = 0) or (ISNULL(@OTU_Sex, 0) = 0 and ISNULL(@NTU_Sex, 0) = 1))
				BEGIN
					IF @sMod != 'INS'
						SELECT @sText_Old = CASE ISNULL(@OTU_Sex, 0)
								WHEN 0 THEN 'Adult'
								WHEN 1 THEN 'Adult'
								WHEN 2 THEN 'Child'
								WHEN 3 THEN 'Infant'
								END
					ELSE
						SET @sText_Old = ''
					IF @sMod != 'DEL'
						SELECT @sText_New = CASE ISNULL(@NTU_Sex, 0)
								WHEN 0 THEN 'Adult'
								WHEN 1 THEN 'Adult'
								WHEN 2 THEN 'Child'
								WHEN 3 THEN 'Infant'
								END
					ELSE
						SET @sText_New = ''
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1067, @sText_Old, @sText_New, @OTU_Sex, @NTU_Sex, null, null, 0, @bNeedCommunicationUpdate output
				END
			END
		if (ISNULL(@OTU_RealSex, 0) != ISNULL(@NTU_RealSex, 0))
		BEGIN
				IF @sMod != 'INS'
					SELECT @sText_Old = CASE ISNULL(@OTU_RealSex, 0)
							WHEN 0 THEN 'Male'
							WHEN 1 THEN 'Female'
							END
				ELSE
					Set @sText_Old = ''
				IF @sMod != 'DEL'
					SELECT @sText_New = CASE ISNULL(@NTU_RealSex, 0)
							WHEN 0 THEN 'Male'
							WHEN 1 THEN 'Female'
							END
				ELSE
					Set	@sText_New = ''
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1068, @sText_Old, @sText_New, @OTU_RealSex, @NTU_RealSex, null, null, 0, @bNeedCommunicationUpdate output
		END

		if (ISNULL(@OTU_BIRTHCOUNTRY, '') != ISNULL(@NTU_BIRTHCOUNTRY, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1126, @OTU_BIRTHCOUNTRY, @NTU_BIRTHCOUNTRY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_BIRTHCITY, '') != ISNULL(@NTU_BIRTHCITY, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1127, @OTU_BIRTHCITY, @NTU_BIRTHCITY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_CITIZEN, '') != ISNULL(@NTU_CITIZEN, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1128, @OTU_CITIZEN, @NTU_CITIZEN, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTINDEX, '') != ISNULL(@NTU_POSTINDEX, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1129, @OTU_POSTINDEX, @NTU_POSTINDEX, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTCITY, '') != ISNULL(@NTU_POSTCITY, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1130, @OTU_POSTCITY, @NTU_POSTCITY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTSTREET, '') != ISNULL(@NTU_POSTSTREET, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1131, @OTU_POSTSTREET, @NTU_POSTSTREET, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTBILD, '') != ISNULL(@NTU_POSTBILD, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1132, @OTU_POSTBILD, @NTU_POSTBILD, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTFLAT, '') != ISNULL(@NTU_POSTFLAT, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1133, @OTU_POSTFLAT, @NTU_POSTFLAT, null, null, null, null, 0, @bNeedCommunicationUpdate output
		-- 
		DECLARE @PrivatePerson int;
		------- CRM02174G8K3 28.06.2012 kolbeshkin: будем проверять DG_DUPUSERKEY, если он уже проставлен, то покупателя не меняем,
		-- иначе в покупателе представитель партнера (DupUser) затрется главным туристом
		DECLARE @dgDupUserKey int
		SELECT @dgDupUserKey = DG_DUPUSERKEY FROM tbl_Dogovor WHERE DG_Key = @NTU_DGKey
		-------
		IF (@sMod = 'UPD')
		BEGIN
			IF(ISNULL(@NTU_ISMAIN,0) = 1 AND ISNULL(@dgDupUserKey,0) = 0)
			BEGIN
				EXEC @PrivatePerson = dbo.CheckPrivatePerson @NTU_DGCOD;
				IF(@PrivatePerson = 1)
				BEGIN
					EXEC [dbo].[UpdateReservationMainManByTourist] @NTU_NAMERUS, @NTU_FNAMERUS, @NTU_SNAMERUS, @NTU_PHONE
																 , @NTU_POSTINDEX, @NTU_POSTCITY, @NTU_POSTSTREET
																 , @NTU_POSTBILD, @NTU_POSTFLAT, @NTU_PASPRUSER
																 , @NTU_PASPRUNUM, @NTU_DGCOD;
				END
			END
		END
		ELSE IF (@sMod = 'DEL')
		BEGIN
			DECLARE @NewMainTourist int;
			SELECT @NewMainTourist = TU_KEY 
			  FROM [dbo].[TBL_TURIST]
			 WHERE TU_KEY <> @TU_Key AND TU_SEX < 2 AND TU_DGCOD = @OTU_DGCOD;
			IF(@NewMainTourist IS NULL)
			BEGIN
				SELECT @NewMainTourist = TU_KEY 
				  FROM [dbo].[TBL_TURIST]
				 WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @OTU_DGCOD;
			END
			IF(@NewMainTourist IS NOT NULL)
			BEGIN
				UPDATE [dbo].[TBL_TURIST]
				   SET TU_ISMAIN = 1
				 WHERE TU_KEY = @NewMainTourist;
				 IF  (ISNULL(@dgDupUserKey,0) = 0)
				 BEGIN
					EXEC @PrivatePerson = dbo.CheckPrivatePerson @OTU_DGCOD;
					IF(@PrivatePerson = 1)
					BEGIN
						DECLARE @Name varchar(35),
								@FName varchar(15),
								@SName varchar(15),
								@Phone varchar(60),
								@PostIndex varchar(8),
								@PostCity varchar(60),
								@PostStreet varchar(25),
								@PostBuilding varchar(10),
								@PostFlat varchar(4),
								@PassportSeries varchar(10),
								@PassportNumber varchar(10);
						SELECT @Name = TU_NAMERUS, @FName = TU_FNAMERUS, @SName = TU_SNAMERUS, @Phone = TU_PHONE
							 , @PostIndex = TU_POSTINDEX, @PostCity = TU_POSTCITY, @PostStreet = TU_POSTSTREET
							 , @PostBuilding = TU_POSTBILD, @PostFlat = TU_POSTFLAT, @PassportSeries = TU_PASPRUSER
							 , @PassportNumber = TU_PASPRUNUM
						  FROM [dbo].[tbl_turist]
						 WHERE TU_KEY = @NewMainTourist;
						EXEC [dbo].[UpdateReservationMainManByTourist] @Name, @FName, @SName, @Phone
																	 , @PostIndex, @PostCity, @PostStreet
																	 , @PostBuilding, @PostFlat, @PassportSeries
																	 , @PassportNumber, @OTU_DGCOD;
					END
					ELSE
					BEGIN
						EXEC [dbo].[UpdateReservationMainMan] '','','','',@OTU_DGCOD;
					END
				END
			END
		END
		ELSE IF(@sMod = 'INS')
		BEGIN
			DECLARE @HaveMainMan int, @MainManSex int;
			SELECT @HaveMainMan = TU_KEY, @MainManSex = TU_SEX
			  FROM [dbo].[TBL_TURIST]
			 WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @NTU_DGCOD AND TU_ISMAIN = 1
			IF(@HaveMainMan IS NULL OR ((ISNULL(@MainManSex,0) >= 2) AND ISNULL(@NTU_SEX,99) < 2 AND ISNULL(@NTU_ISMAIN,0) = 1))
			BEGIN
				IF(@HaveMainMan IS NULL)
				BEGIN
					UPDATE [dbo].[TBL_TURIST]
					   SET TU_ISMAIN = 1
					 WHERE TU_KEY = @TU_Key;
				END
				ELSE
				BEGIN
					UPDATE [dbo].[TBL_TURIST]
					   SET TU_ISMAIN = 0
					 WHERE TU_KEY = @HaveMainMan;
				END
				IF (ISNULL(@dgDupUserKey,0) = 0)
				BEGIN
					EXEC @PrivatePerson = dbo.CheckPrivatePerson @NTU_DGCOD;
					IF(@PrivatePerson = 1)
					BEGIN
						EXEC [dbo].[UpdateReservationMainManByTourist] @NTU_NAMERUS, @NTU_FNAMERUS, @NTU_SNAMERUS, @NTU_PHONE
																	 , @NTU_POSTINDEX, @NTU_POSTCITY, @NTU_POSTSTREET
																	 , @NTU_POSTBILD, @NTU_POSTFLAT, @NTU_PASPRUSER
																	 , @NTU_PASPRUNUM, @NTU_DGCOD;
					END
				END
			END
			ELSE IF(@HaveMainMan IS NOT NULL AND ISNULL(@NTU_ISMAIN,0) = 1)
			BEGIN
				UPDATE [dbo].[TBL_TURIST]
				   SET TU_ISMAIN = 0
				 WHERE TU_KEY = @HaveMainMan; 
				 IF (ISNULL(@dgDupUserKey,0) = 0)
				 BEGIN
					EXEC @PrivatePerson = dbo.CheckPrivatePerson @NTU_DGCOD;
					IF(@PrivatePerson = 1)
					BEGIN
						EXEC [dbo].[UpdateReservationMainManByTourist] @NTU_NAMERUS, @NTU_FNAMERUS, @NTU_SNAMERUS, @NTU_PHONE
																	 , @NTU_POSTINDEX, @NTU_POSTCITY, @NTU_POSTSTREET
																	 , @NTU_POSTBILD, @NTU_POSTFLAT, @NTU_PASPRUSER
																	 , @NTU_PASPRUNUM, @NTU_DGCOD; 
					END
				END
			END
		END
		
		If @bNeedCommunicationUpdate=1
			If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey)
				UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@nDGKey

	  ------------------------------------------------------------------------------------------------
	  END
    FETCH NEXT FROM cur_Turist INTO @TU_Key, @sTU_ShortName,
				@OTU_DGCod, @OTU_DGKey, @OTU_NameRus, @OTU_NameLat, @OTU_FNameRus, @OTU_FNameLat,
				@OTU_SNameRus, @OTU_SNameLat, @OTU_BirthDay, @OTU_PasportType, @OTU_PasportNum,	@OTU_PaspRuSer,
				@OTU_PaspRuNum, @OTU_PasportDate, @OTU_PasportDateEnd, @OTU_PasportByWhoM, @OTU_PaspRuDate, @OTU_PaspRuByWhoM, 
				@OTU_Sex, @OTU_RealSex, 
				@OTU_BIRTHCOUNTRY,
				@OTU_BIRTHCITY,
				@OTU_CITIZEN,
				@OTU_POSTINDEX,
				@OTU_POSTCITY,
				@OTU_POSTSTREET,
				@OTU_POSTBILD,
				@OTU_POSTFLAT,
				@OTU_ISMAIN,
				@OTU_PHONE,
				@NTU_DGCod, @NTU_DGKey, @NTU_NameRus, @NTU_NameLat,	@NTU_FNameRus, @NTU_FNameLat,
				@NTU_SNameRus, @NTU_SNameLat, @NTU_BirthDay, @NTU_PasportType, @NTU_PasportNum,	@NTU_PaspRuSer,
				@NTU_PaspRuNum, @NTU_PasportDate, @NTU_PasportDateEnd, @NTU_PasportByWhoM, @NTU_PaspRuDate, @NTU_PaspRuByWhoM,
				@NTU_Sex, @NTU_RealSex,
				@NTU_BIRTHCOUNTRY,
				@NTU_BIRTHCITY,
				@NTU_CITIZEN,
				@NTU_POSTINDEX,
				@NTU_POSTCITY,
				@NTU_POSTSTREET,
				@NTU_POSTBILD,
				@NTU_POSTFLAT,
				@NTU_ISMAIN,
				@NTU_PHONE
    END
  CLOSE cur_Turist
  DEALLOCATE cur_Turist
END
GO
/*********************************************************************/
/* end T_TuristUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_UpdDogListQuota.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_UpdDogListQuota]'))
DROP TRIGGER [dbo].[T_UpdDogListQuota]
GO
CREATE TRIGGER [dbo].[T_UpdDogListQuota] 
ON [dbo].[tbl_DogovorList]
AFTER INSERT, UPDATE, DELETE
AS
--<VERSION>2008.1.01.12a</VERSION>
-- inserting into roomnumberlists , servicebydate
DECLARE @DLKey int, @DGKey int, @O_DLSVKey int, @O_DLCode int, @O_DLSubcode1 int, @O_DLDateBeg datetime, @O_DLDateEnd datetime, @O_DLNMen int, @O_DLPartnerKey int, @O_DLControl int, 
		@N_DLSVKey int, @N_DLCode int, @N_DLSubcode1 int, @N_DLDateBeg datetime, @N_DLDateEnd datetime, @N_DLNMen int, @N_DLPartnerKey int, @N_DLControl int,
		@Date datetime, @RLID int, @RPID int,
		@HRIsMain smallint, @RMKey int, @RCKey int, @ACKey int,
		@RMPlacesMain smallint, @RMPlacesEx smallint,
		@ACPlacesMain smallint, @ACPlacesEx smallint, @ACPerRoom smallint,
		@RLPlacesMain smallint, @RLPlacesEx smallint, @RLCount smallint, 
		@AC_FreeMainPlacesCount smallint, @AC_FreeExPlacesCount smallint,
		@RL_Use smallint, @From int, --@SDPlace smallint, 
		@nDelCount smallint, @nInsCount smallint, @Mod varchar(3), @SetToNewQuota bit,
		@CurrentPlaceIsEx bit, @RL_FreeMainPlacesCount smallint, @RL_FreeExPlacesCount smallint,
		@Days smallint, @RPCount smallint, @NeedPlacesForMen smallint, @TUKey int,
		@SVQUOTED smallint

SELECT @nDelCount = COUNT(*) FROM DELETED
SELECT @nInsCount = COUNT(*) FROM INSERTED
SET @SetToNewQuota = 0
IF (@nInsCount = 0)
BEGIN
    DECLARE cur_DogovorListChanged2 CURSOR FOR 
    SELECT 	O.DL_Key, O.DL_DGKey,
			O.DL_SvKey, O.DL_Code, O.DL_SubCode1, O.DL_DateBeg, O.DL_DateEnd, O.DL_NMen, O.DL_PartnerKey, O.DL_Control, 
			null, null, null, null, null, null, null, null
    FROM DELETED O
	SET @Mod = 'DEL'
END
ELSE IF (@nDelCount = 0)
BEGIN
    DECLARE cur_DogovorListChanged2 CURSOR FOR 
    SELECT 	N.DL_Key, N.DL_DGKey,
			null, null, null, null, null, null, null, null,
			N.DL_SvKey, N.DL_Code, N.DL_SubCode1, N.DL_DateBeg, N.DL_DateEnd, N.DL_NMen, N.DL_PartnerKey, N.DL_Control
    FROM	INSERTED N 
	SET @Mod = 'INS'
END
ELSE 
BEGIN
    DECLARE cur_DogovorListChanged2 CURSOR FOR 
    SELECT 	N.DL_Key, N.DL_DGKey, 
			O.DL_SvKey, O.DL_Code, O.DL_SubCode1, O.DL_DateBeg, O.DL_DateEnd, O.DL_NMen, O.DL_PartnerKey, O.DL_Control, 
			N.DL_SvKey, N.DL_Code, N.DL_SubCode1, N.DL_DateBeg, N.DL_DateEnd, N.DL_NMen, N.DL_PartnerKey, N.DL_Control
    FROM DELETED O, INSERTED N 
    WHERE N.DL_Key = O.DL_Key
	SET @Mod = 'UPD'
END

OPEN cur_DogovorListChanged2
FETCH NEXT FROM cur_DogovorListChanged2 
	INTO	@DLKey, @DGKey,
			@O_DLSVKey, @O_DLCode, @O_DLSubCode1, @O_DLDateBeg, @O_DLDateEnd, @O_DLNMen, @O_DLPartnerKey, @O_DLControl, 
			@N_DLSVKey, @N_DLCode, @N_DLSubCode1, @N_DLDateBeg, @N_DLDateEnd, @N_DLNMen, @N_DLPartnerKey, @N_DLControl
WHILE @@FETCH_STATUS = 0
BEGIN

	SELECT @SVQUOTED=isnull(SV_Quoted,0) from service where sv_key=@N_DLSVKey

	EXEC InsMasterEvent 3, @DLKey
	IF ((@O_DLSVKey in (3,7)) and ((@N_DLCode!=@O_DLCode) or (@N_DLSubCode1!=@O_DLSubCode1) or (@O_DLDateBeg!=@N_DLDateBeg) or (@O_DLDateEnd!=@N_DLDateEnd)))
		or ((@O_DLSVKey in (1,2,4)) and (@O_DLDateBeg!=@N_DLDateBeg))
		update turistservice set tu_numroom='' where tu_dlkey=@DLKey

	IF @N_DLDateBeg < '01-JAN-1901' and @O_DLDateBeg >= '01-JAN-1901'
		SET @Mod='DEL'
	IF @N_DLDateBeg > '01-JAN-1901' and @O_DLDateBeg <= '01-JAN-1901'
		SET @SetToNewQuota=1
		--SET @Mod='INS'
		/*select @rlid=sd_rlid from servicebydate where sd_dlkey=@dlkey
		delete from roomnumberlists where rl_id=@rlid
		delete from servicebydate where sd_dlkey=@dlkey*/
	IF @Mod='UPD' and ISNULL(@O_DLNMen,0)=0 and ISNULL(@N_DLNMen,0)>0
		SET @Mod='INS'
	IF @Mod='DEL' or (@Mod='UPD' and 
		(ISNULL(@O_DLSVKey,0) != ISNULL(@N_DLSVKey,0)) or (ISNULL(@O_DLCode,0) != ISNULL(@N_DLCode,0)) 
		or (ISNULL(@O_DLSubCode1,0) != ISNULL(@N_DLSubCode1,0)) or (ISNULL(@O_DLPartnerKey,0) != ISNULL(@N_DLPartnerKey,0)) )
	BEGIN	
		DELETE FROM ServiceByDate WHERE SD_DLKey=@DLKey
		SET @SetToNewQuota=1
	END

	--изменился период действия услуги
	IF @Mod='UPD' and (@SetToNewQuota!=1 and ((@O_DLDateBeg != @N_DLDateBeg) or (@O_DLDateEnd != @N_DLDateEnd)))
	BEGIN
		IF @N_DLDateBeg>@O_DLDateEnd OR @N_DLDateEnd<@O_DLDateBeg
		BEGIN
			DELETE FROM ServiceByDate WHERE SD_DLKey=@DLKey
			SET @SetToNewQuota=1
		END
		ELSE --для услуг имеющих продолжительность сохраняем информацию о квотировании в рамках периода
		BEGIN
			--если теперь услуга заканчивается раньше, чем до этого начиналась
			IF @N_DLDateBeg < @O_DLDateBeg
			BEGIN
				IF @N_DLDateEnd<@O_DLDateBeg
					Set @Days=DATEDIFF(DAY,@N_DLDateBeg,@N_DLDateEnd)+1
				ELSE
					Set @Days=DATEDIFF(DAY,@N_DLDateBeg,@O_DLDateBeg)
					
				INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, SD_State)
				SELECT DATEADD(DAY,NU_ID-1,@N_DLDateBeg), SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, @SVQUOTED + 3 
				FROM ServiceByDate, Numbers
				WHERE (NU_ID between 1 and @Days) and SD_Date=@O_DLDateBeg and SD_DLKey=@DLKey
			END
			
			--если теперь услуга начинается позже, чем до этого заканчивалась
			IF @N_DLDateEnd > @O_DLDateEnd
			BEGIN
				IF @N_DLDateBeg>@O_DLDateEnd
					Set @Days=DATEDIFF(DAY,@N_DLDateBeg,@N_DLDateEnd)+1
				ELSE
					Set @Days=DATEDIFF(DAY,@O_DLDateEnd,@N_DLDateEnd)
					
				INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, SD_State)
				SELECT DATEADD(DAY,-NU_ID+1,@N_DLDateEnd), SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, @SVQUOTED + 3 
				FROM ServiceByDate, Numbers
				WHERE (NU_ID between 1 and @Days) and SD_Date=@O_DLDateEnd and SD_DLKey=@DLKey
			END
			
			
			IF @N_DLDateBeg>@O_DLDateBeg
				DELETE FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_Date < @N_DLDateBeg
			IF @N_DLDateEnd<@O_DLDateEnd
				DELETE FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_Date > @N_DLDateEnd
		END
		
		-- если эта услуга на продолжительность
		if exists (select 1 from [Service] where SV_Key = @N_DLSVKey and isnull(SV_IsDuration,0) = 1)
		and exists(select 1 -- если услуга сидела на квоте с продолжительностью
						from ServiceByDate 
						where SD_DLKey = @DLKey 
						and exists (select 1 
									from QuotaParts
									where QP_ID = SD_QPID
									and QP_Durations is not null))
		begin
			--то пересаживаем всю услугу
			EXEC DogListToQuotas @DLKey, null, null, null, null, @N_DLDateBeg, @N_DLDateEnd, null, null
		end
	END
	SET @NeedPlacesForMen=0
	SET @From = CAST(@N_DLDateBeg as int)
	--изменилось количество человек
	IF @Mod='UPD' and (@SetToNewQuota!=1 and ISNULL(@O_DLNMen,0) != ISNULL(@N_DLNMen,0))
	BEGIN
		SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)-ISNULL(@O_DLNMen,0)
		if ISNULL(@O_DLNMen,0) > ISNULL(@N_DLNMen,0)
		BEGIN
			while (SELECT count(1) FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_Date=@N_DLDateBeg)>ISNULL(@N_DLNMen,0)
			BEGIN
				if @N_DLSVKey=3 --для проживания отдельная ветка
				BEGIN
					SELECT TOP 1 @RLID=SD_RLID, @RPCount=count(SD_ID) FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_TUKey is null and SD_Date=@N_DLDateBeg
					GROUP BY SD_RLID
					ORDER BY 2
					--SELECT @RLID=SDRLID, @RPCount=SDIDcount
					--FROM
					--( 
					--	SELECT TOP 1 SD_RLID SDRLID, count(SD_ID) SDIDcount
					--	FROM ServiceByDate 
					--	WHERE SD_DLKey=@DLKey and SD_TUKey is null and SD_Date=@N_DLDateBeg
					--	GROUP BY SD_RLID
					--	ORDER BY 2
					--) AS QUERY
					SELECT TOP 1 @RPID=SD_RPID FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_RLID=@RLID and SD_TUKey is null
					DELETE FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_RLID=@RLID and ISNULL(SD_RPID,0)=ISNULL(@RPID,0) and SD_TUKey is null
				END
				ELSE
				BEGIN
					SELECT TOP 1 @RPID=SD_RPID FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_TUKey is null
					DELETE FROM ServiceByDate WHERE SD_DLKey=@DLKey and ISNULL(SD_RPID,0)=ISNULL(@RPID,0) and SD_TUKey is null
				END
			END
		END
		ELSE --если новое число туристов больше, чем было до этого (@O_DLNMen<@N_DLNMen)
		BEGIN
			if @N_DLSVKey=3 --для проживания отдельная ветка
			BEGIN				
				SELECT	@HRIsMain=AC_MAIN, @ACPlacesMain=ISNULL(AC_NRealPlaces,0), @ACPlacesEx=ISNULL(AC_NMenExBed,0), @ACPerRoom=ISNULL(AC_PerRoom,0)
				FROM AccmdMenType
				WHERE AC_Key=(SELECT HR_ACKey From HotelRooms WHERE HR_Key=@N_DLSubCode1)
				IF @HRIsMain = 1 and @ACPlacesMain = 0 and @ACPlacesEx = 0
					set @ACPlacesMain = 1
				ELSE IF @HRIsMain = 0 and @ACPlacesMain = 0 and @ACPlacesEx = 0
					set @ACPlacesEx = 1
				--есть 3 варианта размещения: только основные, только дополнительные, основные и дополнительные
				--в первых 2-х вариантах сначала занимаем свободные уже существующие места данного типа в номерах этой услуги, в последнем занимаем все свободные места
				if @ACPlacesMain>0
					WHILE (@NeedPlacesForMen>0 and EXISTS(select RP_ID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_Type=0))
					BEGIN
						select TOP 1 @RPID=RP_ID,@RLID=RP_RLID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_Type=0
						INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_RPID, SD_State)	
							SELECT CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RLID, @RPID, 4
							FROM NUMBERS as N1 WHERE N1.NU_ID between 1 and CAST(@N_DLDateEnd as int)-@From+1
						SET @NeedPlacesForMen=@NeedPlacesForMen-1
					END
				if @ACPlacesEx>0
					WHILE (@NeedPlacesForMen>0 and EXISTS(select RP_ID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_Type=1))
					BEGIN
						select TOP 1 @RPID=RP_ID,@RLID=RP_RLID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM ServicebyDate where SD_DLKey=@DLKey) and RP_Type=1
						INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_RPID, SD_State)	
							SELECT CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RLID, @RPID, 4
							FROM NUMBERS as N1 WHERE N1.NU_ID between 1 and CAST(@N_DLDateEnd as int)-@From+1
						SET @NeedPlacesForMen=@NeedPlacesForMen-1
					END
			END
		END
	END

	IF @Mod='INS' or (@Mod='UPD' and @SetToNewQuota=1) or @NeedPlacesForMen>0
	BEGIN		
		if @N_DLSVKey=3 --для проживания отдельная ветка
		BEGIN
			If @NeedPlacesForMen>0
			BEGIN
				SELECT TOP 1 @RLPlacesMain=RL_NPlaces, @RLPlacesEx=RL_NPlacesEx, @RMKey=RL_RMKey, @RCKey=RL_RCKey from RoomNumberLists,ServiceByDate where RL_ID=SD_RLID and SD_DLKey=@DLKey
			END
			ELSE
			BEGIN
				SELECT	@HRIsMain=HR_MAIN, @RMKey=HR_RMKEY, @RCKey=HR_RCKEY, @ACKey=HR_ACKEY,
						@RMPlacesMain=RM_NPlaces, @RMPlacesEx=RM_NPlacesEx,
						@ACPlacesMain=ISNULL(AC_NRealPlaces,0), @ACPlacesEx=ISNULL(AC_NMenExBed,0), @ACPerRoom=ISNULL(AC_PerRoom,0)
				FROM HotelRooms, Rooms, AccmdMenType
				WHERE HR_Key=@N_DLSubcode1 and RM_Key=HR_RMKEY and AC_KEY=HR_ACKEY
				if @ACPerRoom=1 or (ISNULL(@RMPlacesMain,0)=0 and ISNULL(@RMPlacesEx,0)=0)
				BEGIN
					SET @RLPlacesMain = @ACPlacesMain
					SET @RLPlacesEx = ISNULL(@ACPlacesEx,0)
				END
				Else
				BEGIN
					IF @HRIsMain = 1 and @ACPlacesMain = 0 and @ACPlacesEx = 0
					BEGIN
						set @ACPlacesMain = 1
					END
					ELSE IF @HRIsMain = 0 and @ACPlacesMain = 0 and @ACPlacesEx = 0
					BEGIN
						set @ACPlacesEx = 1
					END

					SET @RLPlacesMain = @RMPlacesMain
					SET	@RLPlacesEx = ISNULL(@RMPlacesEx,0)
				END
				IF @Mod='UPD' and @SetToNewQuota=1	--если услуга полностью ставится на квоту (из-за глобальных изменений (было удаление из ServiceByDate))
					SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)
				ELSE
					SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)-ISNULL(@O_DLNMen,0)
			END
	
			SET @RLID = 0
			SET @AC_FreeMainPlacesCount = 0
			SET @AC_FreeExPlacesCount = 0
			SET @RL_FreeMainPlacesCount = 0
			SET @RL_FreeExPlacesCount = 0
			WHILE (@NeedPlacesForMen>0)
			BEGIN
				--если в последнем номере кончились места, то выставляем признак @RLID = 0
				IF @AC_FreeMainPlacesCount = 0 and @AC_FreeExPlacesCount = 0
				BEGIN
					SET @AC_FreeMainPlacesCount = @ACPlacesMain
					SET @AC_FreeExPlacesCount = @ACPlacesEx
					--создаем новый номер, всегда когда есть хоть кто-то на основном месте ???
					IF (@AC_FreeMainPlacesCount > @RL_FreeMainPlacesCount) or (@AC_FreeExPlacesCount > @RL_FreeExPlacesCount)
					BEGIN
						--создаем новый номер для каждой услуги, если размещение на номер.
						--IF @ACPlacesMain>0
						IF @ACPerRoom>0
						BEGIN			
							INSERT INTO RoomNumberLists(RL_NPlaces, RL_NPlacesEx, RL_RMKey, RL_RCKey) values (@RLPlacesMain, @RLPlacesEx, @RMKey, @RCKey)
							set @RLID=SCOPE_IDENTITY()
							INSERT INTO RoomPlaces (RP_RLID, RP_Type)
								SELECT @RLID, CASE WHEN NU_ID>@RLPlacesMain THEN 1 ELSE 0 END FROM NUMBERS WHERE NU_ID between 1 and (@RLPlacesMain+@RLPlacesEx)
							set @RPID=SCOPE_IDENTITY()-@RLPlacesMain-@RLPlacesEx+1
							SET @RL_FreeMainPlacesCount = @RLPlacesMain
							SET @RL_FreeExPlacesCount = @RLPlacesEx
						END
						ELSE
						BEGIN
							/*
							1. Ищем к кому подселиться в данной путевке, если не находим, то прийдется создавать новый номер
							*/
							set @RPID = null
							SELECT	TOP 1 @RPID=RP_ID, @RLID=RP_RLID
							FROM	RoomPlaces
							WHERE
								RP_Type=CASE WHEN @ACPlacesMain>0 THEN 0 ELSE 1 END
								and RP_RLID in 
								(	SELECT SD_RLID 
									FROM ServiceByDate,DogovorList,RoomNumberLists 
									WHERE SD_DLKey=DL_Key and DL_DGKey=@DGKey and RL_ID=SD_RLID and SD_TUKey=@TUKey
										and DL_SVKey=@N_DLSVKey and DL_Code=@N_DLCode 
										and DL_DateBeg=@N_DLDateBeg and DL_DateEnd=@N_DLDateEnd
										and RL_RMKey=@RMKey and RL_RCKey=@RCKey
								)
								and not exists 
								(	SELECT SD_RPID FROM ServiceByDate WHERE SD_RLID=RP_RLID and SD_RPID=RP_ID)
							ORDER BY RP_ID
							IF @RPID is null	-- надо создавать новый номер даже для дополнительного размещения
							BEGIN
								INSERT INTO RoomNumberLists(RL_NPlaces, RL_NPlacesEx, RL_RMKey, RL_RCKey) values (@RLPlacesMain, @RLPlacesEx, @RMKey, @RCKey)
								set @RLID=SCOPE_IDENTITY()
								INSERT INTO RoomPlaces (RP_RLID, RP_Type)
								SELECT @RLID, CASE WHEN NU_ID>@RLPlacesMain THEN 1 ELSE 0 END FROM NUMBERS WHERE NU_ID between 1 and (@RLPlacesMain+@RLPlacesEx)
								set @RPID = SCOPE_IDENTITY()
								set @RPID=CASE WHEN @ACPlacesMain>0 THEN SCOPE_IDENTITY()-@RLPlacesEx-@RLPlacesMain+1 ELSE SCOPE_IDENTITY()-@RLPlacesEx+1 END
								SET @RL_FreeMainPlacesCount = @RLPlacesMain
								SET @RL_FreeExPlacesCount = @RLPlacesEx
							END
						END
					END
				END
				
				--смотрим есть ли в текущем номере свободные ОСНОВНЫЕ места
				IF @AC_FreeMainPlacesCount > 0
				BEGIN
					SET @AC_FreeMainPlacesCount = @AC_FreeMainPlacesCount - 1
					SET @RL_FreeMainPlacesCount = @RL_FreeMainPlacesCount - 1
					SET @CurrentPlaceIsEx=0
				END
				--если ОСНОВНЫХ мест в номере уже нет, то может посадим на ДОПОЛНИТЕЛЬНОЕ? 
				ELSE IF @AC_FreeExPlacesCount > 0
				BEGIN
					SET @AC_FreeExPlacesCount = @AC_FreeExPlacesCount - 1
					SET @RL_FreeExPlacesCount = @RL_FreeExPlacesCount - 1
					SET @CurrentPlaceIsEx=1
				END
				--INSERT INTO RoomPlaces (RP_RLID, RP_Type) values (@RLID,@CurrentPlaceIsEx)
				--set @RPID=SCOPE_IDENTITY()
				--SELECT @RPID=RP_ID FROM RoomPlaces WHERE RP_RLID=@RLID and RP_Type=@CurrentPlaceIsEx and RP_ID NOT IN (SELECT SD_RPID FROM ServiceByDate)
				--insert into debug (db_n1, db_n2, db_n3) values (@RLID, @CurrentPlaceIsEx, 1011)
				set @TUKey=null
				SELECT @TUKey=TU_TUKey FROM dbo.TuristService WHERE TU_DLKey=@DLKey and TU_TUKey not in (SELECT SD_TUKey FROM ServiceByDate WHERE SD_DLKey=@DLKey)
				INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_RPID, SD_TUKey)
					SELECT CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RLID, @RPID, @TUKey
					FROM NUMBERS as N1 WHERE N1.NU_ID between 1 and CAST(@N_DLDateEnd as int)-@From+1
				SET @NeedPlacesForMen=@NeedPlacesForMen-1
				SET @RPID=@RPID+1
			END		
		END --для проживания отдельная ветка... (КОНЕЦ)
		else --для всех услуг кроме проживания
		--while (@Date<=@N_DLDateEnd)
		BEGIN
			IF @Mod='UPD' and @SetToNewQuota=1	--если услуга полностью ставится на квоту (из-за глобальных изменений (было удаление из ServiceByDate))
				SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)
			ELSE
				SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)-ISNULL(@O_DLNMen,0)

			while(@NeedPlacesForMen > 0)
			BEGIN
				--INSERT INTO ServiceByDate (SD_Date, SD_DLKey) values (@Date, @DLKey)
				set @TUKey=null
				SELECT @TUKey=TU_TUKey FROM dbo.TuristService WHERE TU_DLKey=@DLKey and TU_TUKey not in (SELECT SD_TUKey FROM ServiceByDate WHERE SD_DLKey=@DLKey)
				INSERT INTO RoomPlaces(RP_RLID, RP_Type) values (0,0)
				set @RPID=SCOPE_IDENTITY()				
				INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RPID, SD_TUKey)	
					SELECT CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RPID, @TUKey
					FROM NUMBERS as N1 WHERE N1.NU_ID between 1 and CAST(@N_DLDateEnd as int)-@From+1
				set @NeedPlacesForMen=@NeedPlacesForMen-1
			END
			--set @Date=@Date+1
		END
		exec dbo.DogListToQuotas @DLKey --в этой хранимке будет выполнена попытка постановки услуги на квоту
	END
	FETCH NEXT FROM cur_DogovorListChanged2 
		INTO	@DLKey, @DGKey,
				@O_DLSVKey, @O_DLCode, @O_DLSubCode1, @O_DLDateBeg, @O_DLDateEnd, @O_DLNMen, @O_DLPartnerKey, @O_DLControl,
				@N_DLSVKey, @N_DLCode, @N_DLSubCode1, @N_DLDateBeg, @N_DLDateEnd, @N_DLNMen, @N_DLPartnerKey, @N_DLControl
END
CLOSE cur_DogovorListChanged2
DEALLOCATE cur_DogovorListChanged2

GO


/*********************************************************************/
/* end T_UpdDogListQuota.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.07.02)_ADD_COLUMNS_History.sql */
/*********************************************************************/
-- Прочитано ли ссообщение
if not exists (select 1 from dbo.syscolumns where name = 'HI_IsRead' and id = object_id(N'[dbo].[History]'))
begin
	alter table dbo.History add HI_IsRead int null
end
go
/*********************************************************************/
/* end (2012.07.02)_ADD_COLUMNS_History.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_DogovorMonitor.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DogovorMonitor]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DogovorMonitor]
GO

CREATE PROCEDURE [dbo].[DogovorMonitor]
  (
--<VERSION>2009.2.13</VERSION>
--<DATE>2012-07-05</DATE>
	@dtStartDate datetime,			-- начальная дата просмотра изменений
	@dtEndDate datetime,			-- конечная дата просмотра изменений
	@nCountryKey int,				-- ключ страны
	@nCityKey int,					-- ключ города
	@nDepartureCityKey int,			-- ключ города вылета
	@nCreatorKey int,				-- ключ создателя
	@nOwnerKey int,					-- ключ ведущего менеджера
	@nViewProceed smallint,			-- не показывать обработанные: 0 - показывать, 1 - не показывать
	@sFilterKeys varchar(255),		-- ключи выбранных фильтров
	@nFilialKey int,				-- ключ филиала
	@nBTKey int,					-- ключ типа бронирования: -1 - все, 0 - офис, 1 - онлайн
	@sLang varchar(10)				-- язык (если en, селектим поля NameLat, а не Name)
	       
  )
AS
BEGIN

CREATE TABLE #DogovorMonitorTable
(
	DM_CreateDate datetime, -- DM_HistoryDate
	DM_FirstProcDate datetime, -- NEW
	DM_LastProcDate datetime, -- DM_ProcDate
	DM_DGCODE nvarchar(10),
	DM_CREATOR nvarchar(25),
	DM_TurDate datetime,
	DM_TurName nvarchar(160),
	DM_PartnerName nvarchar(80),
	DM_FilterName nvarchar(1024),
	DM_NotesCount int,
	DM_PaymentStatus nvarchar(4),
	DM_IsBilled bit,
	DM_MessageCount int,
    DM_MessageCountRead int,
	DM_MessageCountUnRead int,
	DM_AnnulReason varchar(60),
	DM_AnnulDate datetime,
	DM_PriceToPay money,
	DM_Payed money,
	DM_OrderStatus varchar(20)
)

CREATE TABLE #TempTable
(
	#dogovorCreateDate datetime,
	#lastDogovorActionDate datetime,
	#sDGCode varchar(10),
	#sCreator varchar(25),
	#dtTurDate datetime,
	#sTurName nvarchar(160),
	#sPartnerName nvarchar(80),
	#dgKey int,
	#sPaymentStatus nvarchar(4),
	#AnnulReason varchar(60),
	#PriceToPay money,
	#Payed money
)

declare @nObjectAliasFilter int, @sFilterType varchar(3)

DECLARE @dogovorCreateDate datetime, @lastDogovorActionDate datetime -- @dtHistoryDate
declare @sDGCode varchar(10), @nDGKey int
declare @sCreator varchar(25), @dtTurDate datetime, @sTurName varchar(160)
declare @sPartnerName varchar(80), @sFilterName varchar(255), @nHIID int
declare @sHistoryMod varchar(3), @sPaymentStatus as varchar(4)
declare @AnnulReason AS varchar(60), @AnnulDate AS datetime, @PriceToPay AS money, @Payed AS money

set @sHistoryMod = 'DMP'

declare @nFilterKey int, @nLastPos int

while len(@sFilterKeys) > 0
begin
	set @nLastPos = 0
	set @nLastPos = charindex(',', @sFilterKeys, @nLastPos)
	if @nLastPos = 0
		set @nLastPos = len(@sFilterKeys) + 1
	
	set @nFilterKey = cast(substring(@sFilterKeys, 0, @nLastPos) as int)
	if @nLastPos <> len(@sFilterKeys) + 1
		set @sFilterKeys = substring(@sFilterKeys, @nLastPos + 1, len(@sFilterKeys) - @nLastPos)
	else
		set @sFilterKeys = ''
	
	select @sFilterName = DS_Value from Descriptions where DS_KEY = @nFilterKey


	declare filterCursor cursor local fast_forward for
	select OF_OAId, OF_Type
	from ObjectAliasFilters
	where OF_DSKey = @nFilterKey
	order by OF_OAId
	
	open filterCursor
	fetch next from filterCursor into @nObjectAliasFilter, @sFilterType
	while(@@fetch_status = 0)
	begin
		
		declare @sql varchar(max)

		set @sql = N'insert into #TempTable
				select DISTINCT 
				(SELECT MIN(HI_DATE) FROM history h2 WHERE h2.HI_DGCOD = DG_CODE) AS DOGOVOR_CREATE_DATE, 
				(SELECT MAX(HI_DATE) FROM history h2 WHERE h2.HI_DGCOD = DG_CODE) AS LAST_DOGOVOR_ACTION_DATE, 
				DG_CODE, US_FullName, DG_TurDate, TL_NAME, PR_NAME, DG_KEY,
				CASE
					WHEN DG_PRICE = 0 AND DG_PAYED = DG_PRICE THEN ''OK''
					WHEN DG_PAYED = 0 THEN ''NONE''
					WHEN DG_PAYED < DG_PRICE THEN ''LOW''
					WHEN DG_PAYED = DG_PRICE THEN ''OK''
					WHEN DG_PAYED > DG_PRICE THEN ''OVER''
				END AS DM_PAYMENTSTATUS, AR_Name, 
				CASE
					WHEN DG_PDTTYPE = 1 THEN DG_PRICE + DG_DISCOUNTSUM
					ELSE DG_PRICE					
				END AS DM_PriceToPay, DG_PAYED
			from dogovor with(nolock), history with(nolock), historydetail with(nolock), userlist with(nolock), TurList with(nolock), Partners with(nolock), AnnulReasons with(nolock)
			where HI_DGCOD = DG_CODE and HI_ID = HD_HIID and US_KEY = DG_CREATOR and TL_KEY = DG_TRKEY and PR_KEY = DG_PARTNERKEY and 
				HI_DATE BETWEEN ''' + convert(varchar, @dtStartDate, 120) + ''' and dateadd(day, 1, ''' + convert(varchar, @dtEndDate, 120) + ''') and
				((' + str(@nCountryKey) + ' < 0 and DG_CNKEY in (select CN_KEY from Country with(nolock))) OR (' + str(@nCountryKey) + ' >= 0 and DG_CNKEY = ' + str(@nCountryKey) + ')) and
				(' + str(@nCityKey) + ' < 0 OR DG_CTKEY = ' + str(@nCityKey) + ') and
				(' + str(@nDepartureCityKey) + ' < 0 OR DG_CTDepartureKey = ' + str(@nDepartureCityKey) + ') and
				(' + str(@nCreatorKey) + ' < 0 OR DG_CREATOR = ' + str(@nCreatorKey) + ') and
				(' + str(@nOwnerKey) + ' < 0 OR DG_OWNER = ' + str(@nOwnerKey) + ') and
				(' + str(@nFilialKey) + ' < 0 OR DG_FILIALKEY = ' + str(@nFilialKey) + ') and
				(' + str(@nBTKey) + ' < 0 OR (' + str(@nBTKey) + ' = 0 AND DG_BTKEY is NULL) OR DG_BTKEY = ' + str(@nBTKey) + ') and
				(AR_Key = DG_ARKEY)'
				
-----------------------------------------------------------------------------------------------
-- MEG00037288 06.09.2011 Kolbeshkin: добавил алиасы 41-43 для проверки корректности путевки --
-----------------------------------------------------------------------------------------------
		DECLARE @sNotAnnuled varchar(max)
		SET @sNotAnnuled = ' and DG_TURDATE <> ''1899-12-30 00:00:00.000'' '
		SET @sql = @sql + 
		CASE 
		WHEN (@nObjectAliasFilter = 41) -- Путевка без услуг
			THEN ' and not exists (select 1 from dogovorlist where dl_dgkey = dg_key)' + @sNotAnnuled
		WHEN (@nObjectAliasFilter = 42) -- Путевка без туристов
			THEN ' and not exists (select 1 from Turist where TU_DGKEY = DG_KEY)' + @sNotAnnuled
		WHEN (@nObjectAliasFilter = 43) -- Услуги с непривязанными туристами
			THEN ' and exists (select 1 from dogovorlist where dl_dgkey = dg_key and not exists (select 1 from TuristService where tu_dlkey = dl_key))' + @sNotAnnuled
		--------- Отсутствуют обязательные(неудаляемые) услуги решено пока не делать, потому что нет прямой связи DogovorList c TurService
		--WHEN (@nObjectAliasFilter = 44) -- Отсутствуют обязательные(неудаляемые) услуги
		--	THEN ' and ((select (
		--	(select COUNT(1) from TurService ts where TS_TRKEY=dg.DG_TRKEY and TS_ATTRIBUTE % 2 = 0) -- Кол-во неудаляемых услуг в туре
		--	-
		--	(select COUNT(1) from Dogovorlist dl join TurService ts on -- Кол-во услуг попавших в путевку из неудаляемых в туре
		--	(ts.TS_TRKEY = dg.DG_TRKEY and ts.TS_ATTRIBUTE % 2 = 0
		--	and dl.DL_SVKEY = ts.TS_SVKEY and dl.DL_CODE = ts.TS_CODE
		--	) where dl.DL_DGKEY = dg.DG_Key and dl.DL_TRKEY = dg.DG_TRKEY )))
		--	> 0) ' 
		ELSE 
			 ' and (HD_OAId = ' + str(@nObjectAliasFilter) + ') 
			 and (''' + @sFilterType + '''= '''' OR HI_MOD = ''' + @sFilterType + ''')'
		END
		
-------------------------------------------------------------------------------------
-- MEG00037288 07.09.2011 Kolbeshkin: локализация. Если язык En, селектим поля LAT --
-------------------------------------------------------------------------------------
		IF @sLang like 'en'
		BEGIN
		set @sql = REPLACE(@sql,'US_FullName','US_FullNameLat')
		set @sql = REPLACE(@sql,'TL_NAME','TL_NAMELAT')
		set @sql = REPLACE(@sql,'PR_NAME','PR_NAMEENG')
		set @sql = REPLACE(@sql,'AR_Name','AR_NameLat')
		END
		--print @sql
		exec (@sql)
		
		declare dogovorsCursor cursor local fast_forward for
		select * from #TempTable

		--нашли путевки
		open dogovorsCursor
		fetch next from dogovorsCursor into @dogovorCreateDate, @lastDogovorActionDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @nDGKey, @sPaymentStatus, @AnnulReason, @PriceToPay, @Payed
		while(@@fetch_status = 0)
		begin
			--if not exists (select * from #DogovorMonitorTable where datediff(mi, DM_HistoryDate, @dtHistoryDate) = 0 and DM_DGCODE = @sDGCode and DM_FilterName LIKE @sFilterName)
			--begin
				DECLARE @firstDogovorProcessDate datetime 
				DECLARE @lastDogovorProcessDate datetime -- @hiDate

				SET @firstDogovorProcessDate = (select MIN(HI_DATE) from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod)
				SET @lastDogovorProcessDate = (select MAX(HI_DATE) from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod)

--				--select @hiDate = HI_DATE from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod
--				if exists (select HI_DATE from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod)
--					select @hiDate = HI_DATE from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod
--				else
--					set @hiDate = NULL


				------ Получение даты тура до аннуляции ------
				IF (@dtTurDate = '12/30/1899')
				BEGIN
					SELECT @dtTurDate = DG_TURDATEBFRANNUL
					FROM Dogovor
					WHERE DG_Code = @sDGCode
				END
				----------------------------------------------

				SET @AnnulDate = NULL;
				------ Получение даты аннуляции ------
				SELECT @AnnulDate = History.HI_DATE
				FROM HistoryDetail
				JOIN History 
					ON HI_ID = HD_HIID
				WHERE HistoryDetail.HD_Alias = 'DG_Annulate' AND History.HI_DgCod = @sDGCode
				--------------------------------------
				
				DECLARE @notesCount int
				SELECT @notesCount = COUNT(HI_TEXT) FROM HISTORY
				WHERE HI_DGCOD = @sDGCode AND HI_MOD = 'WWW'

				DECLARE @isBilled bit
				SET @isBilled = 0
				IF EXISTS(SELECT AC_KEY FROM ACCOUNTS WHERE AC_DGCOD = @sDGCode)
					SET @isBilled = 1

				DECLARE @messageCount int, @MessageCountRead int, @MessageCountUnRead int
				SELECT @messageCount = COUNT(HI_TEXT)
			          ,@MessageCountRead = SUM(case when HI_IsRead = 1 then 1 else 0 end)
			          ,@MessageCountUnRead = SUM(case when HI_IsRead <> 1 then 1 else 0 end)
			    FROM HISTORY
				WHERE HI_DGCOD = @sDGCode AND HI_MOD = 'MTM'
				AND HI_TEXT NOT LIKE 'От агента: %' -- notes from web (copies of 'WWW' moded notes)
				
				--узнаем статус путевки
				DECLARE @orderStatus varchar(20);
				select @orderStatus  = case when @sLang='en' then o.OS_NameLat else o.OS_NAME_RUS end
				from Order_Status o
				left join Dogovor d on d.DG_SOR_CODE=o.OS_CODE
				where d.DG_Key = @nDGKey

				DECLARE @includeRecord bit
				SET @includeRecord = 0

				if (@nViewProceed = 0) OR (@lastDogovorProcessDate IS NULL)
				begin
					--insert into #DogovorMonitorTable (DM_HistoryDate, DM_ProcDate, DM_DGCODE, DM_CREATOR, DM_TurDate, DM_TurName, DM_PartnerName, DM_FilterName, DM_NotesCount, DM_PaymentStatus, DM_IsBilled, DM_MessageCount)
					--values (@dtHistoryDate, @hiDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @sFilterName, @notesCount, @sPaymentStatus, @isBilled, @messageCount)
					SET @includeRecord = 1
				end
				else
				begin
					--if @dtHistoryDate > @hiDate
					if @lastDogovorActionDate > @lastDogovorProcessDate
					begin
						--insert into #DogovorMonitorTable (DM_HistoryDate, DM_ProcDate, DM_DGCODE, DM_CREATOR, DM_TurDate, DM_TurName, DM_PartnerName, DM_FilterName, DM_NotesCount, DM_PaymentStatus, DM_IsBilled, DM_MessageCount) 
						--values (@dtHistoryDate, @hiDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @sFilterName, @notesCount, @sPaymentStatus, @isBilled, @messageCount)
						SET @includeRecord = 1
					end
				end
              
				-------------------
				IF @includeRecord = 1
				BEGIN
					IF EXISTS (SELECT dm_dgcode FROM #DogovorMonitorTable WHERE dm_dgcode = @sDGCode)
					BEGIN
						IF NOT EXISTS (SELECT 1 FROM #DogovorMonitorTable WHERE dm_dgcode = @sDGCode AND dm_filtername LIKE '%' + @sFilterName + '%')
							UPDATE #DogovorMonitorTable SET DM_FilterName = DM_FilterName + ', ' + @sFilterName WHERE dm_dgcode = @sDGCode
					END
					ELSE
					BEGIN
						INSERT INTO #DogovorMonitorTable
						VALUES (@dogovorCreateDate, @firstDogovorProcessDate, @lastDogovorProcessDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @sFilterName, @notesCount, @sPaymentStatus, @isBilled, @messageCount, @MessageCountRead , @MessageCountUnRead, @AnnulReason, @AnnulDate, @PriceToPay, @Payed,@orderStatus);
					END
				END
				-------------------

			--end
			fetch next from dogovorsCursor into @dogovorCreateDate, @lastDogovorActionDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @nDGKey, @sPaymentStatus, @AnnulReason, @PriceToPay, @Payed
		end
			
		close dogovorsCursor
		deallocate dogovorsCursor
		delete from #TempTable

		fetch next from filterCursor into @nObjectAliasFilter, @sFilterType
	end

	close filterCursor
	deallocate filterCursor
end
	SELECT *
	FROM #DogovorMonitorTable
	ORDER BY DM_CreateDate
	
	DROP TABLE #TempTable
	DROP TABLE #DogovorMonitorTable

END

grant exec on [dbo].[DogovorMonitor] to public
go

/*********************************************************************/
/* end sp_DogovorMonitor.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CheckDoubleDogovor.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='CheckDoubleDogovor')
	drop proc dbo.CheckDoubleDogovor
go

create procedure [dbo].[CheckDoubleDogovor]  
	--<VERSION>2009.2.15<VERSION/>
	--<DATA>2012-07-27<DATA/>
	@TourDate varchar (10),
	@TourDuration int,
	@LastName varchar (25),
	@FirstName varchar (25),
	@Sex int,	
	@HotelKey int,
	@HotelStartDate varchar (10) = null,
	@HotelEndDate varchar (10) = null,
	@Birthday varchar (10) = null,
	@PassportType varchar(5) = null,
	@PassportNum varchar(13) = null
AS
begin
    --CRM01804K4X8 27.07.2012 kolbeshkin: переделал хранимку проверки дублирования туристов
	SET @LastName = REPLACE (@LastName,'''','')
	SET @FirstName = REPLACE (@FirstName,'''','')
	-- проверяем только: 
	-- 1.Взрослых
	-- 2.Если есть отель, т.к. остальные услуги могут быть по 2 и более и разнесены по разным путевкам
	IF @Sex NOT IN (0,1) OR @HotelKey < 0 OR @HotelStartDate IS NULL OR @HotelEndDate IS NULL
		RETURN
	-- Сравнение:
	-- 1.Фамилия
	-- 2.Имя
	-- 3.Пересекаются ли даты тура
	-- 4.Пол
	-- 5.Существует ли проживание и пересекаются ли его даты
	DECLARE @sql nvarchar(max)
	SET @sql = 'SELECT TU_DGCOD, TU_KEY 
			From [dbo].[tbl_turist] 
			where RTRIM(LTRIM((UPPER(TU_NAMERUS)))) = RTRIM(LTRIM((UPPER(''' + @LastName + ''')))) 
			AND RTRIM(LTRIM((UPPER(TU_FNAMERUS)))) = RTRIM(LTRIM((UPPER(''' + @FirstName + ''')))) 
			AND EXISTS (SELECT DG_KEY 
						FROM dogovor 
						where DG_CODE = TU_DGCOD
						and (''' + @TourDate + ''' between DG_TURDATE and DATEADD(DAY, DG_NDAY - 1, DG_TURDATE)
								or DG_TURDATE between ''' + @TourDate + ''' and DATEADD(DAY, ' + CAST(@TourDuration AS varchar(2)) + ' - 1, ''' + @TourDate + '''))) 
			AND ISNULL(TU_SEX,0) in (0,1) AND ISNULL(TU_SEX,0) = ' + CAST(@Sex AS varchar(2)) + '
			AND EXISTS (SELECT 1 FROM DogovorList,TuristService WHERE DL_SVKey=3 and TU_DLKey=DL_Key and DL_DGCOD=TU_DGCOD and TU_TUKey=TU_Key
						AND (''' + @HotelStartDate + ''' between DL_DATEBEG and DATEADD(DAY,-1,DL_DATEEND) 
							OR DL_DATEBEG between ''' + @HotelStartDate + ''' and DATEADD(DAY,-1,''' + @HotelEndDate + ''')) )'
	-- 6.Дата рождения (если задана у бронирующего)						
	IF @Birthday IS NOT NULL
		SET @sql = @sql + '
		 AND (TU_BIRTHDAY IS NULL OR TU_BIRTHDAY = ''' + @Birthday + ''')'
	-- 7.Серия паспорта (если задана у бронирующего)			
	IF @PassportType IS NOT NULL
		SET @sql = @sql + '
		 AND (TU_PASPORTTYPE IS NULL OR TU_PASPORTTYPE = ''' + @PassportType + ''')'
	-- 8.Серия паспорта (если задана у бронирующего)	
	IF @PassportNum IS NOT NULL
		SET @sql = @sql + '
		 AND (TU_PASPORTNUM IS NULL OR TU_PASPORTNUM = ''' + @PassportNum + ''')'
		
 --print @sql
 EXECUTE sp_executesql @sql
end
go

grant exec on [dbo].[CheckDoubleDogovor] to public
go


/*********************************************************************/
/* end sp_CheckDoubleDogovor.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120827)_Grant_CostOffers.sql */
/*********************************************************************/
GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.CostOffers TO PUBLIC
GO
/*********************************************************************/
/* end (20120827)_Grant_CostOffers.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20120829_Insert_ProviderStatuses.sql */
/*********************************************************************/
if not exists(select 1 from ProviderStatuses where PS_KEY = 0)
begin
set identity_insert ProviderStatuses on

insert into ProviderStatuses (PS_KEY,PS_NAME,PS_NAMELAT) values (0,'','')

set identity_insert ProviderStatuses off
end

go
/*********************************************************************/
/* end 20120829_Insert_ProviderStatuses.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (090907)mwCheckFlightGroupsQuotes.sql */
/*********************************************************************/
if object_id('dbo.mwCheckFlightGroupsQuotes', 'p') is not null
	drop proc dbo.mwCheckFlightGroupsQuotes
go

create proc [dbo].[mwCheckFlightGroupsQuotes]
	@pagingType int,
	@chkey int,
	@flightGroups varchar(256),
	@agentKey int,
	@partnerKey int,
	@tourdate datetime,
	@day int,
	@requestOnRelease int,
	@noPlacesResult int,
	@checkAgentQuota int,
	@checkCommonQuota int,
	@checkNoLongQuota int,
	@findFlight smallint,
	@pkkey int,
	@tourDays int,
	@expiredReleaseResult int,
	@aviaQuotaMask smallint,
	@result varchar(256) output,
	@linked_day int = null
as
begin
	declare @DYNAMIC_SPO_PAGING smallint
	set @DYNAMIC_SPO_PAGING=3

	declare @now datetime, @percentPlaces float
	select @now = currentDate from dbo.mwCurrentDate

	if(@aviaQuotaMask is null)
		set @aviaQuotaMask = 0

	declare @correctionResult varchar(128)
	set @result = ''
	set @correctionResult = ''

	declare @gpos int, @pos int, @gplaces int, @gallplaces int, @tmpPlaces int, @tmpPlacesAll int, @gStep smallint, @gCorrection int
	set @gpos = 1
	
	declare @gseparatorPos int, @separatorPos int,
		@groupKeys varchar(256), @key varchar(256), @nkey int,
		@glen int, @len int

	if (@aviaQuotaMask > 0)
	begin
		declare @quotaMask smallint -- признаки статусов квот, устанавливаются, если хоть в одной группе встретился соответствующий статус
		set @quotaMask = 0
	end

	set @glen = len(@flightGroups)
	while(@gpos < @glen)
	begin
		set @gseparatorPos = charindex('|', @flightGroups, @gpos)
		if(@gseparatorPos = 0)
		begin
			set @groupKeys = substring(@flightGroups, @gpos, @glen - @gpos + 1)	
			set @gpos = @glen
		end
		else
		begin
			set @groupKeys = substring(@flightGroups, @gpos, @gseparatorPos - @gpos)
			set @gpos = @gseparatorPos + 1
		end

		if(len(@result) > 0)
		begin
			set @result = @result + '|'
			if(@pagingType = @DYNAMIC_SPO_PAGING)
			begin
				set @correctionResult = @correctionResult + '|'
			end
		end

		set @gplaces = 0
		set @gallplaces = 0
		set @pos = 1
		set @len = len(@groupKeys)		
		while(@pos < @len)
		begin
			set @separatorPos = charindex(',', @groupKeys, @pos)
			if(@separatorPos = 0)
			begin
				set @key = substring(@groupKeys, @pos, @len - @pos + 1)	
				set @pos = @len
			end
			else
			begin
				set @key = substring(@groupKeys, @pos, @separatorPos - @pos)
				set @pos = @separatorPos + 1
			end

			set @nkey = cast(@key as int)
			select @tmpPlaces = qt_places, @tmpPlacesAll = qt_allPlaces
			from dbo.mwCheckQuotesEx2(1, @chkey, @nkey, 0, @agentKey, @partnerKey, @tourdate,
				@day, 1, @requestOnRelease, @noPlacesResult, @checkAgentQuota,
				@checkCommonQuota, @checkNoLongQuota, @findFlight, 0, 0, @pkkey,
				@tourDays, @expiredReleaseResult, @linked_day)
			if(@gplaces = 0 or (@tmpPlaces > 0 and @tmpPlaces > @gplaces))
			begin
				set @gplaces = @tmpPlaces
				set @gallplaces = @tmpPlacesAll

				if(@pagingType = @DYNAMIC_SPO_PAGING)
				begin
					set @percentPlaces = 0.0
					if(@gplaces > 0 and @gallplaces > 0)
						set @percentPlaces = 1.0*@gplaces/@gallplaces
					exec dbo.GetDynamicCorrections @now,@tourdate,1,@chkey,@nkey,0,@percentPlaces, @gStep output, @gCorrection output				
				end
			end

			if(@gplaces > 0)
				break	
		end

		if (@aviaQuotaMask > 0)
		begin
			if(@gplaces > 0)
				set @quotaMask = @quotaMask | 1
			else if(@gplaces = 0)
				set @quotaMask = @quotaMask | 2
			else if(@gplaces = -1)
				set @quotaMask = @quotaMask | 4
		end

		set @result = @result + cast(@gplaces as varchar) + ':' + cast(@gallplaces as varchar)
		if(@pagingType = @DYNAMIC_SPO_PAGING)
			set @correctionResult = @correctionResult + cast(@gCorrection as varchar) + ':' + cast(@gStep as varchar)
	end

	if (@aviaQuotaMask > 0)
	begin
		if((@aviaQuotaMask & @quotaMask) = 0)
			set @result = ''
	end

	if(@pagingType = @DYNAMIC_SPO_PAGING)
		set @result = @result + '#' + @correctionResult
end
go

grant exec on dbo.mwCheckFlightGroupsQuotes to public
go
/*********************************************************************/
/* end (090907)mwCheckFlightGroupsQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (19.06.2012)_Insert_SystemSettings.sql */
/*********************************************************************/
if not exists (SELECT * FROM SystemSettings WHERE ss_parmName LIKE 'SYSProtourQuotesHistory')
begin
	insert into SystemSettings (
		SS_ParmName
		,SS_ParmValue
		,SS_Name)
	values (
		'SYSProtourQuotesHistory'
		,convert(varchar(100), getdate(), 105)
		,'Произошла ли сегодня загрузка квот из ProTour')
end
GO

/*********************************************************************/
/* end (19.06.2012)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (19.07.2012)_Insert_SystemSettings.sql */
/*********************************************************************/
if not exists (SELECT * FROM SystemSettings WHERE ss_parmName LIKE 'SYSSetQuotaToTourist')
begin
	insert into SystemSettings (
		SS_ParmName
		,SS_ParmValue)
	values (
		'SYSSetQuotaToTourist'
		,1)
end
GO

/*********************************************************************/
/* end (19.07.2012)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012-04-24)_Add_SystemSetting_mwUseSmartSearch.sql */
/*********************************************************************/
-- 4864 Добавление настройки для включения подмешивания отелей при поиске в QuotedDynamic (SmartSearch)
--<DATE>2012-04-24</DATE>
--<VERSION>2007.2.40.1</VERSION>
if not exists (select 1 from SystemSettings where SS_ParmName='mwUseSmartSearch')
	insert into SystemSettings (SS_ParmName,SS_ParmValue)
	values ('mwUseSmartSearch','0')
go
/*********************************************************************/
/* end (2012-04-24)_Add_SystemSetting_mwUseSmartSearch.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.02.20)_Insert_AddCostTypes.sql */
/*********************************************************************/
if not exists (select top 1 1 from AddCostTypes where ACT_Id = 1)
begin
	set identity_insert AddCostTypes on
	insert into AddCostTypes (ACT_Id, ACT_Name) values (1, N'услугу');
	set identity_insert AddCostTypes off
end
go
if not exists (select top 1 1 from AddCostTypes where ACT_Id = 2)
begin
	set identity_insert AddCostTypes on
	insert into AddCostTypes (ACT_Id, ACT_Name) values (2, N'человека');
	set identity_insert AddCostTypes off
end
go
if not exists (select top 1 1 from AddCostTypes where ACT_Id = 3)
begin
	set identity_insert AddCostTypes on
	insert into AddCostTypes (ACT_Id, ACT_Name) values (3, N'взрослого/ребенка');
	set identity_insert AddCostTypes off
end
go
/*********************************************************************/
/* end (2012.02.20)_Insert_AddCostTypes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.19)_Add_TL_CalculationAction_tbl_TurList.sql */
/*********************************************************************/
if not exists (select 1 from dbo.syscolumns where name = 'TL_CalculationAction' and id = object_id(N'[dbo].[tbl_TurList]'))
    begin	
		ALTER TABLE dbo.tbl_TurList add TL_CalculationAction int not null default 0
	end
go

exec sp_RefreshViewForAll 'TurList'
go
/*********************************************************************/
/* end (2012.03.19)_Add_TL_CalculationAction_tbl_TurList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.23)_Data_TableExtensions.sql */
/*********************************************************************/
if not exists (select top 1 1 from dbo.TableExtension_Tables where TET_Id = 1)
begin
	SET IDENTITY_INSERT dbo.TableExtension_Tables ON
	insert into TableExtension_Tables (TET_Id, TET_TableName, TET_TableDescription)
	values (1, 'TuristService', 'Таблица связи туристов с услугами в путевке')
	SET IDENTITY_INSERT dbo.TableExtension_Tables OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_Tables where TET_Id = 2)
begin
	SET IDENTITY_INSERT dbo.TableExtension_Tables ON
	insert into TableExtension_Tables (TET_Id, TET_TableName, TET_TableDescription)
	values (2, 'Service', 'Таблица классов услуг')
	SET IDENTITY_INSERT dbo.TableExtension_Tables OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_ColumnTypes where TECT_Id = 1)
begin
	SET IDENTITY_INSERT dbo.TableExtension_ColumnTypes ON
	insert into TableExtension_ColumnTypes (TECT_Id, TECT_TypeName, TECT_CLRType)
	values (1, 'Числовой', 'System.Int32')
	SET IDENTITY_INSERT dbo.TableExtension_ColumnTypes OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_ColumnTypes where TECT_Id = 2)
begin
	SET IDENTITY_INSERT dbo.TableExtension_ColumnTypes ON
	insert into TableExtension_ColumnTypes (TECT_Id, TECT_TypeName, TECT_CLRType)
	values (2, 'Список чисел', 'System.Collections.Generic.IEnumerable`1[System.Int32]')
	SET IDENTITY_INSERT dbo.TableExtension_ColumnTypes OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_ColumnTypes where TECT_Id = 3)
begin
	SET IDENTITY_INSERT dbo.TableExtension_ColumnTypes ON
	insert into TableExtension_ColumnTypes (TECT_Id, TECT_TypeName, TECT_CLRType)
	values (3, 'Строка', 'System.String')
	SET IDENTITY_INSERT dbo.TableExtension_ColumnTypes OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_Columns where TEC_Id = 1)
begin
	SET IDENTITY_INSERT dbo.TableExtension_Columns ON
	insert into TableExtension_Columns (TEC_Id, TEC_TETId, TEC_TECTId, TEC_ColumnName, TEC_SortOrder)
	values (1, 1, 3, 'NumberOfWagon', 1)
	SET IDENTITY_INSERT dbo.TableExtension_Columns OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_Columns where TEC_Id = 2)
begin
	SET IDENTITY_INSERT dbo.TableExtension_Columns ON
	insert into TableExtension_Columns (TEC_Id, TEC_TETId, TEC_TECTId, TEC_ColumnName, TEC_SortOrder)
	values (2, 1, 3, 'SeatInWagon', 2)
	SET IDENTITY_INSERT dbo.TableExtension_Columns OFF
end
go
if not exists (select top 1 1 from dbo.TableExtension_Columns where TEC_Id = 3)
begin
	SET IDENTITY_INSERT dbo.TableExtension_Columns ON
	insert into TableExtension_Columns (TEC_Id, TEC_TETId, TEC_TECTId, TEC_ColumnName, TEC_SortOrder)
	values (3, 2, 2, 'ColumsInListOfServiceWindow', 1)
	SET IDENTITY_INSERT dbo.TableExtension_Columns OFF
end
go
grant select, insert, update, delete on TableExtension_Tables to public
go
grant select, insert, update, delete on TableExtension_ColumnTypes to public
go
grant select, insert, update, delete on TableExtension_Columns to public
go
grant select, insert, update, delete on TableExtension_Values to public
go
/*********************************************************************/
/* end (2012.03.23)_Data_TableExtensions.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.03.29)_GRANT_SPOTypes.sql */
/*********************************************************************/
if exists( select * from sysobjects where id = object_id(N'[dbo].[SpoTypes]') and objectproperty(id, N'IsUserTable') = 1 )
	grant select, update, insert, delete on dbo.SpoTypes to public
go
/*********************************************************************/
/* end (2012.03.29)_GRANT_SPOTypes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.04.06)_DELETE_UserSettings.sql */
/*********************************************************************/
-- удаляем настройки для колонок в гриде т.к. форма CostEditorForm после ДЦ стала CostEditorFormOld
-- а CostEditorForm - используется только при включенной настройке NewReCalculatePrice и содержит
-- другой набор колонок и порядок их отображения
delete UserSettings where ST_ParmName='CostEditorForm.dgvCosts'
go
/*********************************************************************/
/* end (2012.04.06)_DELETE_UserSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.04.09)_ALTER_Seasons.sql */
/*********************************************************************/
if not exists (select * from syscolumns where name='SN_IsMain' and id=object_id('dbo.Seasons'))
begin
	alter table dbo.Seasons add [SN_IsMain] [bit] NOT NULL default(0);
					
end
go
/*********************************************************************/
/* end (2012.04.09)_ALTER_Seasons.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.04.12)_Insert_Actions.sql */
/*********************************************************************/
if not exists (select 1 from actions where ac_key = 140)

begin

insert into Actions (AC_Key,AC_Name,AC_Description)
values (140,'ДЦ->Редактировать цены у активированных ценовых блоков','ДЦ->Редактировать цены у активированных ценовых блоков')

end

else

print 'Ошибка! Action с ключем 140 уже есть в базе. Обратитесь в службу поддержки.'

go


update actions set ac_customscript = null where ac_key = 140
GO
/*********************************************************************/
/* end (2012.04.12)_Insert_Actions.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.05.12)_Delete_Actions.sql */
/*********************************************************************/
delete from Actions
where ac_key in (
	83	--Персональные данные->Разрешить управление правами доступа к ПДН
)
go

--10759 tkachuk если у нас есть поле из старой репликации, нам надо сделать его nullable
IF EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE (TABLE_NAME = N'Actions') AND (COLUMN_NAME = N'msrepl_tran_version'))
 ALTER TABLE Actions ALTER COLUMN msrepl_tran_version uniqueidentifier null

go

if (select count(*) from Actions WHERE ac_key=50)=0 begin
--Экшон был ошибочно удален, восстанавливаем
INSERT INTO ACTIONS(AC_KEY,AC_NAME,AC_Description,AC_CustomScript,AC_NameLat) VALUES (50,'Разрешить подтверждать услуги при наступлении релиз-периода',NULL,NULL,'Allow confirming service if relese period come')
end
go

if (select count(*) from Actions WHERE ac_key=51)=0 begin
--Экшон был ошибочно удален, восстанавливаем
INSERT INTO ACTIONS(AC_KEY,AC_NAME,AC_Description,AC_CustomScript,AC_NameLat) VALUES (51,'Разрешить подтверждать услуги при наступлении Stop-Sale',NULL,NULL,'Allow confirming service if Stop-Sale come')
end
go
/*********************************************************************/
/* end (2012.05.12)_Delete_Actions.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.05.12)_Update_UserList.sql */
/*********************************************************************/
UPDATE UserList
SET US_PassMinLength = 6
WHERE ISNULL(US_PassMinLength, 0) < 6

GO
/*********************************************************************/
/* end (2012.05.12)_Update_UserList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.06.01)_CHANGE_AL_Name_ApplicationLogs.sql */
/*********************************************************************/
if  EXISTS (select * from syscolumns where name='AL_Name' and id=object_id('ApplicationLogs')) begin

ALTER TABLE ApplicationLogs ALTER COLUMN AL_Name nvarchar(max) 

end

GO
/*********************************************************************/
/* end (2012.06.01)_CHANGE_AL_Name_ApplicationLogs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.06.04)_Create_Table_CreateLicenseTables.sql */
/*********************************************************************/
IF Not EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ProgramIdentity]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)
	CREATE TABLE [dbo].[ProgramIdentity](
	[PI_ProductFamilyId] [int] NOT NULL,
	[PI_DataBaseGuid] [timestamp] NOT NULL,
	[PI_IsActive] [bit] NULL,
	CONSTRAINT [PK_DataBaseIdentity] PRIMARY KEY CLUSTERED 
	(
		[PI_ProductFamilyId] ASC
	)
	) ON [PRIMARY]

GO

GRANT  SELECT ,  UPDATE ,  INSERT ,  DELETE  ON [dbo].[ProgramIdentity] TO PUBLIC
GO

IF Not EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ProgramIdentitySetting]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[ProgramIdentitySetting](
	[PIS_Id] [int] IDENTITY(1,1) NOT NULL,
	[PIS_ParamName] [nvarchar](50) NOT NULL,
	[PIS_ParamValue] [nvarchar](50) NOT NULL,
	[PIS_CheckSum] [nvarchar](200) NOT NULL,
 CONSTRAINT [PK_ProgramIdentitySettings] PRIMARY KEY CLUSTERED 
(
	[PIS_Id] ASC
)
) ON [PRIMARY]

GO

GRANT  SELECT ,  UPDATE ,  INSERT ,  DELETE  ON [dbo].[ProgramIdentitySetting] TO PUBLIC
GO


IF Not EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[ProgramModule]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[ProgramModule](
	[PM_ID] [int] IDENTITY(1,1) NOT NULL,
	[PM_ProductFamilyId] [int] NOT NULL,
	[PM_ModuleGuid] [nvarchar](50) NOT NULL,
	[PM_ProductCategoryCode] [nvarchar](50) NOT NULL,
	[PM_ExpireDate] [datetime] NOT NULL,
	[PM_MaxConnectionsNum] [int] NOT NULL,
	[PM_CheckSum] [nvarchar](200) NOT NULL,
	[PM_Functions] [nvarchar](50) NULL,
	[PM_Name] [nvarchar](100) NOT NULL,
	[PM_Version] [nvarchar](50)  NULL,
	[PM_Serial] [nvarchar](50) NOT NULL,
 CONSTRAINT [PK_DataBaseModules] PRIMARY KEY CLUSTERED 
(
	[PM_ID] ASC
)
) ON [PRIMARY]
GO

GRANT  SELECT ,  UPDATE ,  INSERT ,  DELETE  ON [dbo].[ProgramModule] TO PUBLIC
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_ProgramModule_ProgramIdentity]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
ALTER TABLE [dbo].[ProgramModule]  WITH CHECK ADD  CONSTRAINT [FK_ProgramModule_ProgramIdentity] FOREIGN KEY([PM_ProductFamilyId])
REFERENCES [dbo].[ProgramIdentity] ([PI_ProductFamilyId])
GO

if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[FK_ProgramModule_ProgramIdentity]')  and OBJECTPROPERTY(id, N'IsForeignKey') = 1) 
ALTER TABLE [dbo].[ProgramModule] CHECK CONSTRAINT [FK_ProgramModule_ProgramIdentity]
GO



/*********************************************************************/
/* end (2012.06.04)_Create_Table_CreateLicenseTables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.06.19)_Delete_SysUsers.sql */
/*********************************************************************/
if exists (select * from master.sys.syslogins where name = 'MegatecLogger')
begin
	Drop LOGIN [MegatecLogger]
END
if exists (select * from sys.sysusers where name = 'MegatecLogger')
begin
	drop USER [MegatecLogger]
END

GO
/*********************************************************************/
/* end (2012.06.19)_Delete_SysUsers.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.06.25)_Delete_T_UpdateDogList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_UpdateDogList]'))
DROP TRIGGER [dbo].[T_UpdateDogList]
GO
/*********************************************************************/
/* end (2012.06.25)_Delete_T_UpdateDogList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.07.11)_Alter_Data_SystemSettings.sql */
/*********************************************************************/
-- добавляем настройку искать по взрослым детям в вебе. По умолчанию она выключена
if not exists (select top 1 SS_ParmValue from SystemSettings where SS_ParmName = 'OnlineFindByAdultChild')
begin
	insert into SystemSettings (SS_ParmName, SS_ParmValue)
	values ('OnlineFindByAdultChild', 0)
end
go
/*********************************************************************/
/* end (2012.07.11)_Alter_Data_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.07.18)_ALTER_BN_INN_Banks.sql */
/*********************************************************************/
ALTER TABLE dbo.Banks
ALTER COLUMN BN_INN varchar(12) NULL
go

ALTER TABLE dbo.Banks
ALTER COLUMN BN_Street varchar(160) NULL
go

/*********************************************************************/
/* end (2012.07.18)_ALTER_BN_INN_Banks.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120413)_CreateTable_ToursPackets.sql */
/*********************************************************************/
-- MEG00040685 13.04.2012 rozin. Добавление услуг в существующую путевку
--<DATE>2012-04-13</DATE>
--<VERSION>2007.2.40.1</VERSION>
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ToursPackets]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].ToursPackets
(
        [TRPK_Id] [int] IDENTITY(1,1) NOT NULL,
        [TRPK_TourId] [int] NOT NULL,
        [TRPK_ExtSrvPkId] [int] NOT NULL,	
        CONSTRAINT [UC_ToursPacketsExtraService] UNIQUE (TRPK_TourId, TRPK_ExtSrvPkId),
        CONSTRAINT [PK_ToursPackets] PRIMARY KEY CLUSTERED 
        (
            [TRPK_Id] ASC
        ) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.ToursPackets TO PUBLIC
END
GO
/*********************************************************************/
/* end (20120413)_CreateTable_ToursPackets.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120425)_CreateTable_HotelPriorities.sql */
/*********************************************************************/
-- 4864 25.04.2012 gorshkov Приоритеты для отелей для SmartSearch
--<DATE>2012-04-13</DATE>
--<VERSION>2007.2.40.1</VERSION>
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[HotelPriorities]') AND type in (N'U'))
	CREATE TABLE [dbo].[HotelPriorities](
		[HP_HDKey] [int] NOT NULL,
		[HP_CountryPriority] [int] NULL,
		[HP_ResortPriority] [int] NULL,
		[HP_CityPriority] [int] NULL,
	 CONSTRAINT [PK_HotelPriorities] PRIMARY KEY CLUSTERED 
	(
		[HP_HDKey] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_HotelPriorities_HotelDictionary]') AND parent_object_id = OBJECT_ID(N'[dbo].[HotelPriorities]'))
	ALTER TABLE [dbo].[HotelPriorities]  WITH NOCHECK ADD  CONSTRAINT [FK_HotelPriorities_HotelDictionary] FOREIGN KEY([HP_HDKey])
	REFERENCES [dbo].[HotelDictionary] ([HD_KEY])
	ON DELETE CASCADE
	NOT FOR REPLICATION 
GO

ALTER TABLE [dbo].[HotelPriorities] CHECK CONSTRAINT [FK_HotelPriorities_HotelDictionary]
GO

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].[HotelPriorities] TO PUBLIC
GO
/*********************************************************************/
/* end (20120425)_CreateTable_HotelPriorities.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120609)_CreateTable_ProTourQuotes.sql */
/*********************************************************************/
-- 09.06.2012 gorshkov Квоты загруженные из сервиса ProTour
--<DATE>2012-06-16</DATE>
--<VERSION>2009.2.13.3</VERSION>
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ProTourQuotes]') AND type in (N'U'))
	CREATE TABLE [dbo].[ProTourQuotes](
		[PTQ_Id] [int] IDENTITY(1,1) NOT NULL,
		[PTQ_PartnerKey] [int] NOT NULL,
		[PTQ_HotelKey] [int] NOT NULL,
		[PTQ_RoomCategoryKey] [int] NOT NULL,
		[PTQ_Date] [datetime] NOT NULL,
		[PTQ_State] [tinyint] NOT NULL,
		[PTQ_CommitmentFree] [int] NOT NULL,
		[PTQ_CommitmentSold] [int] NOT NULL,
		[PTQ_CommitmentTotal] [int] NOT NULL,
		[PTQ_AllotmentFree] [int] NOT NULL,
		[PTQ_AllotmentSold] [int] NOT NULL,
		[PTQ_AllotmentTotal] [int] NOT NULL,
		[PTQ_Release] [int] NOT NULL,
		[PTQ_StopSale] [bit] NOT NULL DEFAULT 0,
		[PTQ_CancelStopSale] [bit] NULL,
	 CONSTRAINT [PK_ProTourQuotes] PRIMARY KEY CLUSTERED
	(
		[PTQ_Id] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_ProTourQuotes_Partners]') AND parent_object_id = OBJECT_ID(N'[dbo].[ProTourQuotes]'))
	ALTER TABLE [dbo].[ProTourQuotes]  WITH NOCHECK ADD CONSTRAINT [FK_ProTourQuotes_Partners] FOREIGN KEY([PTQ_PartnerKey])
	REFERENCES [dbo].[tbl_Partners] ([PR_KEY])
	ON DELETE CASCADE
	NOT FOR REPLICATION 
GO

ALTER TABLE [dbo].[ProTourQuotes] CHECK CONSTRAINT [FK_ProTourQuotes_Partners]
GO

IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_ProTourQuotes_HotelDictionary]') AND parent_object_id = OBJECT_ID(N'[dbo].[ProTourQuotes]'))
	ALTER TABLE [dbo].[ProTourQuotes]  WITH NOCHECK ADD CONSTRAINT [FK_ProTourQuotes_HotelDictionary] FOREIGN KEY([PTQ_HotelKey])
	REFERENCES [dbo].[HotelDictionary] ([HD_KEY])
	ON DELETE CASCADE
	NOT FOR REPLICATION 
GO

ALTER TABLE [dbo].[ProTourQuotes] CHECK CONSTRAINT [FK_ProTourQuotes_HotelDictionary]
GO

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].[ProTourQuotes] TO PUBLIC
GO
/*********************************************************************/
/* end (20120609)_CreateTable_ProTourQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20120821)_Grant_Update_UserList.US_LastLogDate.sql */
/*********************************************************************/
-- Добавление прав на обновление колонки US_LastLogDate таблицы UserList - для записи даты последнего входа
--<DATE>2012-08-21</DATE>
--<VERSION>2009.2.15.1</VERSION>
GRANT UPDATE ON OBJECT::[dbo].[UserList] (US_LastLogDate) TO [avEconomist]
GRANT UPDATE ON OBJECT::[dbo].[UserList] (US_LastLogDate) TO [avSalesManagers]
GRANT UPDATE ON OBJECT::[dbo].[UserList] (US_LastLogDate) TO [avProductManagers]
GRANT UPDATE ON OBJECT::[dbo].[UserList] (US_LastLogDate) TO [avCasher]
GRANT UPDATE ON OBJECT::[dbo].[UserList] (US_LastLogDate) TO [avAdvertiseManagers]
GRANT UPDATE ON OBJECT::[dbo].[UserList] (US_LastLogDate) TO [guests]

go
/*********************************************************************/
/* end (20120821)_Grant_Update_UserList.US_LastLogDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012_05_12)_ADD_Columns_OptionalServiceBooking.sql */
/*********************************************************************/
if not exists(select * from syscolumns where name = 'ED_Url')
	alter table ExcurDictionary add ED_Url [varchar](192) NULL
GO

if not exists(select * from syscolumns where name = 'ED_ShowOrder')
	alter table ExcurDictionary add ED_ShowOrder [int] NOT NULL DEFAULT(0)
GO

if not exists(select * from syscolumns where name = 'TF_Url')
	alter table [Transfer] add TF_Url [varchar](192) NULL
GO

if not exists(select * from syscolumns where name = 'TF_ShowOrder')
	alter table [Transfer] add TF_ShowOrder [int] NOT NULL DEFAULT(0)
GO

if not exists(select * from syscolumns where name = 'A2_Url')
	alter table addDescript2 add A2_Url [varchar](192) NULL
GO

if not exists(select * from syscolumns where name = 'A2_ShowOrder')
	alter table addDescript2 add A2_ShowOrder [int] NOT NULL DEFAULT(0)
GO

if not exists(select * from syscolumns where name = 'SL_Url')
	alter table ServiceList add SL_Url [varchar](192) NULL
GO

if not exists(select * from syscolumns where name = 'SL_ShowOrder')
	alter table ServiceList add SL_ShowOrder [int] NOT NULL DEFAULT(0)
GO
/*********************************************************************/
/* end (2012_05_12)_ADD_Columns_OptionalServiceBooking.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 2012-03-14_alterview_quotes.sql */
/*********************************************************************/

If exists(select * from sysviews where name = 'Quotes')
	DROP VIEW Quotes
GO

CREATE VIEW [dbo].[Quotes]
AS
SELECT     q.QT_PRKey, qo.QO_SVKey AS qt_svkey, qo.QO_SubCode1 AS qt_subcode1, qo.QO_SubCode2 AS subcode2, qo.QO_Code AS qt_code, 
                      qd.QD_Date AS qt_date, qd.QD_Places AS qt_places, qd.QD_Busy AS qt_busy, ISNULL(qp.QP_AgentKey, 0) AS qt_agent, qp.QP_ID AS qt_key, 
                      qd.QD_Release AS qt_release, qp.QP_IsNotCheckIn AS qt_isnotcheckin, qp.QP_Long AS qt_long, q.QT_ByRoom, qd.QD_Type AS qt_type, 
                      qd.QD_CreateDate AS QT_CREATEDATE, qp.QP_LastUpdate AS QT_LastUpdate, qp.QP_CreatorKey AS QT_OWNER, 
                      ISNULL(qp.QP_CheckInPlaces, 0) AS QT_BYCHECKIN, 0 AS QT_PayTerm, '1900-01-01' AS qt_EntryDate
FROM        Quotas q
INNER JOIN QuotaObjects qo ON qo.QO_QTID = q.QT_ID
INNER JOIN QuotaDetails qd ON qd.QD_QTID = q.QT_ID 
INNER JOIN QuotaParts qp ON qp.QP_QDID = qd.QD_ID
GO

grant select,insert,update,delete on dbo.Quotes to public
GO

exec sp_RefreshViewForAll 'Quotes'
GO
/*********************************************************************/
/* end 2012-03-14_alterview_quotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20120315_Add_HI_UserId_History.sql */
/*********************************************************************/
--<DATE>2012-03-15</DATE>
--<VERSION>9.2.1</VERSION>
if not exists(select id from syscolumns where id = OBJECT_ID('History') and name = 'HI_USERID')
 begin
  alter table dbo.History add HI_USERID int NULL default NULL
 end
GO
/*********************************************************************/
/* end 20120315_Add_HI_UserId_History.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20120410_AlterTable_tbl_Partners.sql */
/*********************************************************************/
--MEG00040713 tkachuk Новый столбец для задания порядка сортировки пользователями Мастер-Тура
	
if not exists(select id from syscolumns where id = OBJECT_ID('tbl_Partners') and name = 'pr_sortOrder')
	alter table tbl_Partners add pr_sortOrder int not null default (0)
go
/*********************************************************************/
/* end 20120410_AlterTable_tbl_Partners.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20120410_AlterView_Partners.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='v' and name='Partners')
	drop view dbo.Partners
GO

CREATE VIEW [dbo].[Partners]
AS
SELECT     *
FROM         dbo.tbl_Partners
GO

grant select on [dbo].[Partners] to public
GO

grant update on [dbo].[Partners] to public
GO

grant insert on [dbo].[Partners] to public
GO

grant delete on [dbo].[Partners] to public
GO

exec sp_refreshviewforall [Partners]
GO
/*********************************************************************/
/* end 20120410_AlterView_Partners.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20120704_AlterTablesMWPriceDataTables.sql */
/*********************************************************************/
declare @tableName varchar(256), @sql varchar(max), @viewName varchar(256)

declare priceTablesCursor cursor for
SELECT OBJECT_NAME(OBJECT_ID) as name
FROM sys.dm_db_partition_stats st
WHERE index_id < 2 and OBJECT_NAME(OBJECT_ID) like 'mwPriceDataTable%'
ORDER BY st.row_count asc

open priceTablesCursor
fetch priceTablesCursor into @tableName
while @@FETCH_STATUS = 0
begin
	set @sql = '
	if not exists (select * from syscolumns where name=''pt_directFlightAttribute'' and id=object_id(''dbo.' + @tableName + '''))
	begin
		alter table dbo.' + @tableName + ' add pt_directFlightAttribute [int]
	end
	'
	print (@sql)
	exec (@sql)

	set @sql = '
	if not exists (select * from syscolumns where name=''pt_backFlightAttribute'' and id=object_id(''dbo.' + @tableName + '''))
	begin
		alter table dbo.' + @tableName + ' add pt_backFlightAttribute int
	end
	'
	print(@sql)
	exec (@sql)

	set @viewName = replace(@tableName, 'mwPriceDataTable', 'mwPriceTable')
	exec sp_refreshviewforall @viewName

	fetch priceTablesCursor into @tableName
end
close priceTablesCursor
deallocate priceTablesCursor

GO
/*********************************************************************/
/* end 20120704_AlterTablesMWPriceDataTables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20120706_UpdateTPToursForTourML.sql */
/*********************************************************************/
update tp_tours 
set to_pricecount = (select count(1) from tp_prices with(nolock) where tp_tokey = TO_Key)
where to_pricecount is null
GO
/*********************************************************************/
/* end 20120706_UpdateTPToursForTourML.sql */
/*********************************************************************/

/*********************************************************************/
/* begin Create_TestCalculationPrices.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TestCalculationPrices]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[TestCalculationPrices](
		[TP_Key] [int] NOT NULL,
		[TP_TOKey] [int] NOT NULL,
		[TP_DateBegin] [datetime] NOT NULL,
		[TP_DateEnd] [datetime] NULL,
		[TP_Gross] [float] NULL,
		[TP_TIKey] [int] NOT NULL,
		[TP_CalculatingKey] [int] NULL,
		[TP_Updatedate] [datetime] NULL,
		[TP_TLKey] [int] NOT NULL,
		[TP_IsNewCalculate] [bit] NOT NULL
	 CONSTRAINT [PK_TestCalculationPrices] PRIMARY KEY CLUSTERED 
	(
		[TP_Key] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end Create_TestCalculationPrices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin Create_TestCalculationServiceLists.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TestCalculationServiceLists]') AND type in (N'U'))
begin
CREATE TABLE [dbo].[TestCalculationServiceLists](
	[TL_Key] [int] NOT NULL,
	[TL_TOKey] [int] NOT NULL,
	[TL_TSKey] [int] NOT NULL,
	[TL_TIKey] [int] NOT NULL,
	[TL_CalculatingKey] [int] NOT NULL,
	[TS_SvKey] [int] NOT NULL,
	[TS_Code] [int] NOT NULL,
	[TS_SubCode1] [int] NOT NULL,
	[TS_SubCode2] [int] NOT NULL,
	[TS_OpPartnerKey] [int] NOT NULL,
	[TS_Days] [smallint] NOT NULL
 CONSTRAINT [PK_TestCalculationServiceLists] PRIMARY KEY CLUSTERED 
(
	[TL_Key] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end Create_TestCalculationServiceLists.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetTiHotelKeys.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwGetTiHotelKeys')
	drop function dbo.mwGetTiHotelKeys
GO

create function [dbo].[mwGetTiHotelKeys] (@tikey int) returns varchar(100) 	
as
begin
declare @res varchar(100)
set @res = ''
select 
	@res = @res + isnull(ltrim(str(ts_code)),'') + ','
from 
	tp_services with(nolock) inner join tp_servicelists with(nolock) on tl_tskey = ts_key
where
	ts_svkey = 3 and
	tl_tikey = @tikey
order by
	ts_day

if(len(@res) > 0)
	set @res = substring(@res, 1, len(@res) - 1)

return @res
end
GO

grant exec on [dbo].[mwGetTiHotelKeys] to public
GO
/*********************************************************************/
/* end fn_mwGetTiHotelKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetTiHotelNights.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwGetTiHotelNights')
	drop function dbo.mwGetTiHotelNights
GO

create function [dbo].[mwGetTiHotelNights] (@tikey int) returns varchar(100) 	
as
begin
declare @res varchar(100)
set @res = ''
select 
	@res = @res + isnull(ltrim(str(ts_days)),'') + ','
from 
	tp_services with(nolock) inner join tp_servicelists with(nolock) on tl_tskey = ts_key
where
	ts_svkey = 3 and
	tl_tikey = @tikey
order by
	ts_day

if(len(@res) > 0)
	set @res = substring(@res, 1, len(@res) - 1)

return @res
end
GO

grant exec on [dbo].[mwGetTiHotelNights] to public
GO
/*********************************************************************/
/* end fn_mwGetTiHotelNights.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetTiHotelRoomKeys.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwGetTiHotelRoomKeys')
	drop function dbo.mwGetTiHotelRoomKeys
GO

create function [dbo].[mwGetTiHotelRoomKeys] (@tikey int) returns varchar(100) 	
as
begin
declare @res varchar(100)
set @res = ''
select 
	@res = @res + isnull(ltrim(str(ts_subcode1)),'') + ','
from 
	tp_services with(nolock) inner join tp_servicelists with(nolock) on tl_tskey = ts_key
where
	ts_svkey = 3 and
	tl_tikey = @tikey
order by
	ts_day

if(len(@res) > 0)
	set @res = substring(@res, 1, len(@res) - 1)

return @res
end
GO

grant exec on [dbo].[mwGetTiHotelRoomKeys] to public
GO
/*********************************************************************/
/* end fn_mwGetTiHotelRoomKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetTiNights.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwGetTiNights')
	drop function dbo.mwGetTiNights
GO

create function [dbo].[mwGetTiNights] (@tikey int) returns int 	
as
begin
	declare @nights int,
			@currday int,
			@day int,
			@duration int
	set @nights = 0
	set @currday = 0

	declare curs cursor for
	select ts_day, ts_days
	from tp_servicelists
		inner join tp_services on tl_tskey = ts_key 
	where tl_tikey = @tikey and ts_svkey = 3
	order by ts_day
	open curs

	fetch NEXT from curs
	into @day, @duration

	while @@FETCH_STATUS = 0
	begin
		if @currday <= @day
		begin
			set @nights = @nights + @duration
			set @currday = @day + @duration
		end

		fetch NEXT from curs
		into @day, @duration
	end

	close curs
	deallocate curs

	return @nights
end
GO

grant exec on [dbo].[mwGetTiNights] to public
GO
/*********************************************************************/
/* end fn_mwGetTiNights.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetTiPansionKeys.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwGetTiPansionKeys')
	drop function dbo.mwGetTiPansionKeys
GO

create function [dbo].[mwGetTiPansionKeys] (@tikey int) returns varchar(100) 	
as
begin
declare @res varchar(100)
set @res = ''
select 
	@res = @res + isnull(ltrim(str(ts_subcode2)),'') + ','
from 
	tp_services with(nolock) inner join tp_servicelists with(nolock) on tl_tskey = ts_key
where
	ts_svkey = 3 and
	tl_tikey = @tikey
order by
	ts_day

if(len(@res) > 0)
	set @res = substring(@res, 1, len(@res) - 1)

return @res
end
GO

grant exec on [dbo].[mwGetTiPansionKeys] to public
GO
/*********************************************************************/
/* end fn_mwGetTiPansionKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetTourCharterAttribute.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwGetTourCharterAttribute')
	drop function dbo.mwGetTourCharterAttribute
GO

create function [dbo].[mwGetTourCharterAttribute](@tikey int, @isDirectFlight smallint)
returns int
as
--<VERSION>9.2.13.1</VERSION>
--<DATE>04-07-2012</DATE>
begin
	declare @result int
	set		@result = null

	select TOP 1 
		@result = ts_attribute
	from 
		tp_services 
			inner join dbo.tp_servicelists on tl_tskey = ts_key
			inner join dbo.tp_lists on ti_key = tl_tikey
	where
		ts_svkey = 1 and
		tl_tikey = @tikey and
		(
			(@isDirectFlight > 0 and ts_day <= ti_days / 2)
			or
			(@isDirectFlight = 0 and ts_day > ti_days / 2)
		)
	order by
		ts_day

	return @result
end
GO

GRANT EXEC ON [dbo].[mwGetTourCharterAttribute] TO PUBLIC
GO
/*********************************************************************/
/* end fn_mwGetTourCharterAttribute.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwIsTourAllowedForPublish.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects 
			where id = object_id(N'[dbo].[mwIsTourAllowedForPublish]') 
				and OBJECTPROPERTY(id, N'IsScalarFunction') = 1)
DROP FUNCTION [dbo].[mwIsTourAllowedForPublish] 
GO

-- MEG00040028. 09.02.2012. Golubinsky.
-- Функция проверяет, разрешено ли выставлять указанный тур
-- Анализируются настройки (таблица SystemSettings):
--	mwTourOwners		- ключи менеджеров-владельцев тура, по которым разрешено выставление тура в интернет
--	mwDeniedTourOwners	- ключи менеджеров-владельцев тура, по которым запрещено выставление тура в интернет
-- Действует одно из двух условий: либо заданы ТОЛЬКО разрешенные к выставлению менеджеры туров, 
-- либо, если они не заданы, обрабатываются ТОЛЬКО запрещенные
--<VERSION>ALL</VERSION>
--<DATE>2012-02-09</DATE>
CREATE FUNCTION mwIsTourAllowedForPublish
(
	@TourListKey int	-- ключ тура (tbl_Turlist)
)
RETURNS bit
AS
BEGIN
	-- Declare the return variable
	DECLARE @result as bit

	declare @mwTourOwnersSettingName as varchar(25)
	declare @mwDeniedTourOwnersSettingName as varchar(25)
	
	set @mwTourOwnersSettingName = 'MWTourOwners'
	set @mwDeniedTourOwnersSettingName = 'mwDeniedTourOwners'
	
	declare @mwTourOwnersValue as nvarchar(500)
	declare @mwDeniedTourOwnersValue as nvarchar(500)
	
	-- read settings
	select top 1 @mwTourOwnersValue = rtrim(ltrim(ss_parmvalue)) 
					from systemsettings 
					where ss_parmname = @mwTourOwnersSettingName
					
	select top 1 @mwDeniedTourOwnersValue = rtrim(ltrim(ss_parmvalue)) 
					from systemsettings 
					where ss_parmname = @mwDeniedTourOwnersSettingName
					
	declare @curTourOwner as nvarchar(50)
	
	-- get current tour owner
	select top 1 @curTourOwner = ',' + rtrim(ltrim(str(tl_opkey))) + ',' 
					from TurList where tl_key = @TourListKey
					
	if len(@mwTourOwnersValue) > 0
	begin
		-- check allowed users	
		if (CHARINDEX ( @curTourOwner , ',' + IsNull(@mwTourOwnersValue, '') + ',') > 0)
		begin		
			set @result = 1;		
		end
		else
		begin
			set @result = 0;
		end
	end
	else if len(@mwDeniedTourOwnersValue) > 0
	begin
		-- check denied users
		if (CHARINDEX ( @curTourOwner , ',' + IsNull(@mwDeniedTourOwnersValue, '') + ',') > 0)
		begin		
			set @result = 0;		
		end
		else
		begin
			set @result = 1;
		end
	end
	else
	begin	
		set @result = 1;	
	end

	-- Return the result of the function
	RETURN @result

END
GO

GRANT EXEC ON mwIsTourAllowedForPublish TO public
GO
/*********************************************************************/
/* end fn_mwIsTourAllowedForPublish.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwTourHotelCtKeys.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwTourHotelCtKeys')
	drop function dbo.mwTourHotelCtKeys
GO

create function [dbo].[mwTourHotelCtKeys] (@tourkey int) returns nvarchar(256)
as
begin
	declare @result nvarchar(256)
	set @result = N''

	select @result = @result + rtrim(ltrim(str(tbl.ts_ctkey))) + N', ' from (select distinct ts_ctkey from tp_services with(nolock) where ts_tokey = @tourkey and ts_svkey = 3) tbl 

	declare @len int
	set @len = len(@result)
	if(@len > 0)
		set @result = substring(@result, 1, @len - 1)

	return @result
end
GO

GRANT EXEC ON [dbo].[mwTourHotelCtKeys] TO PUBLIC
GO
/*********************************************************************/
/* end fn_mwTourHotelCtKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwTourHotelCtNames.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwTourHotelCtNames')
	drop function dbo.mwTourHotelCtNames
GO

CREATE function [dbo].[mwTourHotelCtNames] (@tourkey int) returns nvarchar(256)
as
begin
	declare @result varchar(256)
	set @result = N''

	select @result = @result + rtrim(ltrim(ct_name)) + N', ' 
	from (select distinct ct_name 
		from CityDictionary with(nolock)
		where CT_Key in (select distinct ts_ctkey from tp_services with(nolock) where ts_svkey = 3 and ts_tokey = @tourkey)
	) as tbl 
	order by tbl.ct_name

	declare @len int
	set @len = len(@result)
	if(@len > 0)
		set @result = substring(@result, 1, @len - 1)

	return @result
end
GO

GRANT EXEC ON [dbo].[mwTourHotelCtNames] TO PUBLIC
GO
/*********************************************************************/
/* end fn_mwTourHotelCtNames.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwTourHotelKeys.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwTourHotelKeys')
	drop function dbo.mwTourHotelKeys
GO

CREATE function [dbo].[mwTourHotelKeys] (@tourkey int) returns nvarchar(256)
as
begin
	declare @result nvarchar(256)
	set @result = N''

	--select @result = @result + rtrim(ltrim(str(tbl.ti_firsthdkey))) + N', ' from (select distinct ti_firsthdkey from tp_lists where ti_tokey = @tourkey) tbl 
	select @result = @result + rtrim(ltrim(str(tbl.ts_ctkey))) + N', ' from (select distinct ts_ctkey from tp_services with(nolock) where ts_svkey = 3 and ts_tokey = @tourkey) tbl 

	declare @len int
	set @len = len(@result)
	if(@len > 0)
		set @result = substring(@result, 1, @len - 1)

return @result
end
GO

GRANT EXEC ON [dbo].[mwTourHotelKeys] TO PUBLIC
GO
/*********************************************************************/
/* end fn_mwTourHotelKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwTourHotelRsKeys.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='mwTourHotelRsKeys')
	drop function dbo.mwTourHotelRsKeys
GO

CREATE function [dbo].[mwTourHotelRsKeys] (@tourkey int) returns nvarchar(256)
as
begin
	declare @result nvarchar(256)
	set @result = N''

	select @result = @result + rtrim(ltrim(str(tbl.ti_firstrskey))) + N', ' from (select distinct ti_firstrskey from tp_lists with(nolock) where ti_tokey = @tourkey) tbl 

	declare @len int
	set @len = len(@result)
	if(@len > 0)
		set @result = substring(@result, 1, @len - 1)

return @result
end
GO

GRANT EXEC ON [dbo].[mwTourHotelRsKeys] TO PUBLIC
GO
/*********************************************************************/
/* end fn_mwTourHotelRsKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_RoundPrice.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='fn' and name='RoundPrice')
	drop function dbo.RoundPrice
GO
--округляет цену в зависимости от настроек МТ
CREATE function [dbo].[RoundPrice](@roundtype smallint, @cost float) returns float
as
--<VERSION>2009.2.01</VERSION>
--<DATE>2012-02-16</DATE>
begin

declare @ROUND_NOTWITHDISC int
	declare @ROUND_SERVICE_MATH int
	declare @ROUND_SERVICE0_5 int
	declare @ROUND_PRICE0_5 int
	declare @ROUND_SERVICE int
	declare @ROUND_PRICE int
	declare @ROUND_NOT int

	declare @ROUND_NO int
	declare @ROUND_NORMAL int
	declare @ROUND_TOUP int
	declare @ROUND_TODOWN int
	declare @ROUND_TO5 int
	declare @ROUND_TO10 int

	Set @ROUND_NOTWITHDISC = 64
	Set @ROUND_SERVICE_MATH = 32
	Set @ROUND_SERVICE0_5 = 16
	Set @ROUND_PRICE0_5 = 8
	Set @ROUND_SERVICE = 4
	Set @ROUND_PRICE = 2
	Set @ROUND_NOT = 1

	Set @ROUND_NO = 0
	Set @ROUND_NORMAL = 1
	Set @ROUND_TOUP = 2
	Set @ROUND_TODOWN = 3
	Set @ROUND_TO5 = 4
	Set @ROUND_TO10 = 5

	If @roundtype = @ROUND_NOT or @roundtype = @ROUND_NOTWITHDISC
		Return @cost

	declare @rcost int
	set @rcost = round(@cost, 0)

	If @roundtype = @ROUND_SERVICE_MATH
	begin
		Return @rcost
	end

	If @roundtype = @ROUND_PRICE0_5 or @roundtype = @ROUND_SERVICE0_5
	begin
		declare @mod_rcost int
		set @mod_rcost = @rcost % 5

		If @mod_rcost > 0
			Set @rcost = @rcost + 5 - @mod_rcost
	end
	Else
	If @rcost < @cost
		Set @rcost = @rcost + 1

	Return @rcost
end
GO

grant exec on [dbo].[RoundPrice] to public
GO
/*********************************************************************/
/* end fn_RoundPrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin GrantUpdatemwPriceDataTable.sql */
/*********************************************************************/
declare @mwSearchType int
select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
where SS_ParmName = 'MWDivideByCountry'

if(@mwSearchType = 0)
begin
	grant update on dbo.mwPriceDataTable to public
	grant update on dbo.mwPriceTable to public
end
else
begin
	declare @tableName varchar(256)
	declare @sql nvarchar(max)
	declare @cnKey int, @ctKeyFrom int
	declare priceCursor cursor local fast_forward for
	select distinct pt_cnkey, pt_ctkeyfrom from mwPriceDataTable with(nolock)
	
	open priceCursor
	fetch next from priceCursor into @cnKey, @ctKeyFrom
	while @@FETCH_STATUS = 0
	begin
		set @tableName = dbo.mwGetPriceViewName(@cnKey, @ctKeyFrom)
		
		set @sql = 'grant update on ' + @tableName + ' to public'
		exec(@sql)
		
		fetch next from priceCursor into @cnKey, @ctKeyFrom
	end
	
	close priceCursor
	deallocate priceCursor
end
GO
/*********************************************************************/
/* end GrantUpdatemwPriceDataTable.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_IX_Paging.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[CacheQuotas]') AND name = N'IX_Paging')
begin
	DROP INDEX [IX_Paging] ON [dbo].[CacheQuotas] WITH ( ONLINE = OFF )
end
GO

CREATE NONCLUSTERED INDEX [IX_Paging] ON [dbo].[CacheQuotas] 
(
	[cq_svkey] ASC,
	[cq_code] ASC,
	[cq_date] ASC,
	[cq_day] ASC,
	[cq_prkey] ASC,
	[cq_pkkey] ASC,
	[cq_findFlight] ASC,
	[cq_places] ASC
)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, FILLFACTOR = 70, ONLINE = OFF) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_IX_Paging.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_IX_Search.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[CacheQuotas]') AND name = N'IX_Search')
begin
	DROP INDEX [IX_Search] ON [dbo].[CacheQuotas] WITH ( ONLINE = OFF )
end
GO

CREATE NONCLUSTERED INDEX [IX_Search] ON [dbo].[CacheQuotas] 
(
	[cq_svkey] ASC,
	[cq_code] ASC,
	[cq_rmkey] ASC,
	[cq_rckey] ASC,
	[cq_date] ASC,
	[cq_day] ASC,
	[cq_days] ASC,
	[cq_prkey] ASC,
	[cq_pkkey] ASC
)
INCLUDE 
(
	[cq_places],
	[cq_findFlight]
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, FILLFACTOR = 70) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_IX_Search.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_load_tourists_ServiceByDate.sql */
/*********************************************************************/
if not exists ( select * from sysindexes where id = object_id(N'[dbo].[ServiceByDate]') and name = N'x_load_tourists' )
	CREATE NONCLUSTERED INDEX [x_load_tourists] ON [dbo].[ServiceByDate] 
	(
		[SD_DLKey] ASC
	)
	INCLUDE ( [SD_Date],
	[SD_RLID],
	[SD_ID],
	[SD_QPID],
	[SD_TUKey],
	[SD_RPID],
	[SD_State])
	GO
GO

/*********************************************************************/
/* end INDEX_ADD_x_load_tourists_ServiceByDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_Payments_DateDeleted.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_date_deleted' and id = object_id(N'Payments'))
	CREATE NONCLUSTERED INDEX [x_date_deleted]
	ON [dbo].[Payments] ([PM_POId],[PM_IsDeleted],[PM_Date])
GO
/*********************************************************************/
/* end INDEX_ADD_x_Payments_DateDeleted.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_TP_PriceComponents_PC_TPKey.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'TP_PriceComponents_PC_TPKey')
begin
	CREATE NONCLUSTERED INDEX [TP_PriceComponents_PC_TPKey] ON [dbo].[TP_PriceComponents] 
	(
		[PC_TPKey] ASC
	)
	INCLUDE ( [PC_Id],
	[PC_TOKey],
	[PC_TourDate],
	[PC_Days],
	[SCPId_1],
	[SCPId_2],
	[SCPId_3],
	[SCPId_4],
	[SCPId_5],
	[SCPId_6],
	[SCPId_7],
	[SCPId_8],
	[SCPId_9],
	[SCPId_10],
	[SCPId_11],
	[SCPId_12],
	[SCPId_13],
	[SCPId_14],
	[SCPId_15],
	[SVKey_1],
	[SVKey_2],
	[SVKey_3],
	[SVKey_4],
	[SVKey_5],
	[SVKey_6],
	[SVKey_7],
	[SVKey_8],
	[SVKey_9],
	[SVKey_10],
	[SVKey_11],
	[SVKey_12],
	[SVKey_13],
	[SVKey_14],
	[SVKey_15]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_TP_PriceComponents_PC_TPKey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_TP_ServicePriceActualDate_AutoOnline_TP_ServicePriceActualDate.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='X_TP_ServicePriceActualDate_AutoOnline' and id = object_id(N'TP_ServicePriceActualDate'))
	CREATE NONCLUSTERED INDEX [X_TP_ServicePriceActualDate_AutoOnline] ON [dbo].[TP_ServicePriceActualDate] 
	(
		[SPAD_SaleDate] ASC,
		[SPAD_AutoOnline] ASC,
		[SPAD_NeedApply] ASC
	)
	INCLUDE ( [SPAD_Id],
	[SPAD_SCPId],
	[SPAD_IsCommission],
	[SPAD_Rate],
	[SPAD_Gross],
	[SPAD_DateLastChange],
	[SPAD_DateLastCalculate]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_X_TP_ServicePriceActualDate_AutoOnline_TP_ServicePriceActualDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_TP_ServicePriceActualDate_SCPId.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_ServicePriceActualDate]') AND name = N'X_TP_ServicePriceActualDate_SCPId')
begin
	CREATE NONCLUSTERED INDEX [X_TP_ServicePriceActualDate_SCPId] ON [dbo].[TP_ServicePriceActualDate] 
	(
		[SPAD_SaleDate] ASC,
		[SPAD_SCPId] ASC
	)
	INCLUDE ( [SPAD_Netto],
	[SPAD_Gross]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end INDEX_ADD_X_TP_ServicePriceActualDate_SCPId.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_TourMarginActualDate_TO_Key.sql */
/*********************************************************************/
if not exists (select 1 from sysindexes where name='x_TP_TourMarginActualDate_TR_Key' and id = object_id(N'TP_TourMarginActualDate'))
	CREATE NONCLUSTERED INDEX [x_TP_TourMarginActualDate_TR_Key] ON [dbo].[TP_TourMarginActualDate] 
	(
		[TMAD_TRKey],
		[TMAD_SvKey],
		[TMAD_DateCheckIn],
		[TMAD_Long]
	)
	INCLUDE 
	(
		[TMAD_Percent],
		[TMAD_IsCommission],
		[TMAD_NeedApply]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_x_TP_TourMarginActualDate_TO_Key.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TurList_Search.sql */
/*********************************************************************/
-- для поиска туров в экране комиссий

if not exists ( select * from sysindexes where id = object_id(N'[dbo].[tbl_TurList]') and name = N'x_TurList_Search' )
  CREATE INDEX x_TurList_Search
    ON tbl_TURLIST (TL_KEY) INCLUDE (TL_DELETED, TL_TIP, TL_CNKEY);
GO

/*********************************************************************/
/* end INDEX_ADD_x_TurList_Search.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INSERT_FileHeadersDocType_Name_SPO.sql */
/*********************************************************************/
-- добавляет в табл. FileHeadersDocType запись с именем 'SPO'

IF NOT EXISTS (SELECT TOP(1) ft_key FROM FileHeadersDocType WHERE FT_NameLat LIKE 'SPO')
BEGIN
	INSERT INTO dbo.FileHeadersDocType(FT_Name, FT_NameLat) VALUES ('SPO', 'SPO')
END
GO

/*********************************************************************/
/* end INSERT_FileHeadersDocType_Name_SPO.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CheckConsistency.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckConsistency]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckConsistency]
GO
CREATE procedure [dbo].[CheckConsistency] 
AS
begin
--<VERSION>2007.2.39.1</VERSION>
-- .6 Gen 25.04.2012 исключить проверку на корректность для заказов с пакетами 'FLIGHT%'
-- .5 Gen 09.04.2012 исключить из поиска туры с наименованием Индивидуальн% и поставщика 44678
-- .4 (MEG00030677) добавил проверку на отсутствие кода синхронизации по отелю
-- .3 добавил проверку на отсутствие кода синхронизации по размещению
-- .2 добавил проверку поиска неаннулированных услуг в аннулированных путевках
DECLARE @StateDouble int, @StateNotConsistent int, @StateSyncError int, @DGKey int, @DGCode varchar(20)
SELECT	@StateDouble=CAST(ILR_StatusKeys as int) FROM	ILReferenceNew	WHERE ILR_Key=6
SELECT	@StateNotConsistent=CAST(ILR_StatusKeys as int) FROM	ILReferenceNew	WHERE ILR_Key=7
SET @StateSyncError=16 -- 'Нет кода синхронизации'
--print @StateDouble

--------------------------------------------------
declare @ProtourCountryKeysSetting nvarchar(max)

set @ProtourCountryKeysSetting = (select SS_ParmValue from SystemSettings
								 where SS_ParmName = 'ProtourCountryKeys')

declare @CountryKeys as table (CNKey int)

if @ProtourCountryKeysSetting <> ''
begin
	insert @CountryKeys 
	select * 
	from ParseKeys(@ProtourCountryKeysSetting)
end
--------------------------------------------------

DECLARE cur_4 CURSOR LOCAL FOR 
(
select DG_Code,DG_Key from Dogovor with(nolock) where DG_TurDate>GetDate() 
and DG_Sor_Code not in (@StateDouble,@StateNotConsistent) and DG_Sor_Code not in (SELECT OS_Code FROM Order_Status WHERE OS_Global=2) 
and DG_NMen!=(select count(1) from Turist with(nolock) Where TU_DGKey=DG_Key and TU_DGCod=DG_Code)
and NOT EXISTS (SELECT 1 FROM HISTORY WHERE HI_DGCod=DG_Code AND HI_Date BETWEEN DATEADD(MINUTE,-10,GetDate()) AND GetDate() )
-- Gen 25.04.2012
and NOT DG_TRKEY in (select TL_KEY from dbo.tbl_TurList where TL_NAME like 'FLIGHT%')
-- end 25.04.2012 
union 
select DG_Code,DG_Key from Dogovor with(nolock) where DG_TurDate>GetDate() 
and DG_Sor_Code not in (@StateDouble,@StateNotConsistent) and DG_Sor_Code not in (SELECT OS_Code FROM Order_Status WHERE OS_Global=2) 
and EXISTS (SELECT 1 FROM DogovorList with(nolock) where DL_SVKey in (2,3) and DL_DGKey=DG_Key and DL_DGCod=DG_Code and DL_TurDate>GetDate() and DL_Nmen!=(select count(1) from TuristService with(nolock) Where TU_DLKey=DL_Key))
and NOT EXISTS (SELECT 1 FROM HISTORY WHERE HI_DGCod=DG_Code AND HI_Date BETWEEN DATEADD(MINUTE,-10,GetDate()) AND GetDate() )
-- Gen 25.04.2012
and NOT DG_TRKEY in (select TL_KEY from dbo.tbl_TurList where TL_NAME like 'FLIGHT%')
-- end 25.04.2012 
)
union
select DG_Code,DG_Key from Dogovor where exists (select 1 from dogovorlist where dl_dgkey=dg_key and dl_datebeg > GetDate()) and dg_turdate='30-DEC-1899'
-- Gen 25.04.2012
and NOT DG_TRKEY in (select TL_KEY from dbo.tbl_TurList where TL_NAME like 'FLIGHT%')
-- end 25.04.2012 

OPEN cur_4
FETCH NEXT FROM cur_4 INTO @DGCode,@DGKey
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.InsHistory @DGCode, @DGKey, 1, @DGKey, 'UPD', 'Целостность данных нарушена', '', 0, ''
	UPDATE Dogovor SET DG_Sor_Code=@StateNotConsistent WHERE DG_Key=@DGKey and DG_Sor_Code!=@StateNotConsistent
	FETCH NEXT FROM cur_4 INTO @DGCode,@DGKey
END
CLOSE cur_4
DEALLOCATE cur_4

DECLARE @SyncError_Type smallint -- (1- Нет кода размещения, 2- Нет кода отеля)
DECLARE cur_6 CURSOR LOCAL FOR 
SELECT DISTINCT DG_Code,DG_Key,1 FROM Dogovor,DogovorList WHERE DG_ProTourFlag is null and 
	DG_TurDate > GetDate() and DG_SOR_Code not in (@StateDouble,@StateNotConsistent,@StateSyncError)
	and NOT EXISTS (SELECT 1 FROM HISTORY with (nolock) WHERE HI_DGCod=DG_Code AND HI_Date BETWEEN DATEADD(MINUTE,-12,GetDate()) AND GetDate() )
	and DL_DGKey=DG_Key and DL_SVKey=3 
	and DL_SubCode1 not in (SELECT MP_IntKey FROM Mappings WHERE MP_TableID=13 and MP_IntKey=DL_SubCode1)
	and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
	-- Gen 09.04.2012 
	and DG_TRKEY <> 0
	and NOT EXISTS (SELECT 1 FROM dbo.tbl_DogovorList with (nolock) WHERE DL_DGCOD=DG_CODE and DL_SVKEY = 3 and DL_PARTNERKEY = 44678)
	-- end 09.04.2012 
UNION
SELECT DISTINCT DG_Code,DG_Key,2 FROM Dogovor,DogovorList WHERE DG_ProTourFlag is null and 
	DG_TurDate > GetDate() and DG_SOR_Code not in (@StateDouble,@StateNotConsistent,@StateSyncError)
	and NOT EXISTS (SELECT 1 FROM HISTORY with (nolock) WHERE HI_DGCod=DG_Code AND HI_Date BETWEEN DATEADD(MINUTE,-12,GetDate()) AND GetDate() )
	and DL_DGKey=DG_Key and DL_SVKey=3 
	and DL_Code not in (SELECT MP_IntKey FROM Mappings WHERE MP_TableID=12 and MP_IntKey=DL_Code)
	and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
	-- Gen 09.04.2012 
	and DG_TRKEY <> 0
	and NOT EXISTS (SELECT 1 FROM dbo.tbl_DogovorList with (nolock) WHERE DL_DGCOD=DG_CODE and DL_SVKEY = 3 and DL_PARTNERKEY = 44678)
	-- end 09.04.2012 
OPEN cur_6
FETCH NEXT FROM cur_6 INTO @DGCode,@DGKey,@SyncError_Type
WHILE @@FETCH_STATUS = 0
BEGIN
	IF @SyncError_Type=1
		EXEC dbo.InsHistory @DGCode, @DGKey, 1, @DGKey, 'UPD', 'Нет кода синхронизации для размещения', '', 0, ''
	ELSE IF @SyncError_Type=2
		EXEC dbo.InsHistory @DGCode, @DGKey, 1, @DGKey, 'UPD', 'Нет кода синхронизации для отеля', '', 0, ''
	UPDATE Dogovor SET DG_Sor_Code=@StateSyncError WHERE DG_Key=@DGKey and DG_Sor_Code!=@StateSyncError
	FETCH NEXT FROM cur_6 INTO @DGCode,@DGKey,@SyncError_Type
END
CLOSE cur_6
DEALLOCATE cur_6
end
GO

grant exec on [dbo].[CheckConsistency] to public
go
/*********************************************************************/
/* end sp_CheckConsistency.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CheckQuotaExist.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckQuotaExist]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckQuotaExist]
GO

CREATE PROCEDURE [dbo].[CheckQuotaExist]
(
--<VERSION>2008.1.03.13a</VERSION>
	@SVKey int,
	@Code int,
	@SubCode1 int,
	@DateBeg datetime, 
	@DateEnd datetime,
	@DateFirst datetime,
	@PRKey int,
	@AgentKey int,
	@TourDuration smallint,
	@FilialKey int,				--пока не обрабатывается 
	@CityDepartment int,		--пока не обрабатывается 
	--возвращаемые параметры
	--при наличии Stop-Sale возвращаем

--	Убрал, не нужны более
--	@StopExist int output, --ключ стопа
--	@StopDate smalldatetime output, --дата стопа 

	--переехали из [CheckQuotaInfo]
	@TypeOfResult smallint =null,			
	/*	тип результата 
			0-возвращение полной таблицы данных (без фильтров) используется в экране проверки мест, 
			1-информация о первой подходящей квоте, 
			2-максимальное доступное число мест по всем квотам */	
	@Pax smallint =null,					--кол-во туристов по услуге
	--возвращаемые параметры, в случае @TypeOfResult=2 (попытка проверить возможность постановки услуги на квоту)
	@Wait smallint =null, --в случае не надо снимать квоту,
	@Quota_CheckState smallint =null output,
	/*	0 - RQ (можно бронировать только под запрос)
		1 - OK (можно посадить на квоту)
		2 - STOP (стоп, мест на сущ.квотах недостаточно)
		3 - RELEASE (стопа нет, есть релиз, мест на сущ.квотах недостаточно)	*/
	@Quota_CheckDate smalldatetime =null output,
	/*  если @Quota_Check=2, то в этом поле дата на которую стоит стоп */
	@Quota_CheckInfo smallint =null output,
	/*  если @Quota_Check in (0,3), то в этом поле сколько мест не хватает */

	--возвращаемые параметры, в случае @TypeOfResult=1 (возвращаем характеристики оптимальной квоты)
	@Quota_Count int =null output,
	@Quota_AgentKey int =null output,
	@Quota_Type smallint =null output,
	@Quota_ByRoom bit =null output,
	@Quota_PRKey int =null output, 
	@Quota_FilialKey int =null output,
	@Quota_CityDepartments int =null output,
	@Quota_Duration smallint =null output,
	@Quota_SubCode1 int =null output,
	@Quota_SubCode2 int =null output
	
) AS
if (@Wait=1 AND @TypeOfResult=2)
BEGIN
	set @Quota_CheckState=0
	return 0
end
declare @quoted smallint
select @quoted = isnull(SV_Quoted, 0) from Service where SV_Key = @SVKEY
if (@quoted = 0)
BEGIN
	set @Quota_CheckState=1
	return 0
end
Set @DateFirst=ISNULL(@DateFirst,@DateBeg)

declare @LimitAgentQuote bit, @LimitQuoteLong bit
set @LimitAgentQuote = 0
set @LimitQuoteLong = 0

IF EXISTS(SELECT top 1 1 FROM dbo.SystemSettings WHERE SS_ParmName='SYSLimitAgentQuote' and SS_ParmValue = 1)
	set @LimitAgentQuote = 1
IF EXISTS(SELECT top 1 1 FROM dbo.SystemSettings WHERE SS_ParmName='SYSLimitQuoteLong' and SS_ParmValue = 1)
	set @LimitQuoteLong = 1

--Проверка отсутствия Стопа
declare @StopExist int, @StopDate smalldatetime

exec CheckStopInfo 1,null,@SVKey,@Code,@SubCode1,@PRKey,@DateBeg,@DateEnd,@StopExist output,@StopDate output

declare @Q_QTID int, @Q_Partner int, @Q_ByRoom int, @Q_Type int, @Q_Release int, 
		@Q_FilialKey int, @Q_CityDepartments int, @Q_AgentKey int, @Q_Duration smallint,
		@Q_Places smallint, @ServiceWithDuration bit, @SubQuery varchar(5000), @Query varchar(5000),
		@Q_SubCode1 int, @Q_SubCode2 int, @Q_QTID_Prev int, @DaysCount int

SET @DaysCount=DATEDIFF(DAY,@DateBeg,@DateEnd)+1
SET @Q_QTID_Prev=0

SELECT @ServiceWithDuration=ISNULL(SV_IsDuration,0) FROM [Service] WHERE SV_Key=@SVKey
IF @ServiceWithDuration=1
	SET @TourDuration=DATEDIFF(DAY,@DateBeg,@DateEnd)+1

-- karimbaeva 28-04-2012 чтобы не выводилось сообщение о недостатке квоты на дополнительное место, если квота последняя и размещение на номер 
IF @SVKey=3 and exists(SELECT TOP 1 1 FROM QuotaObjects, Quotas, QuotaDetails, QuotaParts, HotelRooms WHERE QD_QTID=QT_ID and QD_ID=QP_QDID and QO_QTID=QT_ID
	and HR_Key=@SubCode1 and HR_MAIN=0 and QT_ByRoom = 1 and (QP_AgentKey=@AgentKey or QP_AgentKey is null)
	and (QT_PRKey=@PRKey or QT_PRKey=0) and QO_Code=@Code and QD_Date between @DateBeg and @DateEnd and QP_Date = QD_Date
	and QP_ID in (select SD_QPID
					from ServiceByDate as SBD2 join RoomPlaces as RP2 on SBD2.SD_RPID = RP2.RP_ID
					where RP2.RP_Type = 0))
begin
	set @Quota_CheckInfo = 0
	Set @Quota_CheckState = 1
	If @StopExist > 0
	BEGIN
		Set @Quota_CheckState = 2						
		Set @Quota_CheckDate = @StopDate
	END
	return 0
end
	
-- создаем таблицу со стопами
CREATE TABLE #StopSaleTemp
(SST_Code int, SST_SubCode1 int, SST_SubCode2 int, SST_QOID int, SST_PRKey int, SST_Date smalldatetime,
SST_QDID int, SST_Type smallint, SST_State smallint, SST_Comment varchar(255)
)

INSERT INTO #StopSaleTemp exec dbo.GetTableQuotaDetails NULL, @Q_QTID, @DateBeg, @DaysCount, null, null, @SVKey, @Code, @SubCode1, @PRKey

IF @SVKey=3
BEGIN
	declare CheckQuotaExistСursor cursor for 
		select	DISTINCT QT_ID, QT_PRKey, QT_ByRoom, 
				QD_Type, 
				QP_FilialKey, QP_CityDepartments, QP_AgentKey, CASE WHEN QP_Durations='' THEN 0 ELSE @TourDuration END, QP_FilialKey, QP_CityDepartments, 
				QO_SubCode1, QO_SubCode2
		from	QuotaObjects, Quotas, QuotaDetails, QuotaParts, HotelRooms
		where	QO_SVKey=@SVKey and QO_Code=@Code and HR_Key=@SubCode1 and (QO_SubCode1=HR_RMKey or QO_SubCode1=0) and (QO_SubCode2=HR_RCKey or QO_SubCode2=0) and QO_QTID=QT_ID
			and QD_QTID=QT_ID and QD_Date between @DateBeg and @DateEnd
			and QP_Date = QD_Date
			and QP_QDID = QD_ID
			and (QP_AgentKey=@AgentKey or QP_AgentKey is null) 
			and (QT_PRKey=@PRKey or QT_PRKey=0)
			and QP_IsDeleted is null and QD_IsDeleted is null	
			and (QP_Durations = '' or @TourDuration in (Select QL_Duration From QuotaLimitations Where QL_QPID=QP_ID))
			and not exists(select top 1 1
							from #StopSaleTemp 
							where SST_PRKey = QT_PRKey
							and SST_QOID = QO_ID
							and SST_QDID = QD_ID
							and SST_Date = QD_Date
							and SST_State is not null)
		group by QT_ID, QT_PRKey, QT_ByRoom, QD_Type, QP_FilialKey, QP_CityDepartments, QP_AgentKey, QP_Durations, QO_SubCode1, QO_SubCode2
		--having Count(*) = (@Days+1)
		order by QP_AgentKey DESC, QT_PRKey DESC
END
ELSE
BEGIN
	declare CheckQuotaExistСursor cursor for 
		select	DISTINCT QT_ID, QT_PRKey, QT_ByRoom, 
				QD_Type, 
				QP_FilialKey, QP_CityDepartments, QP_AgentKey, CASE WHEN QP_Durations='' THEN 0 ELSE @TourDuration END, QP_FilialKey, QP_CityDepartments, 
				QO_SubCode1, QO_SubCode2
		from	QuotaObjects, Quotas, QuotaDetails, QuotaParts
		where	
			QO_SVKey = @SVKey and QO_Code = @Code and (QO_SubCode1=@SubCode1 or QO_SubCode1=0) and QO_QTID=QT_ID
			and QD_QTID = QT_ID and QD_Date between @DateBeg and @DateEnd
			and QP_QDID = QD_ID
			and QP_Date = QD_Date
			and (QP_AgentKey=@AgentKey or QP_AgentKey is null) 
			and (QT_PRKey=@PRKey or QT_PRKey=0)
			and QP_IsDeleted is null and QD_IsDeleted is null	
			and (QP_Durations = '' or @TourDuration in (Select QL_Duration From QuotaLimitations Where QL_QPID=QP_ID))
			and not exists(select top 1 1
							from #StopSaleTemp 
							where SST_PRKey = QT_PRKey
							and SST_QOID = QO_ID
							and SST_QDID = QD_ID
							and SST_Date = QD_Date
							and SST_State is not null)
		group by QT_ID, QT_PRKey, QT_ByRoom, QD_Type, QP_FilialKey, QP_CityDepartments, QP_AgentKey, QP_Durations, QO_SubCode1, QO_SubCode2
		order by QP_AgentKey DESC, QT_PRKey DESC
END
open CheckQuotaExistСursor
fetch CheckQuotaExistСursor into	@Q_QTID, @Q_Partner, @Q_ByRoom, 
									@Q_Type, 
									@Q_FilialKey, @Q_CityDepartments, @Q_AgentKey, @Q_Duration, @Q_FilialKey, @Q_CityDepartments, 
									@Q_SubCode1, @Q_SubCode2

CREATE TABLE #Tbl (	TMP_Count int, TMP_QTID int, TMP_AgentKey int, TMP_Type smallint, TMP_Date datetime, 
					TMP_ByRoom bit, TMP_Release smallint, TMP_Partner int, TMP_Durations nvarchar(25) COLLATE Cyrillic_General_CI_AS, TMP_FilialKey int, 
					TMP_CityDepartments int, TMP_SubCode1 int, TMP_SubCode2 int)

While (@@fetch_status = 0)
BEGIN
	SET @SubQuery = 'QD_QTID = QT_ID and QP_QDID = QD_ID 
		and QT_ID=' + CAST(@Q_QTID as varchar(10)) + '
		and QT_ByRoom=' + CAST(@Q_ByRoom as varchar(1)) + ' 
		and QD_Type=' + CAST(@Q_Type as varchar(1)) + ' 
		and QO_SVKey=' + CAST(@SVKey as varchar(10)) + '
		and QO_Code=' + CAST(@Code as varchar(10)) + ' 
		and QO_SubCode1=' + CAST(@Q_SubCode1 as varchar(10)) + ' 
		and QO_SubCode2=' + CAST(@Q_SubCode2 as varchar(10)) + '	
		and (QD_Date between ''' + CAST((@DateBeg) as varchar(20)) + ''' and ''' + CAST(@DateEnd as varchar(20)) + ''') and QD_IsDeleted is null'

	IF @Q_FilialKey is null
		SET @SubQuery = @SubQuery + ' and QP_FilialKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_FilialKey=' + CAST(@Q_FilialKey as varchar(10))
	IF @Q_CityDepartments is null
		SET @SubQuery = @SubQuery + ' and QP_CityDepartments is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_CityDepartments=' + CAST(@Q_CityDepartments as varchar(10))
	IF @Q_AgentKey is null
		SET @SubQuery = @SubQuery + ' and QP_AgentKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_AgentKey=' + CAST(@Q_AgentKey as varchar(10))		
	IF @Q_Duration=0
		SET @SubQuery = @SubQuery + ' and QP_Durations = '''' '
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_ID in (Select QL_QPID From QuotaLimitations Where QL_Duration=' + CAST(@Q_Duration as varchar(5)) + ') '
	IF @Q_Partner =''
		SET @SubQuery = @SubQuery + ' and QT_PRKey = '''' '
	ELSE
		SET @SubQuery = @SubQuery + ' and QT_PRKey=' + CAST(@Q_Partner as varchar(10))

	declare @SubCode2 int

	SET @Query = 
	'
	INSERT INTO #Tbl (	TMP_Count, TMP_QTID, TMP_AgentKey, TMP_Type, TMP_Date, 
						TMP_ByRoom, TMP_Release, TMP_Partner, TMP_Durations, TMP_FilialKey, 
						TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2)
		SELECT	DISTINCT QP_Places-QP_Busy as d1, QT_ID, QP_AgentKey, QD_Type, QD_Date, 
				QT_ByRoom, QD_Release, QT_PRKey, QP_Durations, QP_FilialKey,
				QP_CityDepartments, QO_SubCode1, QO_SubCode2
		FROM	Quotas QT1, QuotaDetails QD1, QuotaParts QP1, QuotaObjects QO1, #StopSaleTemp
		WHERE	QO_ID = SST_QOID and QD_ID = SST_QDID and SST_State is null and ' + @SubQuery
	print @Query

	exec (@Query)
	
	SET @Q_QTID_Prev=@Q_QTID
	fetch CheckQuotaExistСursor into	@Q_QTID, @Q_Partner, @Q_ByRoom, 
										@Q_Type, 
										@Q_FilialKey, @Q_CityDepartments, @Q_AgentKey, @Q_Duration, @Q_FilialKey, @Q_CityDepartments, 
										@Q_SubCode1, @Q_SubCode2	
END

/*
Обработаем настройки
						При наличии квоты на агенство, запретить бронирование из общей квоты
						При наличии квоты на продолжительность, запретить бронировать из квоты без продолжительности
*/

-- если стоят 2 настройки и параметры пришли и на продолжительность и на агенство и есть такая квота сразу на агенство и на продолжительность,
-- то удалим остальные
if ((@LimitAgentQuote = 1) and (@LimitQuoteLong = 1))
begin
	if ((isnull(@AgentKey, 0) != 0) and (isnull(@TourDuration, 0) != 0) and (exists (select top 1 1 from #Tbl where isnull(TMP_AgentKey, 0) = @AgentKey and isnull(TMP_Durations, 0) = @TourDuration)))
	begin
		delete #Tbl where isnull(TMP_AgentKey, 0) != @AgentKey or isnull(TMP_Durations, 0) != @TourDuration
	end
	
	--бывают случаии когда обе настройки включены, но найти нужно только по одному из параметров
	if (exists (select top 1 1 from #Tbl where isnull(TMP_AgentKey, 0) = @AgentKey))
	begin
		delete #Tbl where isnull(TMP_AgentKey, 0) != @AgentKey
	end
	if (exists (select top 1 1 from #Tbl where isnull(TMP_Durations, 0) = @TourDuration))
	begin
		delete #Tbl where isnull(TMP_Durations, 0) != @TourDuration
	end
end
-- если стоит настройка только на агенство и нам пришол параметром агенство и квота на агенство есть,
-- то удалим остальные
else if ((@LimitAgentQuote = 1) and (@LimitQuoteLong = 0) and (isnull(@AgentKey, 0) != 0) and (exists (select top 1 1 from #Tbl where isnull(TMP_AgentKey, 0) = @AgentKey)))
begin
	delete #Tbl where isnull(TMP_AgentKey, 0) != @AgentKey
end
-- если есть настройка на продолжительность, и нам пришол параметр продолжительность и есть квота на продолжительность,
-- то удалим остальные
else if ((@LimitAgentQuote = 0) and (@LimitQuoteLong = 1) and (isnull(@TourDuration, 0) != 0) and (exists (select top 1 1 from #Tbl where isnull(TMP_Durations, 0) = @TourDuration)))
begin
	delete #Tbl where isnull(TMP_Durations, 0) != @TourDuration	
end

DELETE FROM #Tbl WHERE exists 
		(SELECT top 1 1  FROM QuotaParts QP2, QuotaDetails QD2, Quotas QT2 
		WHERE	QT_ID=QD_QTID and QP_QDID=QD_ID
				and QD_Type=TMP_Type and QT_ByRoom=TMP_ByRoom
				and QD_IsDeleted is null and QP_IsDeleted is null
				and QT_ID=TMP_QTID
				and ISNULL(QP_FilialKey,-1)=ISNULL(TMP_FilialKey,-1) and ISNULL(QP_CityDepartments,-1)=ISNULL(TMP_CityDepartments,-1)
				and ISNULL(QP_AgentKey,-1)=ISNULL(TMP_AgentKey,-1) and ISNULL(QT_PRKey,-1)=ISNULL(TMP_Partner,-1)
				and QP_Durations=TMP_Durations and ISNULL(QD_Release,-1)=ISNULL(TMP_Release,-1)
				and QD_Date=@DateFirst and (QP_IsNotCheckIn=1 or QP_CheckInPlaces-QP_CheckInPlacesBusy <= 0))

close CheckQuotaExistСursor
deallocate CheckQuotaExistСursor

DECLARE @Tbl_DQ Table 
 		(TMP_Count smallint, TMP_AgentKey int, TMP_Type smallint, TMP_ByRoom bit, 
				TMP_Partner int, TMP_Duration smallint, TMP_FilialKey int, TMP_CityDepartments int,
				TMP_SubCode1 int, TMP_SubCode2 int, TMP_ReleaseIgnore bit)

DECLARE @DATETEMP datetime
SET @DATETEMP = GetDate()
-- Разрешим посадить в квоту с релиз периодом 0 текущим числом
set @DATETEMP = DATEADD(day, -1, @DATETEMP)
if exists (select top 1 1 from systemsettings where SS_ParmName='SYSCheckQuotaRelease' and SS_ParmValue=1) OR exists (select top 1 1 from systemsettings where SS_ParmName='SYSAddQuotaPastPermit' and SS_ParmValue=1)
	SET @DATETEMP='01-JAN-1900'
INSERT INTO @Tbl_DQ
	SELECT	MIN(d1) as TMP_Count, TMP_AgentKey, TMP_Type, TMP_ByRoom, TMP_Partner, 
			d2 as TMP_Duration, TMP_FilialKey, TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2,0 as TMP_ReleaseIgnore FROM
		(SELECT	SUM(TMP_Count) as d1, TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner, 
				TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END as d2, TMP_SubCode1, TMP_SubCode2
		FROM	#Tbl
		WHERE	(TMP_Date >= @DATETEMP + ISNULL(TMP_Release,0) OR (TMP_Date < GETDATE() - 1))
		GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
					TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END, TMP_SubCode1, TMP_SubCode2) D
	GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
				TMP_FilialKey, TMP_CityDepartments, d2, TMP_SubCode1, TMP_SubCode2
	HAVING count(*)=DATEDIFF(day,@DateBeg,@DateEnd)+1
	UNION
	SELECT	MIN(d1) as TMP_Count, TMP_AgentKey, TMP_Type, TMP_ByRoom, TMP_Partner, 
			d2 as TMP_Duration, TMP_FilialKey, TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2,1 as TMP_ReleaseIgnore FROM
		(SELECT	SUM(TMP_Count) as d1, TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner, 
				TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END as d2, TMP_SubCode1, TMP_SubCode2
		FROM	#Tbl
		GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
					TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END, TMP_SubCode1, TMP_SubCode2) D
	GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
				TMP_FilialKey, TMP_CityDepartments, d2, TMP_SubCode1, TMP_SubCode2
	HAVING count(*)=DATEDIFF(day,@DateBeg,@DateEnd)+1

if exists (select TOP 1 * from #Tbl where TMP_Count > 0 and TMP_Date = @DateBeg and TMP_Release > 0)
begin
declare @release smallint 
	select @release = TMP_Release from #Tbl where TMP_Count > 0 and TMP_Date = @DateBeg and TMP_Release > 0
	if (GETDATE() >= @DateBeg - @release)
	begin
		set @Quota_CheckState = 3	-- наступил РЕЛИЗ-Период
		return 
	end
end
/*
Комментарии к запросу выше!!!
Заполняем таблицу квот, которые могут нам подойти (группируя квоты по всем разделяемым параметрам, кроме релиз-периода
Все строки в таблице дублируются (важно! 11-ый параметр): 
	квоты с учетом релиз-периода (0) --TMP_ReleaseIgnore
	квоты без учета релиз-периода (1)--TMP_ReleaseIgnore
При выводе всех доступных квот требуется отсекать строки без учета релиз-периода и с количеством мест <=0 
*/

DECLARE @IsCommitmentFirst bit
IF Exists (SELECT SS_ID FROM dbo.SystemSettings WHERE SS_ParmName='SYS_Commitment_First' and SS_ParmValue='1')
	SET @IsCommitmentFirst=1

If @TypeOfResult is null or @TypeOfResult=0
BEGIN
	IF @IsCommitmentFirst=1
		select * from @Tbl_DQ order by TMP_ReleaseIgnore, TMP_Type, TMP_Partner DESC, TMP_AgentKey DESC, TMP_SubCode1 DESC, TMP_SubCode2 DESC, TMP_Duration DESC
	ELSE
		select * from @Tbl_DQ order by TMP_ReleaseIgnore, TMP_Type DESC, TMP_Partner DESC, TMP_AgentKey DESC, TMP_SubCode1 DESC, TMP_SubCode2 DESC, TMP_Duration DESC
END

DECLARE @Priority int;
SELECT @Priority=QPR_Type FROM   QuotaPriorities 
WHERE  QPR_Date=@DateFirst and QPR_SVKey = @SVKey and QPR_Code=@Code and QPR_PRKey=@PRKey

IF @Priority is not null
	SET @IsCommitmentFirst=@Priority-1

If @TypeOfResult=1 --(возвращаем характеристики оптимальной квоты)
BEGIN
	If exists (SELECT top 1 1 FROM @Tbl_DQ)
	BEGIN
		IF @Quota_Type=1 or @IsCommitmentFirst=1
			select	TOP 1 @Quota_Count=TMP_Count, 
					@Quota_AgentKey=TMP_AgentKey, @Quota_Type=TMP_Type, @Quota_ByRoom=TMP_ByRoom,
					@Quota_PRKey=TMP_Partner, @Quota_FilialKey=TMP_FilialKey, @Quota_CityDepartments=TMP_CityDepartments, 
					@Quota_Duration=TMP_Duration, @Quota_SubCode1=TMP_SubCode1, @Quota_SubCode2=TMP_SubCode2
			from	@Tbl_DQ 
			where	TMP_Count>0 and TMP_ReleaseIgnore=0
			order by TMP_ReleaseIgnore, TMP_Type DESC, TMP_Partner DESC, TMP_AgentKey DESC, TMP_SubCode1 DESC, TMP_SubCode2 DESC, TMP_Duration DESC
		ELSE
			select	TOP 1 @Quota_Count=TMP_Count, 
					@Quota_AgentKey=TMP_AgentKey, @Quota_Type=TMP_Type, @Quota_ByRoom=TMP_ByRoom,
					@Quota_PRKey=TMP_Partner, @Quota_FilialKey=TMP_FilialKey, @Quota_CityDepartments=TMP_CityDepartments, 
					@Quota_Duration=TMP_Duration, @Quota_SubCode1=TMP_SubCode1, @Quota_SubCode2=TMP_SubCode2
			from	@Tbl_DQ 
			where	TMP_Count>0 and TMP_ReleaseIgnore=0
			order by TMP_ReleaseIgnore, TMP_Type, TMP_Partner DESC, TMP_AgentKey DESC, TMP_SubCode1 DESC, TMP_SubCode2 DESC, TMP_Duration DESC
	END
END

If @TypeOfResult=2 --(попытка проверить возможность постановки услуги на квоту)
BEGIN
	DECLARE @Places_Count int, @Rooms_Count int,		 --доступное количество мест/номеров в квотах
			@Places_Count_ReleaseIgnore int, @Rooms_Count_ReleaseIgnore int,		 --доступное количество мест/номеров в квотах
			@PlacesNeed_Count smallint,					-- количество мест, которых недостаточно для оформления услуги
			@PlacesNeed_Count_ReleaseIgnore smallint					-- количество мест, которых недостаточно для оформления услуги

	If exists (SELECT top 1 1 FROM @Tbl_DQ)
	BEGIN
		SET @PlacesNeed_Count = 0
		set @PlacesNeed_Count_ReleaseIgnore = 0
		
		select @Places_Count = SUM(TMP_Count) 
		from @Tbl_DQ 
		where TMP_Count > 0 and TMP_ByRoom = 0 and TMP_ReleaseIgnore = 0
		
		select @Places_Count_ReleaseIgnore = SUM(TMP_Count)
		from @Tbl_DQ 
		where TMP_Count > 0 and TMP_ByRoom = 0 and TMP_ReleaseIgnore = 1
		
		If @SVKey=3
		begin
			select @Rooms_Count = SUM(TMP_Count) from @Tbl_DQ where TMP_Count > 0 and TMP_ByRoom = 1 and TMP_ReleaseIgnore = 0
			select @Rooms_Count_ReleaseIgnore = SUM(TMP_Count) from @Tbl_DQ where TMP_Count > 0 and TMP_ByRoom = 1 and TMP_ReleaseIgnore = 1
		end

		Set @Places_Count = ISNULL(@Places_Count,0)
		Set @Rooms_Count = ISNULL(@Rooms_Count,0)
		Set @Places_Count_ReleaseIgnore = ISNULL(@Places_Count_ReleaseIgnore,0)
		Set @Rooms_Count_ReleaseIgnore = ISNULL(@Rooms_Count_ReleaseIgnore,0)
		
		SET @StopExist = ISNULL(@StopExist, 0)
	
		--проверяем достаточно ли будет текущего кол-ва мест для бронирования, если нет устанавливаем статус бронирования под запрос
		declare @nPlaces smallint, @nRoomsService smallint
		If @SVKey=3 and @Rooms_Count>0
		BEGIN
			exec GetServiceRoomsCount @Code, @SubCode1, @Pax, @nRoomsService output
			
			If @nRoomsService > @Rooms_Count
			begin
				Set @PlacesNeed_Count = @nRoomsService - @Rooms_Count
				Set @Quota_CheckState = 0
			end
				
			If @nRoomsService > @Rooms_Count_ReleaseIgnore
			begin
				Set @PlacesNeed_Count_ReleaseIgnore = @nRoomsService - @Rooms_Count_ReleaseIgnore
				Set @Quota_CheckState = 0
			end
		END
		ELSE
		begin
			If @Pax > @Places_Count
			begin
				Set @PlacesNeed_Count = @Pax - @Places_Count
				Set @Quota_CheckState = 0
			end 
				
			If @Pax > @Places_Count_ReleaseIgnore
			begin
				Set @PlacesNeed_Count_ReleaseIgnore = @Pax - @Places_Count_ReleaseIgnore
				Set @Quota_CheckState = 0
			end
		end
				
		-- проверим на релиз
		If @PlacesNeed_Count_ReleaseIgnore <= 0 --мест в квоте хватило
			Set @Quota_CheckState = 3						--Возвращаем "Release" (мест не достаточно, но наступил РЕЛИЗ-Период)"
		
		If @PlacesNeed_Count <= 0 --мест в квоте хватило
			Set @Quota_CheckState = 1						--Возвращаем "Ok (квоты есть)"
		else
			set @Quota_CheckInfo = @PlacesNeed_Count
	END
	else
	begin
		-- если выборка пустая
		Set @Quota_CheckState = 0
	end
	
	-- Проверим на стоп
	If @StopExist > 0
	BEGIN
		Set @Quota_CheckState = 2						--Возвращаем "Внимание STOP"
		Set @Quota_CheckDate = @StopDate
	END
END

GO
grant exec on [dbo].[CheckQuotaExist] to public
go

/*********************************************************************/
/* end sp_CheckQuotaExist.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ClearMasterWebSearchFields.sql */
/*********************************************************************/
if exists(select id from sysobjects where name='ClearMasterWebSearchFields' and xtype='p')
	drop procedure [dbo].[ClearMasterWebSearchFields]
go

CREATE PROCEDURE [dbo].[ClearMasterWebSearchFields]
	@tokey int, -- ключ тура
	@calcKey int = null
as
begin
	update dbo.TP_Tours set TO_Update = 1, TO_Progress = 0 where TO_Key = @tokey

	if(@calcKey is null)
		exec dbo.mwEnablePriceTour @tokey, 0, @calcKey

	if(@calcKey is null)		
	begin
		delete from dbo.mwPriceHotels where sd_tourkey = @tokey
	end

	update dbo.TP_Tours set TO_Progress = 25 where TO_Key = @tokey

	if(@calcKey is not null)
	begin
		delete from dbo.mwPriceDataTable where pt_pricekey in (select tp_key from tp_prices with(nolock) where tp_calculatingkey = @calcKey)
	end
	else
	begin
		delete from dbo.mwPriceDataTable where pt_tourkey = @tokey
	end	

	update dbo.TP_Tours set TO_Progress = 50 where TO_Key = @tokey

	if(@calcKey is null)		
	begin
		delete from dbo.mwPriceDurations where sd_tourkey = @tokey
	end

	update dbo.TP_Tours set TO_Progress = 75 where TO_Key = @tokey

	if(@calcKey is null)		
	begin
		delete from dbo.mwSpoDataTable where sd_tourkey = @tokey
	end

	update dbo.TP_Tours set TO_Update = 0, TO_Progress = 100, TO_UpdateTime = GetDate() where TO_Key = @tokey
end
GO

grant exec on [dbo].[ClearMasterWebSearchFields] to public
go

/*********************************************************************/
/* end sp_ClearMasterWebSearchFields.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CorrectionCalculatedPrice_Run.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CorrectionCalculatedPrice_Run]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CorrectionCalculatedPrice_Run]
GO

CREATE PROCEDURE [dbo].[CorrectionCalculatedPrice_Run]
	(
		-- version 2009.12.03
		-- date 2012-04-13
		@deltaCost decimal(14,2),
		@itogCostMin decimal(14,2),
		@operation bit, -- 1 - изменяем цену, 0 - удаляем цену
		@costInPercent bit, -- 1 - цена в процентах, 0 - цена в у.е.
		@perPerson bit, -- 1 - за человека, 0 - нет
		@serviceTypeKey int,
		@serviceCodeList xml,
		@dateList xml,
		@turList xml,
		@durationList xml,
		@hotelKeys xml
	)
AS
BEGIN
	SET NOCOUNT ON;
	SET ARITHABORT ON;

	declare @round smallint
	SELECT @round = ST_RoundService FROM Setting

	declare @cost decimal(14,2)
	set @cost = @deltaCost;
	
	if (@operation = 0)
	begin
		set @cost = 0;
	end
	
	declare @partUpdate int
	
	set @partUpdate = 100000
	select @partUpdate = SS_ParmValue from SystemSettings where SS_ParmName = 'PartCorrectionPrice'
	
	declare @divide int, @mwReplIsPublisher int, @mwReplIsSubscriber int
	
	set @mwReplIsPublisher = dbo.mwReplIsPublisher()
	set @mwReplIsSubscriber = dbo.mwReplIsSubscriber()

	set @divide = 0

	select @divide = CONVERT(int, isnull(SS_ParmValue, '0'))
	from SystemSettings
	where SS_ParmName = 'MWDivideByCountry'

	select TI_Key
	into #tmp_CorrectionCalculatedPrice_Run
	from TP_ServiceLists with (nolock) join TP_Services with (nolock) on TL_TSKey = TS_Key
	join TP_Lists with (nolock) on TL_TIKey = TI_Key
	where TI_TOKey in (select tbl.res.value('.', 'int') from @turList.nodes('/ArrayOfInt/int') as tbl(res) join TP_Tours on tbl.res.value('.', 'int') = TO_Key where TO_UPDATE != 1)
	and TS_Code in (select tbl.res.value('.', 'int') from @serviceCodeList.nodes('/ArrayOfInt/int') as tbl(res))
	and (@serviceTypeKey != 3 or (TS_SubCode1 in (select tbl.res.value('.', 'int') from @hotelKeys.nodes('/ArrayOfInt/int') as tbl(res))))
	and TS_SVKey = @serviceTypeKey
	and ti_totaldays in (select tbl.res.value('.', 'int') from @durationList.nodes('/ArrayOfInt/int') as tbl(res))
	
	while ((select COUNT(*) from #tmp_CorrectionCalculatedPrice_Run) > 0)
	begin
		-- выборка цен
		select TP_Key as TPU_TPKey, TP_Gross as TPU_TPGrossOld, case when @costInPercent = 0 then
																									convert(int, case when @perPerson = 1 then
																														@cost * (	select top 1 TS_Men
																														from TP_Services with (nolock) join TP_ServiceLists with (nolock) on TS_Key = TL_TSKey 
																														where TS_SVKey = 3
																														and TL_TIKey = TP_TIKey)
																													else 
																														@cost 
																													end)
																								else
																									 convert(int, case when @perPerson = 1 then 
																														TP_Gross * (@cost / 100) * (	select top 1 TS_Men
																																						from TP_Services with (nolock) join TP_ServiceLists with (nolock) on TS_Key = TL_TSKey 
																																						where TS_SVKey = 3
																																						and TL_TIKey = TP_TIKey)
																													else 
																														TP_Gross * (@cost / 100)
																													end)
																								end as TPU_TPGrossDelta
		into #tmp_tpPricesUpdated
		from TP_Prices with (nolock)
		where TP_TIKey in ( select top (@partUpdate) TI_Key from #tmp_CorrectionCalculatedPrice_Run)
		and TP_DateBegin in (select res.value('.', 'datetime') from @dateList.nodes('/ArrayOfDateTime/dateTime') as tbl(res))
				
		if (@operation = 1)
		begin
			-- если изменяем цены
			update TP_Prices with (rowlock)
			set TP_Gross = dbo.RoundPrice(@round,TPU_TPGrossOld + TPU_TPGrossDelta)
			from TP_Prices join #tmp_tpPricesUpdated on TP_Key = TPU_TPKey
		end
		else
		begin
			-- если удаляем цены
			delete TP_Prices with (rowlock)
			from TP_Prices join #tmp_tpPricesUpdated on TP_Key = TPU_TPKey
		end

		-- запишем время изменения в туре
		update TP_Tours
		set to_updatetime = getdate()
		from TP_Tours join @turList.nodes('/ArrayOfInt/int') as tbl(res) on tbl.res.value('.', 'int') = to_key
		
		if (@mwReplIsPublisher <= 0 and @mwReplIsSubscriber <= 0)
		begin
			if (@divide = 0)
			begin
				update mwPriceDataTable with (rowlock)
				set pt_price = dbo.RoundPrice(@round,TPU_TPGrossOld + TPU_TPGrossDelta)
				from mwPriceDataTable join #tmp_tpPricesUpdated on pt_pricekey = TPU_TPKey
			end
			else
			begin
				declare @sql nvarchar(4000), @tableName nvarchar(100)
				declare cur cursor fast_forward read_only for
				select name
				from sysobjects
				where xtype = 'U' and name like 'mwPriceDataTable[_]%'

				open cur
				fetch next from cur into @tableName
				while (@@FETCH_STATUS = 0)
				begin
					if (@operation = 1)
					begin
						set @sql = 'update ' + @tableName + ' with (rowlock)
									set pt_price = dbo.RoundPrice(@round,TPU_TPGrossOld + TPU_TPGrossDelta)
									from ' + @tableName + ' join #tmp_tpPricesUpdated on pt_pricekey = TPU_TPKey'
					end
					else
					begin
						set @sql = 'delete ' + @tableName + ' with (rowlock)
									from ' + @tableName + ' join #tmp_tpPricesUpdated on pt_pricekey = TPU_TPKey'
					end
					
					exec (@sql)
					fetch next from cur into @tableName
				end
				
				close cur
				deallocate cur
			end
		end
		
		insert into TP_PricesUpdated(TPU_TPKey, TPU_TPGrossDelta, TPU_TPGrossOld, TPU_IsChangeCostMode)
		select TPU_TPKey, TPU_TPGrossDelta, TPU_TPGrossOld, @operation
		from #tmp_tpPricesUpdated

		delete top (@partUpdate) #tmp_CorrectionCalculatedPrice_Run
		drop table #tmp_tpPricesUpdated
	end
	
END

GO

SET QUOTED_IDENTIFIER OFF
GO

grant exec on [dbo].[CorrectionCalculatedPrice_Run] to public
go
/*********************************************************************/
/* end sp_CorrectionCalculatedPrice_Run.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CostSplitStr.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CostSplitStr]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CostSplitStr]
GO




CREATE PROCEDURE [dbo].[CostSplitStr]
	@p_dtSplit DATETIME,
	@p_nServiceKey INT,
	@p_sCodes VARCHAR (8000),
	@p_sSubCodes1 VARCHAR (8000),
	@p_sSubCodes2 VARCHAR (8000),
	@p_sPartnerKeys VARCHAR (8000),
	@p_sPacketKeys VARCHAR (8000),
	@p_sPeriodKeys VARCHAR (8000),
	@p_bTypeOfDate bit=null				--0 - CS_DATE, 1 - CS_DATECHECKIN 
AS
--<VERSION>2007.2</VERSION>
--<DATE>2008-09-23</DATE>
DECLARE @tsROWID int
DECLARE @dtSplit1 DATETIME
DECLARE @sQuery VARCHAR (8000)
DECLARE @sSplitDateBegColumnName VARCHAR (20)
DECLARE @sSplitDateEndColumnName VARCHAR (20)
DECLARE @sDateBegColumnName VARCHAR (20)
DECLARE @sDateEndColumnName VARCHAR (20)
DECLARE @nUserKey INT

SET @dtSplit1 = @p_dtSplit - 1

EXEC dbo.GetUserKey @nUserKey output

SET @sSplitDateBegColumnName = 'CS_Date'
SET @sSplitDateEndColumnName = 'CS_DateEnd'
SET @sDateBegColumnName = 'CS_CHECKINDATEBEG'
SET @sDateEndColumnName = 'CS_CHECKINDATEEND'

IF @p_bTypeOfDate = 1
BEGIN
	SET @sSplitDateBegColumnName = 'CS_CHECKINDATEBEG'
	SET @sSplitDateEndColumnName = 'CS_CHECKINDATEEND'
	SET @sDateBegColumnName = 'CS_Date'
	SET @sDateEndColumnName = 'CS_DateEnd'
END

--print @sSplitDateBegColumnName
--print @sSplitDateEndColumnName
--print @sDateBegColumnName
--print @sDateEndColumnName


CREATE TABLE #tmpCostSplitStr (CS_ID int)
SET @sQuery =  '
	INSERT INTO #tmpCostSplitStr (CS_ID)
	SELECT	CS_ID
	FROM	Costs
	WHERE	''' + CAST (@p_dtSplit AS VARCHAR (30)) + ''' 
			BETWEEN ' + @sSplitDateBegColumnName + ' + 1 AND ' + @sSplitDateEndColumnName + ' AND
			CS_SVKey = ' + STR (@p_nServiceKey)
IF NOT (@p_sCodes IS NULL OR @p_sCodes = '')
	SET @sQuery = @sQuery + ' AND CS_Code IN (' + @p_sCodes + ')'
IF NOT (@p_sSubCodes1 IS NULL OR @p_sSubCodes1 = '')
	SET @sQuery = @sQuery + ' AND CS_SubCode1 IN (' + @p_sSubCodes1 + ')'
IF NOT (@p_sSubCodes2 IS NULL OR @p_sSubCodes2 = '')
	SET @sQuery = @sQuery + ' AND CS_SubCode2 IN (' + @p_sSubCodes2 + ')'
IF NOT (@p_sPartnerKeys IS NULL OR @p_sPartnerKeys = '')
	SET @sQuery = @sQuery + ' AND CS_PRKey IN (' + @p_sPartnerKeys + ')'
IF NOT (@p_sPacketKeys IS NULL OR @p_sPacketKeys = '')
	SET @sQuery = @sQuery + ' AND CS_PKKey IN (' + @p_sPacketKeys + ')'
IF NOT (@p_sPeriodKeys IS NULL OR @p_sPeriodKeys = '')	
    SET @sQuery = @sQuery + ' AND CS_BYDAY IN (' + @p_sPeriodKeys + ')'
if ( exists( select top 1 1 from SystemSettings where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue = 1))    
	SET @sQuery = @sQuery + ' AND exists (select 1 from costoffers where co_id = cs_coid and co_state = 0) '
    
EXEC (@sQuery)

--Select * from #tmpCostSplitStr
--print @sQuery

DECLARE curCosts CURSOR
LOCAL FAST_FORWARD FOR SELECT CS_ID FROM #tmpCostSplitStr
OPEN curCosts
FETCH NEXT FROM	curCosts INTO @tsROWID
WHILE @@FETCH_STATUS = 0
	BEGIN
	SET @sQuery = 'INSERT INTO tbl_Costs
			(CS_SVKey, CS_Code, CS_SubCode1, CS_SubCode2,
			CS_PRKey, CS_PKKey, ' + @sSplitDateBegColumnName + ', ' + @sSplitDateEndColumnName + ', 
			CS_Week, CS_CostNetto, CS_Cost, CS_Discount, CS_Type,
			CS_Rate, CS_Long , CS_ByDay, CS_FirstDayNetto, CS_FirstDayBrutto, CS_Profit,
			CS_Creator, CS_UpdDate
			, CS_DATESELLBEG, CS_DATESELLEND, ' + @sDateBegColumnName + ',' + @sDateEndColumnName + ', CS_COID)
		SELECT
			CS_SVKey, CS_Code, CS_SubCode1, CS_SubCode2,
			CS_PRKey, CS_PKKey, ''' + CAST(@p_dtSplit as varchar(30)) + ''', ' + @sSplitDateEndColumnName + ', 
			CS_Week, CS_CostNetto, CS_Cost, CS_Discount, CS_Type,
			CS_Rate, CS_Long , CS_ByDay, CS_FirstDayNetto, CS_FirstDayBrutto, CS_Profit ,' + 
			CAST(@nUserKey  as varchar(10)) + ', GETDATE ()
			, CS_DATESELLBEG, CS_DATESELLEND, ' + @sDateBegColumnName + ',' + @sDateEndColumnName + ', CS_COID
		FROM	Costs
		WHERE	CS_ID = ' + CAST(@tsROWID as varchar(30))
--print @sQuery
	EXEC (@sQuery)
	SET @sQuery = ' UPDATE	Costs
			SET	' + @sSplitDateEndColumnName + ' = ''' + CAST(@dtSplit1 as varchar(30)) + ''',
			CS_Creator = ' + CAST(@nUserKey  as varchar(10)) + ',
			CS_UpdDate = GETDATE ()
		WHERE	CS_ID = ' + CAST(@tsROWID as varchar(30))
--print @sQuery
	EXEC (@sQuery)
		
		FETCH NEXT FROM	curCosts INTO @tsROWID


	END
CLOSE curCosts
DEALLOCATE curCosts

go

grant exec on CostSplitStr to public
go

/*********************************************************************/
/* end sp_CostSplitStr.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_DogListToQuotas.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DogListToQuotas]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DogListToQuotas]
GO
CREATE PROCEDURE [dbo].[DogListToQuotas]
(
	--<VERSION>2009.2.31</VERSION>
	--<DATA>04.06.2012</DATA>
	@DLKey int,
	@SetQuotaCheck bit = null,			--если передается этот признак, то по услуге проверяются актуальные квоты, и в случае не актуальности номер/место снимается с квоты целиком и пытается поставиться на квоту заново
										--остальные квоты занимаемые услугой не снимаются, остаются как есть
	@SetQuotaRLKey int = null,
	@SetQuotaRPKey int = null,
	@SetQuotaQPID int = null,			--передается только из руч.режима (только для одной даты!!!!!!)	
	@SetQuotaDateBeg datetime = null,
	@SetQuotaDateEnd datetime = null,
	@SetQuotaAgentKey int = null, 
	@SetQuotaType smallint = null,		--при переходе на 2008.1 в этот параметр передается отрицательное число (-1 Allotment, -2 Коммитемент)
	@SetQuotaByRoom bit = null, 
	@SetQuotaPartner int = null, 
	@SetQuotaDuration smallint = null,
	@SetQuotaSubCode1 int = null,
	@SetQuotaSubCode2 int = null,
	@SetQuotaFilialKey int = null, 
	@SetQuotaCityDepartments int = null,
	@SetQuotaDateFirst datetime = null,
	@SetOkIfRequest bit = 0 -- запуск из тригера T_UpdDogListQuota
) AS

--insert into Debug (db_n1, db_n2, db_n3) values (@DLKey, @SetQuotaType, 999)
declare @SVKey int, @Code int, @SubCode1 int, @PRKey int, @AgentKey int, @DgKey int,
		@TourDuration int, @FilialKey int, @CityDepartment int,
		@ServiceDateBeg datetime, @ServiceDateEnd datetime, @Pax smallint, @IsWait smallint,@SVQUOTED smallint,
		@SdStateOld int, @SdStateNew int, @nHIID int, @dgCode nvarchar(10), @dlName nvarchar(max)

SELECT	@SVKey=DL_SVKey, @Code=DL_Code, @SubCode1=DL_SubCode1, @PRKey=DL_PartnerKey, 
		@ServiceDateBeg=DL_DateBeg, @ServiceDateEnd=DL_DateEnd, @Pax=DL_NMen,
		@AgentKey=DG_PartnerKey, @TourDuration=DG_NDay, @FilialKey=DG_FilialKey, @CityDepartment=DG_CTDepartureKey, @IsWait=ISNULL(DL_Wait,0),
		@DgKey = DL_DGKEY,
		@dgCode = DG_CODE,
		@dlName = DL_NAME
FROM	DogovorList join Dogovor on DL_DGKey = DG_Key
WHERE	DL_Key = @DLKey

-- сохраним старое значение квотируемости
select @SdStateOld = MAX(SD_State)
from ServiceByDate
where SD_DLKey = @DLKey

if @IsWait=1 and (@SetQuotaType in (1,2) or @SetQuotaType is null)  --Установлен признак "Не снимать квоту при бронировании". На квоту не ставим
BEGIN
	UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0
	begin
		exec SetStatusInRoom @dlkey
	end
	return 0
END
SELECT @SVQUOTED=isnull(SV_Quoted,0) from service where sv_key=@SVKEY
if @SVQUOTED=0
BEGIN
	UPDATE ServiceByDate SET SD_State=3 WHERE SD_DLKey=@DLKey	
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0
	begin
		exec SetStatusInRoom @dlkey
	end
	return 0
END

-- ДОБАВЛЕНА НАСТРОЙКА ЗАПРЕЩАЮЩАЯ СНЯТИЕ КВОТЫ ДЛЯ УСЛУГИ, 
-- ТАК КАК В КВОТАХ НЕТ РЕАЛЬНОЙ ИНФОРМАЦИИ, А ТОЛЬКО ПРИЗНАК ИХ НАЛИЧИЯ (ПЕРЕДАЕТСЯ ИЗ INTERLOOK)
IF (@SetQuotaType in (1,2) or @SetQuotaType is null) and  EXISTS (SELECT 1 FROM dbo.SystemSettings WHERE SS_ParmName='IL_SyncILPartners' and SS_ParmValue LIKE '%/' + CAST(@PRKey as varchar(20)) + '/%')
BEgin
	UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0
	begin
		exec SetStatusInRoom @dlkey
	end
	return 0
End

-- проверим если это доп место в комнате, то ее нельзя посадить в квоты, сажаем внеквоты и эта квота за человека
if exists(select 1 from systemsettings where ss_parmname='SYSSetQuotaForAddPlaces' and SS_ParmValue=1)
begin
set @SetQuotaByRoom=0
	if ( exists (select top 1 1 from ServiceByDate join RoomPlaces on SD_RPID = RP_ID where SD_DLKey = @DLKey and RP_Type = 1) and (@SetQuotaByRoom = 0))
	begin
		set @SetQuotaType = 3
	end
end

/*
If @SVKey=3
	SELECT TOP 1 @Quota_SubCode1=HR_RMKey, @Quota_SubCode2=HR_RCKey FROM HotelRooms WHERE HR_Key=@SubCode1
Else
	Set @Quota_SubCode1=@SubCode1
*/
declare @Q_Count smallint, @Q_AgentKey int, @Q_Type smallint, @Q_ByRoom bit, 
		@Q_PRKey int, @Q_FilialKey int, @Q_CityDepartments int, @Q_Duration smallint, @Q_DateBeg datetime, @Q_DateEnd datetime, @Q_DateFirst datetime, @Q_SubCode1 int, @Q_SubCode2 int,
		@Query nvarchar(max), @SubQuery varchar(1500), @Current int, @CurrentString varchar(50), @QTCount_Need smallint, @n smallint, @n2 smallint, @Result_Exist bit, @nTemp smallint, @Quota_CheckState smallint, @dTemp datetime

--karimbaeva 19-04-2012  по умолчанию если не хватает квот на всех туристов, то ставим их всех на запрос, если установлена настройка 
-- SYSSetQuotaToTourist - 1 - ставим туристов на запрос, 0- снимаем квоты на кого хватает, остальных ставим на запрос
if not exists(select 1 from systemsettings where ss_parmname='SYSSetQuotaToTourist' and SS_ParmValue=0)
begin
	If exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null)
	BEGIN
	declare @QT_ByRoom_1 bit
	create table #DlKeys_1
	(
		dlKey int
	)
	
	insert into #DLKeys_1
		select dl_key 
		from dogovorlist 
		where dl_dgkey in (
							select dl_dgkey 
							from dogovorlist 
							where dl_key = @DLKey
						   )
		and dl_svkey = 3
		
		SELECT @QT_ByRoom_1=QT_ByRoom FROM Quotas,QuotaDetails,QuotaParts WHERE QD_QTID=QT_ID and QD_ID=QP_QDID 
		and QP_ID = (select top 1 SD_QPID
					from ServiceByDate join RoomPlaces on SD_RLID = RP_RLID  
					where RP_Type = 0 and sd_dlkey in (select dlKey from #DlKeys_1) and SD_RLID = (select TOP 1 SD_RLID from ServiceByDate where sd_dlkey=@DlKey))
		
		
		if (@QT_ByRoom_1=0 or @QT_ByRoom_1 is null)
		begin	
		SET @Q_DateBeg=@ServiceDateBeg
		SET @Q_DateEnd=@ServiceDateEnd
		SET @Q_DateFirst=@ServiceDateBeg
	
		EXEC dbo.[CheckQuotaExist] @SVKey, @Code, @SubCode1, @Q_DateBeg,
				@Q_DateEnd, @Q_DateFirst, @PRKey, @AgentKey, @TourDuration, 
				@FilialKey,	@CityDepartment, 2, @Pax,@IsWait, 
				@Quota_CheckState output, @dTemp output, @nTemp output,
				@Q_Count output, @Q_AgentKey output, @Q_Type output, @Q_ByRoom output, @Q_PRKey output, 
				@Q_FilialKey output, @Q_CityDepartments output,	@Q_Duration output, @Q_SubCode1 output, @Q_SubCode2 output
						
		if @Quota_CheckState = 0	
		begin
			UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null
			-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
			if @SetQuotaByRoom = 0
			begin
				exec SetStatusInRoom @dlkey
			end
			return 0
		end	
		end	
END
end 

--Если идет полная постановка услуги на квоту (@SetQuotaType is null) обычно после бронирования
--Или прошло удаление какой-то квоты и сейчас требуется освободить эту квоту и занять другую
--То требуется найти оптимально подходящую квоту и ее использовать

If @SetQuotaType is null or @SetQuotaType<0 --! @SetQuotaType<0 <--при переходе на 2008.1
BEGIN
	IF @SetQuotaCheck=1 
		UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey and SD_RPID in (SELECT DISTINCT SD_RPID FROM QuotaDetails,QuotaParts,ServiceByDate WHERE SD_QPID=QP_ID and QP_QDID=QD_ID and QD_IsDeleted=1 and SD_DLKey=@DLKey)
	ELSE
	BEGIN
		IF @SetQuotaRLKey is not null
			UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey and SD_RLID=@SetQuotaRLKey
		ELSE IF @SetQuotaRPKey is not null
			UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey and SD_RPID=@SetQuotaRPKey
		ELSE
			UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey
	END
	SET @Q_DateBeg=@ServiceDateBeg
	SET @Q_DateEnd=@ServiceDateEnd
	SET @Q_DateFirst=@ServiceDateBeg
	IF @SetQuotaType=-1
		SET @Q_Type=1
	ELSE IF @SetQuotaType=-2
		SET @Q_Type=2

	EXEC dbo.[CheckQuotaExist] @SVKey, @Code, @SubCode1, @Q_DateBeg,
						@Q_DateEnd, @Q_DateFirst, @PRKey, @AgentKey, @TourDuration, 
						@FilialKey,	@CityDepartment, 1, @Pax, @IsWait,
						@nTemp output, @dTemp output, @nTemp output,
						@Q_Count output, @Q_AgentKey output, @Q_Type output, @Q_ByRoom output, @Q_PRKey output, 
						@Q_FilialKey output, @Q_CityDepartments output,	@Q_Duration output, @Q_SubCode1 output, @Q_SubCode2 output
END
ELSE
BEGIN
	IF @SetQuotaType=4 or @SetQuotaType=3  --если новый статус Wait-list или Ok(вне квоты), то меняем статус и выходим из хранимки
		Set @Q_Type=@SetQuotaType
	Else If @SetQuotaQPID is not null
	BEGIN
		If @SetQuotaType is not null and @SetQuotaType>=0
			Set @Q_Type=@SetQuotaType
		Else
			Select @Q_Type=QD_Type from QuotaDetails,QuotaParts Where QP_QDID=QD_ID and QP_ID=@SetQuotaQPID
	END
	Else
		Set @Q_Type=null		
	--@SetQuotaQPID это конкретная квота, ее заполнение возможно только из режима ручного постановки услуги на квоту
	IF @SetQuotaByRoom=1 and @SVKey=3
	BEGIN
		if @SetQuotaRLKey is null
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
		else
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_RLID=@SetQuotaRLKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
	END
	ELSE
	BEGIN
		if @SetQuotaRPKey is null
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
		else
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_RPID=@SetQuotaRPKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
	END
	IF @SetQuotaType=4 or @SetQuotaType=3 or @SetQuotaQPID is not null --собственно выход (либо не надо ставить на квоту либо квота конкретная)
	begin
		-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
		if @SetQuotaByRoom = 0
		begin
			exec SetStatusInRoom @dlkey
		end
		-- запускае хранимку на установку статуса путевки
		--exec SetReservationStatus @DgKey
		return 0
	end

	--	select * from ServiceByDate where SD_DLKey=202618 and SD_RLID=740
	SET @Q_AgentKey=@SetQuotaAgentKey
	SET @Q_Type=@SetQuotaType
	SET @Q_ByRoom=@SetQuotaByRoom
	SET @Q_PRKey=@SetQuotaPartner
	SET @Q_FilialKey=@SetQuotaFilialKey
	SET @Q_CityDepartments=@SetQuotaCityDepartments
	SET @Q_Duration=@SetQuotaDuration
	SET @Q_SubCode1=@SetQuotaSubCode1
	SET @Q_SubCode2=@SetQuotaSubCode2
	SET @Q_DateBeg=@SetQuotaDateBeg
	SET @Q_DateEnd=@SetQuotaDateEnd
	SET @Q_DateFirst=ISNULL(@SetQuotaDateFirst,@Q_DateBeg)
	SET @Result_Exist=0	
END

set @n=0

If not exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null)
	print 'WARNING_DogListToQuotas_1'
If @Q_Count is null
	print 'WARNING_DogListToQuotas_2'
If @Result_Exist > 0
	print 'WARNING_DogListToQuotas_3'

WHILE exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null) and @n<5 and (@Q_Count is not null or @Result_Exist=0)
BEGIN
	--print @n
	set @n=@n+1
	Set @SubQuery = ' QT_ID=QD_QTID and QP_QDID=QD_ID
				and QD_Date = QP_Date
				and QD_Type=' + CAST(@Q_Type as varchar(10)) + ' and QT_ByRoom=' + CAST(@Q_ByRoom as varchar(10)) + '
				and QD_IsDeleted is null and QP_IsDeleted is null
				and QO_QTID=QT_ID and QO_SVKey=' + CAST(@SVKey as varchar(10)) +' and QO_Code=' + CAST(@Code as varchar(10)) +' and QO_SubCode1=' + CAST(@Q_SubCode1 as varchar(10))
	IF @SVKey=3
		Set @SubQuery=@SubQuery+' and QO_SubCode2=' + CAST(@Q_SubCode2 as varchar(10))
	IF @Q_FilialKey is null
		SET @SubQuery = @SubQuery + ' and QP_FilialKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_FilialKey=' + CAST(@Q_FilialKey as varchar(10))
	IF @Q_CityDepartments is null
		SET @SubQuery = @SubQuery + ' and QP_CityDepartments is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_CityDepartments=' + CAST(@Q_CityDepartments as varchar(10))
	IF @Q_AgentKey is null
		SET @SubQuery = @SubQuery + ' and QP_AgentKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_AgentKey=' + CAST(@Q_AgentKey as varchar(10))

	IF @Q_PRKey is null
		SET @SubQuery = @SubQuery + ' and QT_PRKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QT_PRKey=' + CAST(@Q_PRKey as varchar(10))
	IF @Q_Duration=0
		SET @SubQuery = @SubQuery + ' and QP_Durations='''' '
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_ID in (Select QL_QPID From QuotaLimitations Where QL_Duration=' + CAST(@Q_Duration as varchar(5)) + ') ' 	

	Set @Query = '
		DECLARE @n1 smallint, @n2 smallint, @CurrentDate smalldatetime, @Long smallint, @prev bit, @durations_prev varchar(25), @release_prev smallint, @QP_ID int, @SK_Current int, @Temp smallint, @Error bit
		DECLARE @ServiceKeys Table 	(SK_ID int identity(1,1), SK_Key int, SK_QPID int, SK_Date smalldatetime )'

	IF @SetQuotaType is null or @SetQuotaType<0 --! @SetQuotaType<0 <--при переходе на 2008.1
		Set @Query = @Query+'
			INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT ' + CASE @Q_ByRoom WHEN 1 THEN 'SD_RLID' ELSE 'SD_RPID' END +', SD_Date FROM ServiceByDate WHERE SD_DLKey=' + CAST(@DLKey as varchar(10)) +' and SD_State is null'
	ELSE IF @Q_ByRoom=1
		Set @Query = @Query+'
			INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT SD_RLID, SD_Date FROM ServiceByDate WHERE SD_DLKey=' + CAST(@DLKey as varchar(10)) +' and SD_RLID=' + CAST(@SetQuotaRLKey as varchar(10)) + '	and SD_State is null'
	ELSE IF @Q_ByRoom=0
		Set @Query = @Query+'
			INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT SD_RPID, SD_Date FROM ServiceByDate WHERE SD_DLKey=' + CAST(@DLKey as varchar(10)) +' and SD_RPID=' + CAST(@SetQuotaRPKey as varchar(10)) + ' and SD_State is null'

		Set @Query = @Query+'
			--SELECT * FROM @ServiceKeys
			SET @CurrentDate=''' + CAST(@Q_DateBeg as varchar(20)) + '''
			SET @Long=DATEDIFF(DAY,''' + CAST(@Q_DateBeg as varchar(20)) + ''',''' + CAST(@Q_DateEnd as varchar(20)) + ''')+1
			SET @Error=0
			SELECT @SK_Current=MIN(SK_Key) FROM @ServiceKeys WHERE SK_QPID is null
			WHILE @SK_Current is not null and @Error=0
			BEGIN
				SET @n1=1
				WHILE @n1<=@Long and @Error=0
				BEGIN
					SET @QP_ID=null
					SET @n2=0
					WHILE (@QP_ID is null) and @n2<2
					BEGIN
						DECLARE @DATETEMP datetime
						SET @DATETEMP = GetDate()
						-- Разрешим посадить в квоту с релиз периодом 0 текущим числом
						set @DATETEMP = DATEADD(day, -1, @DATETEMP)
						if exists (select top 1 1 from systemsettings where SS_ParmName=''SYSCheckQuotaRelease'' and SS_ParmValue=1) OR exists (select top 1 1 from systemsettings where SS_ParmName=''SYSAddQuotaPastPermit'' and SS_ParmValue=1)
							SET @DATETEMP=''10-JAN-1900''
						IF @prev=1'
		Set @Query = @Query + '	SELECT TOP 1 @QP_ID=QP_ID, @durations_prev=QP_Durations, @release_prev=QD_Release
								FROM QuotaParts QP1, QuotaDetails QD1, Quotas QT1, QuotaObjects
								WHERE ' + @SubQuery + ' and QD_Date=DATEADD(DAY,@n1-1,@CurrentDate)
									and (QP_Places-QP_Busy)>0 and QP_Durations=@durations_prev and QD_Release=@release_prev
									and (	isnull(QP_Durations, '''') = '''' 
											or (isnull(QP_Durations, '''') != '''' and (QP_IsNotCheckIn = 1 or QP_CheckInPlaces - QP_CheckInPlacesBusy > 0)) 
											or (isnull(QP_Durations, '''') != '''' and (QP_IsNotCheckIn = 0 or QP_Places - QP_Busy > 0))
											or (isnull(QP_Durations, '''') != '''' and QD_Date = ''' + CAST(@Q_DateFirst as varchar(20)) + ''')
										)
									and ((QP_IsNotCheckIn = 0) 
											or (QP_IsNotCheckIn = 1 
												and exists (select top 1 1 
															from QuotaDetails as tblQD
															where exists (select top 1 1 
																			from QuotaParts as tblQP 
																			where tblQP.QP_QDID = tblQD.QD_ID
																			and tblQP.QP_Date = tblQD.QD_Date
																			and tblQP.QP_IsNotCheckIn = 0)
															and tblQD.QD_Date = ''' + CAST(@Q_DateFirst as varchar(20)) + '''
															and tblQD.QD_QTID = QD1.QD_QTID)))
									and not exists (SELECT top 1 1 FROM StopSales WHERE SS_QDID=QD_ID and SS_QOID=QO_ID and SS_Date=DATEADD(DAY,@n1-1,@CurrentDate) and (SS_IsDeleted is null or SS_IsDeleted=0))
									and not exists (SELECT top 1 1 FROM QuotaParts QP2, QuotaDetails QD2, Quotas QT2 
									WHERE ' + @SubQuery + ' and QD2.QD_Date=''' + CAST(@Q_DateFirst as varchar(20)) + '''
										and ISNULL(QD2.QD_Release,0)=ISNULL(QD1.QD_Release,0) and QP2.QP_Durations=QP1.QP_Durations and (QP_IsNotCheckIn=1 or QP_CheckInPlaces-QP_CheckInPlacesBusy <= 0))
										and (QD1.QD_Date > @DATETEMP+ISNULL(QD1.QD_Release,-1) OR (QD1.QD_Date < getdate() - 1))
								ORDER BY ISNULL(QD_Release,0) DESC, (select count(distinct QD_QTID) 
																	from QuotaDetails as QDP join QuotaParts as QPP on QDP.QD_ID = QPP.QP_QDID and QDP.QD_Date = QPP.QP_Date
																	where exists (select top 1 1 from @ServiceKeys as SKP where SKP.SK_QPID = QPP.QP_ID)
																	and QDP.QD_QTID = QD1.QD_QTID) DESC
			ELSE'
		Set @Query = @Query + '	SELECT TOP 1 @QP_ID=QP_ID, @durations_prev=QP_Durations, @release_prev=QD_Release
								FROM QuotaParts QP1, QuotaDetails QD1, Quotas QT1, QuotaObjects
								WHERE ' + @SubQuery + ' and QD_Date=DATEADD(DAY,@n1-1,@CurrentDate)
									and (QP_Places-QP_Busy)>0 
									and (	isnull(QP_Durations, '''') = '''' 
											or (isnull(QP_Durations, '''') != '''' and (QP_IsNotCheckIn = 1 or QP_CheckInPlaces - QP_CheckInPlacesBusy > 0)) 
											or (isnull(QP_Durations, '''') != '''' and (QP_IsNotCheckIn = 0 or QP_Places - QP_Busy > 0))
											or (isnull(QP_Durations, '''') != '''' and QD_Date = ''' + CAST(@Q_DateFirst as varchar(20)) + ''')
										)
									and ((QP_IsNotCheckIn = 0) 
											or (QP_IsNotCheckIn = 1 
												and exists (select top 1 1 
															from QuotaDetails as tblQD
															where exists (select top 1 1 
																			from QuotaParts as tblQP 
																			where tblQP.QP_QDID = tblQD.QD_ID
																			and tblQP.QP_Date = tblQD.QD_Date
																			and tblQP.QP_IsNotCheckIn = 0)
															and tblQD.QD_Date = ''' + CAST(@Q_DateFirst as varchar(20)) + '''
															and tblQD.QD_QTID = QD1.QD_QTID)))
									and not exists (SELECT top 1 1 FROM StopSales WHERE SS_QDID=QD_ID and SS_QOID=QO_ID and SS_Date=DATEADD(DAY,@n1-1,@CurrentDate) and (SS_IsDeleted is null or SS_IsDeleted=0))
									and not exists (SELECT top 1 1 FROM QuotaParts QP2, QuotaDetails QD2, Quotas QT2
									WHERE ' + @SubQuery + ' and QD2.QD_Date=''' + CAST(@Q_DateFirst as varchar(20)) + '''
										and ISNULL(QD2.QD_Release,0)=ISNULL(QD1.QD_Release,0) and QP2.QP_Durations=QP1.QP_Durations and (QP_IsNotCheckIn=1 or QP_CheckInPlaces-QP_CheckInPlacesBusy <= 0))
										and (QD1.QD_Date > @DATETEMP+ISNULL(QD1.QD_Release,-1) OR (QD1.QD_Date < getdate() - 1))
								ORDER BY ISNULL(QD_Release,0) DESC, (select count(distinct QD_QTID) 
																	from QuotaDetails as QDP join QuotaParts as QPP on QDP.QD_ID = QPP.QP_QDID and QDP.QD_Date = QPP.QP_Date
																	where exists (select top 1 1 from @ServiceKeys as SKP where SKP.SK_QPID = QPP.QP_ID)
																	and QDP.QD_QTID = QD1.QD_QTID) DESC

							SET @n2=@n2+1
						IF @QP_ID is null
							SET @prev=1				
						ELSE
							UPDATE @ServiceKeys SET SK_QPID=@QP_ID WHERE SK_Key=@SK_Current and SK_Date=DATEADD(DAY,@n1-1,@CurrentDate)	
					END
					If @QP_ID is null
						SET @Error=1
					SET @n1=@n1+1
				END
				IF @Error=0
				begin
					UPDATE ServiceByDate SET SD_State=' + CAST(@Q_Type as varchar(1)) + ', SD_QPID=(SELECT SK_QPID FROM @ServiceKeys WHERE SK_Date=SD_Date and SK_Key=' + CASE @Q_ByRoom WHEN 1 THEN 'SD_RLID' ELSE 'SD_RPID' END +')
						WHERE SD_DLKey=' + CAST(@DLKey as varchar(10)) +' and ' + CASE @Q_ByRoom WHEN 1 THEN 'SD_RLID' ELSE 'SD_RPID' END +'=@SK_Current and SD_State is null
				end
				SET @SK_Current=null	
				SELECT @SK_Current=MIN(SK_Key) FROM @ServiceKeys WHERE SK_QPID is null
			END'
	--print @Query	
	exec (@Query)
		
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0
	begin
		exec SetStatusInRoom @dlkey
	end

	--если @SetQuotaType is null -значит это начальная постановка услги на квоту и ее надо делать столько раз
	--сколько номеров или людей в услуге.
	If @SetQuotaType is null or @SetQuotaType<0 --! @SetQuotaType<0 <--при переходе на 2008.1
	BEGIN		
		If exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null)
		BEGIN
			EXEC dbo.[CheckQuotaExist] @SVKey, @Code, @SubCode1, @Q_DateBeg,
						@Q_DateEnd, @Q_DateFirst, @PRKey, @AgentKey, @TourDuration, 
						@FilialKey,	@CityDepartment, 1, @Pax,@IsWait, 
						@nTemp output, @dTemp output, @nTemp output,
						@Q_Count output, @Q_AgentKey output, @Q_Type output, @Q_ByRoom output, @Q_PRKey output, 
						@Q_FilialKey output, @Q_CityDepartments output,	@Q_Duration output, @Q_SubCode1 output, @Q_SubCode2 output
		END
	END	
	ELSE --а если @SetQuotaType is not null -значит ставим на услугу конкретное место, а раз так то оно должно встать на квоту должно было с первого раза, устанавливаем бит выхода.	
		SET @Result_Exist=1		--бит выхода
END

if exists(select top 1 1 from ServiceByDate where SD_DLKey=@DLKey and SD_State is null) 
begin
	exec SetStatusInRoom @dlkey
end

UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null

-- сохраним новое значение квотируемости
select @SdStateNew = MAX(SD_State)
from ServiceByDate
where SD_DLKey = @DLKey

-- запись в историю
if exists(select top 1 1 from SystemSettings where SS_ParmName like 'SYSServiceStatusToHistory' and SS_ParmValue = '1')
begin
	declare @sOldValue nvarchar(max), @sNewValue nvarchar(max)

	IF ISNULL(@SdStateOld, 0) = 0
		SET @sOldValue = ''
	ELSE IF @SdStateOld = 1
		SET @sOldValue = 'Allotment'
	ELSE IF @SdStateOld = 2
		SET @sOldValue = 'Commitment'
	ELSE IF @SdStateOld = 3
		SET @sOldValue = 'Confirmed'
	ELSE IF @SdStateOld = 4
		SET @sOldValue = 'Wait'

	IF ISNULL(@SdStateNew, 0) = 0
		SET @sNewValue = ''
	ELSE IF @SdStateNew = 1
		SET @sNewValue = 'Allotment'
	ELSE IF @SdStateNew = 2
		SET @sNewValue = 'Commitment'
	ELSE IF @SdStateNew = 3
		SET @sNewValue = 'Confirmed'
	ELSE IF @SdStateNew = 4
		SET @sNewValue = 'Wait'

	EXEC @nHIID = dbo.InsHistory @dgCode, @DgKey, 19, '', 'UPD', @dlName, '', 0, ''
	EXECUTE dbo.InsertHistoryDetail @nHIID, 19001, @sOldValue, @sNewValue, @SdStateOld, @SdStateNew, '', '', 0
end

GO
grant exec on [dbo].[DogListToQuotas] to public
go


/*********************************************************************/
/* end sp_DogListToQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetHotelStopSale.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetHotelStopSale]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetHotelStopSale]
GO

CREATE procedure [dbo].[GetHotelStopSale]
(
	-- скрипт запускается из MasterWebStandard.Extra.StopSale, возвращает список отелей на которые устанвлены стопсайлы
	--date 2012-07-11
	--version 2009.2.11
	@hotelKey int = null,
	@dateBegin datetime,
	@cityKey int = null
)
as
begin
	declare @ssKeys table (ssk_id int)
	
	insert into @ssKeys (ssk_id)
	select SS_Id
	from StopSales
	where 
	SS_Date >= @dateBegin
	and isnull(SS_IsDeleted, 0) = 0
	and	(exists (	select top 1 1
					from QuotaObjects
					where QO_ID = SS_QOID
					and QO_SVKey = 3
					and ((@hotelKey is null or QO_Code = @hotelKey) and (@cityKey is null or QO_CTKey=@cityKey)))
	or exists (select top 1 1
				from QuotaDetails
				where QD_ID = SS_QDID
				and exists (select top 1 1
							from QuotaObjects							
							where QO_QTID = QD_QTID
							and QO_SVKey = 3
							and ((@hotelKey is null or QO_Code = @hotelKey) and (@cityKey is null or QO_CTKey=@cityKey))))
							)
	
	select SS_ID,
	QO_ID,
	QO_Code,
	QO_SubCode1,
	QO_SubCode2,
	SS_Date,
	CT_NAME,
	HD_NAME,
	RM_NAME,
	RC_NAME
	from StopSales as SS1 join QuotaObjects QO1 on SS1.SS_QOID = QO1.QO_ID or exists(select top 1 1
																						from QuotaDetails
																						where SS1.SS_QDID = QD_ID
																						and QD_QTID = QO1.QO_QTID)
	join HotelDictionary on HD_KEY = QO_Code
	join CityDictionary on CT_KEY = HD_CTKEY
	left join Rooms on RM_KEY = QO_SubCode1
	left join RoomsCategory on RC_KEY = QO_SubCode2
	where SS_ID in (select ssk_id from @ssKeys)
	and QO_SVKey = 3
	order by QO_Code, QO_SubCode1, QO_SubCode2, SS_Date
end

GO


grant exec on [dbo].[GetHotelStopSale] to public
go
/*********************************************************************/
/* end sp_GetHotelStopSale.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetQuotaLoadListData_N.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetQuotaLoadListData_N]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[GetQuotaLoadListData_N]
GO

CREATE procedure [dbo].[GetQuotaLoadListData_N]
(
--<VERSION>2009.2.14</VERSION>
--<DATE>2012-07-13</DATE>
@QT_ID int=null,
@Service_SVKey int=null,
@Service_Code int=null,
@DateStart smalldatetime = null,
@DaysCount int=null,			 -- для режима 10-для наличия мест - в этом поле передается продолжительность услуги

@nShowQuotaTypes smallint =null,  -- показывать квоты типа (0 - все, 1 - allotment, 2 - commitment)
@bShowCommonInfo bit =null,  -- показывать (1-общую информацию по квоте, 0-информацию по распределению квоты)
@bShowAgencyInfo bit =null,   -- показывать информацию об агентских квотах
@AgentKey int =null,
@bFreeSale bit =null,
@DLKey int =null,
@ResultType smallint=null,		--варианты отображения (0,null-общее, 10-для наличия мест(из оформления))
@TourDurations  smallint=null,
@DateStart2 smalldatetime = null,
@DateStart3 smalldatetime = null,
@bShowByCheckIn bit =null
)
as 

DECLARE @DateEnd smalldatetime, @Service_PRKey int, @QT_IDLocal int, @Result_From smallint, @Result_To smallint, @ServiceLong smallint, @DurationLocal smallint, @ByRoom int
--@Result
--11 - общее кол-во мест (строка 8000)
--12 - кол-во свободных мест (строка 8000)
--13 - кол-во занятых мест (строка 8000)
--21 - кол-во свободных мест (smallint)
--22 - % Stop-Sale (smallint)
--23 - возможен ли заезд (smallint)
if @ResultType is null or @ResultType not in (10)
	Set @DateEnd = DATEADD(DAY, @DaysCount-1, @DateStart)
Else --для наличия мест(из оформления)
BEGIN
	Set @ServiceLong=@DaysCount
	Set @DateEnd = DATEADD(DAY,ISNULL(@DaysCount,1)-1,@DateStart3)
	Set @DaysCount=DATEDIFF(DAY,@DateStart,@DateEnd)+1

	if exists (select 1 from dbo.Service(nolock) where SV_Key=@Service_SVKey and SV_IsDuration=1)
		set @DurationLocal=@ServiceLong
	Else
		set @DurationLocal=@TourDurations
END

CREATE TABLE #StopSaleTemp
(
SST_QDID int, SST_QO_Count smallint, SST_QO_CountWithStop smallint, SST_Comment varchar(255)
)

CREATE CLUSTERED INDEX idx_StopSaleTemp
ON #StopSaleTemp(SST_QDID ASC)

INSERT INTO #StopSaleTemp exec dbo.GetTableQuotaDetails	@DLKey, null, @DateStart, @DaysCount, null, null, @Service_SVKey, @Service_Code, null, null, 1

--SELECT * FROM #StopSaleTemp

CREATE TABLE #QuotaLoadList(QL_ID int identity(1,1),
QL_QTID int, QL_QOID int, QL_PRKey int, QL_SubCode1 int, QL_SubCode2 int, QL_PartnerName nvarchar(100) collate Cyrillic_General_CI_AS, QL_Description nvarchar(255) collate Cyrillic_General_CI_AS, 
QL_dataType smallint, QL_Type smallint, QL_Release int, QL_Durations nvarchar(20) collate Cyrillic_General_CI_AS, QL_FilialKey int, 
QL_CityDepartments int, QL_AgentKey int, QL_CustomerInfo nvarchar(150) collate Cyrillic_General_CI_AS, QL_DateCheckinMin smalldatetime,
QL_ByRoom int)

DECLARE @n int, @str varchar(8000)
if (@ResultType is null) or (@ResultType <> 10)
BEGIN
	set @n=1
	WHILE @n <= @DaysCount
	BEGIN
		set @str = 'ALTER TABLE #QuotaLoadList ADD QL_' + CAST(@n as varchar(3)) + ' varchar(8000)'
		exec (@str)
		set @n = @n + 1
	END
END
ELSE
BEGIN
	--для наличия мест(из оформления)
	set @n=1
	WHILE @n <= @DaysCount
	BEGIN
		set @str = 'ALTER TABLE #QuotaLoadList ADD QL_' + CAST(@n as varchar(3)) + ' smallint'
		exec (@str)
		set @n = @n + 1
	END
END


if @bShowCommonInfo = 1
BEGIN
	insert into #QuotaLoadList 
	(QL_QTID, QL_Type, QL_Release, QL_dataType, QL_DateCheckinMin, QL_PRKey, QL_ByRoom)
	select	DISTINCT QT_ID, QD_Type, case when QD_Release = 0 then null else QD_Release end, NU_ID, @DateEnd+1,QT_PRKey, QT_ByRoom
	from	Quotas, QuotaObjects, QuotaDetails, Numbers
	where	QT_ID=QO_QTID and QD_QTID=QT_ID
			and ((QO_Code=@Service_Code and QO_SVKey=@Service_SVKey and QO_QTID is not null and @QT_ID is null) or (@QT_ID is not null and @QT_ID=QT_ID))
			and ISNULL(QD_IsDeleted,0)=0
			and QD_Date between @DateStart and @DateEnd
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0)
			and NU_ID between 1 and 3
END
else
BEGIN
	DECLARE @Service_SubCode1 int, @Object_SubCode1 int, @Object_SubCode2 int, @Service_SubCode2 int
	SET @Object_SubCode1=0
	SET @Object_SubCode2=0
	IF @DLKey is not null				-- если мы запустили процедуру из конкрентной услуги
	BEGIN
		SELECT	@Service_SVKey=DL_SVKey, @Service_Code=DL_Code, @Service_SubCode1=DL_SubCode1
			  , @AgentKey=ISNULL(DL_Agent,0), @Service_PRKey=DL_PartnerKey, @Service_SubCode2 = DL_SubCode2
		FROM	DogovorList (nolock)
		WHERE	DL_Key=@DLKey
		If @Service_SVKey=3
			SELECT @Object_SubCode1=HR_RMKey, @Object_SubCode2=HR_RCKey 
			FROM dbo.HotelRooms (nolock) WHERE HR_Key=@Service_SubCode1
		Else
			SET @Object_SubCode1=@Service_SubCode1
		IF @Service_SVKey=1
			SET @Object_SubCode2=@Service_SubCode2
	END

if @ResultType is null or @ResultType not in (10)
BEGIN
	Set @Result_From=11
	Set @Result_To=13
END
ELSE
BEGIN
	--для наличия мест(из оформления)
	Set @Result_From=21
	Set @Result_To=23
END;
	-- сначала заполняем таблицу квотами
	-- чтобы ускорить инсерт добавим временную таблицу
	DECLARE @TempTable2 TABLE
	(
		QL_QTID int,
		QL_Type smallint,
		QL_Release int,
		QL_Durations varchar(20),
		QL_FilialKey int,
		QL_CityDepartments int,
		QL_AgentKey int,
		QL_CustomerInfo varchar(150),
		QL_DateCheckinMin smalldatetime,
		QL_PRKey int,
		QL_ByRoom int		
	)
	
	insert into @TempTable2 (QL_QTID, QL_Type, QL_Release, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom)
	select QT_ID, QD_Type, QD_Release, QP_Durations, QP_FilialKey, QP_CityDepartments, QP_AgentKey, '', @DateEnd + 1, QT_PRKey,QT_ByRoom
	from	Quotas (nolock), QuotaObjects (nolock), QuotaDetails (nolock), QuotaParts (nolock)
	where	QT_ID=QO_QTID
			and QD_QTID=QT_ID
			and QP_QDID = QD_ID
			and ((QO_Code=@Service_Code and QO_SVKey=@Service_SVKey and QO_QTID is not null and @QT_ID is null) or (@QT_ID is not null and @QT_ID=QT_ID))
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) 
			and QD_Date between @DateStart and @DateEnd
			and QP_Date between @DateStart and @DateEnd
			and (QP_AgentKey is null or (@bShowAgencyInfo=1 and ((@AgentKey=QP_AgentKey) or (@AgentKey is null))))
			and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey=QT_PRKey or QT_PRKey=0)))
			and (QP_Durations='' or (@DurationLocal is null or (@DurationLocal is not null and exists (Select QL_QPID From QuotaLimitations (nolock) WHERE QL_Duration=@DurationLocal and QL_QPID=QP_ID))))
			and ISNULL(QP_IsDeleted,0)=0
			and ISNULL(QD_IsDeleted,0)=0			
			and (@DLKey is null or (@DLKey is not null
				and ((QO_SubCode1 = -1) or (QO_SubCode1 in (0,@Object_SubCode1))) 
				and ((QO_SubCode2 = -1) or (QO_SubCode2 in (0,@Object_SubCode2)))
			))


	insert into #QuotaLoadList (QL_QTID, QL_Type, QL_Release, QL_dataType, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom)
	SELECT DISTINCT QL_QTID, QL_Type, QL_Release, NU_ID, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom
	FROM @TempTable2 nolock, Numbers (nolock)
	WHERE NU_ID between @Result_From and @Result_To

END

DECLARE @QD_ID int, @Date smalldatetime, @State smallint, @QD_Release int, @QP_Durations varchar(20), @QP_FilialKey int,
		@QP_CityDepartments int, @QP_AgentKey int, @Quota_Places int, @Quota_Busy int, @QP_IsNotCheckIn bit,
		@QD_QTID int, @QP_ID int, @Quota_Comment varchar(8000), @Stop_Comment varchar(255), @QO_ID int--,	@QT_ID int
DECLARE @ColumnName varchar(10), @QueryUpdate varchar(8000), @QueryUpdate1 varchar(255), @QueryWhere1 varchar(255), @QueryWhere2 varchar(255), 
		@QD_PrevID int, @StopSale_Percent int, @CheckInPlaces smallint, @CheckInPlacesBusy smallint --@QuotaObjects_Count int, 

if @bShowCommonInfo = 1
	DECLARE curQLoadList CURSOR FOR SELECT 
			QT_ID, QD_ID, QD_Date, QD_Type, case when QD_Release = 0 then null else QD_Release end,
			QD_Places, QD_Busy,
			0,'',0,0,0,0, ISNULL(REPLACE(QD_Comment,'''','"'),''),0,0
	FROM	Quotas, QuotaDetails
	WHERE	QD_QTID=QT_ID
			and 
			(	
				(@QT_ID is null and exists 
					(	
						SELECT 1 FROM QuotaObjects WHERE QT_ID=QO_QTID 
						and QO_Code=@Service_Code and QO_SVKey=@Service_SVKey
					)
				)
				or
				(@QT_ID is not null and @QT_ID=QT_ID)
			)
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) and QD_Date between @DateStart and @DateEnd
			and (QD_IsDeleted = 0 or QD_IsDeleted is null)
	ORDER BY QD_Date DESC, QD_ID
else
	DECLARE curQLoadList CURSOR FOR 
	SELECT QT_ID, QD_ID, QD_Date, QD_Type, QD_Release, 
			QP_Places, QP_Busy, 
			QP_ID, QP_Durations, QP_FilialKey, QP_CityDepartments, QP_AgentKey, ISNULL(QP_IsNotCheckIn,0), ISNULL(REPLACE(QD_Comment,'''','"'),'') + '' + ISNULL(REPLACE(QP_Comment,'''','"'),''), QP_CheckInPlaces, QP_CheckInPlacesBusy
	FROM	Quotas, QuotaDetails,QuotaParts
	WHERE	QD_QTID=QT_ID and QP_QDID = QD_ID
			and 
			(	
				(@QT_ID is null and exists 
					(	
						SELECT 1 FROM QuotaObjects WHERE QT_ID=QO_QTID 
						and QO_Code=@Service_Code and QO_SVKey=@Service_SVKey
					)
				)
				or
				(@QT_ID is not null and @QT_ID=QT_ID)
			)
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) 
			and QD_Date between @DateStart and @DateEnd
			and QP_Date between @DateStart and @DateEnd
			and QP_QDID = QD_ID	
			and (QP_AgentKey is null or (@bShowAgencyInfo=1 and ((@AgentKey=QP_AgentKey) or (@AgentKey is null))))
			and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey=QT_PRKey or QT_PRKey=0)))
			and (QP_Durations='' or (@DurationLocal is null or (@DurationLocal is not null and exists (Select QL_QPID From QuotaLimitations WHERE QL_Duration=@DurationLocal and QL_QPID=QP_ID))))
			and (QP_IsDeleted = 0 or QP_IsDeleted is null)
			and (QD_IsDeleted = 0 or QD_IsDeleted is null)
	ORDER BY QD_Date DESC, QD_ID


OPEN curQLoadList
FETCH NEXT FROM curQLoadList INTO	@QT_IDLocal,
									@QD_ID, @Date, @State, @QD_Release, @Quota_Places, @Quota_Busy,
									@QP_ID, @QP_Durations, @QP_FilialKey, @QP_CityDepartments, @QP_AgentKey, @QP_IsNotCheckIn, @Quota_Comment, @CheckInPlaces, @CheckInPlacesBusy
SET @QD_PrevID = @QD_ID - 1

SET @StopSale_Percent=0
WHILE @@FETCH_STATUS = 0
BEGIN
	set @QueryUpdate1=''
	if DATEADD(DAY,ISNULL(@QD_Release,0),GetDate()) < @Date
		set @QueryUpdate1=', QL_DateCheckInMin=''' + CAST(@Date as varchar(250)) + ''''
	set @ColumnName = CAST(CAST((@Date-@DateStart+1) as int) as varchar(6))

	If @QD_PrevID != @QD_ID
	BEGIN
		SET @StopSale_Percent=0
		
		SET @Stop_Comment = ''
		IF @DLKey is null
		BEGIN
			if Exists (SELECT 1 FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID )
				SELECT @StopSale_Percent = 100*SST_QO_Count/SST_QO_CountWithStop, @Stop_Comment = SST_Comment FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID
		END
		ELSE
		BEGIN
			if Exists (SELECT 1 FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID )
				SELECT @StopSale_Percent = 100, @Stop_Comment = SST_Comment FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID
		END

		If @Stop_Comment!=''
			SET @Quota_Comment=@Quota_Comment+ 'Stop-Sale info: ' + @Stop_Comment
		SET @QD_PrevID = @QD_ID
	END	
	ELSE
		If @Stop_Comment!=''
			SET @Quota_Comment=@Quota_Comment+ 'Stop-Sale info: ' + @Stop_Comment

	set @QueryWhere1 = ' where QL_Type = ' + CAST(@State as varchar(1))
	if @QD_Release is null
		set @QueryWhere1 = @QueryWhere1 + ' and QL_Release is null' 
	else
		set @QueryWhere1 = @QueryWhere1 + ' and QL_Release = ' + CAST(@QD_Release as varchar(5))
	
	if @bShowCommonInfo = 1
	BEGIN
	--			+ ',QL_B_' + @ColumnName + ' = ''' + CAST((@Quota_Busy) as varchar(10)) + ';' + CAST(@QD_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@Quota_Comment as varchar(7980)) + ''''
		set @QueryUpdate = 'UPDATE #QuotaLoadList SET 
			QL_' + @ColumnName + ' = (CASE QL_dataType WHEN 1 THEN ''' + CAST((@Quota_Places) as varchar(10))  + ''' WHEN 2 THEN ''' + CAST((@Quota_Places-@Quota_Busy) as varchar(10))  + ''' WHEN 3 THEN ''' + CAST((@Quota_Busy) as varchar(10)) + ''' END)+' + ''';' + CAST(@QD_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@Quota_Comment as varchar(7980)) + ''''
				+ @QueryUpdate1
				+ @QueryWhere1 + ' and QL_dataType in (1,2,3) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
		--print @QueryUpdate
		exec (@QueryUpdate)
	END
	else
	BEGIN
		set @QueryWhere2 = ''
		if @QP_Durations is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_Durations is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_Durations = ''' + @QP_Durations + ''''
		if @QP_FilialKey is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_FilialKey is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_FilialKey = ' + CAST(@QP_FilialKey as varchar(10))
		if @QP_CityDepartments is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_CityDepartments is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_CityDepartments = ' + CAST(@QP_CityDepartments as varchar(10))
 		if @QP_AgentKey is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_AgentKey is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_AgentKey = ' + CAST(@QP_AgentKey as varchar(10))
	--			+ ',QL_B_' + @ColumnName + ' = ''' + CAST((@Quota_Busy) as varchar(10))  + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7980)) + ''''
		IF @ResultType is null or @ResultType not in (10)
		BEGIN
			IF @bShowByCheckIn = 1 and @QP_Durations <> '' 
			set @QueryUpdate = 'UPDATE #QuotaLoadList SET	
					QL_' + @ColumnName + ' = (CASE QL_dataType WHEN 11 THEN ''' + CAST(ISNULL(@CheckInPlaces,0) as varchar(10)) + ''' WHEN 12 THEN ''' + CAST(ISNULL(@CheckInPlaces-@CheckInPlacesBusy,0) as varchar(10)) + ''' WHEN 13 THEN ''' + CAST(ISNULL(@CheckInPlacesBusy,0) as varchar(10)) + ''' END)+' + ''';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + ''''
				+ @QueryUpdate1
				+ @QueryWhere1 + @QueryWhere2 + ' and QL_dataType in (11,12,13) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
			ELSE
			BEGIN
				-- @StopSaleOrPlaces служит для показывания буквы 'S' для стопов на объекты квотирования вместо 0
				DECLARE @StopSaleOrPlaces varchar(255)
				if @QD_ID < 0
					set @StopSaleOrPlaces = '''S'
				else
					set @StopSaleOrPlaces = '(CASE QL_dataType WHEN 11 THEN ''' + CAST((@Quota_Places) as varchar(10)) + ''' WHEN 12 THEN ''' + CAST((@Quota_Places-@Quota_Busy) as varchar(10)) + ''' WHEN 13 THEN ''' + CAST((@Quota_Busy) as varchar(10)) + ''' END)+'''
					
				set @QueryUpdate = 'UPDATE #QuotaLoadList SET	
						QL_' + @ColumnName + ' = ' + @StopSaleOrPlaces + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + ''''
					+ @QueryUpdate1
					+ @QueryWhere1 + @QueryWhere2 + ' and QL_dataType in (11,12,13) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
			END		
		END
		ELSE
		BEGIN
		--для наличия мест(из оформления)
			--  WHEN 22 THEN ' + @StopSale_Percent + ' WHEN 23 THEN ' + @QP_IsNotCheckIn + ' END
			set @QueryUpdate = 'UPDATE #QuotaLoadList SET	
					QL_' + @ColumnName + ' = (CASE QL_dataType WHEN 21 THEN ' + CAST((@Quota_Places-@Quota_Busy) as varchar(5)) + ' WHEN 22 THEN ' + CAST(@StopSale_Percent as varchar(5)) + ' WHEN 23 THEN ' + CAST(@QP_IsNotCheckIn as varchar(5)) + ' END)' 
				+ @QueryUpdate1
				+ @QueryWhere1 + @QueryWhere2 + ' and QL_dataType in (21,22,23) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
		END	
		--print @QueryUpdate
		exec (@QueryUpdate)
	END	
	FETCH NEXT FROM curQLoadList INTO	@QT_IDLocal,
										@QD_ID, @Date, @State, @QD_Release, @Quota_Places, @Quota_Busy,
										@QP_ID, @QP_Durations, @QP_FilialKey, @QP_CityDepartments, @QP_AgentKey, @QP_IsNotCheckIn, @Quota_Comment, @CheckInPlaces, @CheckInPlacesBusy
END
CLOSE curQLoadList
DEALLOCATE curQLoadList

--select * from #QuotaLoadList
-- заполняем таблицу стопами, т.е. обозначаем квоты на которых стоит стоп, и если стоп поставлен плагином, добавляем строчку с буквой "S"
DECLARE @TEMP_QL_ID INT, 
	@SS_Code INT, @SS_SubCode1 INT, @SS_SubCode2 INT, @SS_PRKey INT, @SS_AllotmentAndCommitment INT, @SS_Date datetime, @SS_Comment varchar(255),
	@SS_PrevCode INT, @SS_PrevSubCode1 INT, @SS_PrevSubCode2 INT, @SS_PrevPRKey INT, @SS_PrevAllotmentAndCommitment INT, @SS_PrevDate datetime, 
	@SS_PrevComment varchar(255)

SET @StopSaleOrPlaces = 'S'
SET @QP_ID=-1
SET @StopSale_Percent = 100
SET @QP_IsNotCheckIn = 0
SET @TEMP_QL_ID = null

declare StopSaleWithOutQO CURSOR FOR
	SELECT	QO_Code, QO_SubCode1, QO_SubCode2, SS_PRKey, ISNULL(SS_AllotmentAndCommitment,0), SS_Date, SS_Comment
	FROM	QuotaObjects, StopSales 
	WHERE	QO_ID = SS_QOID 
			and QO_Code = @Service_Code and QO_SVKey = @Service_SVKey and QO_QTID is null
			and SS_Date between @DateStart and @DateEnd
			and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey = SS_PRKey or SS_PRKey = 0)))
			and ISNULL(SS_IsDeleted,0) = 0
	ORDER BY QO_Code, QO_SubCode1, QO_SubCode2, SS_PRKey, SS_AllotmentAndCommitment, SS_Date, SS_Comment
OPEN StopSaleWithOutQO
FETCH NEXT FROM StopSaleWithOutQO INTO	
			@SS_Code, @SS_SubCode1, @SS_SubCode2, @SS_PRKey, @SS_AllotmentAndCommitment, @SS_Date, @SS_Comment
WHILE @@FETCH_STATUS = 0
BEGIN
	IF @SS_Code != ISNULL(@SS_PrevCode,-100)
		OR @SS_SubCode1 != @SS_PrevSubCode1
		OR @SS_SubCode2 != @SS_PrevSubCode2
		OR @SS_PRKey != @SS_PrevPRKey
		OR @SS_AllotmentAndCommitment != @SS_PrevAllotmentAndCommitment
	BEGIN
		SET @SS_PrevDate = null
		SET @ColumnName = CAST((DATEDIFF(DAY,@DateStart,@SS_Date)+1) as varchar(3))
		SET @Quota_Comment = ISNULL(@SS_Comment,'')
		SET @QueryUpdate='INSERT INTO #QuotaLoadList 
			(QL_QTID, QL_PRKey, QL_SubCode1, QL_SubCode2, QL_dataType, 
			QL_Type, QL_ByRoom, QL_' + @ColumnName + ')
			values 
			(0, ' + CAST(@SS_PRKey as varchar(15)) + ', ' + CAST(@SS_SubCode1 as varchar(15)) + ', ' + CAST(@SS_SubCode2 as varchar(15)) + ', 11, ' +
			CAST((@SS_AllotmentAndCommitment+1) as varchar(2)) + ', 1, 
			''' + @StopSaleOrPlaces + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + '''
			)
		'
		exec (@QueryUpdate)
	END
	ELSE
	BEGIN
		IF @SS_Date != @SS_PrevDate
		BEGIN
			SET @ColumnName = CAST((DATEDIFF(DAY,@DateStart,@SS_Date)+1) as varchar(3))
			SET @Quota_Comment = ISNULL(@SS_Comment,'')
			SET @QueryUpdate='UPDATE #QuotaLoadList SET	
						QL_' + @ColumnName + ' = ''' + @StopSaleOrPlaces + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + ''' 
						WHERE 
							QL_PRKey = ' + CAST(@SS_PRKey as varchar(15)) + '
							AND QL_SubCode1 = ' + CAST(@SS_SubCode1 as varchar(15)) + '
							AND QL_SubCode2 = ' + CAST(@SS_SubCode2 as varchar(15)) + '
							AND QL_Type = ' + CAST((@SS_AllotmentAndCommitment+1) as varchar(2)) 
							
			exec (@QueryUpdate)
		END
		ELSE IF @SS_Date = @SS_PrevDate
		BEGIN 
			IF @SS_Comment != @SS_PrevComment
			BEGIN
				SET @Quota_Comment = ISNULL(@SS_Comment,'')
				SET @QueryUpdate='UPDATE #QuotaLoadList SET	
						QL_' + @ColumnName + ' = QL_' + @ColumnName + ' + CAST(' + @Quota_Comment + ' as varchar(7900)) +  
						WHERE 
							QL_PRKey = ' + CAST(@SS_PRKey as varchar(15)) + '
							AND QL_SubCode1 = ' + CAST(@SS_SubCode1 as varchar(15)) + '
							AND QL_SubCode2 = ' + CAST(@SS_SubCode2 as varchar(15)) + '
							AND QL_Type = ' + CAST((@SS_AllotmentAndCommitment+1) as varchar(2)) 
				exec (@QueryUpdate)
			END
		END
	END
	SET @SS_PrevDate = @SS_Date
	SET @SS_PrevComment = @SS_Comment	
	SET @SS_PrevCode = @SS_Code
	SET @SS_PrevSubCode1 = @SS_SubCode1
	SET @SS_PrevSubCode2 = @SS_SubCode2
	SET @SS_PrevPRKey = @SS_PRKey
	SET @SS_PrevAllotmentAndCommitment = @SS_AllotmentAndCommitment
	FETCH NEXT FROM StopSaleWithOutQO INTO	
				@SS_Code, @SS_SubCode1, @SS_SubCode2, @SS_PRKey, @SS_AllotmentAndCommitment, @SS_Date, @SS_Comment
END
CLOSE StopSaleWithOutQO
DEALLOCATE StopSaleWithOutQO


IF @DLKey is null and @QT_ID is null and (@ResultType is null or @ResultType not in (10))
BEGIN
	IF(@Service_SVKey = 3)
		SET @ByRoom = (SELECT AVG(ISNULL(QL_ByRoom,0)) FROM #QuotaLoadList)
	ELSE
		SET @ByRoom = 0

	insert into #QuotaLoadList 
		(QL_SubCode1, QL_Type, QL_dataType, QL_PRKey, QL_ByRoom)
	select DISTINCT DL_SubCode1, SD_State, 21, DL_PartnerKey, @ByRoom
	from	DogovorList (nolock),ServiceByDate (nolock)
	where	SD_DLKey=DL_Key
			and DL_SVKey=@Service_SVKey and DL_Code=@Service_Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd))
			and SD_Date<=@DateEnd and SD_Date>=@DateStart
			and SD_State not in (1,2)
	group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State
END

update #QuotaLoadList set QL_CustomerInfo = (Select PR_Name from Partners (nolock) where PR_Key = QL_AgentKey and QL_AgentKey > 0)
update #QuotaLoadList set QL_PartnerName = (Select PR_Name from Partners (nolock) where PR_Key = QL_PRKey and QL_PRKey > 0)
update #QuotaLoadList set QL_PartnerName = 'All partners' where QL_PRKey=0

IF @DLKey is null and @QT_ID is null and (@ResultType is null or @ResultType not in (10))
BEGIN
	DECLARE @ServiceCount int, @SubCode1 int, @PartnerKey int

	DECLARE curQServiceList CURSOR FOR SELECT
		SD_Date,
		CASE @ByRoom WHEN 1 THEN count(distinct SD_RLID) ELSE count(SD_ID) END,
		DL_SubCode1,
		DL_PartnerKey,
		SD_State
		from	DogovorList (nolock),ServiceByDate (nolock)
		where	SD_DLKey=DL_Key
				and DL_SVKey=@Service_SVKey and DL_Code=@Service_Code 
				and DL_DateBeg<=@DateEnd and DL_DateEnd>=@DateStart
				and SD_Date<=@DateEnd and SD_Date>=@DateStart
				and SD_State not in (1,2)
		group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State
	OPEN curQServiceList
	FETCH NEXT FROM curQServiceList INTO	@Date, @ServiceCount, @SubCode1, @PartnerKey, @State

	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @ColumnName = CAST(CAST((@Date-@DateStart+1) as int) as varchar(6))
		set @QueryWhere1 = ' where QL_Type = ' + CAST(@State as varchar(1))

		set @QueryUpdate = 'UPDATE #QuotaLoadList SET QL_' + @ColumnName + ' = ''' + CAST((@ServiceCount) as varchar(10))  + ''' 
		WHERE QL_Type = ' + CAST(@State as varchar(1)) + ' and QL_SubCode1= ' + CAST(@SubCode1 as varchar(10)) + ' and QL_PRKey= ' + CAST(@PartnerKey as varchar(10))

		exec (@QueryUpdate)
		FETCH NEXT FROM curQServiceList INTO	@Date, @ServiceCount, @SubCode1, @PartnerKey, @State
	END
	CLOSE curQServiceList
	DEALLOCATE curQServiceList
END

DECLARE @QO_SubCode int, @QO_TypeD smallint, @DL_SubCode1 int, @QT_ID_Prev int, @ServiceName1 varchar(100), @ServiceName2 varchar(100), @Temp varchar(100),
	@IDEN_Local int, @IDEN_Prev int, @IDENTYPE_Local int, @IDENTYPE_Prev int
DECLARE curQLoadListQO CURSOR FOR 
	SELECT DISTINCT QO_QTID, QO_SubCode1, 1, null, 1 FROM QuotaObjects (nolock) WHERE QO_QTID in (SELECT QL_QTID FROM #QuotaLoadList (nolock) WHERE QO_QTID is not null)
	UNION
	SELECT DISTINCT QO_QTID, QO_SubCode2, 2, null, 1 FROM QuotaObjects (nolock) WHERE QO_QTID in (SELECT QL_QTID FROM #QuotaLoadList (nolock) WHERE QO_QTID is not null)
	UNION
	SELECT DISTINCT QL_ID, QL_SubCode1, 1, null, 3 FROM #QuotaLoadList (nolock) WHERE QL_SubCode1 is not null
	UNION
	SELECT DISTINCT QL_ID, QL_SubCode2, 2, null, 3 FROM #QuotaLoadList (nolock) WHERE QL_SubCode2 is not null
	UNION
	SELECT DISTINCT null, null, null, QL_SubCode1, 2 FROM #QuotaLoadList (nolock) WHERE QL_SubCode1 is not null
	ORDER BY 5,1,3

OPEN curQLoadListQO
FETCH NEXT FROM curQLoadListQO INTO	@IDEN_Local, @QO_SubCode, @QO_TypeD, @DL_SubCode1, @IDENType_Local
Set @IDEN_Prev=@IDEN_Local
Set @IDENTYPE_Prev=@IDENTYPE_Local

Set @ServiceName1=''
Set @ServiceName2=''


WHILE @@FETCH_STATUS = 0
BEGIN
	if @DL_SubCode1 is not null
	BEGIN
		Set @Temp=''
		exec GetSvCode1Name @Service_SVKey, @DL_SubCode1, null, @Temp output, null, null

		Update #QuotaLoadList set QL_Description=ISNULL(QL_Description,'') + @Temp where QL_SubCode1=@DL_SubCode1
	END
	Else
	BEGIN
		If (@IDEN_Prev != @IDEN_Local) OR (@IDENTYPE_Prev != @IDENTYPE_Local)
		BEGIN
			If @Service_SVKey=3
			BEGIN
				Set @ServiceName2='(' + @ServiceName2 + ')'
			END
			IF @IDENTYPE_Prev = 1
				Update #QuotaLoadList set QL_Description=LEFT(ISNULL(QL_Description,'') + @ServiceName1 + @ServiceName2,255) where QL_QTID=@IDEN_Prev
			IF @IDENTYPE_Prev = 3
				Update #QuotaLoadList set QL_Description=LEFT(@ServiceName1 + @ServiceName2,255) where QL_ID=@IDEN_Prev
			Set @ServiceName1=''
			Set @ServiceName2=''
		END
		
		SET @IDEN_Prev=@IDEN_Local
		SET @IDENTYPE_Prev=@IDENTYPE_Local
		Set @Temp=''
		If @Service_SVKey=3
		BEGIN
			IF @QO_TypeD=1
			BEGIN
				EXEC GetRoomName @QO_SubCode, @Temp output, null
				print @Temp
				If @ServiceName1!=''
					Set @ServiceName1=@ServiceName1+','
				Set @ServiceName1=@ServiceName1+@Temp
			END			
			Set @Temp=''
			IF @QO_TypeD=2
			BEGIN
				EXEC GetRoomCtgrName @QO_SubCode, @Temp output, null
				If @ServiceName2!=''
					Set @ServiceName2=@ServiceName2+','
				Set @ServiceName2=@ServiceName2+@Temp
			END
		END
		ELse
		BEGIN
			exec GetSvCode1Name @Service_SVKey, @QO_SubCode, null, @Temp output, null, null
			If @ServiceName1!=''
				Set @ServiceName1=@ServiceName1+','
			Set @ServiceName1=@ServiceName1+@Temp
		END
	END
	FETCH NEXT FROM curQLoadListQO INTO	@IDEN_Local, @QO_SubCode, @QO_TypeD, @DL_SubCode1, @IDENType_Local
END

If @Service_SVKey=3
BEGIN
	Set @ServiceName2='(' + @ServiceName2 + ')'
END
IF @IDENTYPE_Prev = 1
	Update #QuotaLoadList set QL_Description=LEFT(ISNULL(QL_Description,'') + @ServiceName1 + @ServiceName2,255) where QL_QTID=@IDEN_Prev
IF @IDENTYPE_Prev = 3
	Update #QuotaLoadList set QL_Description=LEFT(@ServiceName1 + @ServiceName2,255) where QL_ID=@IDEN_Prev

CLOSE curQLoadListQO
DEALLOCATE curQLoadListQO


/*
-- 29-03-2012 karimbaeva удаляю строки, чтобы не дублировались при выводе в окне, если стоп стоит по нескольким типам номеров
delete from #QuotaLoadList where ql_qoid <> (select top 1  ql_qoid from #QuotaLoadList) and ql_qoid is not null
*/

If @Service_SVKey=3
BEGIN
	Update #QuotaLoadList set QL_Description = QL_Description + ' - Per person' where QL_ByRoom = 0
END

-- удаляем вспомогательный столбец
alter table #QuotaLoadList drop column QL_QOID
alter table #QuotaLoadList drop column QL_SubCode2
alter table #QuotaLoadList drop column QL_ID

IF @ResultType is null or @ResultType not in (10)
BEGIN
	select * 
	from #QuotaLoadList (nolock)
	order by ISNULL(QL_QTID,-1)-ISNULL(QL_QTID,-1) DESC /*Сначала квоты, потом неквоты*/,QL_Description,QL_PartnerName,QL_Type DESC,QL_Release,QL_Durations,QL_CityDepartments,QL_FilialKey,QL_CustomerInfo,QL_QTID,QL_DataType
	RETURN 0
END
ELSE
BEGIN --для наличия мест(из оформления)
	CREATE TABLE #ServicePlacesTr(
		SPT_QTID int, SPT_PRKey int, SPT_SubCode1 int, SPT_PartnerName varchar(100), SPT_Description varchar(255), 
		SPT_Type smallint, SPT_FilialKey int, SPT_CityDepartments int, SPT_Release int, SPT_Durations varchar(100),
		SPT_AgentKey int, SPT_Date smalldatetime, SPT_Places smallint, SPT_Stop smallint, SPT_CheckIn smallint)
	
	-- В MSSQL 2000 это не работает
	--ALTER TABLE #ServicePlacesTr ADD SPT_Date smalldatetime
	--ALTER TABLE #ServicePlacesTr ADD SPT_Places smallint
	--ALTER TABLE #ServicePlacesTr ADD SPT_Stop smallint
	--ALTER TABLE #ServicePlacesTr ADD SPT_CheckIn smallint


	set @n=1
	WHILE @n <= @DaysCount
	BEGIN
		DECLARE @curDate smalldatetime
		SET @curDate = DATEADD(DAY,@n-1,@DateStart)

		set @str = '
			INSERT INTO #ServicePlacesTr 
				(SPT_QTID, SPT_PRKey,SPT_SubCode1,SPT_PartnerName,SPT_Description,SPT_Type,
				SPT_FilialKey,SPT_CityDepartments,SPT_Release,SPT_Durations,SPT_AgentKey,
				SPT_Date,SPT_Places) 
			SELECT QL_QTID, QL_PRKey,QL_SubCode1,QL_PartnerName, QL_Description, QL_Type, 
				QL_FilialKey, QL_CityDepartments,QL_Release,QL_Durations,QL_AgentKey, 
				''' + CAST(@curDate as varchar(20)) + ''', QL_' + CAST(@n as varchar(3)) + '
				FROM #QuotaLoadList
				WHERE QL_dataType=21'
		exec (@str)

		set @str = 'UPDATE #ServicePlacesTr SET SPT_Stop=
					(SELECT QL_' + CAST(@n as varchar(3)) + '
					FROM #QuotaLoadList
					WHERE  QL_dataType=22 and 
					SPT_QTID=QL_QTID and
					SPT_PRKey=QL_PRKey and 
					ISNULL(SPT_SubCode1,-1)=ISNULL(QL_SubCode1,-1) and 
					SPT_PartnerName=QL_PartnerName and 
					SPT_Description=QL_Description and 
					SPT_Type=QL_Type and 
					ISNULL(SPT_FilialKey,-1)=ISNULL(QL_FilialKey,-1) and 
					ISNULL(SPT_CityDepartments,-1)=ISNULL(QL_CityDepartments,-1) and 
					ISNULL(SPT_Release,-1)=ISNULL(QL_Release,-1) and 
					ISNULL(SPT_Durations,-1)=ISNULL(QL_Durations,-1) and 
					ISNULL(SPT_AgentKey,-1)=ISNULL(QL_AgentKey,-1) and 
					SPT_Date=''' + CAST(@curDate as varchar(20)) + ''')
					WHERE SPT_Date=''' + CAST(@curDate as varchar(20))+ ''''

		exec (@str)

		set @str = 'UPDATE #ServicePlacesTr SET SPT_CheckIn=
					(SELECT QL_' + CAST(@n as varchar(3)) + '
					FROM #QuotaLoadList
					WHERE  QL_dataType=23 and
					SPT_QTID=QL_QTID and 
					SPT_PRKey=QL_PRKey and 
					ISNULL(SPT_SubCode1,-1)=ISNULL(QL_SubCode1,-1) and 
					SPT_PartnerName=QL_PartnerName and 
					SPT_Description=QL_Description and 
					SPT_Type=QL_Type and 
					ISNULL(SPT_FilialKey,-1)=ISNULL(QL_FilialKey,-1) and 
					ISNULL(SPT_CityDepartments,-1)=ISNULL(QL_CityDepartments,-1) and 
					ISNULL(SPT_Release,-1)=ISNULL(QL_Release,-1) and 
					ISNULL(SPT_Durations,-1)=ISNULL(QL_Durations,-1) and
					ISNULL(SPT_AgentKey,-1)=ISNULL(QL_AgentKey,-1) and 
					SPT_Date= ''' + CAST(@curDate as varchar(20)) + ''')
					WHERE SPT_Date=''' + CAST(@curDate as varchar(20)) + ''''

		exec (@str)
		set @n = @n + 1
	END
END

--Select * from #ServicePlacesTr 	ORDER BY  SPT_PRKey, SPT_Type, SPT_SubCode1, SPT_PartnerName, SPT_Description, SPT_FilialKey, SPT_CityDepartments, SPT_Date, SPT_Release

DECLARE @ServicePlaces TABLE
(
	SP_PRKey int, SP_SubCode1 int, SP_PartnerName nvarchar(100), SP_Description nvarchar(255), 
	SP_Type smallint, SP_FilialKey int, SP_CityDepartments int, 
	SP_Places1 smallint, SP_Places2 smallint, SP_Places3 smallint, 
	SP_NonReleasePlaces1 smallint,SP_NonReleasePlaces2 smallint,SP_NonReleasePlaces3 smallint, 
	SP_StopPercent1 smallint,SP_StopPercent2 smallint,SP_StopPercent3 smallint
)

DECLARE @SPT_QTID int, @SPT_PRKey int, @SPT_SubCode1 int, @SPT_PartnerName varchar(100), @SPT_Description varchar(255), 
		@SPT_Type smallint, @SPT_FilialKey int, @SPT_CityDepartments int, @SPT_Release smallint, @SPT_Date smalldatetime, 
		@SPT_Places smallint, @SPT_Stop smallint, @SPT_CheckIn smallint, @SPT_PRKey_Old int, @SPT_PartnerName_Old varchar(100), 
		@SPT_SubCode1_Old int, @SPT_Description_Old varchar(255), @SPT_Type_Old smallint, @SPT_FilialKey_Old int,
		@SPT_CityDepartments_Old int, @SPT_Date_Old smalldatetime,
		@currentPlaces1 smallint, @currentPlaces2 smallint, @currentPlaces3 smallint,
		@currentNonReleasePlaces1 smallint, @currentNonReleasePlaces2 smallint, @currentNonReleasePlaces3 smallint,
		@OblectPlacesMin1 smallint, @OblectPlacesMin2 smallint, @OblectPlacesMin3 smallint,
		@OblectNonReleasePlacesMin1 smallint, @OblectNonReleasePlacesMin2 smallint, @OblectNonReleasePlacesMin3 smallint,
		@stopPercentSum1 smallint,@stopPercentSum2 smallint,@stopPercentSum3 smallint,
		@quotaCounter1 smallint,@quotaCounter2 smallint,@quotaCounter3 smallint,
		@Now smalldatetime

SET @Now = GETDATE()
		
DECLARE curQ2 CURSOR FOR SELECT
			 SPT_QTID, SPT_PRKey, SPT_SubCode1, SPT_PartnerName, SPT_Description, SPT_Type, SPT_FilialKey, 
			 SPT_CityDepartments, ISNULL(SPT_Release, 0), SPT_Date, ISNULL(SPT_Places, 0), ISNULL(SPT_Stop,0), SPT_CheckIn
	FROM	#ServicePlacesTr
	ORDER BY  SPT_PRKey, SPT_Type, SPT_SubCode1, SPT_PartnerName, SPT_Description, 
		SPT_FilialKey, SPT_CityDepartments, SPT_Date, SPT_Release

OPEN curQ2
FETCH NEXT FROM curQ2 INTO @SPT_QTID, @SPT_PRKey, @SPT_SubCode1, @SPT_PartnerName, @SPT_Description, 
		@SPT_Type, @SPT_FilialKey, @SPT_CityDepartments, @SPT_Release, @SPT_Date, @SPT_Places, @SPT_Stop, @SPT_CheckIn	

SET @SPT_PRKey_Old=@SPT_PRKey
SET @SPT_Description_Old=@SPT_Description
SET @SPT_PartnerName_Old=@SPT_PartnerName
SET @SPT_Type_Old=@SPT_Type
SET @SPT_Date_Old=@SPT_Date
SET @currentPlaces1=0
SET @currentPlaces2=0
SET @currentPlaces3=0
SET @currentNonReleasePlaces1=0
SET @currentNonReleasePlaces2=0
SET @currentNonReleasePlaces3=0
SET @stopPercentSum1=0
SET @stopPercentSum2=0
SET @stopPercentSum3=0
SET @quotaCounter1=0
SET @quotaCounter2=0
SET @quotaCounter3=0


WHILE @@FETCH_STATUS = 0
BEGIN
	IF @SPT_PRKey=@SPT_PRKey_Old and @SPT_Description=@SPT_Description_Old and ISNULL(@SPT_Type,-1)=ISNULL(@SPT_Type_Old,-1) and @SPT_Date!=@SPT_Date_Old
	BEGIN
		If (@OblectPlacesMin1 is null or @OblectPlacesMin1 > @currentPlaces1) AND @SPT_Date_Old BETWEEN @DateStart AND DATEADD(DAY,@ServiceLong-1,@DateStart)
		BEGIN
			--Set @quotaCounter1=0
			Set @OblectPlacesMin1=@currentPlaces1
			--Set @currentPlaces1=0
			Set @OblectNonReleasePlacesMin1=@currentNonReleasePlaces1
			--Set @currentNonReleasePlaces1=0
		END
		If (@OblectPlacesMin2 is null or @OblectPlacesMin2 > @currentPlaces2) AND @SPT_Date_Old BETWEEN @DateStart2 AND DATEADD(DAY,@ServiceLong-1,@DateStart2)
		BEGIN
			--Set @quotaCounter2=0
			Set @OblectPlacesMin2=@currentPlaces2
			--Set @currentPlaces2=0
			Set @OblectNonReleasePlacesMin2=@currentNonReleasePlaces2
			--Set @currentNonReleasePlaces2=0
		END
		If (@OblectPlacesMin3 is null or @OblectPlacesMin3 > @currentPlaces3) AND @SPT_Date_Old BETWEEN @DateStart3 AND DATEADD(DAY,@ServiceLong-1,@DateStart3)
		BEGIN
			--Set @quotaCounter3=0
			Set @OblectPlacesMin3=@currentPlaces3
			--Set @currentPlaces3=0
			Set @OblectNonReleasePlacesMin3=@currentNonReleasePlaces3
			--Set @currentNonReleasePlaces3=0
		END
-- При смене даты обнуляем текущие колличества мест
		SET @currentPlaces1=0
		SET @currentPlaces2=0
		SET @currentPlaces3=0
		SET @currentNonReleasePlaces1=0
		SET @currentNonReleasePlaces2=0
		SET @currentNonReleasePlaces3=0
	END

	IF @SPT_PRKey!=@SPT_PRKey_Old or @SPT_Description!=@SPT_Description_Old or ISNULL(@SPT_Type,-1)!=ISNULL(@SPT_Type_Old,-1)
	BEGIN
		IF @quotaCounter1 = 0 SET @quotaCounter1 = 1
		IF @quotaCounter2 = 0 SET @quotaCounter2 = 1
		IF @quotaCounter3 = 0 SET @quotaCounter3 = 1
		INSERT INTO @ServicePlaces (SP_PRKey, SP_SubCode1, SP_PartnerName, SP_Description, SP_Type, 
				SP_FilialKey, SP_CityDepartments, SP_Places1, SP_Places2, SP_Places3, 
				SP_NonReleasePlaces1, SP_NonReleasePlaces2, SP_NonReleasePlaces3,
				SP_StopPercent1,SP_StopPercent2,SP_StopPercent3)
		Values (@SPT_PRKey_Old, @SPT_SubCode1_Old, @SPT_PartnerName_Old, @SPT_Description_Old, @SPT_Type_Old, 
				@SPT_FilialKey_Old, @SPT_CityDepartments_Old, 
				ISNULL(@OblectPlacesMin1,@currentPlaces1), ISNULL(@OblectPlacesMin2,@currentPlaces2), ISNULL(@OblectPlacesMin3,@currentPlaces3),
				ISNULL(@OblectNonReleasePlacesMin1,@currentNonReleasePlaces1), ISNULL(@OblectNonReleasePlacesMin2,@currentNonReleasePlaces2), ISNULL(@OblectNonReleasePlacesMin3,@currentNonReleasePlaces3),
				@stopPercentSum1/@quotaCounter1,@stopPercentSum2/@quotaCounter2,@stopPercentSum3/@quotaCounter3)

		set @OblectPlacesMin1 = null
		set @OblectPlacesMin2 = null
		set @OblectPlacesMin3 = null
		set @OblectNonReleasePlacesMin1 = null
		set @OblectNonReleasePlacesMin2 = null
		set @OblectNonReleasePlacesMin3 = null
		Set @currentPlaces1=0
		Set @currentPlaces2=0
		Set @currentPlaces3=0
		Set @currentNonReleasePlaces1=0
		Set @currentNonReleasePlaces2=0
		Set @currentNonReleasePlaces3=0
		Set @stopPercentSum1=0
		Set @stopPercentSum2=0
		Set @stopPercentSum3=0
		Set @quotaCounter1=0
		Set @quotaCounter2=0
		Set @quotaCounter3=0
	END

	If @SPT_Date BETWEEN @DateStart AND DATEADD(DAY,@ServiceLong-1,@DateStart)
	BEGIN
			Set @quotaCounter1=@quotaCounter1+1
		Set @stopPercentSum1 = @stopPercentSum1 + @SPT_Stop
		Set @currentPlaces1=@currentPlaces1+@SPT_Places
		If @DateStart > DATEADD(DAY,@SPT_Release,@Now)
			Set @currentNonReleasePlaces1=@currentNonReleasePlaces1+@SPT_Places
	END
	If @SPT_Date BETWEEN @DateStart2 AND DATEADD(DAY,@ServiceLong-1,@DateStart2)
	BEGIN
			Set @quotaCounter2=@quotaCounter2+1
		Set @stopPercentSum2 = @stopPercentSum2 + @SPT_Stop
		Set @currentPlaces2=@currentPlaces2+@SPT_Places
		If @DateStart2 > DATEADD(DAY,@SPT_Release,@Now)
			Set @currentNonReleasePlaces2=@currentNonReleasePlaces2+@SPT_Places
	END
	If @SPT_Date BETWEEN @DateStart3 AND DATEADD(DAY,@ServiceLong-1,@DateStart3)
	BEGIN
			Set @quotaCounter3=@quotaCounter3+1
		Set @stopPercentSum3 = @stopPercentSum3 + @SPT_Stop
		Set @currentPlaces3=@currentPlaces3+@SPT_Places
		If @DateStart3 > DATEADD(DAY,@SPT_Release,@Now)
			Set @currentNonReleasePlaces3=@currentNonReleasePlaces3+@SPT_Places
	END

	SET @SPT_PRKey_Old=@SPT_PRKey
	SET @SPT_PartnerName_Old=@SPT_PartnerName
	SET @SPT_Description_Old=@SPT_Description
	SET @SPT_Type_Old=@SPT_Type
	SET @SPT_Date_Old=@SPT_Date
	FETCH NEXT FROM curQ2 INTO @SPT_QTID, @SPT_PRKey, @SPT_SubCode1, @SPT_PartnerName, @SPT_Description, 
			@SPT_Type, @SPT_FilialKey, @SPT_CityDepartments, @SPT_Release, @SPT_Date, @SPT_Places, @SPT_Stop, @SPT_CheckIn	

	If @@FETCH_STATUS != 0
	BEGIN
		IF @quotaCounter1 = 0 SET @quotaCounter1 = 1
		IF @quotaCounter2 = 0 SET @quotaCounter2 = 1
		IF @quotaCounter3 = 0 SET @quotaCounter3 = 1
		INSERT INTO @ServicePlaces (SP_PRKey, SP_SubCode1, SP_PartnerName, SP_Description, SP_Type, 
			SP_FilialKey, SP_CityDepartments, SP_Places1, SP_Places2, SP_Places3, 
			SP_NonReleasePlaces1, SP_NonReleasePlaces2, SP_NonReleasePlaces3,
			SP_StopPercent1,SP_StopPercent2,SP_StopPercent3)
		Values (@SPT_PRKey_Old, @SPT_SubCode1_Old, @SPT_PartnerName_Old, @SPT_Description_Old, @SPT_Type_Old, 
			@SPT_FilialKey_Old, @SPT_CityDepartments_Old, 
			ISNULL(@OblectPlacesMin1,@currentPlaces1), ISNULL(@OblectPlacesMin2,@currentPlaces2), ISNULL(@OblectPlacesMin3,@currentPlaces3),
			ISNULL(@OblectNonReleasePlacesMin1,@currentNonReleasePlaces1), ISNULL(@OblectNonReleasePlacesMin2,@currentNonReleasePlaces2), ISNULL(@OblectNonReleasePlacesMin3,@currentNonReleasePlaces3),
			@stopPercentSum1/@quotaCounter1,@stopPercentSum2/@quotaCounter2,@stopPercentSum3/@quotaCounter3)
		END
END
CLOSE curQ2
DEALLOCATE curQ2

--select * from #ServicePlacesTr
--ORDER BY  SPT_PRKey, SPT_Type, SPT_SubCode1, SPT_PartnerName, SPT_Description, 
--		SPT_FilialKey, SPT_CityDepartments, SPT_Date, SPT_Release

--select * from #ServicePlaces


	select 
		SP_PRKey,SP_PartnerName,SP_Description,SP_SubCode1,SP_Type,SP_FilialKey,SP_CityDepartments,
		CAST(SP_Places1 as varchar(4))+';'+CAST(SP_NonReleasePlaces1 as varchar(4))+';'+CAST(SP_StopPercent1 as varchar(4)) as SP_1,
		CAST(SP_Places2 as varchar(4))+';'+CAST(SP_NonReleasePlaces2 as varchar(4))+';'+CAST(SP_StopPercent2 as varchar(4)) as SP_2,
		CAST(SP_Places3 as varchar(4))+';'+CAST(SP_NonReleasePlaces3 as varchar(4))+';'+CAST(SP_StopPercent3 as varchar(4)) as SP_3
	from @ServicePlaces
	order by SP_Description, SP_PartnerName, SP_Type
GO

grant execute on [dbo].[GetQuotaLoadListData_N] to public
GO

/*********************************************************************/
/* end sp_GetQuotaLoadListData_N.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetServiceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetServiceList]
GO

CREATE procedure [dbo].[GetServiceList] 
(
--<VERSION>2009.02.02</VERSION>
--<DATE>2012-07-06</DATE>
@TypeOfRelult int, -- 1-список по по услугам, 2-список по туристам на услуге
@SVKey int, 
@Codes varchar(100), 
@SubCode1 int=null,
@Date datetime =null, 
@QDID int =null,
@QPID int =null,
@ShowHotels bit =null,
@ShowFligthDep bit =null,
@ShowDescription bit =null,
@State smallint=null,
@SubCode2 int = null
)
as 
declare @Query varchar(8000)
 
CREATE TABLE #Result
(
	DG_Code nvarchar(max), DG_Key int, DG_DiscountSum money, DG_Price money, DG_Payed money,
	DG_PriceToPay money, DG_Rate nvarchar(3), DG_NMen int, PR_Name nvarchar(max), CR_Name nvarchar(max),
	DL_Key int, DL_NDays int, DL_NMen int, DL_Reserved int, DL_CTKeyTo int, DL_CTKeyFrom int, DL_CNKEYFROM int,
	DL_SubCode1 int, TL_Key int, TL_Name nvarchar(max), TUCount int, TU_NameRus nvarchar(max), TU_NameLat nvarchar(max),
	TU_FNameRus nvarchar(max), TU_FNameLat nvarchar(max), TU_Key int, TU_Sex Smallint, TU_PasportNum nvarchar(max),
	TU_PasportType nvarchar(max), TU_PasportDateEnd datetime, TU_BirthDay datetime, TU_Hotels nvarchar(max),
	Request smallint, Commitment smallint, Allotment smallint, Ok smallint, TicketNumber nvarchar(max),
	FlightDepDLKey int, FligthDepDate datetime, FlightDepNumber nvarchar(max), ServiceDescription nvarchar(max),
	ServiceDateBeg datetime, ServiceDateEnd datetime, RM_Name nvarchar(max), RC_Name nvarchar(max), SD_RLID int,
	TU_SNAMERUS nvarchar(max), TU_SNAMELAT nvarchar(max), TU_IDKEY int
)
 
if @TypeOfRelult = 2
begin
	--- создаем таблицу в которой пронумируем незаполненых туристов
	CREATE TABLE #TempServiceByDate
	(
		SD_ID int identity(1,1) not null,
		SD_Date datetime,
		SD_DLKey int,
		SD_RLID int,
		SD_QPID int,
		SD_TUKey int,
		SD_RPID int,
		SD_State int
	)

	-- вносим все записи которые нам могут подойти
	insert into #TempServiceByDate(SD_Date, SD_DLKey, SD_RLID, SD_QPID,	SD_TUKey, SD_RPID, SD_State)
	select SD_Date, SD_DLKey, SD_RLID, SD_QPID,	SD_TUKey, SD_RPID, SD_State
	from ServiceByDate as SSD join Dogovorlist on DL_KEY = SD_DLKey
	where DL_SVKEY = @SVKey
	and DL_CODE = convert(int, @Codes)
	and ((@SubCode1 is null) or (DL_SUBCODE1 = @SubCode1))
	and ((@QPID is null) or (SD_QPID = @QPID))
	and ((@State is null) or (SD_State = @State))
	and exists (select 1 from ServiceByDate as SSD2 where SSD.SD_DLKey = SSD2.SD_DLKey and SSD2.SD_Date = @Date)

	declare @Id int, @SDDate datetime, @SDDLKey int, @SDTUKey int,
	@oldDlKey int, @oldDate datetime, @i int

	set @i = -1
	 
	DECLARE noBodyTurists CURSOR FOR 
	select SD_ID, SD_Date, SD_DLKey, SD_TUKey
	from #TempServiceByDate
	where SD_TUKey is null
	order by SD_DLKey, SD_Date

	OPEN noBodyTurists
	FETCH NEXT FROM noBodyTurists INTO @Id, @SDDate, @SDDLKey, @SDTUKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- если мы встретили новую дату или услугу то сбрасываем счетчик
		if @oldDlKey != @SDDLKey or @oldDate != @SDDate
		begin
			set @i = -1
		end
			
		update #TempServiceByDate
		set SD_TUKey = @i
		where SD_ID = @Id
		
		set @i = @i - 1

		set @oldDlKey = @SDDLKey
		set @oldDate = @SDDate
		
		FETCH NEXT FROM noBodyTurists INTO @Id, @SDDate, @SDDLKey, @SDTUKey
	END
	CLOSE noBodyTurists
	DEALLOCATE noBodyTurists 

	--select * from #TempServiceByDate


	SET @Query = '
		INSERT INTO #Result (DG_Code, DG_Key, DG_DiscountSum, DG_Price, DG_Payed, 
		DG_PriceToPay, DG_Rate, DG_NMen, 
		PR_Name, CR_Name, 
		DL_Key, DL_NDays, DL_NMen, DL_Reserved, DL_CTKeyTo, DL_CTKeyFrom, DL_SubCode1, ServiceDateBeg, ServiceDateEnd, 
		TL_Key, TUCount, TU_NameRus, TU_NameLat, TU_FNameRus, TU_FNameLat, TU_Key, 
		TU_Sex, TU_PasportNum, TU_PasportType, TU_PasportDateEnd, TU_BirthDay, TicketNumber, TU_SNAMERUS, TU_SNAMELAT, TU_IDKEY)
		SELECT	  DG_CODE, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED, 
		(case DG_PDTTYPE when 1 then DG_PRICE+DG_DISCOUNTSUM else DG_PRICE end ), DG_RATE, DG_NMEN, 
		PR_NAME, CR_NAME, DL_KEY, DL_NDays, DL_NMEN, DL_RESERVED, DL_CTKey, DL_SubCode2, DL_SubCode1, 
		DL_DateBeg, CASE WHEN ' + CAST(@SVKey as varchar(10)) + '=3 THEN DATEADD(DAY,1,DL_DateEnd) ELSE DL_DateEnd END,
		DG_TRKey, 0, TU_NAMERUS, TU_NAMELAT, TU_FNAMERUS, TU_FNAMELAT, SD_TUKey, case when SD_TUKey > 0 then isnull(TU_SEX,0) else null end, TU_PASPORTTYPE + ''№'' + TU_PASPORTNUM, TU_PASPORTTYPE, 
		TU_PASPORTDATEEND, TU_BIRTHDAY, TU_NumDoc, TU_SNAMERUS, TU_SNAMELAT, TU_IDKEY
		FROM  Dogovor join Dogovorlist on dl_dGKEY = DG_KEY
		left join Partners on dl_agent = pr_key
		join Controls on dl_control = cr_key
		join #TempServiceByDate on SD_DLKey = DL_KEY
		left join TuristService on tu_dlkey = dl_key and TU_TUKEY = SD_TUKey
		left join Turist on tu_key = tu_tukey
		WHERE '

		SET @Query=@Query + '
			 DL_SVKEY=' + CAST(@SVKey as varchar(20)) + ' AND DL_CODE in (' + @Codes + ') AND ''' + CAST(@Date as varchar(20)) + ''' BETWEEN DL_DATEBEG AND DL_DATEEND '

		IF @QPID is not null or @QDID is not null
		BEGIN
			IF @QPID is not null
				SET @Query=@Query + 'and SD_QPID IN (' + CAST(@QPID as varchar(20)) + ')'
			ELSE
				SET @Query=@Query + 'and exists (SELECT top 1 SD_DLKEY FROM #TempServiceByDate, QuotaParts WHERE SD_QPID=QP_ID and QP_QDID IN (' + CAST(@QDID as varchar(20)) + ') and SD_DLKEY=DL_Key and sd_tukey = tu_tukey)'
		END
				
		if (@SubCode1 != '0')
			SET @Query=@Query + ' AND DL_SUBCODE1 in (' + CAST(@SubCode1 as varchar(20)) + ')'
		IF @State is not null
			SET @Query=@Query + ' and SD_State=' + CAST(@State as varchar(1))
		if (@SubCode2 != '0')
			SET @Query=@Query + ' AND DL_SUBCODE2 in (' + CAST(@SubCode2 as varchar(20)) + ')'
		SET @Query=@Query + ' 
		group by DG_CODE, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED, DG_PDTTYPE, DG_RATE, DG_NMEN, 
		PR_NAME, CR_NAME, DL_KEY, DL_NDays, DL_NMEN, DL_RESERVED, DL_CTKey, DL_SubCode2, DL_SubCode1, DL_DateBeg,
		DL_DateEnd, DG_TRKey, TU_NAMERUS, TU_NAMELAT, TU_FNAMERUS,
		TU_FNAMELAT, SD_TUKey, TU_SEX, TU_PASPORTNUM, TU_PASPORTTYPE, TU_PASPORTDATEEND, TU_BIRTHDAY, TU_NumDoc, TU_SNAMERUS, TU_SNAMELAT, TU_IDKEY'
end
else
begin
	SET @Query = '
		INSERT INTO #Result (DG_Code, SD_RLID, RM_Name, RC_Name, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED,
		DG_PriceToPay, DG_RATE, DG_NMEN,
		PR_NAME, CR_NAME, DL_NDays, DL_NMEN, DL_RESERVED, DL_CTKeyTo, DL_SubCode1,
		ServiceDateBeg, ServiceDateEnd, TL_Key, TUCount, DL_Key, DL_CTKeyFrom)
		select DG_CODE, SD_RLID, RM_Name, RC_Name, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED,
		(case when DG_PDTTYPE = 1 then DG_PRICE+DG_DISCOUNTSUM else DG_PRICE end ), DG_RATE, DG_NMEN,
		PR_NAME, CR_NAME, DL_NDays, case when QT_ByRoom = 1 then count(distinct SD_RLID) else count(distinct SD_RPID) end as DL_NMEN,
		DL_RESERVED, DL_CTKey, DL_SubCode2, DL_DateBeg, CASE WHEN ' + CAST(@SVKey as varchar(10)) + ' = 3 THEN DATEADD(DAY,1,DL_DateEnd) ELSE DL_DateEnd END, DG_TRKey, Count(distinct SD_TUKey), DL_KEY, DL_SubCode2
		from ServiceByDate left join RoomNumberLists on sd_rlid = rl_id
		left join Rooms on rl_rmkey = rm_key
		left join RoomsCategory on rl_rckey = rc_key
		left join QuotaParts on sd_qpid = qp_id
		left join QuotaDetails on QP_QDID = QD_ID and QP_Date = QD_Date
		left join Quotas on QT_ID = QD_QTID
		join Dogovorlist on sd_dlkey = dl_key
		join Controls on dl_control = cr_key
		left join Partners on dl_agent = pr_key
		join Dogovor on dl_dGKEY = DG_KEY
		where DL_SVKEY=' + CAST(@SVKey as varchar(20)) + ' AND DL_CODE in (' + @Codes + ') AND ''' + CAST(@Date as varchar(20)) + ''' BETWEEN DL_DATEBEG AND DL_DATEEND'
		
	if @QDID is not null
		SET @Query = @Query + ' and qp_qdid = ' + CAST(@QDID as nvarchar(max))
	if @QPID is not null
		SET @Query = @Query + ' and qp_id = ' + CAST(@QPID as nvarchar(max))
	
	SET @Query = @Query + '
		group by DG_CODE, SD_RLID, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED,
		DG_PDTTYPE, DG_DISCOUNTSUM, DG_RATE, DG_NMEN,
		PR_NAME, CR_NAME, DL_NDays, DL_RESERVED, DL_CTKey, DL_SubCode2,
		DL_DateBeg, DL_DateEnd, DG_TRKey, RM_Name, RC_Name, QT_ByRoom, DL_KEY'
end

--PRINT @Query
EXEC (@Query)
 
UPDATE #Result SET #Result.TL_Name=(SELECT TL_Name FROM TurList WHERE #Result.TL_Key=TurList.TL_Key)

--select * from  #Result

if @TypeOfRelult=1
BEGIN
	UPDATE #Result SET #Result.Request=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=4)
	UPDATE #Result SET #Result.Commitment=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=2)
	UPDATE #Result SET #Result.Allotment=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=1)
	UPDATE #Result SET #Result.Ok=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=3)
END
else
BEGIN
	UPDATE #Result SET #Result.Request=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=4)
	UPDATE #Result SET #Result.Commitment=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=2)
	UPDATE #Result SET #Result.Allotment=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=1)
	UPDATE #Result SET #Result.Ok=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=3)
END
 
IF @ShowHotels=1
BEGIN
	IF @TypeOfRelult = 2
	BEGIN
		DECLARE @HD_Name varchar(100), @HD_Stars varchar(25), @PR_Name varchar(100), @TU_Key int, @HD_Key int, @PR_Key int, @TU_KeyPrev int, @TU_Hotels varchar(255)
		DECLARE curServiceList CURSOR FOR 
			SELECT	  DISTINCT HD_Name, HD_Stars, PR_Name, TU_TUKey, HD_Key, PR_Key 
			FROM  HotelDictionary, DogovorList, TuristService, Partners
			WHERE	  PR_Key=DL_PartnerKey and HD_Key=DL_Code and TU_DLKey=DL_Key and TU_TUKey in (SELECT TU_Key FROM #Result) and dl_SVKey=3 
			ORDER BY TU_TUKey
		OPEN curServiceList
		FETCH NEXT FROM curServiceList INTO	  @HD_Name, @HD_Stars, @PR_Name, @TU_Key, @HD_Key, @PR_Key
		WHILE @@FETCH_STATUS = 0
		BEGIN
			IF @TU_Key!=@TU_KeyPrev or @TU_KeyPrev is null
			  Set @TU_Hotels=@HD_Name+' '+@HD_Stars+' ('+@PR_Name+')'
			ELSE
			  Set @TU_Hotels=@TU_Hotels+', '+@HD_Name+' '+@HD_Stars+' ('+@PR_Name+')'
			UPDATE #Result SET TU_Hotels=@TU_Hotels WHERE TU_Key=@TU_Key
			SET @TU_KeyPrev=@TU_Key
			FETCH NEXT FROM curServiceList INTO	  @HD_Name, @HD_Stars, @PR_Name, @TU_Key, @HD_Key, @PR_Key
		END
		CLOSE curServiceList
		DEALLOCATE curServiceList
	END
	IF @TypeOfRelult = 1
	BEGIN
		DECLARE @HD_Name1 varchar(100), @HD_Stars1 varchar(25), @PR_Name1 varchar(100), @DL_Key1 int, @HD_Key1 int, 
				@PR_Key1 int, @DL_KeyPrev1 int, @TU_Hotels1 varchar(255), @DG_Key int, @DG_KeyPrev int
		DECLARE curServiceList CURSOR FOR 
			--SELECT DISTINCT HD_Name, HD_Stars, P.PR_Name, DogList.DL_Key, HD_Key, PR_Key--, DG_Key
			--FROM HotelDictionary, DogovorList DogList, TuristService, Partners P
			--WHERE P.PR_Key = DogList.DL_PartnerKey and HD_Key = DogList.DL_Code and TU_DLKey = DogList.DL_Key and
			--TU_TUKey in (SELECT TU_TUKEY FROM TuristService WHERE TU_DLKEY in (SELECT DL_KEY FROM #Result)) 
			--and DL_SVKey=3 
			--ORDER BY DogList.DL_Key
			SELECT DISTINCT HD_Name, HD_Stars, HD_Key, P.PR_Name, P.PR_Key, DogList.DL_Key, R.DG_Key
			FROM HotelDictionary, DogovorList DogList, Partners P, #Result R
			WHERE P.PR_Key = DogList.DL_PartnerKey and HD_Key = DogList.DL_Code and DogList.DL_DGKey = R.DG_Key			
				  and DogList.DL_SVKey=3 
			ORDER BY R.DG_Key
		OPEN curServiceList
		FETCH NEXT FROM curServiceList INTO @HD_Name1, @HD_Stars1, @HD_Key1, @PR_Name1, @PR_Key1, @DL_Key1, @DG_Key
		WHILE @@FETCH_STATUS = 0
		BEGIN
			IF @DG_Key != @DG_KeyPrev or @DG_KeyPrev is null  
			BEGIN
			  Set @TU_Hotels1=@HD_Name1+' '+@HD_Stars1+' ('+@PR_Name1+')'
			END
			ELSE
			BEGIN
			  Set @TU_Hotels1=@TU_Hotels1+', '+@HD_Name1+' '+@HD_Stars1+' ('+@PR_Name1+')'
			END
			UPDATE #Result SET TU_Hotels=@TU_Hotels1 WHERE DG_Key=@DG_Key --DL_Key=@DL_Key1
			SET @DG_KeyPrev = @DG_Key
			FETCH NEXT FROM curServiceList INTO @HD_Name1, @HD_Stars1, @HD_Key1, @PR_Name1, @PR_Key1, @DL_Key1, @DG_Key
		END
		CLOSE curServiceList
		DEALLOCATE curServiceList
	END
END
 
IF @ShowFligthDep=1 and @SVKey=1
BEGIN
	IF @TypeOfRelult = 2
	BEGIN
		Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and DL_SubCode2=#Result.DL_CTKeyTo and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)
		if exists (select 1 from #Result Where FlightDepDLKey is null)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc) where FlightDepDLKey is null
		--если по городу не нашли ишем по стране
		if exists (select 1 from #Result Where FlightDepDLKey is null)     
		begin
			update #Result set DL_CNKEYFROM = (select top 1 ct_cnkey from citydictionary where ct_key =#Result.DL_CTKEYFROM)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CNKey=#Result.DL_CNKeyFrom and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)	where FlightDepDLKey is null	  
		end
	END
	ELSE
	BEGIN
		Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList Where DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and DL_SubCode2=#Result.DL_CTKeyTo and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)
		if exists (select 1 from #Result Where FlightDepDLKey is null)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList Where DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc) where FlightDepDLKey is null
		--если по городу не нашли ишем по стране
		if exists (select 1 from #Result Where FlightDepDLKey is null)     
		begin
			update #Result set DL_CNKEYFROM = (select top 1 ct_cnkey from citydictionary where ct_key =#Result.DL_CTKEYFROM)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CNKey=#Result.DL_CNKeyFrom and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)	where FlightDepDLKey is null	  
		end
	END
	Update #Result set FligthDepDate = (select dl_dateBeg From DogovorList where DL_Key=#Result.FlightDepDLKey)
	Update #Result set FlightDepNumber = (select CH_AirLineCode + ' ' + CH_Flight From DogovorList, Charter where DL_Code=CH_Key and DL_Key=#Result.FlightDepDLKey)
END

IF @ShowDescription=1
BEGIN
	IF @SVKey=1
		Update #Result SET ServiceDescription=LEFT((SELECT ISNUll(AS_Code, '') + '-' + AS_NameRus FROM AirService WHERE AS_Key=DL_SubCode1),80)
	ELSE IF (@SVKey=2 or @SVKey=4)
		Update #Result SET ServiceDescription=LEFT((SELECT TR_Name FROM Transport WHERE TR_Key=DL_SubCode1),80)
	ELSE IF (@SVKey=3 or @SVKey=8)
	BEGIN
		Update #Result SET ServiceDescription=LEFT((SELECT RM_Name + '(' + RC_Name + ')' + AC_Name FROM Rooms,RoomsCategory,AccMdMenType,HotelRooms WHERE HR_Key=DL_SubCode1 and HR_RMKey=RM_Key and HR_RCKey=RC_Key and HR_ACKey=AC_Key),80)
		IF @SVKey=8
			Update #Result SET ServiceDescription='All accommodations' where DL_SubCode1=0
	END
	ELSE IF (@SVKey=7 or @SVKey=9)
	BEGIN
		Update #Result SET ServiceDescription=LEFT((SELECT ISNULL(CB_Code,'') + ',' + ISNULL(CB_Category,'') + ',' + ISNULL(CB_Name,'') FROM Cabine WHERE CB_Key=DL_SubCode1),80)
		IF @SVKey=9
			Update #Result SET ServiceDescription='All accommodations' where DL_SubCode1=0
	END
	ELSE
		Update #Result SET ServiceDescription=LEFT((SELECT A1_Name FROM AddDescript1 WHERE A1_Key=DL_SubCode1),80) WHERE ISNULL(DL_SubCode1,0)>0
END

--print @Query
SELECT * FROM #Result

GO
GRANT EXECUTE ON [dbo].[GetServiceList] TO Public
GO

/*********************************************************************/
/* end sp_GetServiceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceLoadListData.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetServiceLoadListData]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetServiceLoadListData]
GO
CREATE procedure [dbo].[GetServiceLoadListData]
(
--<VERSION>2008.1.00.11a</VERSION>
@SVKey int,
@Code int,
@PRKey int =null,-- @PRKEY=null все
@DateStart smalldatetime = null,
@DaysCount int,
@CityDepartureKey int = null,-- город вылета
@bShowByRoom     bit =null,  -- показывать информацию по номерам (по умолчанию по людям)
@bShowByPartner  bit =null,  -- информацию разделять по партнерам
@bShowState      bit =null,  -- показать статус бронирования (запрос, на квоте, Ok) 
@bShowCommonInfo bit =null  -- показывать общую информацию по загрузке услуги
)
as 
/*
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@DaysCount,@SVKey,89)
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@PRKey,@bShowByRoom,88)
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@bShowByPartner,@bShowState,87)
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@bShowCommonInfo,@Code,86)
*/
if @SVKey!=3
	Set @bShowByRoom=0

DECLARE @DateEnd smalldatetime
Set @DateEnd = DATEADD(DAY, @DaysCount-1, @DateStart)

CREATE TABLE #ServiceLoadList
(
SL_ID INT IDENTITY(1,1) NOT NULL, 
SL_ServiceName nvarchar(100), SL_State smallint,
SL_SubCode1 int, SL_SubCode2 int, SL_PRKey int
/*SL_DataType это мнимая колонка, есть только при выводе результата 
содержит тип информации для записей с итогами
(1 - общий итог, 2 - данные по услуге)
*/
)
DECLARE @n int, @nMax int, @str nvarchar(max),@SL_SubCode1 int, @SL_SubCode2 int, @s nvarchar(1), @ServiceName nvarchar(255), @ServiceName_1 nvarchar(255)
set @n=1 

WHILE @n <= @DaysCount
BEGIN
	set @str = 'ALTER TABLE #ServiceLoadList ADD SL_' + CAST(@n as nvarchar(3)) + ' nvarchar(20)'
	exec (@str)
	set @n = @n + 1
END

if @SVKey != 8
begin
	if @bShowByPartner =1 and @bShowState=1
	insert into #ServiceLoadList (SL_SubCode1, SL_PRKey, SL_State)
		select distinct DL_SubCode1, DL_PartnerKey, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
else if @bShowByPartner =0 and @bShowState=1
	insert into #ServiceLoadList (SL_SubCode1, SL_State)
		select distinct DL_SubCode1, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
else if @bShowByPartner =1 and @bShowState=0
	insert into #ServiceLoadList (SL_SubCode1, SL_PRKey)
		select distinct DL_SubCode1, DL_PartnerKey from DogovorList, Dogovor
		where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
else
	insert into #ServiceLoadList (SL_SubCode1)
		select distinct DL_SubCode1 from DogovorList, Dogovor
		where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
end if @SVKey = 8
begin 
	if @bShowByPartner =1 and @bShowState=1
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2, SL_PRKey, SL_State)
			select distinct DL_SubCode1, DL_SubCode2, DL_PartnerKey, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
			where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
	else if @bShowByPartner =0 and @bShowState=1
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2, SL_State)
			select distinct DL_SubCode1, DL_SubCode2, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
			where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
	else if @bShowByPartner =1 and @bShowState=0
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2, SL_PRKey)
			select distinct DL_SubCode1, DL_SubCode2, DL_PartnerKey from DogovorList, Dogovor
			where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
	else
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2)
			select distinct DL_SubCode1, DL_SubCode2 from DogovorList, Dogovor
			where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
end
 
while exists(select SL_SubCode1 from #ServiceLoadList where SL_ServiceName is null)
BEGIN
	if @SVKey != 8
	begin
		select @SL_SubCode1=SL_SubCode1 from #ServiceLoadList where SL_ServiceName is null
		exec GetSvCode1Name @SVKey,@SL_SubCode1,@s output,@ServiceName output,@s output,@s output
		UPDATE #ServiceLoadList SET SL_ServiceName=@ServiceName where SL_SubCode1=@SL_SubCode1
	end if @SVKey = 8
	begin
		select @SL_SubCode1=SL_SubCode1, @SL_SubCode2=SL_SubCode2 from #ServiceLoadList where SL_ServiceName is null
		exec GetSvCode1Name @SVKey,@SL_SubCode1,@s output,@ServiceName output,@s output,@s output
		exec dbo.GetSvCode2Name @SVKey, @SL_SubCode2, @ServiceName_1 output, @s output
		UPDATE #ServiceLoadList SET SL_ServiceName=@ServiceName + ',' + @ServiceName_1 where SL_SubCode1=@SL_SubCode1 and SL_SubCode2=@SL_SubCode2
	end 
END

If @bShowByRoom=1
	DECLARE curSLoadList CURSOR FOR SELECT
		'UPDATE #ServiceLoadList SET SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + '= ISNULL(SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + ',0)+' + CAST(Count(Distinct SD_RLID) as nvarchar(5)) + ' WHERE SL_SubCode1=' + CAST(DL_SubCode1 as nvarchar(10)) + CASE WHEN @bShowByPartner=1 THEN ' AND SL_PRKey=' + CAST(DL_PartnerKey as nvarchar(10)) ELSE '' END + CASE WHEN @bShowState=1 THEN ' AND SL_State=' + CAST(ISNULL(SD_STATE,0) as nvarchar(10)) ELSE '' END
		from	DogovorList,ServiceByDate, Dogovor 
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey
				and DL_SVKey=@SVKey and DL_Code=@Code 
				and DL_DateBeg<=@DateEnd and DL_DateEnd>=@DateStart
				and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
				and SD_Date<=@DateEnd and SD_Date>=@DateStart
		group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State
Else
	DECLARE curSLoadList CURSOR FOR SELECT
		'UPDATE #ServiceLoadList SET SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + '= ISNULL(SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + ',0)+' + CAST(Count(SD_ID) as nvarchar(5)) + ' WHERE SL_SubCode1=' + CAST(DL_SubCode1 as nvarchar(10)) + CASE WHEN @SVKey=8 THEN 'AND SL_SubCode2=' + CAST(DL_SUBCODE2 as nvarchar(10)) ELSE '' END + CASE WHEN @bShowByPartner=1 THEN ' AND SL_PRKey=' + CAST(DL_PartnerKey as nvarchar(10)) ELSE '' END + CASE WHEN @bShowState=1 THEN ' AND SL_State=' + CAST(ISNULL(SD_STATE,0) as nvarchar(10)) ELSE '' END
		from	DogovorList,ServiceByDate, Dogovor 
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey
				and DL_SVKey=@SVKey and DL_Code=@Code
				and DL_DateBeg<=@DateEnd and DL_DateEnd>=@DateStart
				and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
				and SD_Date<=@DateEnd and SD_Date>=@DateStart
		group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State, DL_SVKey, DL_SUBCODE2

OPEN curSLoadList
FETCH NEXT FROM curSLoadList INTO	@str
WHILE @@FETCH_STATUS = 0
BEGIN
	--print @DateStart
	--print @str
	exec (@str)
	FETCH NEXT FROM curSLoadList INTO	@str
END
CLOSE curSLoadList
DEALLOCATE curSLoadList

Set @str = ''
set @n=1
set @str = @str + 'SELECT SL_ServiceName, SL_State, SL_SubCode1, ' + CASE WHEN @SVKey=8 THEN 'SL_SubCode2, ' ELSE '' END + ' SL_PRKey '
WHILE @n <= @DaysCount
BEGIN
	print @str
	set @str = @str + ', SL_' + CAST(@n as nvarchar(3)) 
	set @n = @n + 1
END
/*
Set @str = @str + ' from #QuotaLoadList, Numbers where NU_ID between 1 and 3
and QL_IsQD=0
order by QL_Type,QL_Release,QL_Durations,QL_CityDepartments,QL_FilialKey,QL_CustomerInfo,NU_ID'
*/
Set @str = @str + ' from #ServiceLoadList order by SL_ServiceName, SL_SubCode1, ' + CASE WHEN @SVKey=8 THEN 'SL_SubCode2,' ELSE '' END + ' SL_PRKey, SL_State'
exec (@str)
GO
grant exec on GetServiceLoadListData to public
go


/*********************************************************************/
/* end sp_GetServiceLoadListData.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetSvCode1Name.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetSvCode1Name]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetSvCode1Name]
GO
CREATE PROCEDURE [dbo].[GetSvCode1Name]
(
--<VERSION>2005.4.22</VERSION>
      @nSvKey INT,
      @nCode1 INT,
      @sTitle VARCHAR(800) OUTPUT,
      @sName VARCHAR(800) OUTPUT,
      @sTitleLat VARCHAR(800) OUTPUT,
      @sNameLat VARCHAR(800) OUTPUT,
      @bIsQuote bit = null
) AS
DECLARE 
      @nRoom INT,
      @nCategory INT,
      @sNameCategory VARCHAR(800),
      @sNameCategoryLat VARCHAR(800),
      @nHrMain INT,
      @nAgeFrom INT,
      @nAgeTo INT,
      @sAcCode VARCHAR(800),
      @sTmp VARCHAR(800),
      @bTmp INT,

      @TYPE_FLIGHT INT, 
      @TYPE_TRANSFER INT,
      @TYPE_HOTEL INT,
      @TYPE_EXCUR INT,
      @TYPE_VISA INT,
      @TYPE_INSUR INT,
      @TYPE_SHIP INT,
      @TYPE_HOTELADDSRV INT,
      @TYPE_SHIPADDSRV INT
      
      Set @TYPE_FLIGHT = 1
      Set @TYPE_TRANSFER = 2
      Set @TYPE_HOTEL = 3
      Set @TYPE_EXCUR = 4
      Set @TYPE_VISA = 5
      Set @TYPE_INSUR = 6
      Set @TYPE_SHIP = 7
      Set @TYPE_HOTELADDSRV = 8
      Set @TYPE_SHIPADDSRV = 9
            
      Set @sName = ''

      IF @nSvKey = @TYPE_FLIGHT
      BEGIN
            SET @sTitle = 'Тариф'
            SET @sName = 'Любой'
            SET @sTitleLat = 'Tariff'
            SET @sNameLat = 'Any'

            IF EXISTS(SELECT * FROM dbo.AirService WHERE AS_Key = @nCode1) and (@nCode1 <> -1)
                  SELECT      @sName = IsNull(AS_Code, '') + '-' + AS_NameRus,
                        @sNameLat = IsNull(AS_Code, '') + '-' + IsNull(AS_NameLat, AS_NameRus)
                  FROM dbo.AirService 
                  WHERE AS_Key = @nCode1
      END
      ELSE
      IF (@nSvKey = @TYPE_TRANSFER) or (@nSvKey = @TYPE_EXCUR)
      BEGIN
            SET @sTitle = 'Транспорт'
            SET @sName = 'Любой'
            SET @sTitleLat = 'Transport'
            SET @sNameLat = 'Any'
            
            IF EXISTS(SELECT * FROM dbo.Transport WHERE TR_Key = @nCode1)
                  SELECT      @sName = TR_Name + ',' + CAST(IsNull(TR_NMen, 0) AS varchar(5)),
                        @sNameLat = IsNull(TR_NameLat, TR_Name) + ',' + CAST(IsNull(TR_NMen, 0) AS varchar(5))
                  FROM dbo.Transport 
                  WHERE       TR_Key = @nCode1        
      END
      ELSE
      IF (@nSvKey = @TYPE_HOTELADDSRV or @nSvKey = @TYPE_HOTEL)
      BEGIN
            IF @nCode1 = 0
                  IF ISNULL(@bIsQuote,0) = 1
                  BEGIN
                        SET @sTitle = 'Тип номера'
                        SET @sName = 'Все типы номеров'
                        SET @sTitleLat = 'Room type'
                        SET @sNameLat = 'All room types'
                  END
                  ELSE
                  BEGIN
                        SET @sTitle = 'Размещение'
                        SET @sName = 'Все размещения'
                        SET @sTitleLat = 'Accommodation'
                        SET @sNameLat = 'All accommodations'
                  END
            ELSE  
                  IF ISNULL(@bIsQuote,0) = 1
                  BEGIN
                        EXEC GetRoomName @nCode1, @sName output, @sNameLat output

                        Set @sTitle = 'Тип номера'
                        Set @sTitleLat = 'Room type'
                  END
                  ELSE
                  BEGIN
                        EXEC GetRoomKey @nCode1, @nRoom output
                        EXEC GetRoomCategoryKey @nCode1, @nCategory output
                        EXEC GetRoomName @nRoom, @sName output, @sNameLat output
                        EXEC GetRoomCtgrName @nCategory, @sNameCategory output, @sNameCategoryLat output

                        Set @sName = @sName + '(' + @sNameCategory + ')'
                        Set @sNameLat = @sNameLat + '(' + @sNameCategoryLat + ')'
                        Set @sTitle = 'Размещение'
                        Set @sTitleLat = 'Accommodation'
                  END
                  
                  if isnull((select SS_ParmValue from SystemSettings where SS_ParmName = 'CartAccmdMenTypeView'), 0) = 0
                  begin
                        SELECT @nHrMain = IsNull(HR_Main, 0), @nAgeFrom = IsNull(HR_AgeFrom, 0), @nAgeTo = IsNull(HR_AgeTo, 0), @sAcCode = IsNull(AC_Name, '') FROM dbo.HotelRooms, dbo.AccmdMenType WHERE (HR_Key = @nCode1) AND (HR_AcKey = AC_Key)                       
                  end
                  else
                  begin
                        SELECT @nHrMain = IsNull(HR_Main, 0), @nAgeFrom = IsNull(HR_AgeFrom, 0), @nAgeTo = IsNull(HR_AgeTo, 0), @sAcCode = IsNull(AC_Code, '') FROM dbo.HotelRooms, dbo.AccmdMenType WHERE (HR_Key = @nCode1) AND (HR_AcKey = AC_Key)
                  end
      END
      ELSE
      if (@nSvKey = @TYPE_SHIPADDSRV or @nSvKey = @TYPE_SHIP)
      BEGIN
            IF @nCode1 = 0
            BEGIN
                  Set @sTitle = 'Каюта'
                  Set @sName = 'Все каюты'
                  SET @sTitleLat = 'Cabin'
                  SET @sNameLat = 'All cabins'
            END
            ELSE
            BEGIN
                  SET @sTitle = 'Каюта'
                  SET @sName = 'Любая'
                  SET @sTitleLat = 'Cabin'
                  SET @sNameLat = 'Any'

                  IF EXISTS( SELECT * FROM dbo.Cabine WHERE CB_Key = @nCode1 )
                        SELECT      @sName = CB_Code + ',' + CB_Category + ',' + CB_Name,
                             @sNameLat = CB_Code + ',' + CB_Category + ',' + ISNULL(CB_NameLat,CB_Name)
                        FROM dbo.Cabine 
                        WHERE CB_Key = @nCode1
            END
      END
      ELSE
      BEGIN
            Set @sTmp = 'CODE1'
            EXEC dbo.GetSvListParm @nSvKey, @sTmp, @bTmp output
      
            IF @bTmp > 0
            BEGIN
                  SET @sTitle = 'Доп.описание'
                  SET @sName = 'Любое'
                  SET @sTitleLat = 'Add.description'
                  SET @sNameLat = 'Any'
                  
                  IF EXISTS( SELECT * FROM dbo.AddDescript1 WHERE A1_Key = @nCode1 )
                        SELECT      @sName = A1_Name + 
                                   (CASE 
                                         WHEN ( LEN(IsNull(A1_Code, '')) > 0 ) THEN (','+ A1_Code) 
                                         ELSE ('') 
                                   END), 
                             @sNameLat = ISNULL(A1_NameLat,A1_Name) + 
                                   (CASE 
                                         WHEN ( LEN(IsNull(A1_Code, '')) > 0 ) THEN (','+ A1_Code) 
                                         ELSE ('') 
                                   END)
                        FROM dbo.AddDescript1 
                        WHERE A1_Key = @nCode1
            END
            ELSE
            BEGIN
                  SET @sTitle = ''
                  SET @sTitleLat = ''
            END
      END


      IF @nCode1 > 0 and ((@nSvKey = @TYPE_HOTEL) or (@nSvKey = @TYPE_HOTELADDSRV)) and isnull(@bIsQuote, 0) = 0
      BEGIN
            if @sAcCode is not null
                  begin
                        Set @sName = @sName + ',' + isnull(@sAcCode, '')
                        Set @sNameLat = @sNameLat + ',' + isnull(@sAcCode, '')
                  end
            SET @sTmp = isnull(CAST(@nAgeFrom as varchar(5)), '0') + '-' + isnull(cast(@nAgeTo as varchar(5)), '')
            If @nHrMain <= 0
            begin                   
                  SET @sName = @sName + ' доп(' + @sTmp + ')'
                  SET @sNameLat = @sNameLat + ' ex(' + @sTmp + ')'
            END
            ELSE
                  IF (@nAgeFrom > 0) or (@nAgeTo > 0)
                  BEGIN
                        print @sTmp
                        SET @sName =  @sName + ' (' + @sTmp + ')'
                        SET @sNameLat = @sNameLat + ' (' + @sTmp + ')'                   
                  END
      END

GO

grant exec on [dbo].[GetSvCode1Name] to public
go
/*********************************************************************/
/* end sp_GetSvCode1Name.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetTableQuotaDetails.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetTableQuotaDetails]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[GetTableQuotaDetails]
GO

create procedure [dbo].[GetTableQuotaDetails]
(
--<VERSION>2009.14</VERSION>
--<DATE>2012-07-27</DATE>
@DL_Key int =null,
@QT_ID int  =null,
@DateStart smalldatetime = null,
@DaysCount int  =null,
@QT_Type int  =null,
@QT_Release int  =null,
@DL_SVKey int  =null, 
@DL_Code int  =null, 
@DL_SubCode1 int  =null, 
@DL_PRKey int  =null,
@GroupByQD bit = null
)
AS
/*
возвращает таблицу со стопами по всем комбинациям услуг

есть 5 вариантов вызова
1. экран "Наличие мест на квоте" - @QT_ID, @DateStart, @DaysCount !!! до 2008.1.1 (после 2008.1.2 см.пункт 5 )
2. экран "Выбрать квоту (основной режим)" - @DL_Key, @DateStart, @DaysCount
3. функция проверки наличия мест [CheckQuotaExist] @QT_ID, @DateStart, @DaysCount, @DL_SVKey, @DL_Code, @DL_SubCode1, @DL_PRKey
4. из экрана Стоп по квоте @QT_ID, @DateStart, @DaysCount, @QT_Type
5. экран "Наличие мест на квоте" - @DateStart, @DaysCount, @DL_SVKey, @DL_Code, @GroupByQD !!! после 2008.1.2 (до 2008.1.1 см.пункт 1 ) 
*/
DECLARE @DateEnd smalldatetime
Set @DateEnd = DATEADD(DAY, @DaysCount-1, @DateStart)

DECLARE @QO_SubCode1 int, @QO_SubCode2 int
IF @DL_Key is not null --значит смотрим из конкретной услуги
	SELECT @DL_SVKey=DL_SVKey, @DL_Code=DL_Code, @DL_SubCode1=DL_SubCode1, @DL_PRKey=DL_PartnerKey FROM DogovorList WHERE DL_Key=@DL_Key
IF @DL_SVKey is not null and @DL_SubCode1 is not null
BEGIN
	SET @QO_SubCode2=0
	IF @DL_SVKey=3
		SELECT @QO_SubCode1=HR_RMKey, @QO_SubCode2=HR_RCKey FROM HotelRooms WHERE HR_Key=@DL_SubCode1
	ELSE
		SET @QO_SubCode1=@DL_SubCode1

	IF @DL_SVKey=1
		set @QO_SubCode2 = -1
END

--проверка стопов
--начало
CREATE TABLE #StopSaleTemp_Local
(
SST_Code int,
SST_SubCode1 int,
SST_SubCode2 int,
SST_QOID int,
SST_PRKey int,
SST_Date smalldatetime,
SST_QDID int,
SST_Type smallint,
SST_State smallint,
SST_Comment varchar(255)
)

IF @DL_Key is not null --значит смотрим по конкретной услуги
BEGIN
	INSERT INTO #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		SELECT	QO_Code,QO_SubCode1,QO_SubCode2,QO_ID,QT_PRKey,QD_Date,QD_ID,QD_Type
		FROM	QuotaObjects,Quotas,QuotaDetails
		WHERE	QO_QTID=QT_ID and ((QT_ID=@QT_ID and @QT_ID is not null) or (@QT_ID is null)) and QD_QTID=QT_ID
				and QD_Date between @DateStart and @DateEnd
				and QO_SVKey=@DL_SVKey and QO_Code=@DL_Code and (QO_SubCode1=@QO_SubCode1 or QO_SubCode1=0)
				and (QO_SubCode2=@QO_SubCode2 or QO_SubCode2=0)
				and (QT_PRKey=@DL_PRKey or QT_PRKey=0)
END
ELSE IF @QT_ID is not null
BEGIN
	INSERT INTO #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		SELECT	QO_Code,QO_SubCode1,QO_SubCode2,QO_ID,QT_PRKey,QD_Date,QD_ID,QD_Type
		FROM	QuotaObjects,Quotas,QuotaDetails
		WHERE	QO_QTID=QT_ID and ((QT_ID=@QT_ID and @QT_ID is not null) or (@QT_ID is null)) and QD_QTID=QT_ID
				and QD_Date between @DateStart and @DateEnd
				and ((QO_SVKey=@DL_SVKey and @DL_SVKey is not null) or (@DL_SVKey is null))
				and ((QO_Code=@DL_Code and @DL_Code is not null) or (@DL_Code is null))
				and (((QO_SubCode1=0 or QO_SubCode1=@QO_SubCode1) and @QO_SubCode1 is not null) or (@QO_SubCode1 is null))
				and (((QO_SubCode2=0 or QO_SubCode2=@QO_SubCode2) and @QO_SubCode2 is not null) or (@QO_SubCode2 is null))
				and ((QD_Type=@QT_Type and @QT_Type is not null) or (@QT_Type is null))
				and ((ISNULL(QD_Release,0)=ISNULL(@QT_Release,0) and @QT_Type is not null) or (@QT_Type is null))	--специально смотрим @QT_Type, т.к. @QT_Release может прийти NULL
END
ELSE IF @QT_ID is null --экран "Наличие мест" (после 2008.1.2)
BEGIN
	INSERT INTO #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		SELECT	QO_Code,QO_SubCode1,QO_SubCode2,QO_ID,QT_PRKey,QD_Date,QD_ID,QD_Type
		FROM	Quotas join QuotaObjects on QO_QTID = QT_ID
				join QuotaDetails on QD_QTID = QT_ID
		WHERE QD_Date between @DateStart and @DateEnd
		and QO_SVKey = @DL_SVKey 
		and QO_Code = @DL_Code
END

		--AleXK добавил чтобы есл есть квота на SST_SubCode1 = все, то создавалиь бы все квоты по признакам
		insert into #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		select QO_Code, QO_SubCode1, QO_SubCode2, QO_ID, SS_PRKey, SS_Date, SST_QDID, SST_Type
		from QuotaObjects join StopSales on QO_ID = SS_QOID
		join #StopSaleTemp_Local on QO_Code = SST_Code and QO_SubCode2 = SST_SubCode2 and SS_PRKey = SST_PRKey and SS_Date = SST_Date
		where not exists (select 1 from #StopSaleTemp_Local where SST_QOID = QO_ID)
		and SST_SubCode1 = 0
		
		--AleXK добавил чтобы есл есть квота на SST_SubCode2 = все, то создавалиь бы все квоты по признакам
		insert into #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		select QO_Code, QO_SubCode1, QO_SubCode2, QO_ID, SS_PRKey, SS_Date, SST_QDID, SST_Type
		from QuotaObjects join StopSales on QO_ID = SS_QOID
		join #StopSaleTemp_Local on QO_Code = SST_Code and QO_SubCode1 = SST_SubCode1 and SS_PRKey = SST_PRKey and SS_Date = SST_Date
		where not exists (select 1 from #StopSaleTemp_Local where SST_QOID = QO_ID)
		and SST_SubCode2 = 0
		
		--AleXK добавил чтобы есл есть квота на SST_SubCode1 = все и SST_SubCode2 = все, то создавалиь бы все квоты по признакам
		insert into #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		select QO_Code, QO_SubCode1, QO_SubCode2, QO_ID, SS_PRKey, SS_Date, SST_QDID, SST_Type
		from QuotaObjects join StopSales on QO_ID = SS_QOID
		join #StopSaleTemp_Local on QO_Code = SST_Code and SS_PRKey = SST_PRKey and SS_Date = SST_Date
		where not exists (select 1 from #StopSaleTemp_Local where SST_QOID = QO_ID)
		and SST_SubCode1 = 0 and SST_SubCode2 = 0

--if exists (select SS_ParmValue from systemsettings where SS_ParmName='SYSCheckQuotaRelease' and SS_ParmValue=1) OR exists (select SS_ParmValue from systemsettings where SS_ParmName='SYSAddQuotaPastPermit' and SS_ParmValue=1)
BEGIN
	-- оборобатываем стопы которые висят на QuotaDetails
	IF @DL_Key is not null --значит по услуге, значит не надо смотреть в QuotaObjects, так как объекты уже отобраны
	begin
		Update #StopSaleTemp_Local Set SST_State=1, SST_Comment= (SELECT TOP 1 REPLACE(SS_Comment,'''','"') FROM StopSales,QuotaObjects WHERE SS_QOID=QO_ID and SS_QDID=SST_QDID and QO_Code=@DL_Code and SS_Date between @DateStart and @DateEnd and (SS_IsDeleted is null or SS_IsDeleted=0)
				and (QO_SubCode1=SST_SubCode1 or QO_SubCode1=0)	and (QO_SubCode2=SST_SubCode2 or QO_SubCode2=0))
			WHERE exists (SELECT SS_ID FROM StopSales,QuotaObjects WHERE SS_QOID=QO_ID and SS_QDID=SST_QDID and QO_Code=@DL_Code and SS_Date between @DateStart and @DateEnd and (SS_IsDeleted is null or SS_IsDeleted=0)
				and (QO_SubCode1=SST_SubCode1 or QO_SubCode1=0)	and (QO_SubCode2=SST_SubCode2 or QO_SubCode2=0))
	end
	Else
	begin
		Update #StopSaleTemp_Local
		Set SST_State=1, SST_Comment = (SELECT TOP 1 REPLACE(SS_Comment,'''','"') 
										FROM StopSales 
										WHERE SS_QDID = SST_QDID 
										and SS_QOID = SST_QOID 
										and SS_Date between @DateStart and @DateEnd 
										and isnull(SS_IsDeleted, 0) = 0)
		WHERE exists (SELECT SS_ID 
						FROM StopSales 
						WHERE SS_QDID = SST_QDID 
						and SS_QOID = SST_QOID 
						and SS_Date between @DateStart and @DateEnd 
						and isnull(SS_IsDeleted, 0) = 0)
	end
		
	-- обрабатывались так же стопы которые висят не на QuotaDetails
	Update #StopSaleTemp_Local Set SST_State = 2, SST_Comment = 
		(
			SELECT TOP 1 REPLACE(SS_Comment,'''','"') 
			FROM StopSales,QuotaObjects
			WHERE	SS_QDID is null
					and SS_Date between @DateStart and @DateEnd
					and (SS_PRKey=SST_PRKey or SS_PRKey=0)					
					and SS_QOID = QO_ID
					and SS_Date=SST_Date
					and (QO_SVKey = @DL_SVKey or @DL_SVKey is null)
					and (QO_Code = SST_Code or QO_Code=0)
					and (QO_SubCode1 = SST_SubCode1 or QO_SubCode1 = 0 or SST_SubCode1 = 0)
					and (QO_SubCode2 = SST_SubCode2 or QO_SubCode2 = 0 or SST_SubCode2 = 0)
					and (SS_IsDeleted is null or SS_IsDeleted=0)
		)
		WHERE exists ( SELECT 1
						FROM QuotaObjects join StopSales on QO_ID = SS_QOID
						WHERE SS_QDID is null
						and SS_Date between @DateStart and @DateEnd
						and (SS_PRKey = SST_PRKey or SS_PRKey = 0)
						and SS_Date = SST_Date
						and (QO_SVKey = @DL_SVKey or @DL_SVKey is null)
						and (QO_Code = SST_Code or QO_Code=0)
						and (QO_SubCode1 = SST_SubCode1 or QO_SubCode1 = 0)
						and (QO_SubCode2 = SST_SubCode2 or QO_SubCode2 = 0)
						and isnull(SS_IsDeleted, 0) = 0
						and (SST_Type = 1 or isnull(SS_AllotmentAndCommitment,0) = 1)
					)
END
 --where sst_QDID=2602
--проверка стопов
--окончание
if @GroupByQD=1
	select	SST_QDID, Count(*) as SST_QO_Count, 
			(SELECT count(*) from #StopSaleTemp_Local s2 WHERE s2.SST_QDID = s1.SST_QDID and SST_State is not null) as SST_QO_CountWithStop,
			(SELECT TOP 1 SST_Comment FROM #StopSaleTemp_Local s3 WHERE s3.SST_QDID=s1.SST_QDID and SST_Comment is not null and SST_Comment != '') as SST_Comment
	from #StopSaleTemp_Local s1
	group by SST_QDID	
	having (SELECT count(*) from #StopSaleTemp_Local s2 WHERE s2.SST_QDID = s1.SST_QDID and SST_State is not null) > 0
else
	select * from #StopSaleTemp_Local
GO

grant execute on [dbo].[GetTableQuotaDetails] to public
GO

/*********************************************************************/
/* end sp_GetTableQuotaDetails.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_InsDogListAfter.sql */
/*********************************************************************/
-- MEG00040685 13.04.2012 rozin
-- Процедура вызывается после добавления элемента путевки с помощью InsDogList

--<VERSION>ALL</VERSION>
--<DATE>13.04.2012</DATE>

IF  EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[InsDogListAfter]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].InsDogListAfter
GO

CREATE PROCEDURE [dbo].InsDogListAfter (@dogovorKey int)
AS
BEGIN
-- На 13.04.2012 ничего не делает
RETURN
END

GO
grant exec on [dbo].InsDogListAfter to [public]
GO
/*********************************************************************/
/* end sp_InsDogListAfter.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_InsertHistory.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='InsertHistory')
	drop proc dbo.InsertHistory
GO

CREATE PROCEDURE [dbo].[InsertHistory]
(
--<DATE>2012-03-15</DATE>
--<VERSION>2009.2.2</VERSION>
	@sHI_DGCOD varchar(10) = null,
	@nHI_DLKEY int = null,
	@sHI_MOD varchar(3),
	@sHI_TEXT varchar(254),
	@sHI_REMARK varchar(25)
)
AS
	declare @sHI_WHO varchar(25)
	declare @nHI_SVKEY int
	declare @nHI_CODE int
	declare @nHI_CODE1 int
	declare @nHI_CODE2 int
	declare @nHI_DAY smallint
	declare @nHI_NDAYS smallint
	declare @nHI_NMEN smallint
	declare @nHI_PRKEY int
	declare @nHI_DGKEY int
	declare @nHI_USERID int		--MEG00040421 tkachuk 15.03.2011 Id пользователя, внесшего изменения

	Set @nHI_SVKEY = null
	Set @nHI_SVKEY = null
	Set @nHI_CODE = null
	Set @nHI_CODE1 = null
	Set @nHI_CODE2 = null
	Set @nHI_DAY = null
	Set @nHI_NDAYS = null
	Set @nHI_NMEN = null
	Set @nHI_PRKEY = null
	Set @nHI_DGKEY = null
	Set @nHI_USERID = null

	If @nHI_DLKEY is not null
	BEGIN
		SELECT 	@sHI_DGCOD = DL_DGCOD, @nHI_SVKEY = DL_SVKEY, @nHI_CODE = DL_CODE, @nHI_CODE1 = DL_SUBCODE1,
				@nHI_CODE2 = DL_SUBCODE2, @nHI_DAY = DL_DAY, @nHI_NDAYS = DL_NDAYS, @nHI_NMEN = DL_NMEN,
				@nHI_PRKEY = DL_PARTNERKEY, @nHI_DGKEY = DL_DGKEY
		FROM	dbo.tbl_DogovorList with (nolock)
		WHERE	DL_KEY = @nHI_DLKEY
	END

	EXEC dbo.CurrentUser @sHI_WHO output
	EXEC dbo.GetUserKey @nHI_USERID output

	IF @nHI_DGKEY IS NULL AND @sHI_DGCOD IS NOT NULL
	BEGIN
		SELECT @nHI_DGKEY = DG_KEY 
		FROM dbo.tbl_Dogovor with (nolock)
		WHERE DG_CODE = @sHI_DGCOD
	END

	INSERT INTO dbo.History with (rowlock) (HI_DGCOD, HI_DGKEY, HI_DATE, HI_WHO, HI_TEXT, HI_MOD, HI_REMARK, HI_DLKEY, HI_SVKEY,
							 HI_CODE, HI_CODE1, HI_CODE2, HI_DAY, HI_NDAYS, HI_NMEN, HI_PRKEY, HI_USERID)
	VALUES (@sHI_DGCOD, @nHI_DGKEY, GETDATE(), @sHI_WHO, @sHI_TEXT, @sHI_MOD, @sHI_REMARK, @nHI_DLKEY, @nHI_SVKEY,
			@nHI_CODE,  @nHI_CODE1, @nHI_CODE2, @nHI_DAY, @nHI_NDAYS, @nHI_NMEN, @nHI_PRKEY, @nHI_USERID)

go

grant exec on dbo.InsertHistory to public
go
/*********************************************************************/
/* end sp_InsertHistory.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_InsHistory.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='InsHistory')
	drop proc dbo.InsHistory
go

--<DATE>2012-03-15</DATE>
--<VERSION>2009.2.2</VERSION>

CREATE PROCEDURE [dbo].[InsHistory]
(
	@sDGCod varchar(10),
	@nDGKey int,
	@nOAId int,
	@nTypeCode int,
	@sMod varchar(3),
	@sText varchar(254),
	@sRemark varchar(25),
	@nInvisible int,
	@sDocumentNumber varchar(255),
	@bMessEnabled bit=0,
	@nSVKey int=null,
	@nCode int=null,
	@nHiId int=null output
)
AS
	declare @sWho varchar(25), @sType varchar(32)
	declare @nHI_USERID int		--MEG00040421 tkachuk 15.03.2011 Id пользователя, внесшего изменения
	
	Set @nHI_USERID = null
	
	EXEC dbo.CurrentUser @sWho output
	EXEC dbo.GetUserKey @nHI_USERID output
	
	select @sType = left(OA_Alias, 32) from ObjectAliases where OA_Id = @nOAId
	
	IF @nDGKey IS NULL AND @sDGCod IS NOT NULL
	BEGIN
		SELECT @nDGKey = DG_KEY 
		FROM dbo.tbl_Dogovor with(nolock)
		WHERE DG_CODE = @sDGCod
	END
	
	INSERT INTO dbo.History with(rowlock) (
		HI_DGCOD, HI_DGKEY, HI_OAId, HI_DATE, HI_WHO, 
		HI_TEXT, HI_MOD, HI_REMARK, HI_TYPE, HI_TYPECODE, 
		HI_INVISIBLE, HI_DOCUMENTNAME, HI_MessEnabled, HI_SVKey, HI_Code, HI_USERID)
	VALUES (
		@sDGCod, @nDGKey, @nOAId, GETDATE(), @sWho, 
		@sText, @sMod, @sRemark, @sType, @nTypeCode, 
		@nInvisible, @sDocumentNumber, @bMessEnabled, @nSVKey, @nCode, @nHI_USERID)

		Set @nHiId = SCOPE_IDENTITY()

	RETURN SCOPE_IDENTITY()
go

grant exec on dbo.InsHistory to public
go

/*********************************************************************/
/* end sp_InsHistory.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_IsNewCalculatePriceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsNewCalculatePriceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[IsNewCalculatePriceList]
GO
CREATE PROCEDURE [dbo].[IsNewCalculatePriceList]
	(
		@nPriceTourKey int, -- ключ обсчитываемого тура
		@result int	output		-- результат выполнения 1 - новый расчет 0 - старый
	)
AS
BEGIN
	declare @calculatePriceByService varchar(255)
	set @result = 0

	select @calculatePriceByService = SS_ParmValue from systemsettings where ss_parmname = 'CalculatePriceByService'

	if isnull(@calculatePriceByService,'') = '1'
	begin
		set @result = 1
	end
END

GO
grant exec on [dbo].[IsNewCalculatePriceList] to public
go
/*********************************************************************/
/* end sp_IsNewCalculatePriceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCacheQuotaInsert.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwCacheQuotaInsert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwCacheQuotaInsert]
GO

create procedure [dbo].[mwCacheQuotaInsert]
	@svkey	int,
	@code	int,
	@subcode1	int,
	@subcode2	int,
	@date	datetime,
	@day	int,
	@days	int,
	@prkey	int,
	@pkkey	int,
	@result varchar(256),
	@places int,
	@step_index smallint,
	@price_correction int,
	@additional varchar(2000),
	@findFlight smallint	
as
begin
	insert into CacheQuotas(cq_svkey,cq_code,cq_rmkey,cq_rckey,cq_date,cq_day,cq_days,cq_prkey,cq_pkkey,cq_res,cq_places,cq_findFlight,cq_Additional) 
	values(@svkey,@code,@subcode1,@subcode2,@date,@day,@days,@prkey,@pkkey,@result,@places,@findFlight,@additional)
end	
GO

grant execute on [dbo].[mwCacheQuotaInsert] to public
GO
/*********************************************************************/
/* end sp_mwCacheQuotaInsert.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCacheQuotaSearch.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwCacheQuotaSearch]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwCacheQuotaSearch]
GO

create procedure [dbo].[mwCacheQuotaSearch]
	@svkey	int,
	@code	int,
	@subcode1	int,
	@subcode2	int,
	@date	datetime,
	@day	int,
	@days	int,
	@prkey	int,
	@pkkey	int,
	@result varchar(256) output,
	@places int output,
	@step_index smallint output,
	@price_correction int output,
	@additional varchar(2000) output,
	@findFlight smallint
as
begin
	set @result = NULL
	declare @datecheck datetime, @CacheQuoteMinute int
	set @CacheQuoteMinute = 10
	set @datecheck = null
	select TOP 1 @datecheck = cq_datecheck, @result = cq_res, @places = cq_places,
			@step_index = cq_stepindex, @price_correction = cq_pricecorrection,
			@additional = cq_Additional
	FROM	CacheQuotas  with (nolock)
	WHERE	cq_svkey = @svkey and cq_code = @code
			and ((@subcode1 = 0) OR (@subcode1 = cq_rmkey))
			and ((@subcode2 = 0) OR (@subcode2 = cq_rckey))
			and cq_date = @date
			and cq_day = @day
			and cq_days = @days
			and ((@prkey = 0) OR (cq_prkey = @prkey))
			and ((cq_pkkey = 0) OR (cq_pkkey = @pkkey))
			and ((cq_findFlight=0) OR (cq_findFlight = @findFlight))

	if @datecheck < DATEADD(MINUTE,-@CacheQuoteMinute,GetDate())
	begin
		DELETE FROM CacheQuotas WHERE cq_datecheck < DATEADD(MINUTE,-@CacheQuoteMinute,GetDate())
		set @result = null
		set @places = 0
	end
end
GO

grant execute on [dbo].[mwCacheQuotaSearch] to public
GO
/*********************************************************************/
/* end sp_mwCacheQuotaSearch.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCleaner.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwCleaner]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	DROP PROCEDURE [dbo].[mwCleaner] 
GO

CREATE proc [dbo].[mwCleaner] @priceCount int = 10000, @deleteToday smallint = 0
as
begin
	--<DATE>2012-06-27</DATE>
	--<VERSION>9.2.13.1</VERSION>
	declare @counter bigint

	insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Запуск mwCleaner', 1)

	truncate table CacheQuotas

	declare @today datetime
	set @today = CAST(CONVERT(varchar(20), GETDATE(), 112) as datetime)
	if (@deleteToday = 1)
		set @today = dateadd(day, 1, @today)
	
	-- Удаляем неактуальные цены
	set @counter = 0
	while(1 = 1)
	begin
		delete top (@priceCount * 100) from dbo.tp_prices with(rowlock) where tp_dateend < @today and tp_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
		if @@ROWCOUNT = 0
		begin
			insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_prices завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
			break
		end
		else
			set @counter = @counter + @@ROWCOUNT
	end

	-- Удаляем неактуальные удаленные цены (ДЦ)
	set @counter = 0
	while(1 = 1)
	begin
		delete top (@priceCount * 100) from dbo.tp_pricesDeleted with(rowlock) where tpd_dateend < @today and tpd_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
		if @@ROWCOUNT = 0
		begin
			insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_pricesDeleted завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
			break
		end
		else
			set @counter = @counter + @@ROWCOUNT
	end	

	if dbo.mwReplIsSubscriber() <= 0
	begin
		set @counter = 0
		while (1 = 1)
		begin
			delete top (@priceCount) from dbo.tp_turdates with(rowlock) where td_date < @today and td_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
			if @@ROWCOUNT = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_turdates завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				break
			end
			else
				set @counter = @counter + @@ROWCOUNT
		end
		
		set @counter = 0
		while (1 = 1)
		begin
			delete top (@priceCount) from dbo.tp_servicelists with(rowlock) where tl_tikey not in (select tp_tikey from tp_prices with(nolock)) and tl_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
			if @@ROWCOUNT = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_servicelists завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				break
			end
			else
				set @counter = @counter + @@ROWCOUNT
		end
		
		set @counter = 0
		while (1 = 1)
		begin
			delete top (@priceCount) from dbo.tp_lists with(rowlock) where ti_key not in (select tp_tikey from tp_prices with(nolock)) and ti_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
			if @@ROWCOUNT = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_lists завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				break
			end
			else
				set @counter = @counter + @@ROWCOUNT
		end
		
		set @counter = 0
		while (1 = 1)
		begin
			delete top (@priceCount) from dbo.tp_services with(rowlock) where ts_key not in (select tl_tskey from tp_servicelists with(nolock)) and ts_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
			if @@ROWCOUNT = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_services завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				break
			end
			else
				set @counter = @counter + @@ROWCOUNT
		end
	end
	else
	begin
		exec dbo.mwCleanerQuotes
	end

	declare @mwSearchType int
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'
	
	-- Удаляем неактуальные туры
	set @counter = 0
	while(1 = 1)
	begin
		delete top (@priceCount / 100) from dbo.TP_Tours with(rowlock) where to_datevalid < @today
		if @@ROWCOUNT = 0
		begin
			insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление TP_Tours завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)		
			break
		end
		else
			set @counter = @counter + @@ROWCOUNT
	end
	
	update top (@priceCount / 100) dbo.tp_tours with(rowlock) set to_pricecount = 
		(select count(1) from dbo.tp_prices with(nolock) where tp_tokey = to_key) 
	where to_update = 0 and exists(select 1 from dbo.tp_turdates with(nolock) where td_tokey = to_key and td_date < @today)
	
	insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Обновление tp_tours завершено. Обновлено ' + ltrim(str(@@ROWCOUNT)) + ' записей', 1)

	if(@mwSearchType = 0)
	begin
			set @counter = 0
			while(1 = 1)
			begin
				delete top (@priceCount * 100) from dbo.mwPriceDataTable with(rowlock) where pt_tourdate < @today and pt_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
				if @@ROWCOUNT = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwPriceDataTable завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @@ROWCOUNT
			end
			
			set @counter = 0
			while(1 = 1)
			begin
				delete top (@priceCount * 100) from dbo.mwSpoDataTable with(rowlock) where sd_tourkey not in (select pt_tourkey from dbo.mwPriceDataTable with(nolock)) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
				if @@ROWCOUNT = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwSpoDataTable завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @@ROWCOUNT
			end
			
			set @counter = 0
			while(1 = 1)
			begin
				delete top (@priceCount * 100) from dbo.mwPriceDurations with(rowlock) where not exists(select 1 from dbo.mwPriceDataTable with(nolock) where pt_tourkey = sd_tourkey and pt_days = sd_days and pt_nights = sd_nights) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
				if @@ROWCOUNT = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwPriceDurations завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @@ROWCOUNT
			end
	end
	else
	begin
		declare @objName nvarchar(50), @counterPart int
		declare @sql nvarchar(500), @params nvarchar(500)
		declare delCursor cursor fast_forward read_only for select distinct sd_cnkey, sd_ctkeyfrom from dbo.mwSpoDataTable
		declare @cnkey int, @ctkeyfrom int
		open delCursor
		fetch next from delCursor into @cnkey, @ctkeyfrom
		while(@@fetch_status = 0)
		begin
			set @objName = dbo.mwGetPriceTableName(@cnkey, @ctkeyfrom)
			set @counter = 0
			while(1 = 1)
			begin
				set @sql = 'delete top (' + ltrim(rtrim(str(@priceCount * 100))) + ') from ' + @objName + ' with(rowlock) where pt_tourdate < ''' + convert(varchar(20), @today, 120) + ''' and pt_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0); set @counterOut = @@ROWCOUNT'
				set @params = '@counterOut int output'
				
				EXECUTE sp_executesql @sql, @params, @counterOut = @counterPart output
				
				if @counterPart = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление ' + @objName + ' завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @counterPart
			end
			
			--exec sp_executesql @sql
			--set @objName = dbo.mwGetPriceTableName(@cnkey, @ctkeyfrom)
			set @counter = 0
			while(1 = 1)
			begin
				set @sql = 'delete top (' + ltrim(rtrim(str(@priceCount * 100))) + ') from dbo.mwSpoDataTable with(rowlock) where sd_cnkey = ' + ltrim(rtrim(str(@cnkey))) + ' and sd_ctkeyfrom = ' + ltrim(rtrim(str(@ctkeyfrom))) + ' and sd_tourkey not in (select pt_tourkey from ' + @objName + ' with(nolock)) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0); set @counterOut = @@ROWCOUNT'
				set @params = '@counterOut int output'
				EXECUTE sp_executesql @sql, @params, @counterOut = @counterPart output
				
				if @counterPart = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwSpoDataTable завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @counterPart
			end
			--exec sp_executesql @sql
			--set @sql = 'delete from dbo.mwPriceDurations where sd_cnkey = ' + ltrim(rtrim(str(@cnkey))) + ' and sd_ctkeyfrom = ' + ltrim(rtrim(str(@ctkeyfrom))) + ' and not exists(select 1 from ' + @objName + ' where pt_tourkey = sd_tourkey and pt_days = sd_days and pt_nights = sd_nights) and sd_tourkey not in (select to_key from tp_tours where to_update <> 0)'
			--exec sp_executesql @sql
			fetch next from delCursor into @cnkey, @ctkeyfrom
		end
		close delCursor
		deallocate delCursor
	end 

	set @counter = 0
	while(1 = 1)
	begin
		delete top (@priceCount) from dbo.mwPriceHotels with(rowlock) where sd_tourkey not in (select sd_tourkey from dbo.mwSpoDataTable with(nolock)) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
		if @@ROWCOUNT = 0
		begin
			insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwPriceHotels завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
			break
		end
		else
			set @counter = @counter + @@ROWCOUNT
	end
	
	insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Окончание выполнения mwCleaner', 1)
end
GO

GRANT EXECUTE ON [dbo].[mwCleaner] TO PUBLIC 
GO
/*********************************************************************/
/* end sp_mwCleaner.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCleanerQuotes.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwCleanerQuotes]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[mwCleanerQuotes]
GO
CREATE PROCEDURE [dbo].[mwCleanerQuotes]
	(
		-- хранимка удаления устаревших квто на поисковой базе
		-- дата с которой считается что квоты устарели
		@oldDate datetime = null,
		-- размер пачки на удаление
		@countRowDeleted int = 10000
	)
AS
BEGIN

	if (@oldDate is null)
	begin
		set @oldDate = getdate();
	end

	-- чистим ServiceByDate
	while (1 = 1)
	begin
		delete top (@countRowDeleted) ServiceByDate
		from ServiceByDate
		where SD_Date < @oldDate
		
		if (@@ROWCOUNT = 0)
		begin
			break;
		end
	end
	
	-- чистим quotaLimitation
	while (1 = 1)
	begin
		delete top (@countRowDeleted) QuotaLimitations 
		from QuotaLimitations
		where QL_QPID in (select QP_Id from QuotaParts with (nolock) where QP_Date < @oldDate)
		
		if (@@ROWCOUNT = 0)
		begin
			break;
		end
	end
	
	-- чистим QuotaParts
	while (1 = 1)
	begin
		delete top (@countRowDeleted) QuotaParts 
		from QuotaParts
		where QP_Date < @oldDate
		and not exists (select top 1 1 from QuotaLimitations with (nolock) where QL_QPID = QP_ID)
		
		if (@@ROWCOUNT = 0)
		begin
			break;
		end
	end
	
	-- чистим StopSales
	while (1 = 1)
	begin
		delete top (@countRowDeleted) StopSales 
		from StopSales
		where SS_Date < @oldDate
		
		if (@@ROWCOUNT = 0)
		begin
			break;
		end
	end
	
	-- чистим QuotaDetailes
	while (1 = 1)
	begin
		delete top (@countRowDeleted) QuotaDetails 
		from QuotaDetails
		where QD_Date < @oldDate
		and not exists (select top 1 1 from StopSales with (nolock) where SS_QDID = QD_Id)
		and not exists (select top 1 1 from QuotaParts with (nolock) where QP_QDID = QD_Id)
		
		if (@@ROWCOUNT = 0)
		begin
			break;
		end
	end
END

GO

grant exec on [dbo].[mwCleanerQuotes] to public
go
/*********************************************************************/
/* end sp_mwCleanerQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCreatePriceTableIndexes.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwCreatePriceTableIndexes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	DROP PROCEDURE [dbo].[mwCreatePriceTableIndexes]
GO

create PROCEDURE [dbo].[mwCreatePriceTableIndexes]
	@countryKey int,
	@cityFromKey int
as
begin
	declare @tableName varchar(50)
	set @tableName = dbo.mwGetPriceTableName(@countryKey, @cityFromKey)
	declare @sql varchar(8000)
	set @sql = '
	if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name not like ''PK[_]%''  and name like ''x[_]%'')
	begin
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_complex'')
			CREATE NONCLUSTERED INDEX [x_complex] ON ' + @tableName + '([pt_cnkey] ASC, [pt_ctkeyfrom] ASC, [pt_tourkey] ASC, [pt_tourdate] ASC) INCLUDE ( [pt_hdkey], [pt_pnkey])
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_date'')
			CREATE NONCLUSTERED INDEX [x_date] ON ' + @tableName + '([pt_tourdate] ASC)
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_enabled'')
			CREATE NONCLUSTERED INDEX [x_enabled] ON ' + @tableName + '([pt_isenabled] DESC)
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_hdkey'')
			CREATE NONCLUSTERED INDEX [x_hdkey] ON ' + @tableName + '([pt_hdkey] ASC)			
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_main_persprice'')
			CREATE NONCLUSTERED INDEX [x_main_persprice] ON ' + @tableName + '([pt_tourdate] ASC,[pt_tourtype] ASC,[pt_rskey] ASC,[pt_ctkey] ASC,[pt_tourkey] ASC,[pt_nights] ASC,[pt_pnkey] ASC,[pt_hdstars] ASC) INCLUDE ([pt_tlkey],[pt_hdkey],[pt_pricekey],[pt_price],[pt_rmkey],[pt_rckey],[pt_days],[pt_isenabled],[pt_hdname],[pt_rcname],[pt_rccode],[pt_chkey],[pt_chbackkey],[pt_hdday],[pt_hdnights],[pt_hdpartnerkey],[pt_chday],[pt_chpkkey],[pt_chprkey],[pt_chbackday],[pt_chbackpkkey],[pt_chbackprkey],[pt_childagefrom],[pt_childageto],[pt_childagefrom2],[pt_childageto2],[pt_main],[pt_tourvalid],[pt_chbackkeys],[pt_chdirectkeys],[pt_hddetails],[pt_topricefor])
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_main_roomprice'')
			CREATE NONCLUSTERED INDEX [x_main_roomprice] ON ' + @tableName + '([pt_mainplaces] ASC,[pt_addplaces] ASC,[pt_tourdate] ASC,[pt_tourtype] ASC,[pt_rskey] ASC,[pt_ctkey] ASC,[pt_tourkey] ASC,[pt_nights] ASC,[pt_pnkey] ASC,[pt_hdstars] ASC) INCLUDE ([pt_tlkey],[pt_hdkey],[pt_pricekey],[pt_price],[pt_rmkey],[pt_rckey],[pt_days],[pt_isenabled],[pt_hdname],[pt_rcname],[pt_rccode],[pt_chkey],[pt_chbackkey],[pt_hdday],[pt_hdnights],[pt_hdpartnerkey],[pt_chday],[pt_chpkkey],[pt_chprkey],[pt_chbackday],[pt_chbackpkkey],[pt_chbackprkey],[pt_childagefrom],[pt_childageto],[pt_childagefrom2],[pt_childageto2],[pt_main],[pt_tourvalid],[pt_chbackkeys],[pt_chdirectkeys],[pt_hddetails],[pt_topricefor])
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_mwHotelDetails'')
			CREATE NONCLUSTERED INDEX [x_mwHotelDetails] ON ' + @tableName + '([pt_isenabled] DESC,[pt_tourvalid] ASC,[pt_main] DESC,[pt_hdkey] ASC,[pt_price] ASC,[pt_tourdate] ASC,[pt_rate] ASC)
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_pricekey'')
			CREATE NONCLUSTERED INDEX [x_pricekey] ON ' + @tableName + '([pt_pricekey] ASC)
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_singleprice'')
			CREATE NONCLUSTERED INDEX [x_singleprice] ON ' + @tableName + '([pt_tourdate] ASC,[pt_hdkey] ASC,[pt_rmkey] ASC,[pt_rckey] ASC,[pt_ackey] ASC,[pt_pnkey] ASC,[pt_days] ASC,[pt_nights] ASC) INCLUDE ( [pt_hdpartnerkey],[pt_chprkey],[pt_tourtype],[pt_main],[pt_isenabled],[pt_autodisabled],[pt_tourkey],[pt_price],[pt_ctkeyfrom])
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_singleprice_tour'')
			CREATE NONCLUSTERED INDEX [x_singleprice_tour] ON ' + @tableName + '([pt_tourkey] ASC,[pt_main] ASC) INCLUDE ( [pt_tourdate],[pt_hdkey],[pt_rmkey],[pt_rckey],[pt_ackey],[pt_pnkey],[pt_days],[pt_nights],[pt_hdpartnerkey],[pt_chprkey],[pt_tourtype],[pt_ctkeyfrom])
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_tourkey'')
			CREATE NONCLUSTERED INDEX [x_tourkey] ON ' + @tableName + '([pt_tourkey] ASC)
		if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_quotacache_flight'')
			CREATE NONCLUSTERED INDEX [x_quotacache_flight] ON ' + @tableName + ' 
				(
					[pt_days] ASC
				)
				INCLUDE ( [pt_tourdate],
				[pt_ctkeyto],
				[pt_pricekey],
				[pt_hdkey],
				[pt_hdpartnerkey],
				[pt_rmkey],
				[pt_rckey],
				[pt_chkey],
				[pt_chbackkey],
				[pt_hdday],
				[pt_hdnights],
				[pt_chday],
				[pt_chpkkey],
				[pt_chprkey],
				[pt_chbackday],
				[pt_chbackpkkey],
				[pt_chbackprkey]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	end
	'
	exec(@sql)
end
GO

GRANT EXECUTE ON [dbo].[mwCreatePriceTableIndexes] TO PUBLIC
GO
/*********************************************************************/
/* end sp_mwCreatePriceTableIndexes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwEnablePriceTourNewSinglePrice.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwEnablePriceTourNewSinglePrice]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwEnablePriceTourNewSinglePrice]
GO

CREATE procedure [dbo].[mwEnablePriceTourNewSinglePrice] 
(
	@toKey int,
	@tempDataTableName varchar (1024)
)
as

begin

	if ISNULL(@tokey, 0) = 0
	return

	declare @today varchar(10)
	set @today = '''' + convert(varchar(10),getdate(), 112 ) + ''''

	declare @cityFromKey int
	declare @countryKey int

	select top 1 @countryKey = tl_cnkey, @cityFromKey = tl_ctdeparturekey
	from TurList with(nolock) join tp_tours with(nolock) on to_trkey = tl_key
	where to_key = @toKey

	declare @mwSinglePrice nvarchar(10)
	select @mwSinglePrice = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePrice'), N'0')

	if (dbo.mwReplIsPublisher() > 0)
		set @mwSinglePrice = '0'

	if @mwSinglePrice = '0'
	return

	declare @tableName varchar(100)

	declare @mwSearchType int
	select @mwSearchType = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings 
	where SS_ParmName = 'MWDivideByCountry'
	 
	if (@mwSearchType = 0)
		set @tableName = 'dbo.mwPriceDataTable'
	else
		set @tableName = dbo.mwGetPriceTableName(@countryKey, @cityFromKey)

	declare @sql varchar(8000)
	declare @where varchar(8000)

	declare @mwSinglePriceType nvarchar(10) -- 'last' or 'min'
	select @mwSinglePriceType = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceType'), N'last') 

	declare @mwSinglePriceAllTours nvarchar(10) -- single price for tour
	select @mwSinglePriceAllTours = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllTours'), N'0') 

	declare @mwSinglePriceAllHotelPrt nvarchar(10) -- single price for hotel partner
	select @mwSinglePriceAllHotelPrt = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllHotelPrt'), N'0') 

	declare @mwSinglePriceAllFlightPrt nvarchar(10) -- single price for flight partner
	select @mwSinglePriceAllFlightPrt = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllFlightPrt'), N'0')

	declare @mwSinglePriceAllTourTypes nvarchar(10) -- single price for tour type
	select @mwSinglePriceAllTourTypes = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllTourTypes'), N'0')

	declare @mwSinglePriceAllDeparts nvarchar(10) -- single price for depart from
	select @mwSinglePriceAllDeparts = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllDeparts'), N'1')

	set @where = ' main.pt_main > 0 and main.pt_tourdate >= getdate() ' +
			 ' and main.pt_hdkey = temp.pt_hdkey ' + 
			 ' and main.pt_rmkey = temp.pt_rmkey ' + 
			 ' and main.pt_rckey = temp.pt_rckey ' + 
			 ' and main.pt_ackey = temp.pt_ackey ' + 
			 ' and main.pt_pnkey = temp.pt_pnkey ' + 
			 ' and main.pt_tourdate = temp.pt_tourdate ' + 
			 ' and main.pt_days = temp.pt_days ' + 
			 ' and main.pt_nights = temp.pt_nights ' 
						 
	if(@mwSinglePriceAllHotelPrt = '0') -- single price for hotel partner
		set @where = @where + ' and main.pt_hdpartnerkey = temp.pt_hdpartnerkey ' 

	if(@mwSinglePriceAllFlightPrt = '0') -- single price for flight partner
		set @where = @where + ' and main.pt_chprkey = temp.pt_chprkey ' 

	if(@mwSinglePriceAllTourTypes = '0') -- single price for tour type
		set @where = @where + ' and main.pt_tourtype = temp.pt_tourtype ' 

	if(@mwSinglePriceAllDeparts = '0') -- single price for departfrom
		set @where = @where + ' and main.pt_ctkeyfrom = temp.pt_ctkeyfrom ' 

	if(@mwSinglePriceType = 'min')
		set @where = @where + ' and main.pt_price > temp.pt_price ' 

	if(@mwSinglePriceAllTours = '0')
		set @where = @where + ' and main.pt_tourkey = ' + ltrim(str(@tokey))
	else
		set @where = @where + ' and main.pt_tourkey != '+ ltrim(str(@tokey))

	create table #keysTable (xKey int, xPriceKey int, xTourKey int)
			
	set @sql = 'insert into #keysTable 
				select main.pt_key, main.pt_priceKey, main.pt_tourkey from ' + @tableName + ' main, ' + @tempDataTableName + ' temp where ' + @where

	--print @sql
	exec(@sql)

	set @sql = 'update ' + @tableName + ' set pt_isenabled = 0, pt_autodisabled = 1 where pt_key in (select xKey from #keysTable)'
	--print @sql
	exec(@sql)

	-- выключаем вслед за ними соответствующие данные из tp_turdates
	set @sql = '
			update updturdates with(rowlock)
			set td_autodisabled = 1
			from tp_turdates updturdates
			where td_autodisabled = 0 and
				exists(select top (1) 1 from ' + @tableName + ' with(nolock) 
						where ' + @tableName + '.pt_tourkey = updturdates.td_tokey
								and ' + @tableName + '.pt_tourdate = updturdates.td_date
								and ' + @tableName + '.pt_pricekey in (select xPriceKey from #keysTable with (nolock)))
			and not exists (select top (1) 1 from ' +@tableName + ' with(nolock) 
						where ' + @tableName+ ' .pt_tourkey = updturdates.td_tokey
								and ' + @tableName + '.pt_tourdate = updturdates.td_date 
								and ' + @tableName + '.pt_isenabled = 1)'

	--print @sql
	exec (@sql)

	drop table #keysTable

	update dbo.mwSpoDataTable set sd_isenabled = 1 where sd_tourkey = @tokey
		
end
GO

grant execute on [dbo].[mwEnablePriceTourNewSinglePrice] to public
GO
/*********************************************************************/
/* end sp_mwEnablePriceTourNewSinglePrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwGetServiceIsEditableAttribute.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CalculatePriceList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwGetServiceIsEditableAttribute]
GO

create procedure [dbo].[mwGetServiceIsEditableAttribute]
--<VERSION>2009.2.14.1</VERSION>
--<DATE>2012-07-26</DATE>
	@tokey int,
	@tscode int,
	@day int,
	@days int,
	@prkey int,
	@pkkey int,
	@isEditable bit output
as
begin	
	declare @editableCode int
	set @editableCode = 2
	
	declare @path varchar(50)
	set @path = case dbo.mwReplIsPublisher() when 1
					then 'mt.' + dbo.mwReplPublisherDB() + '.' 
					else '' 
				end

	declare @sql varchar(4000)
	set @sql ='declare @tmp bit				
	select @tmp=1 from ' + @path + 'dbo.tp_services
	where ts_svkey = 1 and ts_tokey='+ltrim(rtrim(str(@tokey)))+' and ts_code='+ltrim(rtrim(str(@tscode)))+' and ts_day = ' + ltrim(rtrim(str(@day ))) + ' and ts_days in (0,' + ltrim(rtrim(str(@days))) + ') and ts_oppartnerkey= ' + ltrim(rtrim(str(@prkey))) + ' and ts_oppacketkey= ' + ltrim(rtrim(str(@pkkey))) + ' and (ts_attribute&+'+ltrim(rtrim(str(@editableCode)))+')='+ltrim(rtrim(str(@editableCode)))	
	exec (@sql)	
	set @isEditable = @@ROWCOUNT
end
GO

grant execute on [dbo].[mwGetServiceIsEditableAttribute] to public
GO
/*********************************************************************/
/* end sp_mwGetServiceIsEditableAttribute.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwGetTourMonthesQuotas.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='mwGetTourMonthesQuotas')
	drop proc dbo.mwGetTourMonthesQuotas
go

--<DATE>2012-07-09</DATE>
--<VERSION>2009.14</VERSION>

CREATE proc [dbo].[mwGetTourMonthesQuotas] 
      @month_count smallint,
      @agent_key int,
      @quoted_services nvarchar(100),
      @cnkey int,
      @tour_type int,
      @checkAllPartnersQuota smallint,
      @requestOnRelease smallint,
      @noPlacesResult smallint,
      @checkAgentQuotes smallint,
      @checkCommonQuotes smallint,
      @checkNoLongQuotes smallint,
      @findFlight smallint,
      @checkFlightPacket smallint,
      @expiredReleaseResult smallint
as
begin
      create table #tourQuotas(
            tour_key int,
            tour_name nvarchar(250),
            tour_url nvarchar(500),
            tour_quotas nvarchar(4000)
      )

      declare tour_cursor cursor fast_forward read_only 
      for
            select 
                  td_trkey,
                  isnull(tl_nameweb, isnull(tl_name, '')),
                  isnull(tl_webhttp, '') as tour_url,
                  td_date,
                  month(td_date),
                  tl_nday
            from 
                  turdate with(nolock)
                  inner join turlist with(nolock) on tl_key = td_trkey
                  inner join tp_tours with(nolock) on to_trkey = td_trkey
            where
                  td_date between getdate() 
                  and dateadd(month, @month_count, getdate()) 
                  and ((@cnkey >= 0 and tl_cnkey = @cnkey) or (@tour_type >= 0 and tl_tip = @tour_type))
                  and to_isenabled = 1 
            order by
                  isnull(tl_nameweb, isnull(tl_name, '')),
                  td_date                 


            declare 
                  @tour_key int, 
                  @prev_tour_key int, 
                  @prev_month int, 
                  @tour_name nvarchar(250),
            @tour_url nvarchar(500),
            @tour_date datetime,
            @month int,
                  @tour_quotas nvarchar(4000),
                  @tour_duration int

      set @tour_key = -1
      set @prev_tour_key = -1
      set @prev_month = -1
      set @tour_name = ''
      set @tour_url = ''
      set @tour_date = '1800-01-01'
      set @month = 0
      set @tour_quotas = ''

      open tour_cursor

      create table #turService(
            ts_svkey int,
            ts_code int,
            ts_subcode1 int,
            ts_subcode2 int,
            ts_day int,
            ts_ndays int,
            ts_partnerkey int,
            ts_pkkey int
      )

      declare @sql nvarchar(4000)

      fetch next from tour_cursor into @tour_key, @tour_name, @tour_url, @tour_date, @month, @tour_duration
      while @@fetch_status = 0
      begin

        if (@tour_key != @prev_tour_key)
        begin
                  insert into #tourQuotas (
                        tour_key,
                        tour_name,
                        tour_url)
                  values (
                        @tour_key,
                        @tour_name,
                        @tour_url
                  )

            set @prev_month = -1
                  if (@prev_tour_key > 0)
                        update #tourQuotas
                        set tour_quotas = @tour_quotas
                        where tour_key = @prev_tour_key

                  set @tour_quotas = ''

                  truncate table #turService

                  set @sql = N'select 
                                         ts_svkey,
                                         ts_code,
                                         ts_subcode1,
                                         ts_subcode2,
                                         ts_day,
                                         ts_ndays,
                                         ts_partnerkey,
                                         ts_pkkey
                                   from
                                         turservice
                                   where
                                         ts_trkey = ' + str(@tour_key) +N'
                                         and ts_svkey in (' + isnull(@quoted_services, N'3') + N')'

                  insert into #turService exec(@sql)

        end

        if (@month != @prev_month or @tour_key != @prev_tour_key)
        begin
                  if (len(@tour_quotas) > 0)         
                        set @tour_quotas = @tour_quotas + '|' 
                  set @tour_quotas = @tour_quotas + ltrim(str(@month)) + '='
        end
            
            declare service_cursor cursor fast_forward read_only
            for
                  select
                        ts_svkey,
                        ts_code,
                        ts_subcode1,
                        ts_subcode2,
                        ts_day,
                        ts_ndays,
                        (case when @checkAllPartnersQuota > 0 then -1 else ts_partnerkey end),
                        (case when ts_svkey = 1 and @checkFlightPacket > 0 then ts_pkkey else -1 end)
                  from 
                        #turService
            
            declare
                  @svkey int,
                  @code int,
                  @subcode1 int,
                  @subcode2 int,
                  @day int,
                  @ndays int,
                  @partner_key int,
                  @packet_key int,
                  @places int,
                  @allplaces int,
                  @date_places int,
                  @date_allplaces int

            open service_cursor

            fetch next from service_cursor into @svkey, @code, 
                  @subcode1, @subcode2, @day, @ndays, @partner_key, @packet_key
            while @@fetch_status = 0
            begin
                  select 
                        @places = qt_places,
                        @allplaces = qt_allplaces
                  from
                        dbo.mwCheckQuotesEx( 3,@code,0,0,0,0,@tour_date,1,1,0,-1,0,0,0,0,0,0,0,0,-1)

print @places 
print @allplaces

            if (@places = -2 or @places = 0)
            begin
                set @date_places = 0
                        set @date_allplaces = 0
                break
            end
            else  if (@places = -1)
                  begin
                set @date_places = @places
                        set @date_allplaces = 0
                  end
            else if (@places > 0)
                  begin
                set @date_places = @places
                        set @date_allplaces = @allplaces
                  end
                  fetch next from service_cursor into @svkey, @code, 
                        @subcode1, @subcode2, @day, @ndays, @partner_key, @packet_key
            end
      
            close service_cursor
            deallocate service_cursor

            if(@date_places is null)
            begin 
                  set @date_places = -1
                  set @date_allplaces = 0
            end

            if(substring(@tour_quotas, len(@tour_quotas), 1) != '=')
                  set @tour_quotas = @tour_quotas + ','
            set @tour_quotas = @tour_quotas + ltrim(str(day(@tour_date))) + '#' + ltrim(str(@date_places)) + ':' + ltrim(str(@date_allplaces))


            set @prev_tour_key = @tour_key
            set @prev_month = @month
            fetch next from tour_cursor into @tour_key, @tour_name, @tour_url, @tour_date, @month, @tour_duration
      end

      update #tourQuotas
      set tour_quotas = @tour_quotas
      where tour_key = @prev_tour_key

      close tour_cursor
      deallocate tour_cursor

      select * from #tourQuotas
end
GO

grant exec on dbo.mwGetTourMonthesQuotas to public
go

/*********************************************************************/
/* end sp_mwGetTourMonthesQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReindex.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwReindex]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	DROP PROCEDURE [dbo].[mwReindex] 
GO

create procedure [dbo].[mwReindex] as
begin
	ALTER INDEX ALL ON dbo.mwSpoDataTable REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: mwSpoDataTable', 1)
	
	ALTER INDEX ALL ON dbo.mwPriceHotels REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: mwPriceHotels', 1)
	
	ALTER INDEX ALL ON dbo.mwPriceDurations REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: mwPriceDurations', 1)
	
	ALTER INDEX ALL ON dbo.TP_Lists REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: TP_Lists', 1)
	
	ALTER INDEX ALL ON dbo.TP_Prices REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: TP_Prices', 1)
	
	ALTER INDEX ALL ON dbo.TP_ServiceLists REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: TP_ServiceLists', 1)
	
	ALTER INDEX ALL ON dbo.TP_Services REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: TP_Services', 1)
	
	ALTER INDEX ALL ON dbo.TP_Tours REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: TP_Tours', 1)
	
	ALTER INDEX ALL ON dbo.TP_TurDates REBUILD WITH (FILLFACTOR = 70)
	insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: TP_TurDates', 1)

	declare @mwSearchType int 
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings 
	where SS_ParmName = 'MWDivideByCountry'

	if @mwSearchType = 0
	begin
		ALTER INDEX ALL ON dbo.mwPriceDataTable REBUILD WITH (FILLFACTOR = 70)
		insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: dbo.mwPriceDataTable', 1)
	end
	else
	begin
		declare @sql varchar(4000)
		declare @tableName varchar(500)
		declare @indexName varchar(500)

		declare cur cursor fast_forward read_only for select tbl.name, ind.name from sysobjects as tbl 
				INNER JOIN sys.indexes as ind on ind.object_id = tbl.id
		where tbl.name like 'mwPriceDataTable[_]%[_]%'
		
		open cur
		fetch next from cur into @tableName, @indexName
		while @@fetch_status = 0
			begin
				set @sql = 'ALTER INDEX ' + @indexName  + ' ON dbo.' + @tableName + ' REBUILD WITH (FILLFACTOR = 70)'
				insert into SystemLog (sl_date, sl_message, SL_AppID) values (getdate(), 'mwReindex: ' + @tableName + ' ' + @indexName, 1)
				--print @sql
				exec(@sql)
				fetch next from cur into @tableName, @indexName
			end		
		close cur
		deallocate cur
	end
end
GO

grant execute on [dbo].[mwReindex] to public
go
/*********************************************************************/
/* end sp_mwReindex.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwRemoveDeleted.sql */
/*********************************************************************/

if exists(select id from sysobjects where name='mwRemoveDeleted' and xtype='p')
	drop procedure [dbo].[mwRemoveDeleted]
go


create proc [dbo].[mwRemoveDeleted] 
	@remove tinyint = 0
as
begin
	set nocount on
	
	if (dbo.mwReplIsPublisher() = 1)
	begin
		delete from dbo.mwDeleted
		return
	end
	
	declare @name varchar(50)
	declare @sql varchar(8000)
		
	if object_id('tempdb..#tmpDeleted') is not null
	begin
		drop table #tmpDeleted
	end
	create table #tmpDeleted(
		del_key int
	)

	declare @pubdb nvarchar(50)
	set @pubdb = dbo.mwReplPublisherDB()
	
	declare delCur cursor fast_forward read_only 
			for select [name] from sysobjects with(nolock) where name like 'mwPriceDataTable%' and xtype = 'u'			
	
	while exists(select top (1) 1 from dbo.mwDeleted with (nolock))
	begin
		
		insert into #tmpDeleted
		select top (100000) del_key 
		from dbo.mwDeleted with(nolock)				
		
		open delCur
		fetch next from delCur into @name	
		while(@@fetch_status = 0)
		begin
			set @sql = 'delete from dbo.' + ltrim(rtrim(@name)) + ' with(rowlock) where pt_pricekey in (select del_key from #tmpDeleted)'
			exec(@sql)
			fetch next from delCur into @name
		end
		close delCur

		set @sql = '		
			delete from dbo.mwSpoDataTable with(rowlock) where not exists(select top (1) 1 from mt.' + @pubdb + '.dbo.tp_prices with(nolock) where tp_tokey = sd_tourkey)
			delete from dbo.mwPriceHotels with(rowlock) where  not exists(select top (1) 1 from mt.' + @pubdb + '.dbo.tp_prices with(nolock) where tp_tokey = sd_tourkey)
			delete from dbo.mwPriceDurations with(rowlock) where  not exists(select top (1) 1 from mt.' + @pubdb + '.dbo.tp_prices with(nolock) where tp_tokey = sd_tourkey)		
		'
		exec (@sql)
		
		delete from dbo.mwDeleted with(rowlock) where del_key in (select del_key from #tmpDeleted)
		
		delete from #tmpDeleted
		
	end
	
	deallocate delCur
	
	drop table #tmpDeleted

	set nocount off
end

GO

grant exec on [dbo].[mwRemoveDeleted] to public
go

/*********************************************************************/
/* end sp_mwRemoveDeleted.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplProcessQueue.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplProcessQueue]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[mwReplProcessQueue]
GO

CREATE procedure [dbo].[mwReplProcessQueue]
as
begin
	--<data>2012-07-05</data>
	--<version>2009.01.01</version>
	exec [dbo].[mwReplProcessQueueDivide]
	return
end
GO

grant exec on [dbo].[mwReplProcessQueue] to public
go
/*********************************************************************/
/* end sp_mwReplProcessQueue.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplProcessQueueDivide.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplProcessQueueDivide]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[mwReplProcessQueueDivide]
GO
create procedure [dbo].[mwReplProcessQueueDivide]
as
begin
	--<data>2012-07-05</data>
	--<version>2009.01.01</version>
	declare @rqId int
	declare @rqMode int
	declare @rqToKey int
	declare @rqCalculatingKey int
	declare @rqOverwritePrices bit

	declare @TableUsed table(CNKey int, CTKey int)

	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
	begin tran 
	insert into @TableUsed (CNKey, CTKey)
	select distinct to_cnkey, tl_CTDepartureKey
	from mwReplQueue, tp_tours with(nolock), turlist with(nolock)
	where [rq_state] = 3
		and to_key = rq_tokey and to_trkey = tl_key

	select top 1 @rqId = [rq_id], @rqMode = rq_mode, @rqToKey = rq_tokey, @rqCalculatingKey = rq_CalculatingKey
	from mwReplQueue LEFT OUTER JOIN tp_tours with(nolock) ON to_key = rq_tokey LEFT OUTER JOIN turlist with(nolock) ON to_trkey = tl_key
	where ([rq_state] = 1 or [rq_state] = 2)
			and not exists (SELECT 1 FROM @TableUsed WHERE to_cnkey = CNKey and  tl_CTDepartureKey = CTKey)
	order by [rq_priority] desc, [rq_crdate]

	update mwReplQueue set [rq_state] = 3, [rq_startdate] = getdate() where [rq_id] = @rqId
	commit tran

	if (@rqId is null or @rqToKey is null or @rqMode is null)
		return
	
	insert into mwReplQueueHistory([rqh_rqid], [rqh_text])
		select @rqId, 'Command start.'
		
	begin try	
		if (@rqMode = 1)
		begin
			exec FillMasterWebSearchFields @rqToKey, @rqCalculatingKey
		end
		else if (@rqMode = 2)
		begin
			exec FillMasterWebSearchFields @rqToKey, @rqCalculatingKey
		end
		else if (@rqMode = 3)
		begin
			exec mwReplDisablePriceTour @rqToKey, @rqId
		end
		else if (@rqMode = 4)
		begin
			exec mwReplDeletePriceTour @rqToKey, @rqId
		end
		else if (@rqMode = 5)
		begin
			exec mwReplUpdatePriceTourDateValid @rqToKey, @rqId
		end
	
	end try
	begin catch
		update mwReplQueue set [rq_state] = 4, [rq_enddate] = getdate() where [rq_id] = @rqId
		
		declare @errMessage varchar(max)
		set @errMessage = 'Error at ' + isnull(ERROR_PROCEDURE(), '[mwReplProcessQueueDivide]') +' : ' + isnull(ERROR_MESSAGE(), '[msg_not_set]')
		
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text])
		select @rqId, @errMessage
		return
	end catch

	update mwReplQueue set [rq_state] = 5, [rq_enddate] = getdate() where [rq_id] = @rqId
	
	insert into mwReplQueueHistory([rqh_rqid], [rqh_text])
		select @rqId, 'Command complete.'

end

GO

grant exec on [dbo].[mwReplProcessQueueDivide] to public
go
/*********************************************************************/
/* end sp_mwReplProcessQueueDivide.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwSyncDictionaryData.sql */
/*********************************************************************/
--kadraliev MEG00029412 30.09.2010 Добавил проверку isnull при сравнении значений полей
--kadraliev MEG00032468 18.02.2011 
--			Добавил проверку на NULL при обновлении полей синхронизируемых данных
--          Добавил пакетное обновление данных
--			Добавил выборку top 1 по первичному ключу при проверке наличия несинхронизированных записей

if object_id('dbo.mwSyncDictionaryData', 'p') is not null
	drop proc dbo.mwSyncDictionaryData
go

create proc dbo.mwSyncDictionaryData 
	@update_search_table smallint = 0, -- нужно ли синхронизировать данные в mwPriceDataTable
	@update_fields varchar(1024) = NULL -- какие именно данные нужно синхронизировать
as
begin

	--<VERSION>2009.2.10</VERSION>
	--<DATE>2011-12-09</DATE>

	-- Список допустимых параметров для @update_fields (нечувствительны к регистру)
	-- COUNTRY
	-- HOTEL
	-- CITY
	-- RESORT
	-- TOUR
	-- TOURTYPE
	-- PANSION
	-- ROOM
	-- ROOMCATEGORY
	-- ACCOMODATION
	-- TP_TOUR          
	
	-- Признак того, откуда брать основые места
	-- Если @isMainPlacesFromAccomodation = 1, основные места беруться из таблицы Accmdmentype, иначе из Rooms
	-- Синхронизация основных мест происходит если pt_main > 0
	declare @isMainPlacesFromAccomodation bit
	select @isMainPlacesFromAccomodation = SS_ParmValue
	from dbo.SystemSettings
	where SS_ParmName='MWAccomodationPlaces'

	-- Признак того, откуда брать дополнительные места
	-- Если @isAddPlacesFromRooms = 1 и в таблице Accmdmentype по данному ключу NULL,
	-- дополнительные места беруться из таблицы Rooms, иначе из Accmdmentype
	declare @isAddPlacesFromRooms bit
	select @isAddPlacesFromRooms = SS_ParmValue
	from dbo.SystemSettings
	where SS_ParmName='MWRoomsExtraPlaces'
	
	--обновление синхронизируемых таблиц происходит пакетами; размер указывается в процентах
	declare @updatePackageSize real
	set @updatePackageSize = 10.0	--in

	declare @sdtUpdatePackageSize int
	set @sdtUpdatePackageSize = (select count(*) from mwSpoDataTable with(nolock)) * @updatePackageSize / 100.0
	
	if (@sdtUpdatePackageSize <= 0)
		set @sdtUpdatePackageSize = @updatePackageSize
		
	declare @pdtUpdatePackageSize int
	set @pdtUpdatePackageSize = (select count(*) from mwPriceDataTable with(nolock)) * @updatePackageSize / 100.0

	if (@pdtUpdatePackageSize <= 0)
		set @pdtUpdatePackageSize = @updatePackageSize

	declare @fields table(fname varchar(20));
	declare @blUpdateAllFields smallint	

	-- если параметр @update_fields не задан, то будем выполнять синхронизацию по
	-- всем основным полям
	if @update_fields is null or @update_fields = ''
	begin
		set @blUpdateAllFields = 1
	end
	else
	begin
		set @blUpdateAllFields = 0

		-- произведём сплит строки @update_fields по запятой
		-- и запишем результат в таблицу @fields
		declare @nextString varchar(4000) 
		declare @pos int, @nextPos int 
		declare @commaCheck varchar(1) 
		declare @string varchar(4000)
		declare @delimiter varchar(1)
	 
		set @delimiter = ','
		set @nextString = '' 
		set @commaCheck = right(@update_fields, 1) 
		set @string = @update_fields + @delimiter 
	 
		set @pos = charindex(@delimiter, @string) 
		set @nextPos = 1 
		while (@pos <> 0) 
		begin 
			set @nextString = substring(@string, 1, @pos - 1) 
	 
			insert into @fields( fname) 
			values (upper(ltrim(rtrim(@nextString))))
	 
			set @string = substring(@string, @pos + 1, len(@string)) 
			set @nextPos = @pos 
			set @pos = charindex(@delimiter, @string) 
		end
	end
	
	-- страна
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='COUNTRY')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_cnkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 cn_key from tbl_country with(nolock) 
				where sd_cnkey = cn_key and isnull(sd_cnname, '-1') <> isnull(cn_name, '')))
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_cnname = isnull(cn_name, '')
			from
				tbl_country
			where
				sd_cnkey = cn_key and 
				isnull(sd_cnname, '-1') <> isnull(cn_name, '')
		end
	end
	
	-- отель
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='HOTEL')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_hdkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 hd_key from dbo.hoteldictionary with(nolock) where
				sd_hdkey = hd_key
				and (
					isnull(sd_hdstars, '-1') <> isnull(hd_stars, '') or 
					isnull(sd_ctkey, -1) <> isnull(hd_ctkey, 0) or 
					isnull(sd_rskey, -1) <> isnull(hd_rskey, 0) or 
					isnull(sd_hdname, '-1') <> isnull(hd_name, '') or 
					isnull(sd_hotelurl, '-1') <> isnull(hd_http, '')
				)
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_hdstars = isnull(hd_stars, ''),
				sd_ctkey = isnull(hd_ctkey, 0),
				sd_rskey = isnull(hd_rskey, 0),
				sd_hdname = isnull(hd_name, ''),
				sd_hotelurl = isnull(hd_http, '')
			from
				dbo.hoteldictionary
			where
				sd_hdkey = hd_key
				and (
					isnull(sd_hdstars, '-1') <> isnull(hd_stars, '') or 
					isnull(sd_ctkey, -1) <> isnull(hd_ctkey, 0) or 
					isnull(sd_rskey, -1) <> isnull(hd_rskey, 0) or 
					isnull(sd_hdname, '-1') <> isnull(hd_name, '') or 
					isnull(sd_hotelurl, '-1') <> isnull(hd_http, '')
				)
		end
		
		-- mwPriceDataTable	
		if @update_search_table > 0
		begin
			while exists(select top 1 pt_hdkey from dbo.mwPriceDataTable with(nolock) 
				where exists(select top 1 hd_key from dbo.hoteldictionary with(nolock) where
					pt_hdkey = hd_key
					and (
						isnull(pt_hdstars, '-1') <> isnull(hd_stars, '') or 
						isnull(pt_ctkey, -1) <> isnull(hd_ctkey, 0) or
						isnull(pt_rskey, -1) <> isnull(hd_rskey, 0) or
						isnull(pt_hdname, '-1') <> isnull(hd_name, '') or
						isnull(pt_hotelurl, '-1') <> isnull(hd_http, '')
					)
				)
			)
			begin
				update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
				set
					pt_hdstars = isnull(hd_stars, ''),
					pt_ctkey = isnull(hd_ctkey, 0),
					pt_rskey = isnull(hd_rskey, 0),
					pt_hdname = isnull(hd_name, ''),
					pt_hotelurl = isnull(hd_http, '')
				from
					dbo.hoteldictionary
				where
					pt_hdkey = hd_key
					and (
						isnull(pt_hdstars, '-1') <> isnull(hd_stars, '') or 
						isnull(pt_ctkey, -1) <> isnull(hd_ctkey, 0) or
						isnull(pt_rskey, -1) <> isnull(hd_rskey, 0) or
						isnull(pt_hdname, '-1') <> isnull(hd_name, '') or
						isnull(pt_hotelurl, '-1') <> isnull(hd_http, '')
					)
			end
		end
	end
	
	-- город отправления
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='CITY')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_ctkeyfrom from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 ct_key from citydictionary with(nolock) 
				where sd_ctkeyfrom <> 0 and sd_ctkeyfrom = ct_key and isnull(sd_ctfromname, '-1') <> isnull(ct_name, '')))
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_ctfromname = isnull(ct_name,'')
			from
				dbo.citydictionary
			where
				sd_ctkeyfrom <> 0	-- город отправления -Без перелета- не обновляем, это константа (см. FillMasterwebSearchFields)
				and sd_ctkeyfrom = ct_key
				and isnull(sd_ctfromname, '-1') <> isnull(ct_name, '')
		end

		while exists(select top 1 sd_ctkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 ct_key from citydictionary with(nolock) 
				where sd_ctkey = ct_key and isnull(sd_ctname, '-1') <> isnull(ct_name, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_ctname = isnull(ct_name,'')
			from
				dbo.citydictionary
			where
				sd_ctkey = ct_key and 
				isnull(sd_ctname, '-1') <> isnull(ct_name, '')
		end
		
		-- mwPriceDataTable
		if @update_search_table > 0
		begin
			while exists(select top 1 pt_ctkey from dbo.mwPriceDataTable with(nolock)
				where exists(select top 1 ct_key from dbo.citydictionary with(nolock) where
					pt_ctkey = ct_key and isnull(pt_ctname, '-1') <> isnull(ct_name, '')
				)
			)
			begin
				update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
				set
					pt_ctname = isnull(ct_name,'')
				from
					dbo.citydictionary
				where
					pt_ctkey = ct_key and 
					isnull(pt_ctname, '-1') <> isnull(ct_name, '')
			end
		end
	end
	
	--курорт
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='RESORT')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_rskey from dbo.mwSpoDataTable with(nolock)
			where exists(select top 1 rs_key from dbo.resorts with(nolock) where
				sd_rskey = rs_key and isnull(sd_rsname, '-1') <> isnull(rs_name, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_rsname = isnull(rs_name,'')
			from
				dbo.resorts
			where
				sd_rskey = rs_key and 
				isnull(sd_rsname, '-1') <> isnull(rs_name, '')
		end
		
		-- mwPriceDataTable	
		if @update_search_table > 0
		begin
			while exists(select top 1 pt_rskey from dbo.mwPriceDataTable with(nolock)
				where exists(select top 1 rs_key from dbo.resorts with(nolock) where
					pt_rskey = rs_key and isnull(pt_rsname, '-1') <> isnull(rs_name, '')
				)
			)		
			begin
				update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
				set
					pt_rsname = isnull(rs_name, '')
				from
					dbo.resorts
				where
					pt_rskey = rs_key and 
					isnull(pt_rsname, '-1') <> isnull(rs_name, '')
			end
		end
	end
	
	-- тур
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='TOUR')
	begin
		while exists(select 1 from dbo.mwSpoDataTable with(nolock)
			where exists(select 1 from dbo.tbl_turlist with(nolock) where
				sd_tlkey = tl_key
				and (
					isnull(sd_tourname, '-1') <> isnull(tl_nameweb, '') or 
					isnull(sd_tourtype, -1) <> isnull(tl_tip, 0)
				)
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_tourname = isnull(tl_nameweb, ''),
				sd_tourtype = isnull(tl_tip, 0)
			from
				dbo.tbl_turlist
			where
				sd_tlkey = tl_key
				and (
					isnull(sd_tourname, '-1') <> isnull(tl_nameweb, '') or 
					isnull(sd_tourtype, -1) <> isnull(tl_tip, 0)
				)
		end
		
		-- mwPriceDataTable	
		if @update_search_table > 0
		begin			
			while exists(select top 1 pt_tlkey from dbo.mwPriceDataTable with(nolock)
				where exists(select top 1 tl_key from dbo.tbl_turlist with(nolock) where
					pt_tlkey = tl_key
					and (
						isnull(pt_tourname, '-1') <> isnull(tl_nameweb, '') or
						isnull(pt_toururl, '-1') <> isnull(tl_webhttp, '') or
						isnull(pt_tourtype, -1) <> isnull(tl_tip, 0)
					)
				)
			)
			begin
				update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
				set
					pt_tourname = isnull(tl_nameweb, ''),
					pt_toururl = isnull(tl_webhttp, ''),
					pt_tourtype = isnull(tl_tip, 0)
				from
					dbo.tbl_turlist
				where
					pt_tlkey = tl_key
					and (
						isnull(pt_tourname, '-1') <> isnull(tl_nameweb, '') or
						isnull(pt_toururl, '-1') <> isnull(tl_webhttp, '') or
						isnull(pt_tourtype, -1) <> isnull(tl_tip, 0)
					)
			end
		end
	end
	
	-- тип тура
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='TOURTYPE')
	begin
		while exists(select top 1 sd_tourtype from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 tp_key from dbo.tiptur with(nolock) 
				where sd_tourtype = tp_key and isnull(sd_tourtypename, '-1') <> isnull(tp_name, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_tourtypename = isnull(tp_name, '')
			from
				dbo.tiptur
			where
				sd_tourtype = tp_key
				and isnull(sd_tourtypename, '-1') <> isnull(tp_name, '')
		end
	end

	-- питание
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='PANSION')
	begin
		while exists(select top 1 sd_pnkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 pn_key from dbo.pansion with(nolock) 
				where sd_pnkey = pn_key and isnull(sd_pncode, '-1') <> isnull(pn_code, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_pncode = isnull(pn_code, '')
			from
				dbo.pansion
			where
				sd_pnkey = pn_key and 
				isnull(sd_pncode, '-1') <> isnull(pn_code, '')
		end	
		
		if @update_search_table > 0
		begin
			while exists(select top 1 pt_pnkey from dbo.mwPriceDataTable with(nolock)
				where exists(select top 1 pn_key from dbo.pansion with(nolock) where
					pt_pnkey = pn_key
					and (
						isnull(pt_pnname, '-1') <> isnull(pn_name, '') or
						isnull(pt_pncode, '-1') <> isnull(pn_code, '')
					)
				)
			)
			begin
				update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
				set 
					pt_pnname = isnull(pn_name, ''),
					pt_pncode = isnull(pn_code, '')
				from dbo.pansion
				where
					pt_pnkey = pn_key
					and (
						isnull(pt_pnname, '-1') <> isnull(pn_name, '') or
						isnull(pt_pncode, '-1') <> isnull(pn_code, '')
					)
			end
		end
	end
	
	-- номер	
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ROOM')) and @update_search_table > 0
	begin
		while exists(select top 1 pt_rmkey from dbo.mwPriceDataTable with(nolock)
			where exists(select top 1 rm_key from dbo.rooms with(nolock) where
				pt_rmkey = rm_key
				and (
					isnull(pt_rmname, '-1') <> isnull(rm_name, '') or 
					isnull(pt_rmcode, '-1') <> isnull(rm_code, '') or 
					isnull(pt_rmorder, -1) <> isnull(rm_order, 0)
				)
			)
		)
		begin
			update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
			set
				pt_rmname = isnull(rm_name, ''),
				pt_rmcode = isnull(rm_code, ''),
				pt_rmorder = isnull(rm_order, 0)
			from
				dbo.rooms
			where
				pt_rmkey = rm_key
				and (
					isnull(pt_rmname, '-1') <> isnull(rm_name, '') or 
					isnull(pt_rmcode, '-1') <> isnull(rm_code, '') or 
					isnull(pt_rmorder, -1) <> isnull(rm_order, 0)
				)			
		end
	end
	
	-- категория номера
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ROOMCATEGORY')) and @update_search_table > 0
	begin
		while exists(select top 1 pt_rckey from dbo.mwPriceDataTable with(nolock)
			where exists(select top 1 rc_key from dbo.roomscategory with(nolock) where
				pt_rckey = rc_key
				and (
					isnull(pt_rcname, '-1') <> isnull(rc_name, '') or 
					isnull(pt_rccode, '-1') <> isnull(rc_code, '') or 
					isnull(pt_rcorder, -1) <> isnull(rc_order, 0)
				)
			)
		)
		begin
			update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
			set
				pt_rcname = isnull(rc_name, ''),
				pt_rccode = isnull(rc_code, ''),
				pt_rcorder = isnull(rc_order, 0)
			from
				dbo.roomscategory
			where
				pt_rckey = rc_key
				and (
					isnull(pt_rcname, '-1') <> isnull(rc_name, '') or 
					isnull(pt_rccode, '-1') <> isnull(rc_code, '') or 
					isnull(pt_rcorder, -1) <> isnull(rc_order, 0)
				)
		end
	end
	
	-- размещение
	--kadraliev MEG00029412 29.09.2010 Добавил синхронизацию признака isMain, возрастов детей
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ACCOMODATION')) and @update_search_table > 0
	begin	
		while exists(select top 1 pt_ackey from dbo.mwPriceDataTable with(nolock)
			where exists(select top 1 ac_key from dbo.accmdmentype with(nolock) where
				pt_ackey = ac_key
				and (
					isnull(pt_acname, '-1') <> isnull(ac_name, '') or
					isnull(pt_accode, '-1') <> isnull(ac_code, '') or
					isnull(pt_acorder, -1) <> isnull(ac_order, 0) or
					isnull(pt_main, -1) <> isnull(ac_main, 0) or
					isnull(pt_childagefrom, -1) <> isnull(ac_agefrom, 0) or
					isnull(pt_childageto, -1) <> isnull(ac_ageto, 0) or
					isnull(pt_childagefrom2, -1) <> isnull(ac_agefrom2, 0) or
					isnull(pt_childageto2, -1) <> isnull(ac_ageto2, 0)					
				)
			)
		)
		begin
			update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
			set
				pt_acname = isnull(ac_name, ''),
				pt_accode = isnull(ac_code, ''),
				pt_acorder = isnull(ac_order, 0),
				pt_main = isnull(ac_main, 0),
				pt_childagefrom = isnull(ac_agefrom, 0),
				pt_childageto = isnull(ac_ageto, 0),
				pt_childagefrom2 = isnull(ac_agefrom2, 0),
				pt_childageto2 = isnull(ac_ageto2, 0)
			from
				dbo.accmdmentype
			where
				pt_ackey = ac_key
				and (
					isnull(pt_acname, '-1') <> isnull(ac_name, '') or
					isnull(pt_accode, '-1') <> isnull(ac_code, '') or
					isnull(pt_acorder, -1) <> isnull(ac_order, 0) or
					isnull(pt_main, -1) <> isnull(ac_main, 0) or
					isnull(pt_childagefrom, -1) <> isnull(ac_agefrom, 0) or
					isnull(pt_childageto, -1) <> isnull(ac_ageto, 0) or
					isnull(pt_childagefrom2, -1) <> isnull(ac_agefrom2, 0) or
					isnull(pt_childageto2, -1) <> isnull(ac_ageto2, 0)	
				)
		end
	end

	--kadraliev MEG00029412 29.09.2010 номер и размещение (количество основных и дополнительных мест)
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ROOM' or fname='ACCOMODATION')) and @update_search_table > 0
	begin	
		while exists(select top 1 pt_key 
					 from mwPriceDataTable with(nolock)
					 inner join rooms with(nolock) on pt_rmkey = rm_key
					 inner join accmdmentype with(nolock) on pt_ackey = ac_key
					 where
						pt_main > 0 and isnull(pt_mainplaces,-1) <> (case when @isMainPlacesFromAccomodation = 1
								then isnull(ac_nrealplaces,0)
								else isnull(rm_nplaces,0) end) or
						isnull(pt_addplaces,-1) <> (case isnull(ac_nmenexbed, -1) when -1 
								then (case when @isAddPlacesFromRooms = 1 
										then isnull(rm_nplacesex, 0)
										else isnull(ac_nmenexbed, 0) end)
								else isnull(ac_nmenexbed, 0) end))
		begin									
			update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
			set
				pt_mainplaces = (case when pt_main > 0
								then (case when @isMainPlacesFromAccomodation = 1
									then isnull(ac_nrealplaces,0)
									else isnull(rm_nplaces,0) end)
								else isnull(pt_mainplaces,0) end),
				pt_addplaces =	(case isnull(ac_nmenexbed, -1) when -1 
									then (case when @isAddPlacesFromRooms = 1 
											then isnull(rm_nplacesex, 0)
											else isnull(ac_nmenexbed, 0) end)
									else isnull(ac_nmenexbed, 0) end )
			from dbo.mwPriceDataTable orig with(nolock)
				left join rooms with(nolock) on orig.pt_rmkey = rm_key
				left join accmdmentype with(nolock) on orig.pt_ackey = ac_key
			where
				pt_main > 0 and isnull(pt_mainplaces,-1) <> (case when @isMainPlacesFromAccomodation = 1
						then isnull(ac_nrealplaces,0)
						else isnull(rm_nplaces,0) end) or
				isnull(pt_addplaces,-1) <> (case isnull(ac_nmenexbed, -1) when -1 
						then (case when @isAddPlacesFromRooms = 1 
								then isnull(rm_nplacesex, 0)
								else isnull(ac_nmenexbed, 0) end)
						else isnull(ac_nmenexbed, 0) end)
		end			
	end

	-- расчитанный тур
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='TP_TOUR')
	begin
		while exists(select top 1 sd_tourkey from dbo.mwSpoDataTable with(nolock)
			where exists(select top 1 to_key from dbo.tp_tours with(nolock) where
				sd_tourkey = to_key
				and (
					isnull(sd_tourcreated, '1900-01-02') <> isnull(to_datecreated, '1900-01-01') or 
					isnull(sd_tourvalid, '1900-01-02') <> isnull(to_datevalid, '1900-01-01')
				)
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_tourcreated = isnull(to_datecreated, '1900-01-01'),
				sd_tourvalid = isnull(to_datevalid, '1900-01-01')
			from
				dbo.tp_tours
			where
				sd_tourkey = to_key
				and (
					isnull(sd_tourcreated, '1900-01-02') <> isnull(to_datecreated, '1900-01-01') or 
					isnull(sd_tourvalid, '1900-01-02') <> isnull(to_datevalid, '1900-01-01')
				)
		end
		
		-- mwPriceDataTable
		if @update_search_table > 0
		begin			
			while exists(select top 1 pt_tourkey from dbo.mwPriceDataTable with(nolock)
				where exists(select top 1 to_key from dbo.tp_tours with(nolock) where
					pt_tourkey = to_key
					and (
						isnull(pt_tourcreated, '1900-01-02') <> isnull(to_datecreated, '1900-01-01') or 
						isnull(pt_tourvalid, '1900-01-02') <> isnull(to_datevalid, '1900-01-01') or 
						isnull(pt_rate, '-1') COLLATE DATABASE_DEFAULT <> isnull(to_rate, '') COLLATE DATABASE_DEFAULT
					)
				)
			)
			begin
				update top (@pdtUpdatePackageSize) dbo.mwPriceDataTable
				set
					pt_tourcreated = isnull(to_datecreated, '1900-01-01'),
					pt_tourvalid = isnull(to_datevalid, '1900-01-01'),
					pt_rate = isnull(to_rate, '')
				from
					dbo.tp_tours
				where
					pt_tourkey = to_key
					and (
						isnull(pt_tourcreated, '1900-01-02') <> isnull(to_datecreated, '1900-01-01') or 
						isnull(pt_tourvalid, '1900-01-02') <> isnull(to_datevalid, '1900-01-01') or 
						isnull(pt_rate, '-1') COLLATE DATABASE_DEFAULT <> isnull(to_rate, '') COLLATE DATABASE_DEFAULT
					)
			end			
		end
	end
end
go

grant exec on dbo.mwSyncDictionaryData to public
go
/*********************************************************************/
/* end sp_mwSyncDictionaryData.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_PagingPax.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='Paging')
	drop proc dbo.PagingPax
go

--<DATE>2012-01-11</DATE>
---<VERSION>2009.2.1</VERSION>

create procedure [dbo].[PagingPax]
@countryKey	int,			
	@departFromKey	int,		
	@filter		varchar(4000),	
	@sortExpr	varchar(1024),	
	@pageNum	int=0,			
	@pageSize	int=9999,		
	@agentKey	int=0,			
	@hotelQuotaMask smallint=0,	
	@aviaQuotaMask smallint=0,	
	@flightGroups	varchar(256),	
	@checkAgentQuota smallint,
	@checkCommonQuota smallint,
	@checkNoLongQuota smallint,
	@requestOnRelease smallint,
	@expiredReleaseResult int,
	@noPlacesResult int,
	@findFlight smallint,
	@checkFlightPacket smallint,
	@checkAllPartnersQuota smallint = null
AS
set nocount on

declare @pagingType int
	set @pagingType = 0

-- Move @countryKey and @departFromKey to filter
set @filter=' pt_cnkey= ' + LTRIM(STR(@countryKey)) + ' and pt_ctkeyfrom= ' + LTRIM(STR(@departFromKey)) + ' and ' + @filter

declare @MAX_ROWCOUNT int
	set @MAX_ROWCOUNT=1000 

declare @sortType smallint
	set @sortType = 1	

declare @spageNum varchar(30)		
	set @spageNum=LTRIM(STR(@pageNum))

declare @spageSize varchar(30)		
	set @spageSize=LTRIM(STR(@pageSize))

declare @sql varchar(8000)
	set @sql=''

declare @zptPos int
declare @prefix varchar(1024)
set @zptPos = charindex(',',@sortExpr)
if(@zptPos > 0)
	set @prefix = substring(@sortExpr, 1, @zptPos)
else
	set @prefix = @sortExpr

if(charindex('desc', @prefix) > 0)
	set @sortType=-1

declare @viewName varchar(256)
if(@sortType <= 0)
	set @viewName='mwPriceTablePaxViewDesc'
else
	set @viewName='mwPriceTablePaxViewAsc'


CREATE TABLE #days
(
	days int,
	nights int
)

SET @sql='
	select		distinct pt_days,pt_nights 
	from		dbo.mwPriceTable t1 with(nolock) 
---- Берем только последние цены
--	inner join 
--	(	
--		select	pt_ctkeyfrom ctkeyfrom,	pt_cnkey cnkey, 		pt_tourtype tourtype,	pt_mainplaces mainplaces, 
--				pt_addplaces addplaces,	pt_tourdate tourdate,	pt_pnkey pnkey, 		pt_pansionkeys pansionkeys,
--				pt_days days,			pt_nights nights,		pt_hdkey hdkey,			pt_hotelkeys hotelkeys,
--				pt_hrkey hrkey,			max(pt_key) ptkey 
--		from	dbo.mwPriceTable with(nolock) 
--		group by 
--				pt_ctkeyfrom,			pt_cnkey,				pt_tourtype,			pt_mainplaces,
--				pt_addplaces,			pt_tourdate,			pt_pnkey,				pt_pansionkeys,
--				pt_nights,				pt_hotelnights,			pt_days,				pt_hdkey,
--				pt_hotelkeys,			pt_hrkey
--	) t2
--	on			t1.pt_ctkeyfrom=t2.ctkeyfrom 		and			t1.pt_cnkey=t2.cnkey 
--		and		t1.pt_tourtype = t2.tourtype 		and			t1.pt_mainplaces=t2.mainplaces 
--		and		t1.pt_addplaces=t2.addplaces 		and			t1.pt_tourdate=t2.tourdate
--		and		t1.pt_pnkey=t2.pnkey				and			t1.pt_nights=t2.nights
--		and		t1.pt_days=t2.days					and			t1.pt_hdkey=t2.hdkey 
--		and		t1.pt_hrkey=t2.hrkey				and			t1.pt_key=t2.ptkey 
	where ' + @filter + ' and pt_days is not null and pt_nights is not null and pt_days>=1 and pt_nights>=1		-- минимальная длина туров
	order by pt_days,pt_nights'
--print @sql
--print ' Before Execute GetDurationsScript: ' + CONVERT(VARCHAR(20), getdate(),114 )
INSERT INTO #days EXEC(@sql)
--print ' After  Execute GetDurationsScript: ' + CONVERT(VARCHAR(20), getdate(),114 )

	create table #checked(
		svkey int,		code int,
		rmkey int,		rckey int,
		date datetime,	[day] int,
		days int,		prkey int,
		pkkey int,		res varchar(256),
		places int,		step_index smallint,
		price_correction int
	)

	create table #resultsTable(
		paging_id int, 
		pt_ctkey int, 
		pt_ctname varchar(50), 
		pt_hdkey int, 
		pt_hdname varchar(60), 
		pt_hdstars varchar(12), 
		pt_hotelurl varchar(254),
		pt_pnkey int, 
		pt_pncode varchar(30), 
		pt_rate varchar(3), 
		pt_rmkey int, 
		pt_rmname varchar(35), 
		pt_rckey int, 
		pt_rcname varchar(35),
		pt_tourdate datetime
	)

	create table #quotaCheckTable(
		pt_key int,
		pt_pricekey int,
		pt_tourdate datetime,			
		pt_days int,
		pt_nights int,
		pt_hdkey int,		
		pt_hdday int,
		pt_hdnights int,			
		pt_hdpartnerkey int,
		pt_rmkey int,
		pt_rckey int,
		pt_chkey int,
		pt_chday int,
		pt_chpkkey int,
		pt_chprkey int,
		pt_chbackkey int,
		pt_chbackday int,
		pt_chbackpkkey int,
		pt_chbackprkey int,
		pt_hdquota varchar(10),
		pt_chtherequota varchar(256),
		pt_chbackquota varchar(256)		
	)

declare @d int
declare @n int
declare @sdays varchar(10)

declare @sKeysSelect varchar(2024)
	set @sKeysSelect=''

declare @sAlter varchar(2024)
	set @sAlter=''

declare @sWhere varchar(5000)
	set @sWhere=''

--declare @sAddSelect varchar(3950)
--	set @sAddSelect=''
--
--declare @sJoin varchar(3950)
--	set @sJoin=''

declare @sJoinTable varchar(20)
	set @sJoinTable=''

declare @sTmp varchar(8000)
	set @sTmp=''

declare @rowCount int

declare @priceFilter nvarchar(512)
	set @priceFilter = N''

declare @priceKeyFilter nvarchar(512)
	set @priceKeyFilter = N''

declare @nightsPart nvarchar(256)
declare @hotelNightsPart nvarchar(256)

declare @dml varchar(7950)
	set @dml = N''

DECLARE dCur CURSOR FOR SELECT days,nights FROM #days
OPEN dCur
FETCH NEXT FROM dCur INTO @d,@n
WHILE (@@fetch_status=0)
BEGIN
	set @sdays=LTRIM(STR(@d)) + '_' + LTRIM(STR(@n))
	if(substring(@sortExpr, 1, 1) = '*')
	begin
		set @sortExpr = 'p_' + @sdays + '_DBL' + substring(@sortExpr, 2, len(@sortExpr) - 1)
	end
	
----------------------------------------------------------
-- Prepare script for add quota columns to result table --
----------------------------------------------------------
 	if(len(@dml) > 0) 
		set @dml = @dml + ','

	set @dml = @dml + 'prk_' + @sdays + '_DBL varchar(256), hq_' + @sdays + '_DBL varchar(10), cq_' + @sdays + '_DBL varchar(256), cbq_' + @sdays + '_DBL varchar(256), ' +
		'prk_' + @sdays + '_SGL varchar(256), hq_' + @sdays + '_SGL varchar(10), cq_' + @sdays + '_SGL varchar(256), cbq_' + @sdays + '_SGL varchar(256), ' +
		'prk_' + @sdays + '_EXB varchar(256), hq_' + @sdays + '_EXB varchar(10), cq_' + @sdays + '_EXB varchar(256), cbq_' + @sdays + '_EXB varchar(256), ' +
		'prk_' + @sdays + '_CHD varchar(256), hq_' + @sdays + '_CHD varchar(10), cq_' + @sdays + '_CHD varchar(256), cbq_' + @sdays + '_CHD varchar(256)'

---------------------------------------------------------------------------------------
-- Prepare script for select price-duration columns values from View to result table --
---------------------------------------------------------------------------------------
 	if(len(@sKeysSelect) > 0)
		set @sKeysSelect=@sKeysSelect + ', '
	
	set @sKeysSelect=@sKeysSelect 
		+ '  p_' + @sdays + '_DBL' + ', pk_' + @sdays + '_DBL'
		+ ', p_' + @sdays + '_SGL' + ', pk_' + @sdays + '_SGL'
		+ ', p_' + @sdays + '_EXB' + ', pk_' + @sdays + '_EXB'
		+ ', p_' + @sdays + '_CHD' + ', pk_' + @sdays + '_CHD'

-------------------------------------------------------------------
-- Prepare script for add price-duration columns to result table --
-------------------------------------------------------------------
	if(len(@sAlter) > 0)
		set @sAlter=@sAlter + ','

	set @sAlter=@sAlter + 'p_' + @sdays + '_DBL float,pk_' + @sdays + '_DBL int'
		+ ',p_' + @sdays + '_SGL float,pk_' + @sdays + '_SGL int'
		+ ',p_' + @sdays + '_EXB float,pk_' + @sdays + '_EXB int'
		+ ',p_' + @sdays + '_CHD float,pk_' + @sdays + '_CHD int'

-----------------------------------------------
-- Prepare filter predicate for quotas table --
-----------------------------------------------
	if(len(@sWhere) > 0)
		set @sWhere=@sWhere + ' or '

	set @sWhere=@sWhere + 'pt_key in (select pk_' + @sdays + '_DBL from #resultsTable)'
		+ ' or pt_key in (select pk_' + @sdays + '_SGL from #resultsTable)'
		+ ' or pt_key in (select pk_' + @sdays + '_EXB from #resultsTable)'
		+ ' or pt_key in (select pk_' + @sdays + '_CHD from #resultsTable)'

--	if(len(@sAddSelect) > 0)
--		set @sAddSelect=@sAddSelect + ','
--
--	set @sAddSelect=@sAddSelect + ' t_' + @sdays + '_DBL.pt_pricekey prk_' + @sdays + '_DBL, t_' + @sdays + '_DBL.pt_hdquota hq_' + @sdays + '_DBL, t_' + @sdays + '_DBL.pt_chtherequota cq_' + @sdays + '_DBL, t_' + @sdays + '_DBL.pt_chbackquota cbq_' + @sdays + '_DBL'
--								+ ',t_' + @sdays + '_SGL.pt_pricekey prk_' + @sdays + '_SGL, t_' + @sdays + '_SGL.pt_hdquota hq_' + @sdays + '_SGL, t_' + @sdays + '_SGL.pt_chtherequota cq_' + @sdays + '_SGL, t_' + @sdays + '_SGL.pt_chbackquota cbq_' + @sdays + '_SGL'
--								+ ',t_' + @sdays + '_EXB.pt_pricekey prk_' + @sdays + '_EXB, t_' + @sdays + '_EXB.pt_hdquota hq_' + @sdays + '_EXB, t_' + @sdays + '_EXB.pt_chtherequota cq_' + @sdays + '_EXB, t_' + @sdays + '_EXB.pt_chbackquota cbq_' + @sdays + '_EXB'
--								+ ',t_' + @sdays + '_CHD.pt_pricekey prk_' + @sdays + '_CHD, t_' + @sdays + '_CHD.pt_hdquota hq_' + @sdays + '_CHD, t_' + @sdays + '_CHD.pt_chtherequota cq_' + @sdays + '_CHD, t_' + @sdays + '_CHD.pt_chbackquota cbq_' + @sdays + '_CHD'
--
--
--	set @sJoin=@sJoin + ' left outer join #quotaCheckTable t_' + @sdays + '_DBL on t.pk_' + @sdays + '_DBL = t_' + @sdays + '_DBL.pt_key'
--		+ ' left outer join #quotaCheckTable t_' + @sdays + '_SGL on t.pk_' + @sdays + '_SGL = t_' + @sdays + '_SGL.pt_key'
--		+ ' left outer join #quotaCheckTable t_' + @sdays + '_EXB on t.pk_' + @sdays + '_EXB = t_' + @sdays + '_EXB.pt_key'
--		+ ' left outer join #quotaCheckTable t_' + @sdays + '_CHD on t.pk_' + @sdays + '_CHD = t_' + @sdays + '_CHD.pt_key'

	FETCH NEXT FROM dCur INTO @d,@n
END
CLOSE dCur
DEALLOCATE dCur

if(len(@sKeysSelect) > 0)
begin
	set @sTmp = 'alter table #resultsTable add ' + @sAlter
	exec(@sTmp)

	declare @daysPart varchar(50)
	set @daysPart = dbo.mwGetFilterPart(@filter, 'pt_days')

	if(@daysPart is not null)
		set @filter = REPLACE(@filter, @daysPart, '1 = 1')

	--print ' Before Execute PagingSelect: ' + CONVERT(VARCHAR(20), getdate(),114 )

	declare @nSql nvarchar(4000)
	set @nSql=N'
	DECLARE @firstRecord int,@lastRecord int
	SET @firstRecord=('+ @spageNum + ' - 1) * ' + @spageSize+ ' + 1
	SET @lastRecord=('+ @spageNum +' *'+ @spageSize + ')
	select top 250 identity(int,1,1) paging_id, pt_ctkey, pt_ctname, pt_hdkey, pt_hdname, pt_hdstars, hd_http as pt_hotelurl, pt_pnkey, pt_pncode, pt_rate, pt_rmkey, pt_rmname, pt_rckey, pt_rcname, pt_tourdate' 
	
	if(len(@sKeysSelect) > 0)
		set @nSql=@nSql + ',' + @sKeysSelect 
	
	set @nSql=@nSql + '
		into #pg from ' + @viewName + ' inner join hoteldictionary with(nolock) on pt_hdkey = hd_key where ' + @filter

	if(len(isnull(@sortExpr,'')) > 0)
		set @nSql=@nSql + '		order by ' + @sortExpr 
		
	Set @rowCount = null
		
	if(@rowCount is not null)
		set @nSql = @nSql + '
	select @@RowCount as RowsCount'
	else
		set @nSql = @nSql + '
	set @rowCountOUT = @@RowCount'

	set @nSql=@nSql + ' 
	select paging_id, pt_ctkey, pt_ctname, pt_hdkey, pt_hdname, pt_hdstars, pt_hotelurl, pt_pnkey, pt_pncode, pt_rate, pt_rmkey, pt_rmname, pt_rckey, pt_rcname, pt_tourdate'
	if(len(@sKeysSelect) > 0)
		set @nSql=@nSql + ',' + @sKeysSelect 
	set @nSql = @nSql +
	'
	from #pg WHERE #pg.paging_id BETWEEN @firstRecord and @lastRecord order by paging_id
	'

	declare @ParamDef nvarchar(100)
	set @ParamDef = '@rowCountOUT int output'
	
--	print @nSql
	INSERT INTO #resultsTable
		exec sp_executesql @nSql, @ParamDef, @rowCountOUT = @rowCount output
	
	Set @rowCount = (select COUNT(*) from #resultsTable)		--MEG00038933 Tkachuk 16-02-2012 Получаем количество строк не через output-переменную в предыдущей строке, а через select в результирующей таблице
	Select @rowCount

--print ' After Filling #resultTable: ' + CONVERT(VARCHAR(20), getdate(), 114)
--print @nSql

	-- Add quota columns to result table
	set @dml = 'ALTER TABLE #resultsTable ADD  ' + @dml
	exec (@dml)

	SET @sTmp = 'select pt_key, pt_pricekey, pt_tourdate, pt_days,	pt_nights, pt_hdkey, pt_hdday,
						pt_hdnights, (case when ' + ltrim(str(isnull(@checkAllPartnersQuota, 0))) + ' > 0 then -1 else pt_hdpartnerkey end), pt_rmkey,	pt_rckey, pt_chkey,	pt_chday, pt_chpkkey,
						pt_chprkey, pt_chbackkey, pt_chbackday, pt_chbackpkkey, pt_chbackprkey, null, null, null
				from dbo.mwPriceTablePax
				where ' + @sWhere
--print ' Before Execute GetQuotaCheckTableScript: ' + CONVERT(VARCHAR(20), getdate(),114 )
--	print @sTmp
	INSERT INTO #quotaCheckTable exec(@sTmp)
--print ' After  Execute GetQuotaCheckTableScript: ' + CONVERT(VARCHAR(20), getdate(),114 )

	declare quotaCursor cursor for
	select pt_hdkey,pt_rmkey,pt_rckey,pt_tourdate,
		pt_chkey,pt_chbackkey,
		pt_hdday,pt_hdnights,pt_hdpartnerkey,pt_chday,(case when @checkFlightPacket > 0 then pt_chpkkey else -1 end) as pt_chpkkey,pt_chprkey,
		pt_chbackday,(case when @checkFlightPacket > 0 then pt_chbackpkkey else -1 end) as pt_chbackpkkey, pt_chbackprkey,pt_days
	from #quotaCheckTable
	for update of pt_hdquota,pt_chtherequota,pt_chbackquota

	declare @hdkey int,@rmkey int,@rckey int,@tourdate datetime,
		@chkey int,@chbackkey int,@hdday int,@hdnights int,@hdprkey int,
		@chday int,@chpkkey int,@chprkey int,@chbackday int,
		@chbackpkkey int,@chbackprkey int,@days int

	open quotaCursor

	fetch next from quotaCursor into @hdkey,@rmkey,@rckey,
		@tourdate,@chkey,@chbackkey,@hdday,@hdnights,@hdprkey,
		@chday,@chpkkey,@chprkey,@chbackday,
		@chbackpkkey,@chbackprkey,@days

	declare @tmpHotelQuota varchar(10)
	declare @tmpThereAviaQuota varchar(256)		
	declare @tmpBackAviaQuota varchar(256)		
	declare @allPlaces int,@places int

	while(@@fetch_status=0)
	begin
		if(@hotelQuotaMask > 0)
		begin
			set @tmpHotelQuota=null
			select @tmpHotelQuota=res from #checked where svkey=3 and code=@hdkey and rmkey=@rmkey and rckey=@rckey and date=@tourdate and day=@hdday and days=@hdnights and prkey=@hdprkey
			if (@tmpHotelQuota is null)
			begin
				select @places=qt_places,@allPlaces=qt_allPlaces from dbo.mwCheckQuotesEx(3,@hdkey,@rmkey,@rckey, @agentKey,@hdprkey,@tourdate,@hdday,@hdnights,@requestOnRelease,@noPlacesResult,@checkAgentQuota,@checkCommonQuota,@checkNoLongQuota,0,0,0,0,0,@expiredReleaseResult)
				set @tmpHotelQuota=ltrim(str(@places)) + ':' + ltrim(str(@allPlaces))

				insert into #checked(svkey,code,rmkey,rckey,date,[day],days,prkey,pkkey,res) values(3,@hdkey,@rmkey,@rckey,@tourdate,@hdday,@hdnights,@hdprkey,0,@tmpHotelQuota)
			end
		end

		update #quotaCheckTable set pt_hdquota=@tmpHotelQuota,
			pt_chtherequota=@tmpThereAviaQuota,
			pt_chbackquota=@tmpBackAviaQuota
		where CURRENT OF quotaCursor


		fetch next from quotaCursor into @hdkey,@rmkey,@rckey,
			@tourdate,@chkey,@chbackkey,@hdday,@hdnights,@hdprkey,
			@chday,@chpkkey,@chprkey,@chbackday,
			@chbackpkkey,@chbackprkey,@days
	end

	close quotaCursor
	deallocate quotaCursor

------------------------------------------------------------------------------------------
------------------------- Fill #resultsTable with data of quotes -------------------------
--																						--
	DECLARE @UpdateQuotesSQL varchar(8000)												--
		SET @UpdateQuotesSQL = N''														--
																						--
	DECLARE daysCursor CURSOR FOR SELECT days,nights FROM #days							--
	OPEN daysCursor																		--
	FETCH NEXT FROM daysCursor INTO @d,@n												--
	WHILE (@@fetch_status=0)															--
	BEGIN																				--
		SET @sdays = LTRIM(STR(@d)) + '_' + LTRIM(STR(@n))								--
																						--
		SET @UpdateQuotesSQL =															--
			'UPDATE #resultsTable SET ' +												--
				'prk_' + @sdays + '_DBL = pt_pricekey, ' +								--
				'hq_' + @sdays + '_DBL = pt_hdquota, ' +								--
				'cq_' + @sdays + '_DBL = pt_chtherequota, ' +							--
				'cbq_' + @sdays + '_DBL = pt_chbackquota ' +							--
			'FROM #quotaCheckTable WHERE pk_' + @sdays + '_DBL = pt_key '				--
		EXEC (@UpdateQuotesSQL)															--
																						--
		SET @UpdateQuotesSQL =															--
			'UPDATE #resultsTable SET ' +												--
				'prk_' + @sdays + '_SGL = pt_pricekey, ' +								--
				'hq_' + @sdays + '_SGL = pt_hdquota, ' +								--
				'cq_' + @sdays + '_SGL = pt_chtherequota, ' +							--
				'cbq_' + @sdays + '_SGL = pt_chbackquota ' +							--
			'FROM #quotaCheckTable WHERE pk_' + @sdays + '_SGL = pt_key '				--
		EXEC (@UpdateQuotesSQL)															--
																						--
		SET @UpdateQuotesSQL =															--
			'UPDATE #resultsTable SET ' +												--
				'prk_' + @sdays + '_EXB = pt_pricekey, ' +								--
				'hq_' + @sdays + '_EXB = pt_hdquota, ' +								--
				'cq_' + @sdays + '_EXB = pt_chtherequota, ' +							--
				'cbq_' + @sdays + '_EXB = pt_chbackquota ' +							--
			'FROM #quotaCheckTable WHERE pk_' + @sdays + '_EXB = pt_key '				--
		EXEC (@UpdateQuotesSQL)															--
																						--
		SET @UpdateQuotesSQL =															--
			'UPDATE #resultsTable SET ' +												--
				'prk_' + @sdays + '_CHD = pt_pricekey, ' +								--
				'hq_' + @sdays + '_CHD = pt_hdquota, ' +								--
				'cq_' + @sdays + '_CHD = pt_chtherequota, ' +							--
				'cbq_' + @sdays + '_CHD = pt_chbackquota ' +							--
			'FROM #quotaCheckTable WHERE pk_' + @sdays + '_CHD = pt_key '				--
		EXEC (@UpdateQuotesSQL)															--
																						--
		FETCH NEXT FROM daysCursor INTO @d,@n											--
	END																					--
	CLOSE daysCursor																	--
	DEALLOCATE daysCursor																--
--																						--
-------------------------										 -------------------------
------------------------------------------------------------------------------------------

select * from #resultsTable

end
else 
begin
	select 0
	select * from #resultsTable
end
go

grant exec on dbo.Paging to public
go
/*********************************************************************/
/* end sp_PagingPax.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_PagingSelect.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='Paging')
	drop proc dbo.PagingSelect
go

--<DATE>2012-02-17</DATE>
---<VERSION>2009.2.3</VERSION>

create procedure [dbo].[PagingSelect]
@pagingType int,
@sKeysSelect varchar(2024),
@spageNum varchar(30),
@spageSize varchar(30),
@filter	varchar(2024),
@orderBy varchar (2024),
@tableName varchar(256),
@viewName varchar(256),
@rowCount int output
as
begin
create table #checked(
	svkey int,
	code int,
	rmkey int,
	rckey int,
	date datetime,
	day int,
	days int,
	prkey int,
	pkkey int,
	res varchar(10)
)	

declare @sql nvarchar(4000)
declare @nRowCount int
set @nRowCount = 1000
set @sql=N'
DECLARE @firstRecord int,@lastRecord int
SET @firstRecord=('+ @spageNum + ' - 1) * ' + @spageSize+ ' + 1
SET @lastRecord=('+ @spageNum +' *'+ @spageSize + ')
select top ' + ltrim(str(@nRowCount)) + ' identity(int,1,1) paging_id, pt_key,pt_tourdate,pt_pnkey,pt_hdkey,pt_hrkey,pt_tourkey' 
if(len(@sKeysSelect) > 0)
	set @sql=@sql + ',' + @sKeysSelect 
set @sql=@sql + '
into #pg from ' + @viewName + ' where ' + @filter

if(len(isnull(@orderBy,'')) > 0)
	set @sql=@sql + ' order by ' + @orderBy 

if(@rowCount is not null)
	set @sql = @sql + '
		select @@RowCount as RowsCount'
else
	begin
		set @sql = @sql + '
			set @rowCountOUT = @@RowCount
'
	end
set @sql=@sql + ' 
select #pg.paging_id paging_id,#pg.pt_key,tbl.pt_ctkeyfrom,tbl.pt_cnkey,#pg.pt_tourdate,#pg.pt_pnkey,#pg.pt_hdkey,#pg.pt_hrkey,#pg.pt_tourkey,tbl.pt_tlkey as pt_tlkey,tl_tip as pt_tourtype,tl_nameweb as pt_tourname,tl_webhttp as pt_toururl,
hd_name pt_hdname,hd_stars pt_hdstars,hd_ctkey pt_ctkey,hd_rskey pt_rskey,hd_http pt_hotelurl,pn_code pt_pncode,tbl.pt_rate pt_rate,tbl.pt_rmkey pt_rmkey,tbl.pt_rckey pt_rckey,tbl.pt_ackey pt_ackey,tbl.pt_childagefrom pt_childagefrom,tbl.pt_childageto pt_childageto,tbl.pt_childagefrom2 pt_childagefrom2,tbl.pt_childageto2 pt_childageto2, cn_name pt_cnname, ct_name pt_ctname, rs_name pt_rsname, tbl.pt_rmname pt_rmname,tbl.pt_rcname pt_rcname,tbl.pt_acname pt_acname, tbl.pt_chkey pt_chkey, tbl.pt_chbackkey pt_chbackkey, tbl.pt_hotelkeys pt_hotelkeys, tbl.pt_hotelroomkeys pt_hotelroomkeys, tbl.pt_hotelnights pt_hotelnights, tbl.pt_hotelstars pt_hotelstars, tbl.pt_pansionkeys pt_pansionkeys, tbl.pt_rckey pt_actual, dbo.mwGetVisaDeadlineDate(tbl.pt_tlkey, tbl.pt_tourdate, tbl.pt_ctkeyfrom) pt_visadeadline ' --MEG00038933 Tkachuk 16-02-2012: не хватало двух последних столбцов для корректной работы хранимой процедуры
if(len(@sKeysSelect) > 0)
	set @sql=@sql + ',' + @sKeysSelect 
set @sql = @sql +
'
from #pg inner join ' + @tableName + ' tbl on tbl.pt_key=#pg.pt_key inner join turlist on tl_key = tbl.pt_tlkey inner join country on tbl.pt_cnkey = cn_key inner join hoteldictionary on hd_key=#pg.pt_hdkey inner join pansion on #pg.pt_pnkey=pn_key inner join citydictionary on hd_ctkey = ct_key left outer join resorts on hd_rskey = rs_key
WHERE #pg.paging_id '
if (@pagingType = 5)
	set @sql = @sql + '>' + @spageNum
else if (@pagingType = 0)
	set @sql = @sql + 'BETWEEN @firstRecord and @lastRecord'
set @sql = @sql + ' order by paging_id'
declare @ParamDef nvarchar(100)
--print @sql
set @ParamDef = '@rowCountOUT int output'
exec sp_executesql @sql, @ParamDef, @rowCountOUT = @rowCount output
end
go

grant exec on dbo.Paging to public
go
/*********************************************************************/
/* end sp_PagingSelect.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_CheckActualPrice.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_CheckActualPrice]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_CheckActualPrice]
GO
CREATE PROCEDURE [dbo].[ReCalculate_CheckActualPrice]
	(
		-- хранимка проверяет на актуальность цены перерасчитывает их и возвращает их актальное состояние
		-- <version>2009.02.01</version>
		-- <data>2012-04-04</data>
		@tpKeys nvarchar(max)
	)
AS
BEGIN
	SET ARITHABORT ON;
	SET DATEFIRST 1;
	set nocount on;
	
	declare @beginTime datetime
	set @beginTime = getDate()
	
	-- таблица ключей
	declare @tpKeysTable table
	(
		xt_key bigint
	)
	
	insert into @tpKeysTable (xt_key)
	select xt_key from dbo.ParseKeys(@tpKeys)	
	
	print 'Парсинг ключей: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	-- таблица ключей
	declare @tempPriceComponents table
	(
		xPCId bigint,
		xTPKey bigint,
		xTRKey int,
		xTourDate datetime,
		xDays int,
		
		xSCPId1 bigint,
		xSCPId2 bigint,
		xSCPId3 bigint,
		xSCPId4 bigint,
		xSCPId5 bigint,
		xSCPId6 bigint,
		xSCPId7 bigint,
		xSCPId8 bigint,
		xSCPId9 bigint,
		xSCPId10 bigint,
		xSCPId11 bigint,
		xSCPId12 bigint,
		xSCPId13 bigint,
		xSCPId14 bigint,
		xSCPId15 bigint,
		
		xSvKey1 int,
		xSvKey2 int,
		xSvKey3 int,
		xSvKey4 int,
		xSvKey5 int,
		xSvKey6 int,
		xSvKey7 int,
		xSvKey8 int,
		xSvKey9 int,
		xSvKey10 int,
		xSvKey11 int,
		xSvKey12 int,
		xSvKey13 int,
		xSvKey14 int,
		xSvKey15 int
	)
	
	insert into @tempPriceComponents(xPCId, xTPKey, xTRKey, xTourDate, xDays, xSCPId1, xSCPId2, xSCPId3, xSCPId4, xSCPId5, xSCPId6, xSCPId7, xSCPId8, xSCPId9, xSCPId10, xSCPId11, xSCPId12, xSCPId13, xSCPId14, xSCPId15,
	xSvKey1, xSvKey2, xSvKey3, xSvKey4, xSvKey5, xSvKey6, xSvKey7, xSvKey8, xSvKey9, xSvKey10, xSvKey11, xSvKey12, xSvKey13, xSvKey14, xSvKey15)
	select PC_Id, PC_TPKey, PC_TRKey, PC_TourDate, PC_Days, SCPId_1, SCPId_2, SCPId_3, SCPId_4, SCPId_5, SCPId_6, SCPId_7, SCPId_8, SCPId_9, SCPId_10, SCPId_11, SCPId_12, SCPId_13, SCPId_14, SCPId_15,
	SVKey_1, SVKey_2, SVKey_3, SVKey_4, SVKey_5, SVKey_6, SVKey_7, SVKey_8, SVKey_9, SVKey_10, SVKey_11, SVKey_12, SVKey_13, SVKey_14, SVKey_15
	from TP_PriceComponents with(nolock)
	where PC_TPKey in (select xt_key from @tpKeysTable)
	
	print 'Заполнение вспомогательной таблицы @tempPriceComponents: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- Цены
	-- найдем ключи цен которые нам нужно перерасчитать
	declare @xSCPIdTable table
	(
		xSCPId bigint
	)
		
	insert into @xSCPIdTable(xSCPId)
	select SPAD_SCPId as xSCPId
	from @tempPriceComponents join TP_ServicePriceActualDate with(nolock) on 1 = 1
	where SPAD_SaleDate is null
	and SPAD_NeedApply != 0
	and (
			(isnull(xSCPId1, -100500) = SPAD_SCPId) or
			(isnull(xSCPId2, -100500) = SPAD_SCPId) or
			(isnull(xSCPId3, -100500) = SPAD_SCPId) or
			(isnull(xSCPId4, -100500) = SPAD_SCPId) or
			(isnull(xSCPId5, -100500) = SPAD_SCPId) or
			(isnull(xSCPId6, -100500) = SPAD_SCPId) or
			(isnull(xSCPId7, -100500) = SPAD_SCPId) or
			(isnull(xSCPId8, -100500) = SPAD_SCPId) or
			(isnull(xSCPId9, -100500) = SPAD_SCPId) or
			(isnull(xSCPId10, -100500) = SPAD_SCPId) or
			(isnull(xSCPId11, -100500) = SPAD_SCPId) or
			(isnull(xSCPId12, -100500) = SPAD_SCPId) or
			(isnull(xSCPId13, -100500) = SPAD_SCPId) or
			(isnull(xSCPId14, -100500) = SPAD_SCPId)
	)
	
	print 'Поиск ключей цен которые изменились: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- если есть цены которые нужно обсчитать
	if exists(select top 1 1 from @xSCPIdTable)
	begin
		print 'Запускаем расчет цен'
		
		declare @keys nvarchar(max)
		set @keys = ''
		
		select @keys = @keys + convert(nvarchar(max), xSCPId) + ',' from @xSCPIdTable where xSCPId is not null
		
		-- запускаем перерасчет цен, передав в хранимку dbo.ReCalculateCosts список ключей
		exec dbo.ReCalculateCosts 100500, @keys
		-- запускаем перенос цен, передав в хранимку dbo.ReCalculateCosts_GrossMigrate список ключей
		exec dbo.ReCalculateCosts_GrossMigrate 100500, @keys
	end
	
	print 'Расчет изменившихся цен: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- Наценки
	-- найдем ключи наценок которые необходимо перерасчитать
	declare @xTMADIdTable table
	(
		xTMADId int
	)
	insert into @xTMADIdTable(xTMADId)
	select TMAD_Id
	from @tempPriceComponents join TP_TourMarginActualDate on xTRKey = TMAD_TRKey
	where  xTourDate = TMAD_DateCheckIn
	and xDays = TMAD_Long
	and TMAD_NeedApply != 0
	and (	xSVKey1 = TMAD_SvKey
			or xSVKey2 = TMAD_SvKey
			or xSVKey3 = TMAD_SvKey
			or xSVKey4 = TMAD_SvKey
			or xSVKey5 = TMAD_SvKey
			or xSVKey6 = TMAD_SvKey
			or xSVKey7 = TMAD_SvKey
			or xSVKey8 = TMAD_SvKey
			or xSVKey9 = TMAD_SvKey
			or xSVKey10 = TMAD_SvKey
			or xSVKey11 = TMAD_SvKey
			or xSVKey12 = TMAD_SvKey
			or xSVKey13 = TMAD_SvKey
			or xSVKey14 = TMAD_SvKey
			or xSVKey15 = TMAD_SvKey			
		)
	
	print 'Поиск ключей наценок которые изменились: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
		
	
	if (exists (select top  1 1 from @xTMADIdTable))
	begin
		print 'Запускаем перерасчет наценок'
		
		declare @marginKeys nvarchar(max)
		set @marginKeys = ''
		
		select @marginKeys = @marginKeys + convert(nvarchar(max), xTMADId) + ',' from @xTMADIdTable where xTMADId is not null
		
		-- запускаем хранимку dbo.ReCalculateMargin передав ей ключи
		exec dbo.ReCalculateMargin 100500, @marginKeys
		-- запускаем хранимку dbo.ReCalculateCosts_MarginMigrate передав ей ключи
		exec dbo.ReCalculateCosts_MarginMigrate 100500, @marginKeys
	end
	
	print 'Расчет изменившихся наценок: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- Доплаты
	-- Найдем ключи доплат которые нам необходимо перерасчитать
	declare @xQACIdTable table
	(
		xQACId int
	)
	
	insert into @xQACIdTable(xQACId)
	select QAC_Id
	from @tempPriceComponents join TP_QueueAddCosts on xTRKey = QAC_TRKey
	where xTourDate = QAC_DateCheckIn
	and ((xDays >= QAC_TourLongMin or QAC_TourLongMin = 0) and (xDays <= QAC_TourLongMax or QAC_TourLongMax = 0))
	and (
			(xSCPId1 = QAC_SCPId and xSvKey1 = QAC_SVKey) or
			(xSCPId2 = QAC_SCPId and xSvKey2 = QAC_SVKey) or
			(xSCPId3 = QAC_SCPId and xSvKey3 = QAC_SVKey) or
			(xSCPId4 = QAC_SCPId and xSvKey4 = QAC_SVKey) or
			(xSCPId5 = QAC_SCPId and xSvKey5 = QAC_SVKey) or
			(xSCPId6 = QAC_SCPId and xSvKey6 = QAC_SVKey) or
			(xSCPId7 = QAC_SCPId and xSvKey7 = QAC_SVKey) or
			(xSCPId8 = QAC_SCPId and xSvKey8 = QAC_SVKey) or
			(xSCPId9 = QAC_SCPId and xSvKey9 = QAC_SVKey) or
			(xSCPId10 = QAC_SCPId and xSvKey10 = QAC_SVKey) or
			(xSCPId11 = QAC_SCPId and xSvKey11 = QAC_SVKey) or
			(xSCPId12 = QAC_SCPId and xSvKey12 = QAC_SVKey) or
			(xSCPId13 = QAC_SCPId and xSvKey13 = QAC_SVKey) or
			(xSCPId14 = QAC_SCPId and xSvKey14 = QAC_SVKey) or
			(xSCPId15 = QAC_SCPId and xSvKey15 = QAC_SVKey)
	)
	
	print 'Поиск ключей доплат которые изменились: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	if (exists (select top 1 1 from @xQACIdTable))
	begin
		print 'Запускаем перерасчет доплат'
		
		declare @addCostKeys nvarchar(max)
		set @addCostKeys = ''
		
		select @addCostKeys = @addCostKeys + convert(nvarchar(max), xQACId) + ',' from @xQACIdTable where xQACId is not null
		
		-- запускаем dbo.ReCalculateAddCosts, передав на вход ключи из очереди которые нужно перерасчитать
		exec dbo.ReCalculateAddCosts 100500, null, @addCostKeys
	end
	
	print 'Расчет изменившихся доплат: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- После перерасчета всех изменившихся цен, выводим актуальную информацию по ценам
	select PC_TPKey, PC_SummPrice
	from TP_PriceComponents with(nolock)
	where PC_TPKey in (select xt_key from @tpKeysTable)
	
	print 'Вывод результата: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
END
GO
grant exec on [dbo].[ReCalculate_CheckActualPrice] to public
go
/*********************************************************************/
/* end sp_ReCalculate_CheckActualPrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_TakeOff.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_TakeOff]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_TakeOff]
GO
CREATE PROCEDURE [dbo].[ReCalculate_TakeOff]
	(
		-- хранимка удаляет цены из TP_PricesComponents
		--<version>2009.2.01</version>
		--<data>2012-04-10</data>
		-- список ключей @pcIds для удаления цен
		@pcIds xml ([dbo].[ArrayOfLong]) = null
	)
AS
BEGIN	
	SET ARITHABORT ON;
		
	update TP_PriceComponents
	set Gross_1 = null,
	PC_DateLastChangeGross = getdate(),
	PC_UpdateDate = getdate(),
	PC_State = 1
	where PC_Id in (select tbl.res.value('.', 'bigint') from @pcIds.nodes('/ArrayOfLong/long') as tbl(res))
END

GO
grant exec on [dbo].[ReCalculate_TakeOff] to public
go
/*********************************************************************/
/* end sp_ReCalculate_TakeOff.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_SetStatusInRoom.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SetStatusInRoom]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SetStatusInRoom]
GO

CREATE PROCEDURE [dbo].[SetStatusInRoom] 
	(
		--<VERSION>2009.2.2</VERSION>
		--<DATA>04.06.2012</DATA>
		@DlKey int
	)
AS
BEGIN
	/*
	Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	1. Если "Осн" в состоянии "Ок", "А", или "С" - тогда "доп" - в "Ок".
	2. Если "Осн" в "RQ" - тогда доп - в "RQ".
	*/
	declare @ServiceHotelKey int -- ключ услуги проживание
	set @ServiceHotelKey = 3
	
	declare @QT_ByRoom bit
	
	create table #DlKeys
	(
		dlKey int
	)
	
	insert into #DLKeys
		select dl_key 
		from dogovorlist 
		where dl_dgkey in (
							select dl_dgkey 
							from dogovorlist 
							where dl_key = @DLKey
						   )
		and dl_svkey = @ServiceHotelKey
	
	-- karimbaeva 04-06-2012 если квота на номер и у основного места статус ок, то устанавливаем его и у доп места
	if exists (select top 1 SD_ID from ServiceByDate join RoomPlaces on SD_RLID=RP_RLID where RP_Type = 0 and sd_dlkey in (select dlKey from #DLKeys) 
																		and SD_RLID = (select TOP 1 SD_RLID from ServiceByDate where sd_dlkey=@DlKey)) 
	begin
		SELECT @QT_ByRoom=QT_ByRoom FROM Quotas,QuotaDetails,QuotaParts WHERE QD_QTID=QT_ID and QD_ID=QP_QDID 
		and QP_ID = (select top 1 SD_QPID
					from ServiceByDate join RoomPlaces on SD_RLID = RP_RLID  
					where RP_Type = 0 and sd_dlkey in (select dlKey from #DLKeys))

		if (@QT_ByRoom=1)
		begin 
			update ServiceByDate set SD_State = (select top 1 SBD1.SD_State 
			from ServiceByDate as SBD1 join RoomPlaces as RP1 on SBD1.SD_RPID = RP1.RP_ID 
			where RP_Type = 0 and sd_dlkey in (select dlKey from #DLKeys) 
			and SD_RLID = (select TOP 1 SD_RLID from ServiceByDate where sd_dlkey=@DlKey))
			from ServiceByDate join RoomPlaces on SD_RPID = RP_ID 
			where RP_Type=1 and SD_DLKey=@DlKey and SD_State is null
			return 0
		end
	end
	
	update ServiceByDate
	set SD_State = 3
	from ServiceByDate as SBD1 join RoomPlaces as RP1 on SBD1.SD_RPID = RP1.RP_ID
	where RP1.RP_Type = 1 and sd_dlkey in (select dlKey from #DLKeys)
	and ISNULL((select MAX (SD_State)
					from ServiceByDate as SBD2 join RoomPlaces as RP2 on SBD2.SD_RPID = RP2.RP_ID
					where RP2.RP_Type = 0 and sd_dlkey in (select dlKey from #DLKeys) 
					and SBD2.SD_RLID = SBD1.SD_RLID), 4) < 4
	and SBD1.SD_RLID in (select SBD3.SD_RLID
							from ServiceByDate as SBD3
							where SBD3.SD_DLKey = @DlKey)

	update ServiceByDate
	set SD_State = 4
	from ServiceByDate as SBD1 join RoomPlaces as RP1 on SBD1.SD_RPID = RP1.RP_ID
	where RP1.RP_Type = 1
	and ISNULL((select MAX (SD_State)
					from ServiceByDate as SBD2 join RoomPlaces as RP2 on SBD2.SD_RPID = RP2.RP_ID
					where RP2.RP_Type = 0 and sd_dlkey in (select dlKey from #DLKeys)
					and SBD2.SD_RLID = SBD1.SD_RLID), 4) = 4
	and SBD1.SD_RLID in (select SBD3.SD_RLID
							from ServiceByDate as SBD3
							where SBD3.SD_DLKey = @DlKey)
							
	drop table #DLKeys
END

GO

grant exec on [dbo].[SetStatusInRoom] to public
go

/*********************************************************************/
/* end sp_SetStatusInRoom.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_SyncProtourQuotes.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SyncProtourQuotes]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SyncProtourQuotes]
GO
CREATE PROCEDURE [dbo].[SyncProtourQuotes]
(
	--<VERSION>2009.2.5</VERSION>
	--<DATA>25.07.2012</DATA>
	@hotelKeys varchar(2048) = null,	-- строка с ключами отелей (через запятую)
	@startDate datetime = null,		-- дата начала интервала, по которому изменялись квоты (для стопов передается null)
	@endDate datetime = null,		-- дата окончания интервала, по которому изменялись квоты (для стопов передается null)
	@quotesUpdate bit = null			-- признак того, что обновлять надо квоты (т.е. 1 - обновление квот, 0 - обновление стопов)
)
AS
BEGIN
	if (dbo.mwReplIsPublisher() = 0)
		return;
		
	declare @qtid int, @qoid int, @qdid int, @qdbusy int, @uskey int, @str nvarchar(max), @hdname varchar(100), @rcname varchar(100)
	
	if (@startDate is null)
		set @startDate = '1900-01-01'
	if (@endDate is null)
		set @endDate = '2099-12-01'
	
	set @str = 'Количество квот, полученное из ProTour меньше, чем число занятых мест. 
				Обновление информации в Мастер-Туре невозможно. Параметры квот:'
				
	declare @HotelKeysTable as table (HDKey int)
	if @hotelKeys <> ''
	begin
		insert @HotelKeysTable 
		select * from ParseKeys(@hotelKeys) 
	end
	
	set @uskey = 0 
	select @uskey = ISNULL(US_Key,0) from dbo.UserList where US_USERID = SYSTEM_USER
	
	declare @ptq_Id	int, @ptq_PartnerKey int, @ptq_HotelKey	int, @ptq_RoomCategoryKey int, @ptq_Date datetime,
	@ptq_State smallint, @ptq_CommitmentTotal int, @ptq_AllotmentTotal int, @ptq_Release int, @ptq_StopSale bit, -- 0 - квоты, 1 - стопы 
	@ptq_CancelStopSale bit -- 1 - удаление стопов, 0 - добавление стопов 
	
	if (@quotesUpdate = 1 or @quotesUpdate is null)
	begin
		DECLARE qCur CURSOR FAST_FORWARD READ_ONLY FOR
		SELECT	PTQ_Id, Ptq_PartnerKey, Ptq_HotelKey, Ptq_RoomCategoryKey, Ptq_Date, Ptq_State, Ptq_CommitmentTotal, Ptq_AllotmentTotal, 
				Ptq_Release, Ptq_StopSale, Ptq_CancelStopSale 	
				FROM ProtourQuotes where PTQ_Date between @startDate and @endDate   
											and (PTQ_HotelKey in (select HDKey from @HotelKeysTable) or @hotelKeys is null)
											and PTQ_StopSale=0 
											and PTQ_CancelStopSale is null
		
		OPEN qCur
		FETCH NEXT FROM qCur INTO	@ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, 
							@ptq_CommitmentTotal, @ptq_AllotmentTotal, @ptq_Release, @ptq_StopSale, @ptq_CancelStopSale
						
		WHILE @@FETCH_STATUS = 0
		BEGIN 
			if (@ptq_CommitmentTotal > 0 and @ptq_State <> 2)
			begin
				-- проверяем если сегодня закачки квот из ProTour не было (SYSExistsProtourQuotesHistory = 0), то если @ptq_State=3 проверяем наличие квоты в МТ 
				if (@ptq_State=1 or (@ptq_State=3 and exists(select 1 from systemsettings where ss_parmname='SYSProtourQuotesHistory' and SS_ParmValue <> convert(varchar(100), getdate(), 105)))) -- если квота новая
				begin
					if not exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QT_ByRoom = 1
								and QD_Type = 2)
					begin
						insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment) 
						values (@ptq_PartnerKey, 1, '')
						set @qtid = SCOPE_IDENTITY()
						
						insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
						values (@qtid, 3, @ptq_HotelKey, 0, @ptq_RoomCategoryKey)
						set @qoid = SCOPE_IDENTITY()
						
						insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
						values (@qtid, @ptq_Date, 2, @ptq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
						set @qdid = SCOPE_IDENTITY()
				
						insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
						values (@qdid, @ptq_Date, @ptq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0) 
						
						update QuotaObjects
						set QO_CTKey = (select HD_CTKey from HotelDictionary where HD_Key = QO_Code)
						where QO_SVKey = 3 and QO_ID = @qoid and QO_CTKey is null
					
						update QuotaObjects
						set QO_CNKey= (select CT_CNKey from CityDictionary where CT_Key=QO_CTKey) 
						where QO_CNKey is null and QO_CTKey is not null and QO_ID = @qoid
						
						update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
					end
					else
					begin
						if exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 2)
						begin
							select @qdid = QD_ID, @qdbusy = QD_Busy 
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								
							if (@qdbusy > @ptq_CommitmentTotal)
							begin
								select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
								select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
								set @str = @str + CHAR(13) + 'Партнер:' + convert(varchar(100),@ptq_PartnerKey) + CHAR(13) + 
															'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
															'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
															'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)
								print @str
							end 
							else 
							begin
								update QuotaDetails set QD_Places = @ptq_CommitmentTotal where QD_ID = @qdid 
								update QuotaParts set QP_Places = @ptq_CommitmentTotal where QP_QDID = @qdid
								update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							end 
						end
						else
						begin
							select @qtid = QT_ID, @qoid = QO_ID 
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QT_ByRoom = 1
								and QD_Type = 2
								
							insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
							values (@qtid, @ptq_Date, 2, @ptq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
							set @qdid = SCOPE_IDENTITY()
				
							insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
							values (@qdid, @ptq_Date, @ptq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
							
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
						end
					end
				end
				if (@ptq_State=3 and exists(select 1 from systemsettings where ss_parmname='SYSExistsProtourQuotesHistory' and SS_ParmValue = convert(varchar(100), getdate(), 105))) 
				begin
					if exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 2)
					begin
						select @qdid = QD_ID, @qdbusy = QD_Busy 
							from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
							inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
							where QT_PRKey = @ptq_PartnerKey
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QD_Date = @ptq_Date
							and QT_ByRoom = 1
							and QD_Type = 2
								
						if (@qdbusy > @ptq_CommitmentTotal)
						begin
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
							set @str = @str + CHAR(13) + 'Партнер:' + convert(varchar(100),@ptq_PartnerKey) + CHAR(13) + 
														'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
														'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
														'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)
							print @str
						end 
						else 
						begin
							update QuotaDetails set QD_Places = @ptq_CommitmentTotal where QD_ID = @qdid 
							update QuotaParts set QP_Places = @ptq_CommitmentTotal where QP_QDID = @qdid
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end 
					end
					else
					begin
						select @qtid = QT_ID, @qoid = QO_ID 
							from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
							inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
							where QT_PRKey = @ptq_PartnerKey
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QT_ByRoom = 1
							and QD_Type = 2
								
						insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
						values (@qtid, @ptq_Date, 2, @ptq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
						set @qdid = SCOPE_IDENTITY()
				
						insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
						values (@qdid, @ptq_Date, @ptq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
							
						update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
					end
				end
				if (@ptq_State=4) --удаляемая
				begin 
					update QuotaDetails
					set QD_IsDeleted = 4 -- Request
					from Quotas join QuotaDetails on QT_ID = QD_QTID
					join QuotaObjects on QT_ID = QO_QTID
					where QT_PRKey = @ptq_PartnerKey
						and QO_SVKey = 3
						and QO_Code = @ptq_HotelKey
						and QO_SubCode1 = 0
						and QO_SubCode2 = @ptq_RoomCategoryKey
						and QD_Date = @ptq_Date
						and QT_ByRoom = 1
						and QD_Type = 2
		
					exec QuotaDetailAfterDelete
					
					delete QuotaObjects
					from QuotaObjects join Quotas on QO_QTID = QT_ID
					where not exists (select 1 from StopSales where SS_QOID = QO_ID)
					and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
					and QO_SVKey = 3
					and QO_Code = @ptq_HotelKey
					and QO_SubCode1 = 0
					and QO_SubCode2 = @ptq_RoomCategoryKey
					and QT_ByRoom = 1
	
					delete Quotas
					from Quotas join QuotaObjects on QT_ID = QO_QTID
					where not exists (select 1 from QuotaObjects where QO_QTID = QT_ID)
					and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
					and QT_ByRoom = 1
					
					delete ProtourQuotes where PTQ_Id = @ptq_Id
				end
			end 
			
			if (@ptq_AllotmentTotal > 0 and @ptq_State <> 2)
			begin
				-- проверяем если сегодня закачки квот из ProTour не было (SYSExistsProtourQuotesHistory = 0), то если @ptq_State=3 проверяем наличие квоты в МТ 
				if (@ptq_State=1 or (@ptq_State=3 and exists(select 1 from systemsettings where ss_parmname='SYSProtourQuotesHistory' and SS_ParmValue <> convert(varchar(100), getdate(), 105)))) -- если квота новая
				begin
					if not exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QT_ByRoom = 1
								and QD_Type = 1)
					begin
						insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment) 
						values (@ptq_PartnerKey, 1, '')
						set @qtid = SCOPE_IDENTITY()
						
						insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
						values (@qtid, 3, @ptq_HotelKey, 0, @ptq_RoomCategoryKey)
						set @qoid = SCOPE_IDENTITY()
						
						insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
						values (@qtid, @ptq_Date, 1, @ptq_Release, @ptq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
						set @qdid = SCOPE_IDENTITY()
				
						insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
						values (@qdid, @ptq_Date, @ptq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0) 
						
						update QuotaObjects
						set QO_CTKey = (select HD_CTKey from HotelDictionary where HD_Key = QO_Code)
						where QO_SVKey = 3 and QO_ID = @qoid and QO_CTKey is null
					
						update QuotaObjects
						set QO_CNKey= (select CT_CNKey from CityDictionary where CT_Key=QO_CTKey) 
						where QO_CNKey is null and QO_CTKey is not null and QO_ID = @qoid
						
						update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
					end
					else
					begin
						if exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 1)
						begin
							select @qdid = QD_ID, @qdbusy = QD_Busy 
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 1
								
							if (@qdbusy > @ptq_AllotmentTotal)
							begin
								select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
								select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
								set @str = @str + CHAR(13) + 'Партнер:' + convert(varchar(100),@ptq_PartnerKey) + CHAR(13) + 
															'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
															'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
															'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)
								print @str
							end 
							else 
							begin
								update QuotaDetails set QD_Places = @ptq_AllotmentTotal, QD_Release = @ptq_Release where QD_ID = @qdid 
								update QuotaParts set QP_Places = @ptq_AllotmentTotal where QP_QDID = @qdid
								update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							end 
						end
						else
						begin
							select @qtid = QT_ID, @qoid = QO_ID 
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QT_ByRoom = 1
								and QD_Type = 1
								
							insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
							values (@qtid, @ptq_Date, 1, @ptq_Release, @ptq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
							set @qdid = SCOPE_IDENTITY()
				
							insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
							values (@qdid, @ptq_Date, @ptq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
							
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
						end
					end
				end
				if (@ptq_State=3 and exists(select 1 from systemsettings where ss_parmname='SYSExistsProtourQuotesHistory' and SS_ParmValue = convert(varchar(100), getdate(), 105))) 
				begin
					if exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 1)
					begin
						select @qdid = QD_ID, @qdbusy = QD_Busy 
							from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
							inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
							where QT_PRKey = @ptq_PartnerKey
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QD_Date = @ptq_Date
							and QT_ByRoom = 1
							and QD_Type = 1
								
						if (@qdbusy > @ptq_AllotmentTotal)
						begin
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
							set @str = @str + CHAR(13) + 'Партнер:' + convert(varchar(100),@ptq_PartnerKey) + CHAR(13) + 
														'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
														'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
														'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)
							print @str
						end 
						else 
						begin
							update QuotaDetails set QD_Places = @ptq_AllotmentTotal, QD_Release = @ptq_Release where QD_ID = @qdid 
							update QuotaParts set QP_Places = @ptq_AllotmentTotal where QP_QDID = @qdid
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end 
					end
					else
					begin
						select @qtid = QT_ID, @qoid = QO_ID 
							from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
							inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
							where QT_PRKey = @ptq_PartnerKey
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QT_ByRoom = 1
							and QD_Type = 1
								
						insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
						values (@qtid, @ptq_Date, 1, @ptq_Release, @ptq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
						set @qdid = SCOPE_IDENTITY()
				
						insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
						values (@qdid, @ptq_Date, @ptq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
							
						update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
					end
				end
				if (@ptq_State=4) --удаляемая
				begin 
					update QuotaDetails
					set QD_IsDeleted = 4 -- Request
					from Quotas join QuotaDetails on QT_ID = QD_QTID
					join QuotaObjects on QT_ID = QO_QTID
					where QT_PRKey = @ptq_PartnerKey
						and QO_SVKey = 3
						and QO_Code = @ptq_HotelKey
						and QO_SubCode1 = 0
						and QO_SubCode2 = @ptq_RoomCategoryKey
						and QD_Date = @ptq_Date
						and QT_ByRoom = 1
						and QD_Type = 1
		
					exec QuotaDetailAfterDelete
					
					delete QuotaObjects
					from QuotaObjects join Quotas on QO_QTID = QT_ID
					where not exists (select 1 from StopSales where SS_QOID = QO_ID)
					and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
					and QO_SVKey = 3
					and QO_Code = @ptq_HotelKey
					and QO_SubCode1 = 0
					and QO_SubCode2 = @ptq_RoomCategoryKey
					and QT_ByRoom = 1
	
					delete Quotas
					from Quotas join QuotaObjects on QT_ID = QO_QTID
					where not exists (select 1 from QuotaObjects where QO_QTID = QT_ID)
					and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
					and QT_ByRoom = 1
					
					delete ProtourQuotes where PTQ_Id = @ptq_Id
				end
			end
		
			FETCH NEXT FROM qCur INTO @ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, 
							@ptq_CommitmentTotal, @ptq_AllotmentTotal, @ptq_Release, @ptq_StopSale, @ptq_CancelStopSale
						
		END
		CLOSE qCur
		DEALLOCATE qCur	
		
		if (@str <> 'Количество квот, полученное из ProTour меньше, чем число занятых мест. 
				Обновление информации в Мастер-Туре невозможно. Параметры квот:')
		begin
			declare @bkid int
			-- отправка письма, если количество квот, полученное из ProTour меньше, чем число занятых мест
			insert into Blanks (BK_CreateDate, BK_UserKey) values (GETDATE(), ISNULL(@uskey,0))
			set @bkid = SCOPE_IDENTITY()
		
			insert into SendMail (SM_Text, SM_Date, SM_BKID, SM_Creator) values (@str, GETDATE(), @bkid, ISNULL(@uskey,0)) 
		end
	end
	else if (@quotesUpdate = 0 or @quotesUpdate is null) --обрабатываем стопы
	begin

		DECLARE qCur CURSOR FAST_FORWARD READ_ONLY FOR
		
		SELECT	PTQ_Id, Ptq_PartnerKey, Ptq_HotelKey, Ptq_RoomCategoryKey, Ptq_Date, Ptq_State, Ptq_Release, Ptq_StopSale, Ptq_CancelStopSale	
			FROM ProtourQuotes where (PTQ_HotelKey in (select HDKey from @HotelKeysTable) or @hotelKeys is null) and PTQ_StopSale=1
										
		OPEN qCur
		FETCH NEXT FROM qCur INTO	@ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, 
									@ptq_Release, @ptq_StopSale, @ptq_CancelStopSale
						
		WHILE @@FETCH_STATUS = 0
		BEGIN

			if ((@ptq_State = 1  or @ptq_State = 3) and @ptq_CancelStopSale = 0 and @ptq_State <> 2) -- 0 - добавление стопов, 1 - удаление стопов
			begin
				if exists (select TOP 1 1 from QuotaObjects where QO_Code = @ptq_HotelKey and QO_SVKey = 3 and QO_SubCode2 = 0 and QO_SubCode1 = @ptq_RoomCategoryKey) -- при передаче стопов, здесь лежит RM_Key
				begin
					if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
							where SS_PRKey = @ptq_PartnerKey
							and QO_Code = @ptq_HotelKey
							and SS_Date = @ptq_Date
							and QO_SubCode1 = @ptq_RoomCategoryKey) -- при передаче стопов, здесь лежит RM_Key
					begin
						select @qoid = QO_ID from QuotaObjects where QO_Code = @ptq_HotelKey and QO_SubCode1 = @ptq_RoomCategoryKey
					end					
				end
				else
				begin
					insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
					values (null, 3, @ptq_HotelKey, @ptq_RoomCategoryKey, 0)
					set @qdid = SCOPE_IDENTITY()
				end
				
				insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey)
						values (@qoid, null, @ptq_PartnerKey, @ptq_Date, 1, '', GETDATE(), ISNULL(@uskey,0))
				
				update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
			end
			if ((@ptq_State = 4 or @ptq_State = 3) and @ptq_CancelStopSale = 1 and @ptq_State <> 2)
			begin
				delete StopSales
				from StopSales join QuotaObjects on SS_QOID = QO_ID
				where QO_Code = @ptq_HotelKey
				and QO_SVKey = 3
				and QO_SubCode1 = @ptq_RoomCategoryKey
				and SS_Date = @ptq_Date
				and SS_PRKey = @ptq_PartnerKey
				and QO_SubCode2 = 0
				
				delete ProtourQuotes where PTQ_Id = @ptq_Id
			end
			FETCH NEXT FROM qCur INTO @ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, 
							@ptq_Release, @ptq_StopSale, @ptq_CancelStopSale
		END
		CLOSE qCur
		DEALLOCATE qCur
	end
	
	if not exists (select TOP 1 1 from History where (HI_Date between dateadd(dd,datediff(dd,0,getdate()),0) and getdate()) and HI_Text = 'Произошла закачка квот из ProtourQuotes')
	begin
		insert into History (HI_Date, HI_Text) values (getdate(), 'Произошла закачка квот из ProtourQuotes')
		update SystemSettings set SS_ParmValue=convert(varchar(100), getdate(), 105) where SS_ParmName = 'SYSProtourQuotesHistory'
	end
													
END
GO
grant exec on [dbo].[SyncProtourQuotes] to public
go



/*********************************************************************/
/* end sp_SyncProtourQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_TestCalculationClearResults.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='TestCalculationClearResults')
	drop proc dbo.TestCalculationClearResults
go

CREATE procedure [dbo].[TestCalculationClearResults]
	--<DESCRIPTION> Очищаем таблицы TestCalculationPrices / TestCalculationServiceLists.</DESCRIPTION>
	--<VERSION>9.2.12.1</VERSION>
	--<DATE>2012-05-18</DATE>
	@tlKey int = null,	-- ключ нерасчитанного тура
	@onlyNew bit = 0	-- толька результаты расчитанные по новой схеме (действует только если задан тур)
as
begin
	-- если ключ не задан, то тупо удаляем все
	if (@tlKey is null)
	begin
		delete from TestCalculationPrices;
		delete from TestCalculationServiceLists
	end
	-- если задан, то только для этого тура
	else
	begin
	delete from TestCalculationPrices where tp_tlKey = @tlKey and (@onlyNew = 0 or tp_isNewCalculate = 1)
	
	delete from TestCalculationServiceLists 
	where not exists 
		(select top 1 1 from TestCalculationPrices where tp_tiKey = tl_tiKey)
	end
end	
go

grant execute on [dbo].[TestCalculationClearResults] to public
go
/*********************************************************************/
/* end sp_TestCalculationClearResults.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_TestCalculationCompareResults.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='TestCalculationCompareResults')
	drop proc dbo.TestCalculationCompareResults
go

CREATE procedure [dbo].[TestCalculationCompareResults]
	--<DESCRIPTION> Сравниваем результаты посчитанные по старой и новой схемам.
	-- В случае несовпадения выводим информацию.</DESCRIPTION>
	--<VERSION>9.2.12.2</VERSION>
	--<DATE>2012-05-22</DATE>
	-- если задан клю тура, то сравниваем цены только на него. В противном случае все возможные
	@tlKey	int = null	-- ключ нерасчитанного тура 
as
begin
	declare @errorCount int; set @errorCount = 0;
	-- 1. Сравним кол-во цен
	declare @priceCountOld int, @priceCountNew int
	
	select @priceCountOld = count(1) from TestCalculationPrices 
	where TP_IsNewCalculate = 0 and (@tlKey is null or TP_tlKey = @tlKey)
	
	select @priceCountNew = count(1) from TestCalculationPrices 
	where TP_IsNewCalculate = 1 and (@tlKey is null or TP_tlKey = @tlKey)
	
	if (@priceCountOld != @priceCountNew)
	begin
		print 'Ошибка 1. Несоответсвеи количества расчитанныех цен'
		print 'Цен по старой схеме: ' + ltrim(str(@priceCountOld))
		print 'Цен по новой схеме: ' + ltrim(str(@priceCountNew))
		
		--дальше смотреть смысла нет, т.к. уже что-то не то ))
		return
	end
	
	declare @tlKeyOld int, @toKeyOld int, @dateBeginOld datetime, @dateEndOld datetime, @grossOld float, @tiKeyOld int;
	declare @tsSvKey int, @tsCode int, @tsSubcode1 int, @tsSubcode2 int, @tsOpPartnerKey int;
	
	-- 2. Сравним сами цены
	declare testPriceCursor cursor fast_forward read_only for 
    select	tp_tlKey, tp_toKey, tp_dateBegin, tp_dateEnd, tp_gross, tp_tiKey
	from  TestCalculationPrices 
    where TP_IsNewCalculate = 0 and (@tlKey is null or tp_tlKey = @tlKey)
    
    open testPriceCursor
    
    fetch next from testPriceCursor into @tlKeyOld, @toKeyOld, @dateBeginOld, @dateEndOld, @grossOld, @tiKeyOld--, @tsSvKey, @tsCode, @tsSubcode1, @tsSubcode2, @tsOpPartnerKey
    while (@@fetch_status=0)
    begin
		-- найдем вариант расчитанного тура (по новой схеме), который соответсвует варианту расчитаного тура (по старой схеме)
		declare @tiKeyNew int, @grossNew float, @serviceCountOld int
		
		-- запомним сколько услуг было у данного варианта расчитанного тура (это старая схема)
		select @serviceCountOld = count(1) from TestCalculationServiceLists where tl_tiKey = @tiKeyOld
		
		-- найдем вариант расчитаного тура (по новой схеме)
		select @tiKeyNew = b.tl_tiKey from TestCalculationServiceLists a,TestCalculationServiceLists b
		 where a.tl_tiKey = @tiKeyOld and b.tl_tiKey != @tiKeyOld
		 and exists (select top 1 1 from TestCalculationPrices where tp_tlKey = @tlKeyOld and tp_toKey =  b.tl_toKey)
		 and a.ts_svKey = b.ts_svKey
		 and a.ts_code = b.ts_code
		 and a.ts_subcode1 = b.ts_subcode1
		 and a.ts_subcode2 = b.ts_subcode2
		 and a.ts_opPartnerKey = b.ts_opPartnerKey
		 and a.ts_days = b.ts_days
		 group by b.tl_tiKey
		 having count(1) = @serviceCountOld
		 
		 -- 2.1. проверим, нашли ли мы вариант
		 if (@tiKeyNew is null)
		 begin
			print 'Ошибка 2. Несоответсвие вариантов расчитываемого тура'
			print 'Ключ варианта (по старой схеме): ' + ltrim(str(@tiKeyOld))
			
			--дальше смотреть смысла нет, т.к. уже что-то не то ))
			set @errorCount = -1
			break
		end
		
		-- 2.2. сравним непосредственно цены	
		select @grossNew = tp_gross from TestCalculationPrices 
		where tp_tiKey = @tiKeyNew and tp_dateBegin = @dateBeginOld
		and tp_dateEnd = @dateEndOld and tp_tlKey = @tlKeyOld and tp_isNewCalculate = 1
		
		if (@grossNew is null or @grossNew <> @grossOld)
		begin
			set @errorCount = @errorCount + 1
			print 'Ошибка 3. Несоответсвие цен для тура ' + ltrim(str(@tlKeyOld)) + ' на дату ' + ltrim(convert(varchar(20),@dateBeginOld))
			print '	Старая вариант:	' + ltrim(str(@tiKeyOld)) + ',	цена: ' + ltrim(convert(varchar(10), @grossOld))
			print '	Новый вариант:	' + ltrim(str(@tiKeyNew)) + ',	цена: ' + ltrim(convert(varchar(10), @grossNew))
		end
		
		fetch next from testPriceCursor into @tlKeyOld, @toKeyOld, @dateBeginOld, @dateEndOld, @grossOld, @tiKeyOld
    end
    close testPriceCursor;
	deallocate testPriceCursor;
	
	if (@errorCount = 0)
		print 'Цены, расчитанные по двум схемам, идентичны'
	else if (@errorCount > 0)
		print 'Несошлось цен: ' + ltrim(str(@errorCount)) + ' / ' + ltrim(str(@priceCountOld))
end	
go

grant execute on [dbo].[TestCalculationCompareResults] to public
go
/*********************************************************************/
/* end sp_TestCalculationCompareResults.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_TestCalculationSaveResults.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='TestCalculationSaveResults')
	drop proc dbo.TestCalculationSaveResults
go

CREATE procedure [dbo].[TestCalculationSaveResults]
	--<DESCRIPTION> Сохраняем результаты расчета тура (по старой схеме) в TestCalculationPrices для дальнейшего сравнения
	-- Изменяем схему расчета на новую.</DESCRIPTION>
	--<VERSION>9.2.12.2</VERSION>
	--<DATE>2012-05-22</DATE>
	@tlKey	int,	-- ключ нерасчитанного тура
	@calculatePriceByService bit	-- признак использования новой схемы при расчете
as
begin
	-- получим ключ расчитанного тура
	declare @toKey int;
	select top 1 @toKey = to_key from tp_tours where to_trKey = @tlKey

	-- 1. сохраним результаты расчета по новой схеме
	-- 1.1. tp_prices
	insert into dbo.TestCalculationPrices
		(tp_Key, tp_toKey, tp_dateBegin, tp_dateEnd, tp_gross, tp_tiKey,
		tp_calculatingKey, tp_updatedate, tp_tlKey, tp_isNewCalculate)
	select     
		tp_Key, tp_toKey, tp_dateBegin, tp_dateEnd, tp_gross, tp_tiKey, 
		tp_calculatingKey, tp_updatedate, @tlKey , @calculatePriceByService
	from tp_prices where tp_toKey = @toKey
	    
	-- 1.2. tp_serviceLists / tp_services
	
	insert into TestCalculationServiceLists
		(tl_key, tl_toKey, tl_tsKey, tl_tiKey, tl_calculatingKey, 
		ts_svKey, ts_code, ts_subCode1, ts_subCode2, ts_opPartnerKey, ts_days)
	select
		tl_key, tl_toKey, tl_tsKey, tl_tiKey, tl_calculatingKey,
		ts_svKey, ts_code, ts_subCode1, ts_subCode2, ts_opPartnerKey, ts_days
	from tp_serviceLists inner join tp_services on tl_tsKey = ts_key
	where tl_toKey = @toKey
end	
go

grant execute on [dbo].[TestCalculationSaveResults] to public
go
/*********************************************************************/
/* end sp_TestCalculationSaveResults.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_TestCalculationSwitchMethod.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='TestCalculationSwitchMethod')
	drop proc dbo.TestCalculationSwitchMethod
go

CREATE procedure [dbo].[TestCalculationSwitchMethod]
	--<DESCRIPTION> Переключает способ расчета тура:
	--	старая схема (хранимка CalculatePriceList)
	--	новая схема (сервис CalculatePriceListDynamic)</DESCRIPTION>
	--<VERSION>9.2.12.1</VERSION>
	--<DATE>2012-05-21</DATE>
	@calculatePriceByService bit = null	-- использовать новый расчетчик (если не задан, то переключит настройку на противоположную)
as
begin
	declare @calculatePriceByServiceS varchar(255)
	select @calculatePriceByServiceS = ss_parmValue from systemSettings where ss_parmName = 'CalculatePriceByService'
	
	if (@calculatePriceByServiceS is null)
	begin
		print 'Не создана настройка ''CalculatePriceByService'''
		return
	end
	if (@calculatePriceByService is not null)
	begin
		update systemSettings set ss_parmValue = @calculatePriceByService where ss_parmName = 'CalculatePriceByService'
		if (@calculatePriceByService = 0)
		begin
			print 'Установлен способ расчета тура по старой схеме (через хранимку)'
			
		end
		else
		begin
			print 'Установлен способ расчета тура по новой схеме (через сервис)'
		end
	end
	else
	begin
		if (@calculatePriceByServiceS = 0)
		begin
			update systemSettings set ss_parmValue = 1 where ss_parmName = 'CalculatePriceByService'
			print 'Установлен способ расчета тура по новой схеме (через сервис)'
		end
		else
		begin
			update systemSettings set ss_parmValue = 0 where ss_parmName = 'CalculatePriceByService'
			print 'Установлен способ расчета тура по старой схеме (через хранимку)'
		end
	end
end	
go

grant execute on [dbo].[TestCalculationSwitchMethod] to public
go
/*********************************************************************/
/* end sp_TestCalculationSwitchMethod.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_TranslateToProTour.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TranslateToProTour]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[TranslateToProTour]
GO
CREATE PROCEDURE [dbo].[TranslateToProTour]
AS
--<VERSION>2007.2.35.10</VERSION>
--.12 Gen 29.05.2012 не отправлять Аннуляции заявок, закрепленные за TUI Ukraine в испанский Протур.
--.11 Gen 29.05.2012 отменить отправку в ProTour индивидуальных туров DG_TRKEY <> 0
--.10 (MEG00030676) поиск изменений по истории делается теперь за ПОСЛЕДНИЙ месяц, также могут быть отправлены путевки по которым дата заезда уже месяц как прошла
--.9 добавлено условие = не отправлять путевки, в которых существует ошибка в синхронизации размещений
--.8 устанавливаем признак DG_ProTourFlag=3, даже если путевка не отправлялась в ProTour
--.7 исправил ошибку с отправлением путевки
--.6 отправляю сообщение по всем путевкам, даже если прошла дата заезда
--признаком, отмечаются все путевки предназначенные для передачи в ProTour
--задержка 12 минут, так как точно должны отработать правила проверки дублирования и корректности путевки
DECLARE @StateDouble int, @StateNotConsistent int, @StateSyncError int
SELECT	@StateDouble=CAST(ILR_StatusKeys as int) FROM	ILReferenceNew	WHERE ILR_Key=6
SELECT	@StateNotConsistent=CAST(ILR_StatusKeys as int) FROM	ILReferenceNew	WHERE ILR_Key=7
SET @StateSyncError=16

declare @ProtourCountryKeysSetting nvarchar(max)

set @ProtourCountryKeysSetting = (select SS_ParmValue from SystemSettings
								 where SS_ParmName = 'ProtourCountryKeys')

declare @CountryKeys as table (CNKey int)

if @ProtourCountryKeysSetting <> ''
begin
	insert @CountryKeys 
	select * 
	from ParseKeys(@ProtourCountryKeysSetting)
end


UPDATE Dogovor 
SET DG_ProTourFlag=1 
WHERE DG_ProTourFlag is null 
  and DG_TRKEY <> 0 --11. Gen 29.05.2012 
  and DG_TurDate > DATEADD(MONTH,-1,GetDate()) 
  and DG_SOR_Code not in (@StateDouble,@StateNotConsistent,@StateSyncError)
  and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
  and NOT EXISTS (SELECT 1 
				  FROM HISTORY with (nolock) 
				  WHERE HI_DGCod=DG_Code 
					AND HI_Date BETWEEN DATEADD(MINUTE,-12,GetDate()) 
					AND GetDate() )
  

UPDATE Dogovor 
SET DG_ProTourFlag=null 
WHERE DG_ProTourFlag=1 
  and DG_TurDate > DATEADD(MONTH,-1,GetDate()) 
  and DG_SOR_Code in (@StateDouble,@StateNotConsistent,@StateSyncError)
  and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
  and NOT EXISTS (SELECT 1 
				  FROM HISTORY with (nolock) 
				  WHERE HI_DGCod=DG_Code 
					AND HI_Date BETWEEN DATEADD(MINUTE,-12,GetDate()) 
					AND GetDate())

UPDATE Dogovor 
SET DG_ProTourFlag=3 
WHERE DG_ProTourFlag = 2 
  and DG_TurDate = '30-DEC-1899' 
  and DG_TurDateBfrAnnul > DATEADD(MONTH,-1,GetDate())
  and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
  and not (DG_PARTNERKEY = 44516 and DG_CNKEY = 488) --.12 Gen 29.05.2012

UPDATE Dogovor 
SET DG_ProTourFlag=3 
WHERE DG_ProTourFlag = 1 
  and DG_TurDate = '30-DEC-1899' 
  and DG_TurDateBfrAnnul > DATEADD(MONTH,-1,GetDate())
  and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
  and not (DG_PARTNERKEY = 44516 and DG_CNKEY = 488) --.12 Gen 29.05.2012

UPDATE Dogovor 
SET DG_ProTourFlag=3 
WHERE DG_ProTourFlag is not null 
  and DG_ProTourFlag not in (3,4)
  and DG_TurDate = '30-DEC-1899'
  and not (DG_PARTNERKEY = 44516 and DG_CNKEY = 488) --.12 Gen 29.05.2012
  and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
  and NOT EXISTS (SELECT 1 
				  FROM HISTORY with (nolock) 
				  WHERE HI_DGCod=DG_Code 
					AND HI_Date BETWEEN DATEADD(MINUTE,-12,GetDate()) 
					AND GetDate())
	
DECLARE @DG_Key int, @DG_Code varchar(20), @HIDateMTP datetime
DECLARE cur_5 CURSOR FOR
	SELECT DG_Key,DG_Code,MAX(HI_Date) 
	FROM History as h1,Dogovor as d1 
	WHERE HI_Date BETWEEN DATEADD(MONTH,-1,GetDate()) 
      and DATEADD(MINUTE,-12,GetDate()) 
      AND HI_Mod='MTP'
	  and DG_Code=HI_DGCod and (DG_ProTourFlag!=1 and DG_ProTourFlag is not null) 
	  and DG_SOR_Code not in (@StateDouble,@StateNotConsistent,@StateSyncError)
	GROUP BY DG_Key,DG_Code

OPEN cur_5

FETCH NEXT FROM cur_5 INTO @DG_Key, @DG_Code, @HIDateMTP

WHILE @@FETCH_STATUS = 0
BEGIN 
	IF NOT EXISTS (SELECT 1 
				   FROM HISTORY with (nolock), HistoryDetail with (nolock) 
				   WHERE HD_HIID=HI_ID 
					 and hd_oaid=399999 
					 AND HI_DGCod=@DG_Code 
					 AND HI_Date > @HIDateMTP)
	BEGIN
		UPDATE Dogovor 
		SET DG_ProTourFlag=1 
		WHERE DG_Key=@DG_Key
		  and DG_TRKEY <> 0 --11. Gen 29.05.2012 
		  and (not exists(select * from @CountryKeys) or DG_CNKEY IN (select * from @CountryKeys))
		  and NOT EXISTS (SELECT 1 
						  FROM HISTORY with (nolock) 
						  WHERE HI_DGCod=DG_Code 
							AND HI_Date BETWEEN DATEADD(MINUTE,-11,GetDate()) 
							AND GetDate())
	END
	FETCH NEXT FROM cur_5 INTO @DG_Key, @DG_Code, @HIDateMTP
END

CLOSE cur_5

DEALLOCATE cur_5
GO
grant exec on [dbo].[TranslateToProTour] to public
go
/*********************************************************************/
/* end sp_TranslateToProTour.sql */
/*********************************************************************/

/*********************************************************************/
/* begin t_Delete_mwDeleteTour.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwDeleteTour]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
drop trigger [dbo].[mwDeleteTour]
go

CREATE trigger [dbo].[mwDeleteTour] on [dbo].[TP_Tours]
for delete
as
begin
	--<DATE>2012-06-27</DATE>
	--<VERSION>9.2.13.4</VERSION>
	if dbo.mwReplIsSubscriber() <= 0
	begin
		return;
	end

	declare @tableName nvarchar(100), @sql nvarchar(4000), @tokey int
	if exists(select 1 from SystemSettings where SS_ParmName = 'MWDivideByCountry' and SS_ParmValue = 1)
	begin
		--Используется секционирование ценовых таблиц
		declare disableCursor cursor fast_forward read_only for
		select 
			to_key, dbo.mwGetPriceTableName(to_cnkey, tl_ctdeparturekey)
		from 
			deleted inner join tbl_turlist with(nolock) on to_trkey = tl_key

		open disableCursor
		fetch next from disableCursor into @tokey, @tableName
		
		while @@fetch_status = 0
		begin
			if(@tableName is not null and len(@tableName) > 0)
			begin
				set @sql = 'insert into mwDeleted with(rowlock) (del_key) select pt_pricekey from ' + @tableName + ' with(nolock) where pt_tourkey = ' + ltrim(str(@tokey)) + '
							update ' + @tableName + ' with(rowlock) set pt_isenabled = 0 where pt_isenabled > 0 and pt_tourkey = ' + ltrim(str(@tokey)) + '
							update mwSpoDataTable with(rowlock) set sd_isenabled = 0 where sd_isenabled > 0 and sd_tourkey = ' + ltrim(str(@tokey))
				exec (@sql)
			end

			delete from TP_Prices with(rowlock) where tp_tokey = @tokey
			delete from TP_PricesDeleted with(rowlock) where tpd_tokey = @tokey
			delete from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
			delete from TP_Services with(rowlock) where ts_tokey = @tokey
			delete from TP_Lists with(rowlock) where ti_tokey = @tokey

			fetch next from disableCursor into @tokey, @tableName
		end
		
		close disableCursor
		deallocate disableCursor
	end
	else
	begin
		--Секционирование ценовых таблиц НЕ используется
		set @tableName = 'dbo.mwPriceDataTable'
		declare disableCursor cursor fast_forward read_only for
		select 
			to_key
		from 
			deleted 

		open disableCursor
		
		fetch next from disableCursor into @tokey
		while @@fetch_status = 0
		begin
			if(@tableName is not null and len(@tableName) > 0)
			begin
				set @sql = 'insert into mwDeleted with(rowlock) (del_key) select pt_pricekey from ' + @tableName + ' with(nolock) where pt_tourkey = ' + ltrim(str(@tokey)) + '
							update ' + @tableName + ' with(rowlock) set pt_isenabled = 0 where pt_isenabled > 0 and pt_tourkey = ' + ltrim(str(@tokey)) + '
							update mwSpoDataTable with(rowlock) set sd_isenabled = 0 where sd_isenabled > 0 and sd_tourkey = ' + ltrim(str(@tokey))
				exec (@sql)
			end

			delete from TP_Prices with(rowlock) where tp_tokey = @tokey
			delete from TP_PricesDeleted with(rowlock) where tpd_tokey = @tokey
			delete from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
			delete from TP_Services with(rowlock) where ts_tokey = @tokey
			delete from TP_Lists with(rowlock) where ti_tokey = @tokey

			fetch next from disableCursor into @tokey
		end
		
		close disableCursor
		deallocate disableCursor
	end
end
GO



/*********************************************************************/
/* end t_Delete_mwDeleteTour.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_DogovorUpdate.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_DogovorUpdate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
drop trigger [dbo].[T_DogovorUpdate]
GO

CREATE TRIGGER [T_DogovorUpdate]
ON [dbo].[tbl_Dogovor] 
FOR UPDATE, INSERT, DELETE
AS
--<VERSION>2007.2.29.1</VERSION>
--<DATE>2009-07-23</DATE>
IF @@ROWCOUNT > 0
BEGIN
    DECLARE @ODG_Code		varchar(10)
    DECLARE @ODG_Price		float
    DECLARE @ODG_Rate		varchar(3)
    DECLARE @ODG_DiscountSum	float
    DECLARE @ODG_PartnerKey		int
    DECLARE @ODG_TRKey		int
    DECLARE @ODG_TurDate		varchar(10)
    DECLARE @ODG_CTKEY		int
    DECLARE @ODG_NMEN		int
    DECLARE @ODG_NDAY		int
    DECLARE @ODG_PPaymentDate	varchar(16)
    DECLARE @ODG_PaymentDate	varchar(10)
    DECLARE @ODG_RazmerP		float
    DECLARE @ODG_Procent		int
    DECLARE @ODG_Locked		int
    DECLARE @ODG_SOR_Code	int
    DECLARE @ODG_IsOutDoc		int
    DECLARE @ODG_VisaDate		varchar(10)
    DECLARE @ODG_CauseDisc		int
    DECLARE @ODG_OWNER		int
    DECLARE @ODG_LEADDEPARTMENT	int
    DECLARE @ODG_DupUserKey	int
    DECLARE @ODG_MainMen		varchar(50)
    DECLARE @ODG_MainMenEMail	varchar(50)
    DECLARE @ODG_MAINMENPHONE	varchar(50)
    DECLARE @ODG_CodePartner	varchar(50)
    DECLARE @ODG_Creator		int
	DECLARE @ODG_CTDepartureKey int
	DECLARE @ODG_Payed money
    
    DECLARE @NDG_Code		varchar(10)
    DECLARE @NDG_Price		float
    DECLARE @NDG_Rate		varchar(3)
    DECLARE @NDG_DiscountSum	float
    DECLARE @NDG_PartnerKey		int
    DECLARE @NDG_TRKey		int
    DECLARE @NDG_TurDate		varchar(10)
    DECLARE @NDG_CTKEY		int
    DECLARE @NDG_NMEN		int
    DECLARE @NDG_NDAY		int
    DECLARE @NDG_PPaymentDate	varchar(16)
    DECLARE @NDG_PaymentDate	varchar(10)
    DECLARE @NDG_RazmerP		float
    DECLARE @NDG_Procent		int
    DECLARE @NDG_Locked		int
    DECLARE @NDG_SOR_Code	int
    DECLARE @NDG_IsOutDoc		int
    DECLARE @NDG_VisaDate		varchar(10)
    DECLARE @NDG_CauseDisc		int
    DECLARE @NDG_OWNER		int
    DECLARE @NDG_LEADDEPARTMENT	int
    DECLARE @NDG_DupUserKey	int
    DECLARE @NDG_MainMen		varchar(50)
    DECLARE @NDG_MainMenEMail	varchar(50)
    DECLARE @NDG_MAINMENPHONE	varchar(50)
    DECLARE @NDG_CodePartner	varchar(50)
	DECLARE @NDG_Creator		int
	DECLARE @NDG_CTDepartureKey int
	DECLARE @NDG_Payed money

    DECLARE @sText_Old varchar(255)
    DECLARE @sText_New varchar(255)

    DECLARE @nValue_Old int
    DECLARE @nValue_New int

    DECLARE @DG_Key int
    
    DECLARE @sMod varchar(3)
    DECLARE @nDelCount int
    DECLARE @nInsCount int
    DECLARE @nHIID int
    DECLARE @sHI_Text varchar(254)
	DECLARE @bNeedCommunicationUpdate smallint

	DECLARE @bUpdateNationalCurrencyPrice bit

	DECLARE  @sUpdateMainDogovorStatuses varchar(254)
	
	DECLARE @nReservationNationalCurrencyRate smallint
	DECLARE @bReservationCreated smallint
	DECLARE @bCurrencyChangedPrevFixDate smallint
	DECLARE @bCurrencyChangedDate smallint
	DECLARE @bPriceChanged smallint
	DECLARE @bFeeChanged smallint
	DECLARE @bStatusChanged smallint
	DECLARE @changedDate datetime
	
    SELECT @nReservationNationalCurrencyRate = SS_PARMVALUE 
      FROM SystemSettings 
     WHERE SS_PARMNAME LIKE 'SYSReservationNCRate'
    SET @bReservationCreated = @nReservationNationalCurrencyRate & 1
    SET @bCurrencyChangedPrevFixDate = @nReservationNationalCurrencyRate & 2
    SET @bCurrencyChangedDate = @nReservationNationalCurrencyRate & 4
    SET @bPriceChanged = @nReservationNationalCurrencyRate & 8
    SET @bFeeChanged = @nReservationNationalCurrencyRate & 16
    SET @bStatusChanged = @nReservationNationalCurrencyRate & 32
	SET @changedDate = getdate()

  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
    DECLARE cur_Dogovor CURSOR LOCAL FOR 
      SELECT N.DG_Key, 
		N.DG_Code, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null,
		N.DG_Code, N.DG_Price, N.DG_Rate, N.DG_DiscountSum, N.DG_PartnerKey, N.DG_TRKey, CONVERT( char(10), N.DG_TurDate, 104), N.DG_CTKEY, N.DG_NMEN, N.DG_NDAY, 
		CONVERT( char(11), N.DG_PPaymentDate, 104) + CONVERT( char(5), N.DG_PPaymentDate, 108), CONVERT( char(10), N.DG_PaymentDate, 104), N.DG_RazmerP, N.DG_Procent, N.DG_Locked, N.DG_SOR_Code, N.DG_IsOutDoc, CONVERT( char(10), N.DG_VisaDate, 104), N.DG_CauseDisc, N.DG_OWNER, 
		N.DG_LEADDEPARTMENT, N.DG_DupUserKey, N.DG_MainMen, N.DG_MainMenEMail, N.DG_MAINMENPHONE, N.DG_CodePartner, N.DG_Creator, N.DG_CTDepartureKey, N.DG_Payed
      FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
    DECLARE cur_Dogovor CURSOR LOCAL FOR 
      SELECT O.DG_Key,
		O.DG_Code, O.DG_Price, O.DG_Rate, O.DG_DiscountSum, O.DG_PartnerKey, O.DG_TRKey, CONVERT( char(10), O.DG_TurDate, 104), O.DG_CTKEY, O.DG_NMEN, O.DG_NDAY, 
		CONVERT( char(11), O.DG_PPaymentDate, 104) + CONVERT( char(5), O.DG_PPaymentDate, 108), CONVERT( char(10), O.DG_PaymentDate, 104), O.DG_RazmerP, O.DG_Procent, O.DG_Locked, O.DG_SOR_Code, O.DG_IsOutDoc, CONVERT( char(10), O.DG_VisaDate, 104), O.DG_CauseDisc, O.DG_OWNER, 
		O.DG_LEADDEPARTMENT, O.DG_DupUserKey, O.DG_MainMen, O.DG_MainMenEMail, O.DG_MAINMENPHONE, O.DG_CodePartner, O.DG_Creator, O.DG_CTDepartureKey, O.DG_Payed,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null
      FROM DELETED O 
  END
ELSE 
  BEGIN
  	SET @sMod = 'UPD'
    DECLARE cur_Dogovor CURSOR LOCAL FOR 
      SELECT N.DG_Key,
		O.DG_Code, O.DG_Price, O.DG_Rate, O.DG_DiscountSum, O.DG_PartnerKey, O.DG_TRKey, CONVERT( char(10), O.DG_TurDate, 104), O.DG_CTKEY, O.DG_NMEN, O.DG_NDAY, 
		CONVERT( char(11), O.DG_PPaymentDate, 104) + CONVERT( char(5), O.DG_PPaymentDate, 108), CONVERT( char(10), O.DG_PaymentDate, 104), O.DG_RazmerP, O.DG_Procent, O.DG_Locked, O.DG_SOR_Code, O.DG_IsOutDoc, CONVERT( char(10), O.DG_VisaDate, 104), O.DG_CauseDisc, O.DG_OWNER, 
		O.DG_LEADDEPARTMENT, O.DG_DupUserKey, O.DG_MainMen, O.DG_MainMenEMail, O.DG_MAINMENPHONE, O.DG_CodePartner, O.DG_Creator, O.DG_CTDepartureKey, O.DG_Payed,
		N.DG_Code, N.DG_Price, N.DG_Rate, N.DG_DiscountSum, N.DG_PartnerKey, N.DG_TRKey, CONVERT( char(10), N.DG_TurDate, 104), N.DG_CTKEY, N.DG_NMEN, N.DG_NDAY, 
		CONVERT( char(11), N.DG_PPaymentDate, 104) + CONVERT( char(5), N.DG_PPaymentDate, 108),  CONVERT( char(10), N.DG_PaymentDate, 104), N.DG_RazmerP, N.DG_Procent, N.DG_Locked, N.DG_SOR_Code, N.DG_IsOutDoc,  CONVERT( char(10), N.DG_VisaDate, 104), N.DG_CauseDisc, N.DG_OWNER, 
		N.DG_LEADDEPARTMENT, N.DG_DupUserKey, N.DG_MainMen, N.DG_MainMenEMail, N.DG_MAINMENPHONE, N.DG_CodePartner, N.DG_Creator, N.DG_CTDepartureKey, N.DG_Payed
      FROM DELETED O, INSERTED N 
      WHERE N.DG_Key = O.DG_Key
  END
  
    OPEN cur_Dogovor
    FETCH NEXT FROM cur_Dogovor INTO @DG_Key,
		@ODG_Code, @ODG_Price, @ODG_Rate, @ODG_DiscountSum, @ODG_PartnerKey, @ODG_TRKey, @ODG_TurDate, @ODG_CTKEY, @ODG_NMEN, @ODG_NDAY, 
		@ODG_PPaymentDate, @ODG_PaymentDate, @ODG_RazmerP, @ODG_Procent, @ODG_Locked, @ODG_SOR_Code, @ODG_IsOutDoc, @ODG_VisaDate, @ODG_CauseDisc, @ODG_OWNER, 
		@ODG_LEADDEPARTMENT, @ODG_DupUserKey, @ODG_MainMen, @ODG_MainMenEMail, @ODG_MAINMENPHONE, @ODG_CodePartner, @ODG_Creator, @ODG_CTDepartureKey, @ODG_Payed,
		@NDG_Code, @NDG_Price, @NDG_Rate, @NDG_DiscountSum, @NDG_PartnerKey, @NDG_TRKey, @NDG_TurDate, @NDG_CTKEY, @NDG_NMEN, @NDG_NDAY, 
		@NDG_PPaymentDate, @NDG_PaymentDate, @NDG_RazmerP, @NDG_Procent, @NDG_Locked, @NDG_SOR_Code, @NDG_IsOutDoc, @NDG_VisaDate, @NDG_CauseDisc, @NDG_OWNER, 
		@NDG_LEADDEPARTMENT, @NDG_DupUserKey, @NDG_MainMen, @NDG_MainMenEMail, @NDG_MAINMENPHONE, @NDG_CodePartner, @NDG_Creator, @NDG_CTDepartureKey, @NDG_Payed

    WHILE @@FETCH_STATUS = 0
    BEGIN 
    	  ------------Проверка, надо ли что-то писать в историю-------------------------------------------   
	  If (
			ISNULL(@ODG_Code, '') != ISNULL(@NDG_Code, '') OR
			ISNULL(@ODG_Rate, '') != ISNULL(@NDG_Rate, '') OR
			ISNULL(@ODG_MainMen, '') != ISNULL(@NDG_MainMen, '') OR
			ISNULL(@ODG_MainMenEMail, '') != ISNULL(@NDG_MainMenEMail, '') OR
			ISNULL(@ODG_MAINMENPHONE, '') != ISNULL(@NDG_MAINMENPHONE, '') OR
			ISNULL(@ODG_Price, 0) != ISNULL(@NDG_Price, 0) OR
			ISNULL(@ODG_DiscountSum, 0) != ISNULL(@NDG_DiscountSum, 0) OR
			ISNULL(@ODG_PartnerKey, 0) != ISNULL(@NDG_PartnerKey, 0) OR
			ISNULL(@ODG_TRKey, 0) != ISNULL(@NDG_TRKey, 0) OR
			ISNULL(@ODG_TurDate, 0) != ISNULL(@NDG_TurDate, 0) OR
			ISNULL(@ODG_CTKEY, 0) != ISNULL(@NDG_CTKEY, 0) OR
			ISNULL(@ODG_NMEN, 0) != ISNULL(@NDG_NMEN, 0) OR
			ISNULL(@ODG_NDAY, 0) != ISNULL(@NDG_NDAY, 0) OR
			ISNULL(@ODG_PPaymentDate, 0) != ISNULL(@NDG_PPaymentDate, 0) OR
			ISNULL(@ODG_PaymentDate, 0) != ISNULL(@NDG_PaymentDate, 0) OR
			ISNULL(@ODG_RazmerP, 0) != ISNULL(@NDG_RazmerP, 0) OR
			ISNULL(@ODG_Procent, 0) != ISNULL(@NDG_Procent, 0) OR
			ISNULL(@ODG_Locked, 0) != ISNULL(@NDG_Locked, 0) OR
			ISNULL(@ODG_SOR_Code, 0) != ISNULL(@NDG_SOR_Code, 0) OR
			ISNULL(@ODG_IsOutDoc, 0) != ISNULL(@NDG_IsOutDoc, 0) OR
			ISNULL(@ODG_VisaDate, 0) != ISNULL(@NDG_VisaDate, 0) OR
			ISNULL(@ODG_CauseDisc, 0) != ISNULL(@NDG_CauseDisc, 0) OR
			ISNULL(@ODG_OWNER, 0) != ISNULL(@NDG_OWNER, 0) OR
			ISNULL(@ODG_LEADDEPARTMENT, 0) != ISNULL(@NDG_LEADDEPARTMENT, 0) OR
			ISNULL(@ODG_DupUserKey, 0) != ISNULL(@NDG_DupUserKey, 0) OR
			ISNULL(@ODG_CodePartner, '') != ISNULL(@NDG_CodePartner, '') OR
			ISNULL(@ODG_Creator, 0) != ISNULL(@NDG_Creator, 0) OR
			ISNULL(@ODG_CTDepartureKey, 0) != ISNULL(@NDG_CTDepartureKey, 0) OR
			ISNULL(@ODG_Payed, 0) != ISNULL(@NDG_Payed, 0)
		)
	  BEGIN
	  	------------Запись в историю--------------------------------------------------------------------
		EXEC dbo.InsMasterEvent 4, @DG_Key

		if (@sMod = 'INS')
			SET @sHI_Text = ISNULL(@NDG_Code, '')
		else if (@sMod = 'DEL')
			SET @sHI_Text = ISNULL(@ODG_Code, '')
		else if (@sMod = 'UPD')
			SET @sHI_Text = ISNULL(@NDG_Code, '')

		EXEC @nHIID = dbo.InsHistory @sHI_Text, @DG_Key, 1, @DG_Key, @sMod, @sHI_Text, '', 0, ''
		--SELECT @nHIID = IDENT_CURRENT('History')
		IF(@sMod = 'INS')
		BEGIN
			DECLARE @PrivatePerson int;
			EXEC @PrivatePerson = [dbo].[CheckPrivatePerson] @NDG_code;
			IF(@PrivatePerson = 0)
				IF(ISNULL(@NDG_DUPUSERKEY,-1) >= 0)
					EXEC [dbo].[UpdateReservationMainManByPartnerUser] @NDG_code;
		END
		--------Детализация--------------------------------------------------
		if (ISNULL(@ODG_Code, '') != ISNULL(@NDG_Code, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1001, @ODG_Code, @NDG_Code, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_Rate, '') != ISNULL(@NDG_Rate, ''))
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1002, @ODG_Rate, @NDG_Rate, null, null, null, null, 0, @bNeedCommunicationUpdate output
				IF @bCurrencyChangedPrevFixDate > 0 OR @bCurrencyChangedDate > 0
					SET @bUpdateNationalCurrencyPrice = 1
				IF @bCurrencyChangedPrevFixDate > 0
					select @changedDate = MAX(HI_DATE) from history where HI_OAID = 20 and hi_dgcod = @ODG_CODE
			END
		if (ISNULL(@ODG_MainMen, '') != ISNULL(@NDG_MainMen, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1003, @ODG_MainMen, @NDG_MainMen, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_MainMenEMail, '') != ISNULL(@NDG_MainMenEMail, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1004, @ODG_MainMenEMail, @NDG_MainMenEMail, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_MAINMENPHONE, '') != ISNULL(@NDG_MAINMENPHONE, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1005, @ODG_MAINMENPHONE, @NDG_MAINMENPHONE, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_Price, 0) != ISNULL(@NDG_Price, 0))
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1006, @ODG_Price, @NDG_Price, null, null, null, null, 0, @bNeedCommunicationUpdate output
				IF @bPriceChanged > 0
					SET @bUpdateNationalCurrencyPrice = 1
			END
		if (ISNULL(@ODG_DiscountSum, 0) != ISNULL(@NDG_DiscountSum, 0))
		BEGIN
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1007, @ODG_DiscountSum, @NDG_DiscountSum, null, null, null, null, 0, @bNeedCommunicationUpdate output
			IF @bFeeChanged > 0 
				SET @bUpdateNationalCurrencyPrice = 1
		END
		if (ISNULL(@ODG_PartnerKey, 0) != ISNULL(@NDG_PartnerKey, 0))
			BEGIN
				Select @sText_Old = PR_Name from Partners where PR_Key = @ODG_PartnerKey
				Select @sText_New = PR_Name from Partners where PR_Key = @NDG_PartnerKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1008, @sText_Old, @sText_New, @ODG_PartnerKey, @NDG_PartnerKey, null, null, 0, @bNeedCommunicationUpdate output
				UPDATE DogovorList 
				   SET DL_AGENT = @NDG_PartnerKey
				 WHERE DL_DGKEY = @DG_Key;
			END
		if (ISNULL(@ODG_TRKey, 0) != ISNULL(@NDG_TRKey, 0))
			BEGIN
				Select @sText_Old = TL_Name from Turlist where TL_Key = @ODG_TRKey
				Select @sText_New = TL_Name from Turlist where TL_Key = @NDG_TRKey
				If @NDG_TRKey is not null
					Update DogovorList set DL_TRKey=@NDG_TRKey where DL_DGKey=@DG_Key
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1009, @sText_Old, @sText_New, @ODG_TRKey, @NDG_TRKey, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_TurDate, '') != ISNULL(@NDG_TurDate, ''))
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1010, @ODG_TurDate, @NDG_TurDate, null, null, null, null, 0, @bNeedCommunicationUpdate output

				Update DogovorList set DL_TURDATE = CONVERT(datetime, @NDG_TurDate, 104) where DL_DGKey = @DG_Key
				Update tbl_Turist set TU_TURDATE = CONVERT(datetime, @NDG_TurDate, 104) where TU_DGKey = @DG_Key

				--Путевка разаннулируется
				IF (ISNULL(@ODG_SOR_Code, 0) = 2)
				BEGIN
					DECLARE @nDGSorCode_New int, @sDisableDogovorStatusChange int

					SELECT @sDisableDogovorStatusChange = SS_ParmValue FROM SystemSettings WHERE SS_ParmName like 'SYSDisDogovorStatusChange'
					IF (@sDisableDogovorStatusChange is null or @sDisableDogovorStatusChange = '0')
					BEGIN
						exec dbo.SetReservationStatus @DG_Key
					END
				END
			END
		if (ISNULL(@ODG_CTKEY, 0) != ISNULL(@NDG_CTKEY, 0))
			BEGIN
				Select @sText_Old = CT_Name from CityDictionary  where CT_Key = @ODG_CTKEY
				Select @sText_New = CT_Name from CityDictionary  where CT_Key = @NDG_CTKEY
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1011, @sText_Old, @sText_New, @ODG_CTKEY, @NDG_CTKEY, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_NMEN, 0) != ISNULL(@NDG_NMEN, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1012, @ODG_NMEN, @NDG_NMEN, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_NDAY, 0) != ISNULL(@NDG_NDAY, 0))
		begin
			-- если изменилась продолжительность путевки, то нужно пересадить все услуги которые сидят на квотах 
			-- на продолжительность и сами не имеют продолжительности
			declare @DLKey int, @DLDateBeg datetime, @DLDateEnd datetime
			
			declare curSetQuoted CURSOR FORWARD_ONLY for
						select DL_KEY, DL_DATEBEG, DL_DATEEND
						from Dogovorlist join [Service] on SV_KEY = DL_SVKEY
						where DL_DGKEY = @DG_Key
						and isnull(SV_IsDuration, 0) = 0
			OPEN curSetQuoted
			FETCH NEXT FROM curSetQuoted INTO @DLKey, @DLDateBeg, @DLDateEnd

			WHILE @@FETCH_STATUS = 0
			BEGIN
				-- услуга сидит на квоте на продолжительность
				if (exists(select 1 from QuotaParts with(nolock) where LEN(ISNULL(QP_Durations, '')) > 0 and QP_ID in (select SD_QPID from ServiceByDate with(nolock) where SD_DLKey = @DLKey)))
					EXEC DogListToQuotas @DLKey, null, null, null, null, @DLDateBeg, @DLDateEnd, null, null
			
				FETCH NEXT FROM curSetQuoted INTO @DLKey, @DLDateBeg, @DLDateEnd
			end
			CLOSE curSetQuoted
			DEALLOCATE curSetQuoted
			
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1013, @ODG_NDAY, @NDG_NDAY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		end
		if (ISNULL(@ODG_PPaymentDate, 0) != ISNULL(@NDG_PPaymentDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1014, @ODG_PPaymentDate, @NDG_PPaymentDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_PaymentDate, 0) != ISNULL(@NDG_PaymentDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1015, @ODG_PaymentDate, @NDG_PaymentDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_RazmerP, 0) != ISNULL(@NDG_RazmerP, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1016, @ODG_RazmerP, @NDG_RazmerP, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_Procent, 0) != ISNULL(@NDG_Procent, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1017, @ODG_Procent, @NDG_Procent, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_Locked, 0) != ISNULL(@NDG_Locked, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1018, @ODG_Locked, @NDG_Locked, null, null, null, null, 0, @bNeedCommunicationUpdate output
		
		--MEG00040358 вынесла запись истории из условия if (ISNULL(@ODG_SOR_Code, 0) != ISNULL(@NDG_SOR_Code, 0)),
		-- так как условие на вставку в этом блоке никогда не срабатывало, потому что в новой путевке @NDG_SOR_Code всегда нул , а @ODG_SOR_Code всегда ноль
		------путевка была создана--------------
		if (ISNULL(@ODG_SOR_Code, 0) = 0 and @sMod = 'INS')
			EXECUTE dbo.InsertHistoryDetail @nHIID, 1122, null, null, null, null, null, null, 1, @bNeedCommunicationUpdate output

		
		if (ISNULL(@ODG_SOR_Code, 0) != ISNULL(@NDG_SOR_Code, 0))
			BEGIN
				Select @sText_Old = OS_Name_Rus, @nValue_Old = OS_Global from Order_Status Where OS_Code = @ODG_SOR_Code
				Select @sText_New = OS_Name_Rus, @nValue_New = OS_Global from Order_Status Where OS_Code = @NDG_SOR_Code
				If @nValue_New = 7 and @nValue_Old != 7
					UPDATE [dbo].[tbl_Dogovor] SET DG_ConfirmedDate = GetDate() WHERE DG_Key = @DG_Key
				If @nValue_New != 7 and @nValue_Old = 7
					UPDATE [dbo].[tbl_Dogovor] SET DG_ConfirmedDate = NULL WHERE DG_Key = @DG_Key
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1019, @sText_Old, @sText_New, @ODG_SOR_Code, @NDG_SOR_Code, null, null, 0, @bNeedCommunicationUpdate output
				
				------путевка была аннулирована--------------
				if (@NDG_SOR_Code = 2 and @sMod = 'UPD')
					EXECUTE dbo.InsertHistoryDetail @nHIID, 1123, null, null, null, null, null, null, 1, @bNeedCommunicationUpdate output
				
				if @bStatusChanged > 0 and exists(select NC_Id from NationalCurrencyReservationStatuses with(nolock) where NC_OrderStatus = ISNULL(@NDG_SOR_Code, 0))
				begin
					if (@bCurrencyChangedPrevFixDate > 0)
						set @changedDate = ISNULL(dbo.GetFirstDogovorStatusDate (@DG_Key, @NDG_SOR_Code), GetDate())
					
					SET @bUpdateNationalCurrencyPrice = 1
				end
			END
		if (ISNULL(@ODG_IsOutDoc, 0) != ISNULL(@NDG_IsOutDoc, 0))
			BEGIN
				Select @sText_Old = DS_Name from DocumentStatus Where DS_Key = @ODG_IsOutDoc
				Select @sText_New = DS_Name from DocumentStatus Where DS_Key = @NDG_IsOutDoc
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1020, @sText_Old, @sText_New, @ODG_IsOutDoc, @NDG_IsOutDoc, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_VisaDate, 0) != ISNULL(@NDG_VisaDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1021, @ODG_VisaDate, @NDG_VisaDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@ODG_CauseDisc, 0) != ISNULL(@NDG_CauseDisc, 0))
			BEGIN
				Select @sText_Old = CD_Name from CauseDiscounts Where CD_Key = @ODG_CauseDisc
				Select @sText_New = CD_Name from CauseDiscounts Where CD_Key = @NDG_CauseDisc
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1022, @sText_Old, @sText_New, @ODG_CauseDisc, @NDG_CauseDisc, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_OWNER, 0) != ISNULL(@NDG_OWNER, 0))
			BEGIN
				Select @sText_Old = US_FullName from UserList Where US_Key = @ODG_Owner
				Select @sText_New = US_FullName from UserList Where US_Key = @NDG_Owner
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1023, @sText_Old, @sText_New, @ODG_Owner, @NDG_Owner, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_Creator, 0) != ISNULL(@NDG_Creator, 0))
			BEGIN
				Select @sText_Old = US_FullName from UserList Where US_Key = @ODG_Creator
				Select @sText_New = US_FullName from UserList Where US_Key = @NDG_Creator
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1117, @sText_Old, @sText_New, @ODG_Creator, @NDG_Creator, null, null, 0, @bNeedCommunicationUpdate output
				Select @nValue_Old = US_DepartmentKey from UserList Where US_Key = @ODG_Creator
				Select @nValue_New = US_DepartmentKey from UserList Where US_Key = @NDG_Creator
				if (@nValue_Old is not null OR @nValue_New is not null)
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1134, @nValue_Old, @nValue_New, null, null, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_LEADDEPARTMENT, 0) != ISNULL(@NDG_LeadDepartment, 0))
			BEGIN
				Select @sText_Old = PDP_Name from PrtDeps where PDP_Key = @ODG_LeadDepartment
				Select @sText_New = PDP_Name from PrtDeps where PDP_Key = @NDG_LeadDepartment
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1024, @sText_Old, @sText_New, @ODG_LeadDepartment, @NDG_LeadDepartment, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_DupUserKey, 0) != ISNULL(@NDG_DupUserKey, 0))
			BEGIN
				Select @sText_Old = US_FullName FROM Dup_User WHERE US_Key = @ODG_DupUserKey
				Select @sText_New = US_FullName FROM Dup_User WHERE US_Key = @NDG_DupUserKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1025, @sText_Old, @sText_New, @ODG_DupUserKey, @NDG_DupUserKey, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_CTDepartureKey, 0) != ISNULL(@NDG_CTDepartureKey, 0))
			BEGIN
				Select @sText_Old = CT_Name FROM CityDictionary WHERE CT_Key = @ODG_CTDepartureKey
				Select @sText_New = CT_Name FROM CityDictionary WHERE CT_Key = @NDG_CTDepartureKey
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1121, @sText_Old, @sText_New, @ODG_CTDepartureKey, @NDG_CTDepartureKey, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@ODG_CodePartner, '') != ISNULL(@NDG_CodePartner, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1026, @ODG_CodePartner, @NDG_CodePartner, null, null, null, null, 0, @bNeedCommunicationUpdate output

		if (ISNULL(@ODG_Payed, 0) != ISNULL(@NDG_Payed, 0))
		begin
			declare @varcharODGPayed varchar(255), @varcharNDGPayed varchar(255)
			set @varcharODGPayed = cast(@ODG_Payed as varchar(255))
			set @varcharNDGPayed = cast(@NDG_Payed as varchar(255))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 5, @varcharODGPayed, @varcharNDGPayed, null, null, null, null, 0, @bNeedCommunicationUpdate output
		end

		If @bNeedCommunicationUpdate=1
			If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@DG_Key)
				UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@DG_Key

		
		-- $$$ PRICE RECALCULATION $$$ --
		IF (@bUpdateNationalCurrencyPrice = 1 AND @sMod = 'UPD') OR (@sMod = 'INS' AND @bReservationCreated > 0)
		BEGIN
			EXEC dbo.NationalCurrencyPrice2 @NDG_Rate, @ODG_Rate, @ODG_Code, @NDG_Price, @ODG_Price, @NDG_DiscountSum, @changedDate, @NDG_SOR_Code
		END
	  END

		-- recalculate if exchange rate changes (another table) & saving from frmDogovor (tour.apl)
		-- + force-drop #RecalculateAction table in case hasn't been
		/*IF OBJECT_ID('tempdb..#RecalculateAction') IS NOT NULL
		BEGIN
            DECLARE @AlwaysRecalcPrice int 
            SELECT  @AlwaysRecalcPrice = isnull(SS_ParmValue,0) FROM dbo.systemsettings  
            WHERE SS_ParmName = 'SYSAlwaysRecalcNational' 

			SELECT @DGCODE  = [DGCODE] FROM #RecalculateAction
			if @DGCODE = @NDG_Code
			begin
				SELECT @sAction = [Action] FROM #RecalculateAction
				DROP TABLE #RecalculateAction
				if @AlwaysRecalcPrice > 0
					EXEC dbo.NationalCurrencyPrice @ODG_Rate, @NDG_Rate, @ODG_Code, @NDG_Price, @ODG_Price, @NDG_DiscountSum, @sAction, @NDG_SOR_Code
		    end
		END*/
		-- $$$ ------------------- $$$ --

    	  FETCH NEXT FROM cur_Dogovor INTO @DG_Key,
		@ODG_Code, @ODG_Price, @ODG_Rate, @ODG_DiscountSum, @ODG_PartnerKey, @ODG_TRKey, @ODG_TurDate, @ODG_CTKEY, @ODG_NMEN, @ODG_NDAY, 
		@ODG_PPaymentDate, @ODG_PaymentDate, @ODG_RazmerP, @ODG_Procent, @ODG_Locked, @ODG_SOR_Code, @ODG_IsOutDoc, @ODG_VisaDate, @ODG_CauseDisc, @ODG_OWNER, 
		@ODG_LEADDEPARTMENT, @ODG_DupUserKey, @ODG_MainMen, @ODG_MainMenEMail, @ODG_MAINMENPHONE, @ODG_CodePartner, @ODG_Creator, @ODG_CTDepartureKey, @ODG_Payed,
		@NDG_Code, @NDG_Price, @NDG_Rate, @NDG_DiscountSum, @NDG_PartnerKey, @NDG_TRKey, @NDG_TurDate, @NDG_CTKEY, @NDG_NMEN, @NDG_NDAY, 
		@NDG_PPaymentDate, @NDG_PaymentDate, @NDG_RazmerP, @NDG_Procent, @NDG_Locked, @NDG_SOR_Code, @NDG_IsOutDoc, @NDG_VisaDate, @NDG_CauseDisc, @NDG_OWNER, 
		@NDG_LEADDEPARTMENT, @NDG_DupUserKey, @NDG_MainMen, @NDG_MainMenEMail, @NDG_MAINMENPHONE, @NDG_CodePartner, @NDG_Creator, @NDG_CTDepartureKey, @NDG_Payed
    END
  CLOSE cur_Dogovor
  DEALLOCATE cur_Dogovor
END
GO
/*********************************************************************/
/* end T_DogovorUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_mwInsertTour.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[mwInsertTour]'))
DROP TRIGGER [dbo].[mwInsertTour]
GO
create trigger [dbo].[mwInsertTour] on [dbo].[mwReplTours] for insert
as
begin
	--<VERSION>ALL</VERSION>
--<DATE>2012-02-09</DATE>
	if dbo.mwReplIsSubscriber() > 0
	begin
		declare @mwTourOwners varchar(8000), @curTourOwner varchar(50)
		-- Берём из настройки MWTourOwners ключи ведущих менеджеров по турам, которые можно выставлять на этой базе
		-- Если настройка пуста или отсутствует - выставлять можно любые туры
		select @mwTourOwners = rtrim(ltrim(ss_parmvalue)) from systemsettings where ss_parmname = 'MWTourOwners'

		select rt_tokey as trkey, RT_CalcKey as calcKey, rt_trkey as tlkey into #tmpKeys from inserted

		declare replcur cursor fast_forward read_only for
		select trkey, calcKey, tlkey from #tmpKeys

		declare @trkey int, @calcKey int, @tlkey int

		open replcur

		fetch next from replcur into @trkey, @calcKey, @tlkey
		while(@@fetch_status = 0)
		begin
			-- проверка: можно ли выставлять на этот тур на этой базе
			-- MEG00040028. 09.02.2012. Golubinsky
			-- вынес проверку в функцию 
			if dbo.mwIsTourAllowedForPublish(@tlkey) = 1
			begin
				if (@calcKey = 0 or @calcKey is null)
				begin
					insert into [mwReplQueue]([rq_mode], [rq_tokey]) values(1, @trkey)
				end
				else
				begin
					insert into [mwReplQueue]([rq_mode], [rq_tokey]) values(2, @trkey)
				end
			end
			fetch next from replcur into @trkey, @calcKey, @tlkey
		end
		
		close replcur
		deallocate replcur	
	end
end

GO



/*********************************************************************/
/* end T_mwInsertTour.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaDetailsChange.sql */
/*********************************************************************/
if not exists (select 1 from ObjectAliases where OA_Id = 34)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34, 'QuotaDetails', 'Квоты', 0)	
if not exists (select 1 from ObjectAliases where OA_Id = 34001)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34001, 'QD_Type', 'Тип квоты', 0)
if not exists (select 1 from ObjectAliases where OA_Id = 34002)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34002, 'QD_Date', 'Дата квоты', 0)
if not exists (select 1 from ObjectAliases where OA_Id = 34003)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34003, 'QD_Places', 'Места в квоте', 0)
if not exists (select 1 from ObjectAliases where OA_Id = 34004)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34004, 'QD_Busy', 'Занятые места в квоте', 0)
if not exists (select 1 from ObjectAliases where OA_Id = 34005)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34005, 'QD_Release', 'Релиз период в квоте', 0)
if not exists (select 1 from ObjectAliases where OA_Id = 34006)
	insert into ObjectAliases(OA_Id, OA_Alias, OA_Name, OA_TABLEID)
	values (34006, 'QD_IsDeleted', 'Удаление квоты', 0)


IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_QuotaDetailsChange]'))
DROP TRIGGER [dbo].[T_QuotaDetailsChange]
GO

CREATE TRIGGER [dbo].[T_QuotaDetailsChange]
ON [dbo].[QuotaDetails]
FOR UPDATE, INSERT, DELETE
AS
--<VERSION>2008.1.01.05</VERSION>
--<DATE>2012-07-04</DATE>
IF @@ROWCOUNT > 0
BEGIN
	DECLARE @QO_SVKey int, @QO_Code int, @QT_Id int, @QT_ByRoom bit, @QT_PRKey int, @QT_PrtDogsKey int, @QD_ID int,
			@OQD_Type smallint, @OQD_Date smalldatetime, @OQD_Places smallint, @OQD_Busy smallint, @OQD_Release smallint, @OQD_IsDeleted smallint,
			@NQD_Type smallint, @NQD_Date smalldatetime, @NQD_Places smallint, @NQD_Busy smallint, @NQD_Release smallint, @NQD_IsDeleted smallint
    DECLARE @sText_Old varchar(255), @sText_New varchar(255), @sHI_Text varchar(255)
    DECLARE @sMod varchar(3), @nDelCount int, @nInsCount int, @nHIID int

	SELECT @nDelCount = COUNT(*) FROM DELETED
	SELECT @nInsCount = COUNT(*) FROM INSERTED
	IF (@nDelCount = 0)
	BEGIN
		SET @sMod = 'INS'
		DECLARE cur_QuotaDetails CURSOR LOCAL FOR 
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, N.QD_ID,
					null, null, null, null, null, null,
					N.QD_Type, N.QD_Date, N.QD_Places, N.QD_Busy, N.QD_Release, N.QD_IsDeleted
			FROM	INSERTED N join dbo.Quotas on N.QD_QTID = QT_ID
	END
	ELSE IF (@nInsCount = 0)
	BEGIN
		SET @sMod = 'DEL'
		DECLARE cur_QuotaDetails CURSOR LOCAL FOR
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, O.QD_ID,
					O.QD_Type, O.QD_Date, O.QD_Places, O.QD_Busy, O.QD_Release, O.QD_IsDeleted,
					null, null, null, null, null, null
			FROM	DELETED O join dbo.Quotas on O.QD_QTID = QT_ID
	END
	ELSE 
	BEGIN
		SET @sMod = 'UPD'
		DECLARE cur_QuotaDetails CURSOR LOCAL FOR
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, N.QD_ID,
					O.QD_Type, O.QD_Date, O.QD_Places, O.QD_Busy, O.QD_Release, O.QD_IsDeleted,
					N.QD_Type, N.QD_Date, N.QD_Places, N.QD_Busy, N.QD_Release, N.QD_IsDeleted
			FROM	DELETED O join dbo.Quotas on O.QD_QTID = QT_ID
					join INSERTED N on N.QD_QTID = QT_ID
	END

	OPEN cur_QuotaDetails
	FETCH NEXT FROM cur_QuotaDetails INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, @QD_ID,
					@OQD_Type, @OQD_Date, @OQD_Places, @OQD_Busy, @OQD_Release, @OQD_IsDeleted,
					@NQD_Type, @NQD_Date, @NQD_Places, @NQD_Busy, @NQD_Release, @NQD_IsDeleted
	WHILE @@FETCH_STATUS = 0
	BEGIN 
		------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQD_Type, 0) !=			ISNULL(@NQD_Type, 0) OR
			ISNULL(@OQD_Date, 0) !=			ISNULL(@NQD_Date, 0) OR
			ISNULL(@OQD_Places, 0) !=		ISNULL(@NQD_Places, 0) OR
			ISNULL(@OQD_Busy, 0) !=			ISNULL(@NQD_Busy, 0) OR
			ISNULL(@OQD_Release, 0) !=		ISNULL(@NQD_Release, 0) OR
			ISNULL(@OQD_IsDeleted, 0) !=	ISNULL(@NQD_IsDeleted, 0)
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			If @QT_PRKey = 0
				Set @sHI_Text = 'All partners'
			Else
				Select @sHI_Text = PR_Name from Partners where PR_Key = @QT_PRKey
			SET @sText_New=@sHI_Text
			Set @sHI_Text = null
			If isnull(@QT_PrtDogsKey,0) >0
				Select @sHI_Text = PD_DogNumber from PrtDogs where PD_Key=@QT_PrtDogsKey
			If @sHI_Text is not null
				SET @sText_New=@sText_New + '(' + @sHI_Text + ')'
			
			Select TOP 1 @QO_SVKey=QO_SVKey, @QO_Code=QO_Code FROM QuotaObjects WHERE QO_QTID=@QT_Id
			If @QO_SVKey=3
			BEGIN
				If @QT_ByRoom=0
					SET @sText_New=@sText_New + '(BY PERSON)'
				Else
					SET @sText_New=@sText_New + '(BY ROOM)'
			END

			EXEC @nHIID = dbo.InsHistory 
							@sDGCod = '',
							@nDGKey = null,
							@nOAId = 34,
							@nTypeCode = @QD_ID,
							@sMod = @sMod,
							@sText = @sText_New,
							@sRemark = @sHI_Text,
							@nInvisible = 0,
							@sDocumentNumber  = '',
							@bMessEnabled = 0,
							@nSVKey = @QO_SVKey,
							@nCode = @QO_Code
			SET @sText_Old = ''
			SET @sText_New = ''
			
			-- 04-07-2012 karimbaeva если изменился тип квоты, то меняем статус квоты и в путевках, которые сидят в этой квоте
			if ISNULL(@OQD_Type, 0) != ISNULL(@NQD_Type, 0) and @sMod = 'UPD'
			begin	
				update ServiceByDate
								set SD_State = QD_Type
								from QuotaDetails with(nolock) join QuotaParts with(nolock) on QD_ID=QP_QDID 
								where SD_QPID=QP_ID and SD_State <> QD_Type and QD_ID = @QD_ID
			end
			
			--------Детализация--------------------------------------------------
			if ISNULL(@OQD_Type, 0) != ISNULL(@NQD_Type, 0)
			begin				
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34001, @OQD_Type, @NQD_Type, @OQD_Type, @NQD_Type, null, null, 0
			end
			if ISNULL(@OQD_Date, 0) != ISNULL(@NQD_Date, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34002, @OQD_Date, @NQD_Date, null, null, null, null, 0
			END
			if ISNULL(@OQD_Places, 0) != ISNULL(@NQD_Places, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34003, @OQD_Places, @NQD_Places, @OQD_Places, @NQD_Places, null, null, 0
			END
			if ISNULL(@OQD_Busy, 0) != ISNULL(@NQD_Busy, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34004, @OQD_Busy, @NQD_Busy, @OQD_Busy, @NQD_Busy, null, null, 0
			END
			if ISNULL(@OQD_Release, 0) != ISNULL(@NQD_Release, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34005, @OQD_Release, @NQD_Release, @OQD_Release, @NQD_Release, null, null, 0
			END
			if ISNULL(@OQD_IsDeleted, 0) != ISNULL(@NQD_IsDeleted, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34006, @OQD_IsDeleted, @NQD_IsDeleted, @OQD_IsDeleted, @NQD_IsDeleted, null, null, 0
			END
		END
		
		FETCH NEXT FROM cur_QuotaDetails INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, @QD_ID,
					@OQD_Type, @OQD_Date, @OQD_Places, @OQD_Busy, @OQD_Release, @OQD_IsDeleted,
					@NQD_Type, @NQD_Date, @NQD_Places, @NQD_Busy, @NQD_Release, @NQD_IsDeleted
    END
	CLOSE cur_QuotaDetails
	DEALLOCATE cur_QuotaDetails
END
GO



/*********************************************************************/
/* end T_QuotaDetailsChange.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaDetails_QuotaPartsDate_Delete.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_QuotaDetails_QuotaPartsDate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop trigger [dbo].[T_QuotaDetails_QuotaPartsDate]
GO
/*********************************************************************/
/* end T_QuotaDetails_QuotaPartsDate_Delete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaPartsChange.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_QuotaPartsChange]'))
DROP TRIGGER [dbo].[T_QuotaPartsChange]
GO
CREATE TRIGGER [dbo].[T_QuotaPartsChange]
ON [dbo].[QuotaParts] 
FOR UPDATE, INSERT, DELETE
AS
--<VERSION>2008.1.01.04</VERSION>
--<DATE>2012-05-23</DATE>
IF @@ROWCOUNT > 0
BEGIN
	DECLARE @QO_SVKey int, @QO_Code int, @QT_Id int, @QT_ByRoom bit, @QT_PRKey int, @QT_PrtDogsKey int, @QP_ID int,
			@QD_Type smallint, @QD_Date smalldatetime, @QD_Release smallint,
			@OQP_Places smallint, @OQP_IsDeleted smallint, @OQP_AgentKey int, @OQP_Durations varchar(20), @OQP_IsNotCheckIn bit,
			@NQP_Places smallint, @NQP_IsDeleted smallint, @NQP_AgentKey int, @NQP_Durations varchar(20), @NQP_IsNotCheckIn bit
    DECLARE @sText_Old varchar(255), @sText_New varchar(255), @sHI_Text varchar(255)
    DECLARE @sMod varchar(3), @nDelCount int, @nInsCount int, @nHIID int

	SELECT @nDelCount = COUNT(*) FROM DELETED
	SELECT @nInsCount = COUNT(*) FROM INSERTED
	IF (@nDelCount = 0)
	BEGIN
		SET @sMod = 'INS'
		DECLARE cur_QuotaParts CURSOR LOCAL FOR 
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, 
					QD_Type, QD_Date, QD_Release, N.QP_ID,
					null, null, null, null, null,
					N.QP_Places, N.QP_IsDeleted, N.QP_AgentKey, N.QP_Durations, N.QP_IsNotCheckIn
			FROM	INSERTED N, dbo.Quotas, dbo.QuotaDetails
			WHERE	N.QP_QDID=QD_ID and QD_QTID=QT_ID
		
		update QuotaParts
					set QP_Date = QD_Date
					from QuotaParts as QP join QuotaDetails as QD on QD_ID = QP_QDID
					where exists (select 1 from Inserted as Ins where Ins.QP_ID = QP.QP_ID)
	END
	ELSE IF (@nInsCount = 0)
	BEGIN
		SET @sMod = 'DEL'
		DECLARE cur_QuotaParts CURSOR LOCAL FOR 
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, 
					QD_Type, QD_Date, QD_Release, O.QP_ID,
					O.QP_Places, O.QP_IsDeleted, O.QP_AgentKey, O.QP_Durations, O.QP_IsNotCheckIn,
					null, null, null, null, null
			FROM	DELETED O, dbo.Quotas, dbo.QuotaDetails
			WHERE	O.QP_QDID=QD_ID and QD_QTID=QT_ID
	END
	ELSE 
	BEGIN
		SET @sMod = 'UPD'
		DECLARE cur_QuotaParts CURSOR LOCAL FOR
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, 
					QD_Type, QD_Date, QD_Release, N.QP_ID,
					O.QP_Places, O.QP_IsDeleted, O.QP_AgentKey, O.QP_Durations, O.QP_IsNotCheckIn,
					N.QP_Places, N.QP_IsDeleted, N.QP_AgentKey, N.QP_Durations, N.QP_IsNotCheckIn
			FROM	DELETED O, INSERTED N, dbo.Quotas, dbo.QuotaDetails
			WHERE	N.QP_QDID=QD_ID and QT_ID=QD_QTID and O.QP_Id=N.QP_Id
	END

	OPEN cur_QuotaParts
	FETCH NEXT FROM cur_QuotaParts INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, 
					@QD_Type, @QD_Date, @QD_Release, @QP_ID,
					@OQP_Places, @OQP_IsDeleted, @OQP_AgentKey, @OQP_Durations, @OQP_IsNotCheckIn,
					@NQP_Places, @NQP_IsDeleted, @NQP_AgentKey, @NQP_Durations, @NQP_IsNotCheckIn
	WHILE @@FETCH_STATUS = 0
	BEGIN 
		------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQP_Places, 0) != ISNULL(@NQP_Places, 0) OR
			ISNULL(@OQP_AgentKey, 0) != ISNULL(@NQP_AgentKey, 0) OR
			ISNULL(@OQP_Durations, 0) != ISNULL(@NQP_Durations, 0) OR
			ISNULL(@OQP_IsNotCheckIn, 0) != ISNULL(@NQP_IsNotCheckIn, 0) OR
			ISNULL(@OQP_IsDeleted, 0) != ISNULL(@NQP_IsDeleted, 0)
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			If @QT_PRKey=0
				Set @sHI_Text='All partners'
			Else
				Select @sHI_Text = PR_Name from Partners where PR_Key=@QT_PRKey
			SET @sText_New=@sHI_Text
			Set @sHI_Text = null
			If isnull(@QT_PrtDogsKey,0) >0
				Select @sHI_Text = PD_DogNumber from PrtDogs where PD_Key=@QT_PrtDogsKey
			If @sHI_Text is not null
				SET @sText_New=@sText_New + '(' + @sHI_Text + ')'
			
			Select TOP 1 @QO_SVKey=QO_SVKey, @QO_Code=QO_Code FROM QuotaObjects WHERE QO_QTID=@QT_Id
			If @QO_SVKey=3
			BEGIN
				If @QT_ByRoom=0
					SET @sText_New=@sText_New + '(BY PERSON)'
				Else
					SET @sText_New=@sText_New + '(BY ROOM)'
			END
			If @QD_Type=2
				SET @sHI_Text='C'
			Else If @QD_Type=1
				SET @sHI_Text='A'
			If @QD_Release is not null
				SET @sHI_Text=@sHI_Text+'('+CAST(@QD_Release as varchar(4))+')'
			Set @sHI_Text=@sHI_Text+' (' + CONVERT(varchar(20),@QD_Date,104)+')'

			IF @NQP_IsDeleted=1 and @OQP_IsDeleted=0
				SET @sMod='DEL'
			EXEC @nHIID = dbo.InsHistory 
							@sDGCod = '',
							@nDGKey = null,
							@nOAId = 13,
							@nTypeCode = @QP_ID,
							@sMod = @sMod,
							@sText = @sText_New,
							@sRemark = @sHI_Text,
							@nInvisible = 0,
							@sDocumentNumber  = '',
							@bMessEnabled = 0,
							@nSVKey = @QO_SVKey,
							@nCode = @QO_Code
--'', null, 13, @QP_ID, @sMod, @sText_New, '', 0, @sHI_Text, 0, @QO_SVKey, @QO_Code
			SET @sText_Old=''
			SET @sText_New=''

			--------Детализация--------------------------------------------------
			if ISNULL(@OQP_Places, 0) != ISNULL(@NQP_Places, 0)
			begin
				if exists (select 1 from [Service] where SV_Key = @QO_SVKey and isnull(SV_IsDuration, 0) = 0)
				begin
					update QuotaParts
					set QP_CheckInPlaces = @NQP_Places
					where QP_ID = @QP_ID
				end
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13001, @OQP_Places, @NQP_Places, @OQP_Places, @NQP_Places, null, null, 0
			end
			if ISNULL(@OQP_AgentKey, 0) != ISNULL(@NQP_AgentKey, 0)
			BEGIN
				If @OQP_AgentKey is not null
					Select @sText_Old = PR_Name from Partners where PR_Key=@OQP_AgentKey
				If @NQP_AgentKey is not null
					Select @sText_Old = PR_Name from Partners where PR_Key=@NQP_AgentKey
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13002, @sText_Old, @sText_New, @OQP_AgentKey, @NQP_AgentKey, null, null, 0
				SET @sText_Old=''
				SET @sText_New=''
			END
			if ISNULL(@OQP_Durations, 0) != ISNULL(@NQP_Durations, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13003, @OQP_Durations, @NQP_Durations, null, null, null, null, 0
				SET @sText_Old=''
				SET @sText_New=''
			END
			if ISNULL(@OQP_IsNotCheckIn, 0) != ISNULL(@NQP_IsNotCheckIn, 0)
			BEGIN
				Set @sText_Old=CAST(@OQP_IsNotCheckIn as varchar(1))
				Set @sText_New=CAST(@NQP_IsNotCheckIn as varchar(1))
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13004, @sText_Old, @sText_New, @OQP_IsNotCheckIn, @NQP_IsNotCheckIn, null, null, 0
				SET @sText_Old=''
				SET @sText_New=''
			END
		END
		FETCH NEXT FROM cur_QuotaParts INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, 
					@QD_Type, @QD_Date, @QD_Release, @QP_ID,
					@OQP_Places, @OQP_IsDeleted, @OQP_AgentKey, @OQP_Durations, @OQP_IsNotCheckIn,
					@NQP_Places, @NQP_IsDeleted, @NQP_AgentKey, @NQP_Durations, @NQP_IsNotCheckIn
    END
	CLOSE cur_QuotaParts
	DEALLOCATE cur_QuotaParts
END


GO



/*********************************************************************/
/* end T_QuotaPartsChange.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaPartsDate_Delete.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_QuotaPartsDate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop trigger [dbo].[T_QuotaPartsDate]
GO
/*********************************************************************/
/* end T_QuotaPartsDate_Delete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TSToServiceByDate.sql */
/*********************************************************************/
ALTER TRIGGER [T_TSToServiceByDate]
   ON  [dbo].[TuristService]
   AFTER  INSERT,DELETE 
AS 
--<VERSION>2008.1.01.02a</VERSION>
DECLARE @TUID int,@O_DLKey int,@O_TUKey int,@N_DLKey int,@N_TUKey int,
		@BestPlace int, @BestRL int, @nDelCount smallint, @nInsCount smallint

SELECT @nDelCount = COUNT(*) FROM DELETED
SELECT @nInsCount = COUNT(*) FROM INSERTED
IF (@nInsCount = 0)
BEGIN
    DECLARE cur_T_TSToServiceByDate CURSOR FOR 
    SELECT 	O.TU_IDKey,
			O.TU_DLKey, O.TU_TUKey,
			null, null
    FROM DELETED O
END
ELSE IF (@nDelCount = 0)
BEGIN
    DECLARE cur_T_TSToServiceByDate CURSOR FOR 
    SELECT 	N.TU_IDKey,
			null, null,
			N.TU_DLKey, N.TU_TUKey
    FROM	INSERTED N 
END

OPEN cur_T_TSToServiceByDate
FETCH NEXT FROM cur_T_TSToServiceByDate 
	INTO @TUID, @O_DLKey, @O_TUKey, @N_DLKey, @N_TUKey
WHILE @@FETCH_STATUS = 0
BEGIN
	IF @N_TUKey is not null
	BEGIN
		SET @BestRL = 0
		SET @BestPlace = 0
		SELECT @BestRL=Min(SD_RLID),@BestPlace=Max(SD_RPID) FROM ServiceByDate WHERE SD_DLKey=@N_DLKey and SD_TUKey is null
		If @BestRL is null
			UPDATE ServiceByDate SET SD_TUKey=@N_TUKey WHERE SD_DLKey=@N_DLKey and SD_RPID=@BestPlace and SD_RLID is null
		Else
		BEGIN
			SELECT @BestPlace=Max(SD_RPID) FROM ServiceByDate WHERE SD_DLKey=@N_DLKey and SD_RLID=@BestRL and SD_TUKey is null
			UPDATE ServiceByDate SET SD_TUKey=@N_TUKey WHERE SD_DLKey=@N_DLKey and SD_RPID=@BestPlace and SD_RLID=@BestRL
		END
	END
	ELSE IF @O_TUKey is not null
		UPDATE ServiceByDate SET SD_TUKey=null WHERE SD_DLKey=@O_DLKey AND SD_TUKey=@O_TUKey
	FETCH NEXT FROM cur_T_TSToServiceByDate
		INTO @TUID, @O_DLKey, @O_TUKey, @N_DLKey, @N_TUKey
END
CLOSE cur_T_TSToServiceByDate
DEALLOCATE cur_T_TSToServiceByDate
GO
/*********************************************************************/
/* end T_TSToServiceByDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin Version92.sql */
/*********************************************************************/
-- для версии 2009.2
update [dbo].[setting] set st_version = '9.2.14.1', st_moduledate = convert(datetime, '2012-08-27', 120),  st_financeversion = '9.2.14.1', st_financedate = convert(datetime, '2012-08-27', 120) where st_version like '9.%'
GO
UPDATE dbo.SystemSettings SET SS_ParmValue='2012-08-27' WHERE SS_ParmName='SYSScriptDate'
GO
/*********************************************************************/
/* end Version92.sql */
/*********************************************************************/

/*********************************************************************/
/* begin x_singlePrice_mwPriceDataTable.sql */
/*********************************************************************/
declare @tableName nvarchar(100)
declare @sql nvarchar(max)

declare cur cursor fast_forward for select distinct name from sysobjects where name like 'mwPriceDataTable%'
open cur
fetch next from cur into @tableName
while(@@fetch_status = 0)
begin
	
	set @sql = @sql + 'if not exists(select id from sysindexes where id = object_id(''' + @tableName + ''') and indid > 0 and indid < 255 and name = ''x_singleprice'')'
	set @sql = @sql + 'create index x_singleprice on ' + @tableName + ' ([pt_tourdate] ASC,[pt_hdkey] ASC,[pt_rmkey] ASC,[pt_rckey] ASC,[pt_ackey] ASC,[pt_pnkey] ASC,[pt_days] ASC,[pt_nights] ASC,[pt_tourtype] ASC,[pt_ctkeyfrom] ASC,[pt_tourkey] ASC,[pt_main] ASC ) INCLUDE ( [pt_key], [pt_pricekey])'
	exec (@sql)
	
	fetch next from cur into @tableName
end

close cur
deallocate cur
GO
/*********************************************************************/
/* end x_singlePrice_mwPriceDataTable.sql */
/*********************************************************************/
