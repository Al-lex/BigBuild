/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*%%%%%%%%%%%%%%%%%%%%%%%% Дата формирования: 11.11.2013 16:36 %%%%%%%%%%%%%%%%%%%%%%%%*/
/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
SET NOEXEC OFF -- режим компиляция+выполнение скрипта
SET NOCOUNT ON
--*--создаем таблицу логов, если ее нет в БД --*--
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ScriptsSetupLogs]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[ScriptsSetupLogs](
	[RC_ID] [int] IDENTITY(1,1) NOT NULL,
	[RC_Date] [datetime] NOT NULL DEFAULT (getdate()),
	[RC_Creator] [nvarchar](25) NOT NULL,
	[RC_Text] [nvarchar](254) NOT NULL,
	[RC_Status] [nvarchar](20) NOT NULL,
	[RC_Computer] [nvarchar](50) NOT NULL,
	[RC_LOG] [ntext] NULL,
	CONSTRAINT [PK_ScriptsSetupLogs] PRIMARY KEY CLUSTERED 
(
	[RC_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GRANT SELECT, INSERT, UPDATE ON [dbo].[ScriptsSetupLogs] TO PUBLIC
END
--*--
-- =====================  скрипт для проверки совместимости БД ===================== --
BEGIN TRY
	DECLARE @Message varchar (500)
	DECLARE @CurrentVer nvarchar(128)
	DECLARE @SUSER_NAME nvarchar(128) = (SELECT SUSER_NAME())
	DECLARE @HOST_NAME nvarchar(128) = (SELECT HOST_NAME())	

	--*--непосредственно обработка и сравнение --*--
	SET @CurrentVer = (SELECT compatibility_level FROM sys.databases WHERE name = (SELECT DB_NAME()))
	IF (@CurrentVer < 100)
		BEGIN
			SET @Message = 'Режим совместимости базы данных - ' + (SELECT DB_NAME()) + ' указан (' + @CurrentVer + '), для корректного обновления и работы ПК "Мастер-Тур" нужен режим совместимости 2008 (100) и выше.'
			RAISERROR(@Message, 16, 1)
		END
END TRY
BEGIN CATCH
	INSERT INTO ScriptsSetupLogs(RC_Creator, RC_Text, RC_Status, RC_Computer, RC_LOG) VALUES(@SUSER_NAME, 'Ошибка при выполнении скрипта по БД Мастер-Тура.', 'ERR', @HOST_NAME, @Message)
	RAISERROR(@Message, 16, 1) WITH NOWAIT
	SET NOEXEC ON;
END CATCH

-- =====================  скрипт для проверки версии SQL-сервера. Маска версии: [мажорная версия](2 символа).[минорная версия](2 символа).[релизная версия](4 символа) ===================== 
BEGIN TRY
	DECLARE @CurrentSQLVersion nvarchar(128)
	DECLARE @MinimalSQLVersion nvarchar(128)
	DECLARE @curver varchar(20) = null
    DECLARE @minver varchar(20) = null
	--*--непосредственно обработка и сравнение версий SQL --*--
	SET @CurrentSQLVersion = CAST(serverproperty('ProductVersion') AS nvarchar)
	SET @MinimalSQLVersion = '10.50.1600.0'
	
	---------------------------------------
	IF(@CurrentSQLVersion != @MinimalSQLVersion)
	BEGIN
		WHILE LEN(@CurrentSQLVersion) > 0
		BEGIN               
			WHILE LEN(@MinimalSQLVersion) > 0
			BEGIN
				IF PATINDEX('%.%',@CurrentSQLVersion) > 0
				BEGIN
					SET @curver = SUBSTRING(@CurrentSQLVersion, 0, PATINDEX('%.%',@CurrentSQLVersion))
					SET @CurrentSQLVersion = SUBSTRING(@CurrentSQLVersion, LEN(@curver + '.') + 1, LEN(@CurrentSQLVersion))
					SET @minver = SUBSTRING(@MinimalSQLVersion, 0, PATINDEX('%.%',@MinimalSQLVersion))
					SET @MinimalSQLVersion = SUBSTRING(@MinimalSQLVersion, LEN(@minver + '.') + 1, LEN(@MinimalSQLVersion))
					--------в мажорных, минорных и релиз версиях смотрим любое отклонение от 0---------- 
					IF(convert(int, @curver) - convert(int, @minver)) < 0
					BEGIN
							-- обнуляем и выходим из цикла, т.к. уже ошибка
							SET @Message = 'Используемая версия MS SQL Server — ' + CAST(serverproperty('ProductVersion') AS nvarchar)
							+ ', для корректного обновления и работы ПК "Мастер-Тур" нужна версия не ниже MS SQL Server 2008 R2 (10.50.1600.0).'
							RAISERROR(@Message, 16, 1)
					END   
					ELSE IF(convert(int, @curver) - convert(int, @minver)) > 0
					BEGIN
							SET @CurrentSQLVersion = NULL
							SET @MinimalSQLVersion = NULL
					END
				END
				ELSE IF (PATINDEX('%.%',@CurrentSQLVersion) < PATINDEX('%.%',@MinimalSQLVersion))
				BEGIN
					SET @curver = @CurrentSQLVersion
					SET @minver = SUBSTRING(@MinimalSQLVersion, 0, PATINDEX('%.%',@MinimalSQLVersion))
					IF(convert(int, @curver) - convert(int, @minver)) < 0
					BEGIN
						-- обнуляем и выходим из цикла, т.к. уже ошибка
						SET @Message = 'Используемая версия MS SQL Server — ' + CAST(serverproperty('ProductVersion') AS nvarchar)
							+ ', для корректного обновления и работы ПК "Мастер-Тур" нужна версия не ниже MS SQL Server 2008 R2 (10.50.1600.0).'
						RAISERROR(@Message, 16, 1)
					END
	                                            
					-- обнуляем
					SET @CurrentSQLVersion = NULL
					SET @MinimalSQLVersion = NULL     
				END
				ELSE
				BEGIN
					-- обнуляем, т.к. на этом шаге уже идет проверка SP, а нам достаточно до релиза
					SET @CurrentSQLVersion = NULL
					SET @MinimalSQLVersion = NULL    
				END
			END
		END
    END
 ---------------------------------------------------
END TRY
BEGIN CATCH
	INSERT INTO ScriptsSetupLogs(RC_Creator, RC_Text, RC_Status, RC_Computer, RC_LOG) VALUES(@SUSER_NAME, 'Ошибка при выполнении скрипта по БД Мастер-Тура из-за некорректной версии SQL Server.', 'ERR', @HOST_NAME, @Message)
	RAISERROR(@Message, 16, 1) WITH NOWAIT
	SET NOEXEC ON;
END CATCH




/*********************************************************************/
/* begin sp_RecreateDependentObjects.sql */
/*********************************************************************/
if exists(select top 1 1 from sys.objects where name = 'RecreateDependentObjects' and type = 'P')
	drop procedure RecreateDependentObjects
go

create procedure RecreateDependentObjects
-- выполняет указанный скрипт после удаления и до создания зависимых от колонки @ColumnName объектов
-- сейчас в качестве зависимых объектов поддерживаются только некластеризованные и кластеризованные индексы
--<VERSION>9.2.20</VERSION>
--<DATE>2013-11-22</DATE>
(
	@TableName sysname,				-- имя таблицы, колонка которой удаляется
	@ColumnName sysname,			-- имя удаляемой колонки
	@CustomScript nvarchar(max),	-- скрипт, выполняемый между созданием и удалением зависимых объектов
	@recreateWithoutColumn bit = 0	-- флаг, указывающий, что в зависимые объекты надо пересоздавать без переданной колонки
)
as
begin
	declare @errorMessage nvarchar(max)

	-- check arguments
	if not exists (select top 1 1 from sys.tables where name = @TableName)
	begin
		set @errorMessage = 'Table ' + @TableName + ' was not found in database.'
		RAISERROR(@errorMessage, 16, 1)
		return
	end

	if not exists (select top 1 1 from sys.columns where name = @ColumnName)
	begin
		set @errorMessage = 'Column ' + @ColumnName + ' was not found in database.'
		RAISERROR(@errorMessage, 16, 1)
		return
	end

	if not exists (select top 1 1 from sys.columns where name = @ColumnName and object_id = object_id(@TableName))
	begin
		set @errorMessage = 'Incorrect parameters: column ' + @ColumnName + ' doesn''t belong to table ' + @TableName
		RAISERROR(@errorMessage, 16, 1)
		return
	end

	-- признак, что пересоздание ссылающихся на колонку объектов прошло успешно
	declare @updateReferencesComplete as bit
	declare @errmsg as nvarchar(max)

	-- обработка индексов
	declare @ixName sysname
	declare @ixType tinyint

	declare @totalSql as nvarchar(max)
	declare @dropIndexSql as nvarchar(max)
	declare @createIndexSql as nvarchar(max)
	set @dropIndexSql = ''
	set @createIndexSql = ''

	declare indexesCursor cursor for
	select ix.name, ix.type
	from sys.tables tab
	left join sys.indexes ix on ix.object_id = tab.object_id
	where tab.name = @TableName
		and exists (select top 1 1 
					from sys.index_columns ic
					left join sys.columns col on col.column_id = ic.column_id and col.object_id = tab.object_id
					where ic.index_id = ix.index_id 
						and ic.object_id = tab.object_id
						and col.name = @ColumnName
					)

	open indexesCursor

	begin try

	fetch next from indexesCursor into @ixName, @ixType
	while @@FETCH_STATUS = 0
	begin
		if @ixType <> 2 and @ixType <> 1
		begin
			set @errmsg = 'Not supported index type is dependent on specified column ' + @ColumnName + '
			This stored procedure supports only nonclustered and clustered indexes recreation! Not supported index name: ' 
				+ @ixName + ' on table: ' + @TableName
			RAISERROR(@errmsg, 16, 1)
		end

		declare @indexColumns nvarchar(max)
		declare @includedColumns nvarchar(max)

		set @indexColumns = ''
		set @indexColumns = stuff((select ',' + col.name + 
					case
						when ic.is_descending_key = 1 then ' desc'
						else ' asc'
					end
					from sys.tables tab
					left join sys.indexes ix on ix.object_id = tab.object_id
					left join sys.index_columns ic on ic.object_id = tab.object_id and ic.index_id = ix.index_id
					left join sys.columns col on col.column_id = ic.column_id and col.object_id = tab.object_id
					where ic.index_id = ix.index_id 
						and ic.object_id = tab.object_id
						and ic.is_included_column = 0
						and ((@recreateWithoutColumn = 1 and col.name <> @ColumnName) or @recreateWithoutColumn = 0)
						and tab.name = @TableName
						and ix.name = @ixName
					for xml path(''), type
					).value('.', 'varchar(max)'),1,1,'')

		set @includedColumns = stuff((select ',' + col.name
					from sys.tables tab
					left join sys.indexes ix on ix.object_id = tab.object_id
					left join sys.index_columns ic on ic.object_id = tab.object_id and ic.index_id = ix.index_id
					left join sys.columns col on col.column_id = ic.column_id and col.object_id = tab.object_id
					where ic.index_id = ix.index_id 
						and ic.object_id = tab.object_id
						and ic.is_included_column = 1
						and ((@recreateWithoutColumn = 1 and col.name <> @ColumnName) or @recreateWithoutColumn = 0)
						and tab.name = @TableName
						and ix.name = @ixName
					for xml path(''), type
					).value('.', 'varchar(max)'),1,1,'')

		set @dropIndexSql = @dropIndexSql + '
			drop index [@ixName] on [@TableName]'

		if @indexColumns is not null
		begin
			set @createIndexSql = @createIndexSql + 
			'
			create @indexType index [@ixName] on [@TableName]
			(
				@indexColumns
			)'

			if @includedColumns is not null
			begin
				set @createIndexSql = @createIndexSql + 
				'
				include
				(
					@includedColumns
				)
				'
				set @createIndexSql = replace(@createIndexSql, '@includedColumns', isnull(@includedColumns, ''))
			end
			set @createIndexSql = @createIndexSql + 
			'
			WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, 
				ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 70) ON [PRIMARY]
			'
			set @createIndexSql = replace(@createIndexSql, '@indexColumns', @indexColumns)
			set @createIndexSql = replace(@createIndexSql, '@indexType', case when @ixType = 2 then 'nonclustered' when @ixType = 1 then 'clustered' end)
		end

		set @createIndexSql = replace(@createIndexSql, '@ixName', @ixName)
		set @createIndexSql = replace(@createIndexSql, '@TableName', @TableName)
		set @dropIndexSql = replace(@dropIndexSql, '@ixName', @ixName)
		set @dropIndexSql = replace(@dropIndexSql, '@TableName', @TableName)

		fetch next from indexesCursor into @ixName, @ixType
	end
	end try
	begin catch 
		set @errmsg = error_message()
		set @updateReferencesComplete = 0
	end catch

	close indexesCursor
	deallocate indexesCursor

	if @updateReferencesComplete = 0
	begin
		RAISERROR(@errmsg, 16, 1)
		return
	end

	-- execute custom script between drop and recreate dependent objects
	set @totalSql = '
	begin transaction dropAndCreate
	' + @dropIndexSql + '
	' + @customScript + '
	' + @createIndexSql + '
	commit transaction dropAndCreate
	'

	exec sp_executesql @totalSql
end

GO

grant exec on RecreateDependentObjects to public

GO
/*********************************************************************/
/* end sp_RecreateDependentObjects.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwGetSubscriptions.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwGetSubscriptions]') and type in (N'P', N'PC'))
	DROP procedure [dbo].[mwGetSubscriptions]
GO

CREATE procedure [dbo].[mwGetSubscriptions]
--<VERSION>9.2.20</VERSION>
--<DATE>2013-08-19</DATE>
(
	@publicationName sysname = null
)
as
begin
	if @publicationName is null
		set @publicationName = 'MW_PUB'

	create table #tmp_publications
	(
		publisher			sysname not null,
		dbname				sysname not null,
		publication			sysname not null,
		publisher_type		sysname not null,
		publication_type	int not null,
		description			nvarchar(255) null,
		allow_queued		bit default 0 NOT NULL,
		enabled_for_p2p		bit default 0 NOT NULL,
		enabled_for_p2pconflictdetection		bit default 0 NOT NULL
	)

	declare @category int
	select @category = category from master.sys.sysdatabases where name = db_name()
	-- Does category have bits set for 1 (tran), 4 (merge) or 16 (dist db for Oracle)?
	-- If so, this db is enabled for publishing.
	if (@category & 21 <> 0)
	begin
		declare @source_database_id int
		select @source_database_id = source_database_id from master.sys.databases where name = db_name()

		-- Exclude database snapshots by checking for a NULL source_database_id.
		if (@source_database_id is null)
		begin
			exec sys.sp_MSrepl_enumpublications @reserved = 1
		end
	end

	create table #tmp_pubsubscriptions
	(
		publisher				sysname not null,
		publisher_db			sysname not null,
		publisher_type			sysname not null,
		publication             sysname not null,
		publication_type		int not null,
		subscription_name       nvarchar(258) not null,
		subscriber              sysname not null,
		subscriber_db           sysname not null,
		subscription_type       int         not null,
		priority                float(8)    not null default 0.0
	)

	declare @distpublisher sysname, @pub_name_sub sysname
            
	declare read_pub CURSOR LOCAL FAST_FORWARD FOR 
	SELECT
		tmp.publication AS [PublicationName],
		tmp.publisher AS [PublisherName]
	FROM #tmp_publications tmp
	WHERE tmp.publication=@publicationName
		FOR READ ONLY
		open read_pub
		fetch read_pub into @pub_name_sub, @distpublisher
		WHILE (@@fetch_status != -1)
		BEGIN
			exec sys.sp_MSrepl_enumsubscriptions @publication = @pub_name_sub, @publisher = @distpublisher, @reserved = 1
			fetch next from read_pub into @pub_name_sub, @distpublisher
		END
		close read_pub
		deallocate read_pub

	-- get results
	SELECT
	tmpsub.publisher_db AS [PublisherDBName],
	tmpsub.publisher AS [PublisherName],
	tmpsub.subscriber AS [SubscriberName],
	tmpsub.subscriber_db AS [SubscriptionDBName]
	FROM
	#tmp_publications tmp
	INNER JOIN #tmp_pubsubscriptions tmpsub ON tmpsub.publication=tmp.publication AND tmpsub.publisher=tmp.publisher
	WHERE tmp.publication=@publicationName
 	
	drop table #tmp_publications
	drop table #tmp_pubsubscriptions

end

GO

grant exec on [dbo].[mwGetSubscriptions] to public
go
/*********************************************************************/
/* end sp_mwGetSubscriptions.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.30)_Create_Table_CharterDeleteQueue.sql */
/*********************************************************************/
-- если есть репликация и таблица в статьях репликации, выдадим сообщение о необходимости пересоздания подписки
if dbo.mwReplIsPublisher() > 0 
begin
	if exists (select top 1 1 from sys.databases where name = 'distribution')
	begin
		if exists (select * from distribution.dbo.mspublications
								where publication = 'MW_PUB'
									and publisher_db = db_name())
		begin
			if exists (select * 
							from distribution.dbo.msarticles
							where publisher_db = db_name()
								and source_object = 'CharterDeleteQueue'
								and publication_id = (select top 1 publication_id from distribution.dbo.mspublications
														where publication = 'MW_PUB' and publisher_db = db_name())
						)
			begin
				-- drop all subscriptions
				declare @PublisherDBName sysname, @PublisherName sysname, @SubscriberName sysname, @SubscriptionDBName sysname

				create table #t
				(
					[PublisherDBName] sysname,
					PublisherName sysname,
					[SubscriberName] sysname,
					[SubscriptionDBName] sysname
				)

				insert into #t
				exec mwGetSubscriptions

				if exists (select top 1 1 from #t)
				begin
					declare subCursor cursor for
					select * from #t

					open subCursor
					fetch next from subCursor into @PublisherDBName, @PublisherName, @SubscriberName, @SubscriptionDBName
					while @@fetch_status = 0
					begin
						begin try
							print 'удаление подписки (publisher side) ' + @SubscriberName
							exec sp_dropsubscription @publication=N'MW_PUB', @subscriber = @SubscriberName, @article = N'all', @destination_db = @SubscriptionDBName
							print 'готово'

							print 'удаление подписки (subscriber side) ' + @SubscriberName
							declare @dropSql nvarchar(max)
							set @dropSql = 'exec (''exec [@SubscriptionDBName].dbo.sp_droppullsubscription @publisher = ''''@@servername'''', @publisher_db = ''''@PublisherDBName'''', @publication = ''''@pubName'''''')'
							if @SubscriberName <> @@servername
								set @dropSql = @dropSql + ' at [@ls]'

							set @dropSql = replace(@dropSql, '@ls', @SubscriberName)
							set @dropSql = replace(@dropSql, '@@servername', @@servername)
							set @dropSql = replace(@dropSql, '@PublisherDBName', @PublisherDBName)
							set @dropSql = replace(@dropSql, '@SubscriptionDBName', @SubscriptionDBName)
							set @dropSql = replace(@dropSql, '@pubName', 'MW_PUB')
							exec (@dropSql)
							print 'готово'
						end try
						begin catch
							print error_message()
							RAISERROR('Внимание! Не удалось удалить подписку. Для корректной работы пересоздайте её вручную или обратитесь в службу поддержки (см. след. сообщение)', 1, 1)
						end catch

						fetch next from subCursor into @PublisherDBName, @PublisherName, @SubscriberName, @SubscriptionDBName
					end

					close subCursor
					deallocate subCursor

					-- drop article
					begin try
						exec sp_droparticle @publication = N'MW_PUB', @article = N'CharterDeleteQueue'
					end try
					begin catch
						RAISERROR('Внимание! Не удалось удалить таблицу CharterDeleteQueue из статей репликации. Для корректной работы удалите её вручную или обратитесь в службу поддержки (см. след. сообщение)'
							, 1, 1)
					end catch

					RAISERROR('
	Внимание! Для корректной работы приложения Вам необходимо пересоздать подписку(и). 
	Вы можете сделать это либо самостоятельно, как описано здесь: http://wiki.megatec.ru/Мастер-Тур:Настройка_репликации#.D0.9F.D0.B5.D1.80.D0.B5.D1.81.D0.BE.D0.B7.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8, 
	либо обратиться в службу поддержки по телефону +7 (495) 228-3284 или по e-mail: service@megatec.ru.', 16, 1)
				end

				drop table #t
			end
		
		end	
	end
end

if dbo.mwReplIsSubscriber() > 0
begin
	IF EXISTS (SELECT * FROM sys.objects WHERE name = 'CharterDeleteQueue' and type = 'U')
	begin
		drop table dbo.CharterDeleteQueue
	end
end

IF NOT EXISTS (SELECT * FROM sys.objects WHERE name = 'CharterDeleteQueue' and type = 'U')
begin
	CREATE TABLE dbo.CharterDeleteQueue
		(
			id int NOT NULL IDENTITY (1, 1),
			charterIdToReplace int NOT NULL,
			charterToReplaceName nvarchar(150),
			newCharterId int NULL,
			newCharterName nvarchar(150),
			createDate datetime not null,
			startDate datetime null,
			endDate datetime null,
			userId int not null,
			isProcessed bit NOT NULL default(0)
		)  ON [PRIMARY]
	
	ALTER TABLE dbo.CharterDeleteQueue ADD CONSTRAINT
		PK_CharterDeleteQueue PRIMARY KEY CLUSTERED 
		(
		id
		) WITH( STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end

GO
/*********************************************************************/
/* end (2013.07.30)_Create_Table_CharterDeleteQueue.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.10.29)_Create_Type_ListIntValue.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.types st JOIN sys.schemas ss ON st.schema_id = ss.schema_id WHERE st.name = N'ListIntValue' AND ss.name = N'dbo')
begin
	CREATE TYPE [dbo].[ListIntValue] AS TABLE(
		-- список чисел
		[value] [int] NULL
	)
end
GO
GRANT EXECUTE ON TYPE::dbo.[ListIntValue] TO public
go

/*********************************************************************/
/* end (2012.10.29)_Create_Type_ListIntValue.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.10.29)_Create_Type_ReCalculateAddCostResults.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.types st JOIN sys.schemas ss ON st.schema_id = ss.schema_id WHERE st.name = N'ReCalculateAddCostResults' AND ss.name = N'dbo')
begin
	CREATE TYPE [dbo].[ReCalculateAddCostResults] AS TABLE(
		[TrKey] [int] NOT NULL,
		[SvKey] [int] NOT NULL,
		[ScpId] [bigint] NOT NULL,
		[AddCostIsCommission] [money] NOT NULL,
		[AddCostNoCommission] [money] NOT NULL
	)
end
GO
GRANT EXECUTE ON TYPE::dbo.[ReCalculateAddCostResults] TO public
go

/*********************************************************************/
/* end (2012.10.29)_Create_Type_ReCalculateAddCostResults.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2012.12.13)_Create_Type_ReCalculateCostResults.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.types st JOIN sys.schemas ss ON st.schema_id = ss.schema_id WHERE st.name = N'ReCalculateCostResults' AND ss.name = N'dbo')
begin
	CREATE TYPE [dbo].[ReCalculateCostResults] AS TABLE(
		[Id] [bigint] NOT NULL,
		[Netto] [money] NULL,
		[Gross] [money] NULL,
		[IsCommission] [bit] NOT NULL
	)
end
GO
GRANT EXECUTE ON TYPE::dbo.[ListIntValue] TO public
go


/*********************************************************************/
/* end (2012.12.13)_Create_Type_ReCalculateCostResults.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCheckFlightGroupsQuotes.sql */
/*********************************************************************/
if object_id('dbo.mwCheckFlightGroupsQuotes', 'p') is not null
	drop proc dbo.mwCheckFlightGroupsQuotes
go

create proc [dbo].[mwCheckFlightGroupsQuotes]
	@pagingType int,
	@chkey int,
	@flightGroups varchar(256),
	@agentKey int,
	@partnerKey int,
	@tourdate datetime,
	@day int,
	@requestOnRelease int,
	@noPlacesResult int,
	@checkAgentQuota int,
	@checkCommonQuota int,
	@checkNoLongQuota int,
	@findFlight smallint,
	@pkkey int,
	@tourDays int,
	@expiredReleaseResult int,
	@aviaQuotaMask smallint,
	@result varchar(256) output,	-- формат: <FreePlaces>:<TotalPlaces> [ | ...n]
	@linked_day int = null,
	@requestedPlaces int = 1
as
begin

	--<VERSION>9.2.18.1</VERSION>
	--<DATE>2013-07-01</DATE>
	if exists (select top 1 1 from SystemSettings with (nolock) where SS_ParmName = 'ServiceFlightSelection' and SS_ParmValue = 1)
	begin
		Declare @charterDateToService datetime
		set @charterDateToService = DATEADD(DAY, @day - 1, @tourdate)

		create table #resultTable
		(
			id int identity(1, 1),
			value nvarchar(max)
		)

		insert into #resultTable
		EXEC	[dbo].[WcfCheckFlightGroupQuotas]
				@charterGroupsString = @flightGroups,
				@charterKey = @chkey,
				@charterDate = @charterDateToService,
				@aviaQuotaMask = @aviaQuotaMask,
				@packetKey = @pkkey,
				@agentKey = @agentKey,
				@requestedPlaces = @requestedPlaces,
				@tourDuration = @tourDays

		select @result = value from #resultTable where id = 1
		Return;
	end
	
	-- настройки проверки квот через веб-сервис
	declare @checkQuotesOnWebService as bit, @checkQuotesService as nvarchar(150), @wasErrorCallingService bit
	set @checkQuotesOnWebService = 0
	set @wasErrorCallingService = 0
	select top 1 @checkQuotesOnWebService = ss_parmvalue from systemsettings with (nolock) where ss_parmname = 'NewSetToQuota'	

	declare @DYNAMIC_SPO_PAGING smallint
	set @DYNAMIC_SPO_PAGING=3

	declare @now datetime, @percentPlaces float
	select @now = currentDate from dbo.mwCurrentDate

	if(@aviaQuotaMask is null)
		set @aviaQuotaMask = 0

	declare @correctionResult varchar(128)
	set @result = ''
	set @correctionResult = ''

	declare @gpos int, @pos int, @gplaces int, @gallplaces int, @tmpPlaces int, @checkQuotesResult nvarchar(max), @tmpPlacesAll int, @gStep smallint, @gCorrection int
	set @gpos = 1
	
	declare @gseparatorPos int, @separatorPos int,
		@groupKeys varchar(256), @key varchar(256), @nkey int,
		@glen int, @len int

	set @glen = len(@flightGroups)
	while(@gpos < @glen)
	begin
		set @gseparatorPos = charindex('|', @flightGroups, @gpos)
		if(@gseparatorPos = 0)
		begin
			set @groupKeys = substring(@flightGroups, @gpos, @glen - @gpos + 1)	
			set @gpos = @glen
		end
		else
		begin
			set @groupKeys = substring(@flightGroups, @gpos, @gseparatorPos - @gpos)
			set @gpos = @gseparatorPos + 1
		end

		if(len(@result) > 0)
		begin
			set @result = @result + '|'
			if(@pagingType = @DYNAMIC_SPO_PAGING)
			begin
				set @correctionResult = @correctionResult + '|'
			end
		end

		set @gplaces = 0
		set @gallplaces = 0
		set @pos = 1
		set @len = len(@groupKeys)		
		while(@pos < @len)
		begin
			set @separatorPos = charindex(',', @groupKeys, @pos)
			if(@separatorPos = 0)
			begin
				set @key = substring(@groupKeys, @pos, @len - @pos + 1)	
				set @pos = @len
			end
			else
			begin
				set @key = substring(@groupKeys, @pos, @separatorPos - @pos)
				set @pos = @separatorPos + 1
			end

			set @nkey = cast(@key as int)
			if @checkQuotesOnWebService = 1
			begin
				-- включена проверка квот через веб-сервис
				-- подбор перелетов
				declare @cityFrom as int, @cityTo as int
				declare @charterDate datetime, @dayOfWeek int
				select top 1 @cityFrom = ch_citykeyfrom, @cityTo = ch_citykeyto from charter with(nolock) where ch_key = @chkey
				set @charterDate = DATEADD(DAY, @day - 1, @tourdate)
				
				set @wasErrorCallingService = 1	-- в случае, если сервис проверки не отработает - установим признак ошибки, чтобы проверить квоты старым способом
				
				set @dayOfWeek = datepart(dw, @charterDate) - 1
				if(@dayOfWeek = 0)
					set @dayOfWeek = 7

				declare altCharters cursor for
				select ch_key from
				(
					select distinct ch_key, case when ch_key=@chkey then 1 else 0 end as pr 
					from Charter with (nolock)
					left join AirSeason with (nolock) on AS_CHKEY = CH_KEY
					inner join tbl_costs with(nolock) on (cs_svkey = 1 
														and cs_code = ch_key 
														and (@charterDate between cs_date and cs_dateend
															or @charterDate between cs_checkindatebeg and cs_checkindateend)
														and cs_subcode1=@nkey 
														and cs_pkkey = @pkkey)
					where (@findFlight <> 0 or ch_key=@chkey)
						and CH_CITYKEYFROM = @cityFrom
						and CH_CITYKEYTO = @cityTo
						and (AS_WEEK is null 
								or len(as_week)=0 
								or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
						and @charterDate between as_dateFrom and as_dateto
				) as alts
				order by pr desc
				
				declare @remPlaces int, @remPlacesAll int, @remResult int
				create table #charterPlacesResult
				(
					xPlaces int,
					xPlacesAll int,
					xPriority int
				)

				declare @altChKey as int
				open altCharters

				fetch next from altCharters into @altChKey
				while @@FETCH_STATUS = 0
				begin
					declare @dateFrom datetime, @dateTo datetime
					set @dateFrom = dateadd(day, @day-1, @tourdate)
					set @dateTo = dateadd(day, @day-1, @tourdate)

					begin try							
						exec mwCheckQuotaOneResult 1, 1, @altChKey, @nkey, @dateFrom, @dateTo,
							null, @agentKey, @tourDays, @requestedPlaces, null, @checkQuotesResult output, @tmpPlaces output, @tmpPlacesAll output
						
						set @wasErrorCallingService = 0						
					end try
					begin catch
						set @wasErrorCallingService = 1
						break
					end catch
								
					declare @freePlacesMask as int

					if @checkQuotesResult in ('StopSale', 'NoPlaces')
						set @freePlacesMask = 2	-- no places
					else if @checkQuotesResult in ('Release', 'Duration', 'NoQuota')
					begin
						set @freePlacesMask = 4	-- request
						set @tmpPlaces = -1
					end
					else if @checkQuotesResult = 'QuotaExist'
						set @freePlacesMask = 1	-- yes
						
					if (@aviaQuotaMask & @freePlacesMask) = @freePlacesMask
					begin
						declare @priority int
						if (@freePlacesMask = 1)
							set @priority = 1
						else if (@freePlacesMask = 4)
							set @priority = 2
						else
							set @priority = 3
						insert into #charterPlacesResult (xPlaces, xPlacesAll, xPriority) values (@tmpPlaces, @tmpPlacesAll, @priority)
					end
					
					fetch next from altCharters into @altChKey
				
				end
				
				if @wasErrorCallingService = 0
				begin
					select top 1 @tmpPlaces = xPlaces, @tmpPlacesAll = xPlacesAll from #charterPlacesResult order by xPriority asc					
				end
				
				close altCharters
				deallocate altCharters
				
				drop table #charterPlacesResult
			end
			
			-- не сделано через else к условию if @checkQuotesOnWebService = 1, чтобы в случае
			-- ошибки работы с веб-сервисом проверки квот
			if @wasErrorCallingService = 1 or @checkQuotesOnWebService = 0
			begin
				select @tmpPlaces = qt_places, @tmpPlacesAll = qt_allPlaces
				from dbo.mwCheckQuotesEx2(1, @chkey, @nkey, 0, @agentKey, @partnerKey, @tourdate,
					@day, 1, @requestOnRelease, @noPlacesResult, @checkAgentQuota,
					@checkCommonQuota, @checkNoLongQuota, @findFlight, 0, 0, @pkkey,
					@tourDays, @expiredReleaseResult, @linked_day)
			end

			if(@gplaces = 0 or (@tmpPlaces > 0 and @tmpPlaces > @gplaces))
			begin
				set @gplaces = @tmpPlaces
				set @gallplaces = @tmpPlacesAll

				if(@pagingType = @DYNAMIC_SPO_PAGING)
				begin
					set @percentPlaces = 0.0
					if(@gplaces > 0 and @gallplaces > 0)
						set @percentPlaces = 1.0*@gplaces/@gallplaces
					exec dbo.GetDynamicCorrections @now,@tourdate,1,@chkey,@nkey,0,@percentPlaces, @gStep output, @gCorrection output				
				end
			end

			if(@gplaces > 0)
				break	
		end

		set @result = @result + cast(@gplaces as varchar) + ':' + cast(@gallplaces as varchar)
		if(@pagingType = @DYNAMIC_SPO_PAGING)
			set @correctionResult = @correctionResult + cast(@gCorrection as varchar) + ':' + cast(@gStep as varchar)
	end

	if(@pagingType = @DYNAMIC_SPO_PAGING)
		set @result = @result + '#' + @correctionResult
end
go

grant exec on dbo.mwCheckFlightGroupsQuotes to public
go
/*********************************************************************/
/* end sp_mwCheckFlightGroupsQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_WcfQuotaCheckOneResult.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WcfQuotaCheckOneResult]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[WcfQuotaCheckOneResult]
GO

CREATE PROCEDURE [dbo].[WcfQuotaCheckOneResult]
	(
		@useCache bit,
		@serviceKey int,
		@serviceCode int,
		@serviceSubCode1 int,
		@serviceDateBegin datetime,
		@serviceDateEnd datetime,
		@partnerKey int,
		@agentKey int,
		@tourDuration smallint,
		@quotaPlaces smallint,
		@pax smallint
		--<VERSION>11.1.3</VERSION>
	    --<DATA>2013.06.13</DATA>
	)
AS
BEGIN
	declare @commandLine varchar(2000), @path varchar(2000)
	
	select @path = SS_ParmValue from SystemSettings where SS_ParmName = 'PathToWcfClient'
	
	if (@path is not null)
	begin
		set @commandLine = @path + ' CheckOneResult'
		
		set @commandLine = @commandLine + ' ' + (case when @useCache = 1 then ' true' else ' false' end)
		set @commandLine = @commandLine + ' ' + convert(varchar, @serviceKey)
		set @commandLine = @commandLine + ' ' + convert(varchar, @serviceCode)
		set @commandLine = @commandLine + ' ' + convert(varchar, @serviceSubCode1)
		set @commandLine = @commandLine + ' "' + convert(varchar, @serviceDateBegin) + '"'
		set @commandLine = @commandLine + ' "' + convert(varchar, @serviceDateEnd) + '"'
		set @commandLine = @commandLine + ' ' + (case when @partnerKey is null then 'null' else convert(varchar, @partnerKey) end)
		set @commandLine = @commandLine + ' ' + (case when @agentKey is null then 'null' else convert(varchar, @agentKey) end)
		set @commandLine = @commandLine + ' ' + (case when @tourDuration is null then 'null' else convert(varchar, @tourDuration) end)
		set @commandLine = @commandLine + ' ' + convert(varchar, @quotaPlaces)
		set @commandLine = @commandLine + ' ' + (case when @pax is null then 'null' else convert(varchar, @pax) end)
	end
	else
	begin
		RAISERROR('Ошибка: не указан пусть к сервису', 16, 1)
	end
	
	--print @commandLine
	exec xp_cmdshell @commandLine
END

GO
grant exec on [dbo].[WcfQuotaCheckOneResult] to public
go
/*********************************************************************/
/* end sp_WcfQuotaCheckOneResult.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ProcessCharterDeleteQueue.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE name = 'ProcessCharterDeleteQueue' and type='P')
	DROP PROCEDURE [dbo].[ProcessCharterDeleteQueue]
GO

CREATE PROCEDURE [dbo].[ProcessCharterDeleteQueue]
AS
BEGIN
	--<VERSION>9.2.20.0</VERSION>
	--<DATE>2013-08-22</DATE>

	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	declare @oldChId as int
	declare @queueId as int
	
	if not exists (select top 1 1 from CharterDeleteQueue with (nolock))
		return
	
	select top 1 
		@queueId = id, @oldChId = charterIdToReplace
	from CharterDeleteQueue with (nolock)
	where isProcessed = 0
	order by id asc
	
	if @oldChId is null	-- очередь пустая
		return

	update CharterDeleteQueue
	set startDate = GETDATE()
	where id = @queueId
	
	-- 1. определение направления перелета
	declare @cityFrom int, @cityTo int
	select top 1 @cityFrom = ch_citykeyfrom, @cityTo = ch_citykeyto from charter with(nolock) where ch_key = @oldChId	

	-- 2. поиск заменяющего перелета
	declare @newChId int, @newPrId int, @newAirportFrom int, @newAirportTo int
	declare @oldPrKey int, @oldPkKey int
	
	select top 1 @oldPrKey = CS_PRKEY, @oldPkKey = CS_PKKEY
	from tbl_Costs
	where cs_svkey = 1 
		and cs_code = @oldChId

	set @newChId = null

	select top 1 @newChId = ch_key, @newPrId = CS_PRKEY, @newAirportFrom = apKeyFrom, @newAirportTo = apKeyTo
	from 
	(
		select top 1 ch_key, 1 as partnerMatch, CS_PRKEY, portFrom.ap_key apKeyFrom, portTo.ap_key apKeyTo
		from Charter with (nolock)
		inner join tbl_costs with(nolock) on (cs_svkey = 1 
												and cs_code = ch_key
												and CS_PRKEY = @oldPrKey
												and CS_PKKEY = @oldPkKey
											)
		left join Airport portFrom with (nolock) on portFrom.AP_CODE = CH_PORTCODEFROM
		left join Airport portTo with (nolock) on portTo.AP_CODE = CH_PORTCODETO
		where ch_citykeyfrom = @cityFrom
				and ch_citykeyto = @cityTo
				and ch_key <> @oldChId
				and CH_KEY not in (select charterIdToReplace from CharterDeleteQueue with (nolock))
		order by ch_key
						
		union all
		
		select top 1 ch_key, 0 as partnerMatch, CS_PRKEY, portFrom.ap_key apKeyFrom, portTo.ap_key apKeyTo
		from Charter with (nolock)
		inner join tbl_costs with(nolock) on (cs_svkey = 1 
												and cs_code = ch_key
												and CS_PKKEY = @oldPkKey
											)
		left join Airport portFrom with (nolock) on portFrom.AP_CODE = CH_PORTCODEFROM
		left join Airport portTo with (nolock) on portTo.AP_CODE = CH_PORTCODETO
		where ch_citykeyfrom = @cityFrom 
				and ch_citykeyto = @cityTo
				and ch_key <> @oldChId
				and CH_KEY not in (select charterIdToReplace from CharterDeleteQueue with (nolock))
		order by ch_key
	) as res
	order by partnerMatch desc
	
	-- 2.а. если это поисковая база, то возьмем заменяющий перелет с основного сервера,
	-- так как к моменту вызова этой хранимки запись из таблицы Charter уже может быть удалена
	if dbo.mwReplIsSubscriber() > 0 and @newChId is null
	begin
		declare @getCharter as nvarchar(max)
		set @getCharter = 'select top 1 @newChId = newCharterId from mt.[db].dbo.charterDeleteQueue with (nolock) where charterIdToReplace=@oldChId'

		set @getCharter = replace(@getCharter, '[db]', dbo.mwReplPublisherDb())
		exec sp_executesql @getCharter, N'@newChId int output, @oldChId int', @oldChId=@oldChId, @newChId=@newChId output
		
		if @newChId is not null
		begin
			-- получим @newPrId, @newAirportFrom, @newAirportTo снова на поисковом сервере
			select top 1 @newPrId = CS_PRKEY, @newAirportFrom = portFrom.ap_key, @newAirportTo = portTo.ap_key
			from Charter with (nolock)
			inner join tbl_costs with(nolock) on (cs_svkey = 1 
												and cs_code = ch_key
											)
			left join Airport portFrom with (nolock) on portFrom.AP_CODE = CH_PORTCODEFROM
			left join Airport portTo with (nolock) on portTo.AP_CODE = CH_PORTCODETO
			where ch_key = @newChId
		end
	end
	
	update CharterDeleteQueue
	set newCharterId = @newChId, newCharterName = srcCH.CH_AIRLINECODE + ' ' + srcCH.CH_FLIGHT
	from
	(
		select CH_AIRLINECODE, CH_FLIGHT
		from Charter with (nolock)
		where CH_KEY = @newChId
	) as srcCH
	where id = @queueId

	declare @svName VARCHAR(800)
	declare @svNameLat VARCHAR(800)
	declare @nCountry INT
	declare @nCity INT
	declare @nSvKey INT
	declare @nNDays INT
	declare @nCode1 INT
	declare @nCode2 INT
	declare @dServDate DATETIME

	-- проверим, есть ли на удаляемый перелет ссылки
	if exists (select top 1 1 from tp_flights where (tf_codeold = @oldChId or TF_CodeNew = @oldChId) and tf_date > getdate())
		or exists (select top 1 1 from TP_ServiceComponents where SC_Code = @oldChId)
		or exists (select top 1 1 from tbl_DogovorList where dl_Code = @oldChId and DL_DATEBEG > getdate())
		or exists (select top 1 1 from TurService where ts_code = @oldChId)
		or exists (select top 1 1 from tp_services where ts_code = @oldChId)
		or exists (select top 1 1 from tp_lists where ti_chkey = @oldChId or ti_chbackkey = @oldChId)
	begin
		if (dbo.mwReplIsPublisher() <= 0 and dbo.mwReplIsSubscriber() <= 0) or dbo.mwReplIsPublisher() > 0
		begin
			-- 3. Публикатор (при репликации) или репликации нет
			-- Сначала обновим справочники
			
			-- таблица с найденными перелетами для вариантов, когда на каждую строчку
			-- нужно искать свой вариант перелета
			create table #flights
			(
				id int identity(1,1),
				flightDate datetime null,	-- дата перелета
				partnerkey int,				-- ключ партнера на эту дату
				packetKey int,				-- ключ пакета на эту дату
				asKey int,					-- ключ тарифа на этот перелет
				newCharterKey int null,		-- найденный для этого варианта ключ перелета. Изначально ключ пустой
				newPartnerKey int null,		-- найденный для этого варианта ключ партнера. Изначально ключ пустой
				newAsKey int null,			-- найденный для этого варианта ключ тарифа на перелет. Изначально ключ пустой
				checkForNull bit default(1) -- проверять ли текущую строчку на null в заполняемых колонках (newCharterKey...) для выдачи сообщения об ошибке
			)
			
			-- таблица связывающая тур и перелет, для найденных перелетов
			create table #CharterTour
			(	
				to_key int,                --ключ тура
				tf_code int,               --ключ нового перелета
				tf_subcode1 int,
				tf_subcode2 int
			)

			declare @curDate as datetime
			set @curDate = getdate()

			-- заполним таблицу возможными вариантами дат, ключей партнера и пакета, тарифа на перелет
			insert into #flights (flightDate, partnerkey, packetKey, asKey, checkForNull)
			select distinct * from
			(
				select distinct TF_Date, TF_PRKeyOld, TF_PKKey, TF_SubCode1 as TF_GROUP, 1 as checkForNull
				from TP_Flights with (nolock)
				where TF_CodeOld = @oldChId
					and TF_PRKeyOld is not null
					and TF_PKKey is not null
				
				union
				
				select distinct TF_Date, TF_PRKeyNew, TF_PKKey, TF_SubCode1, 1
				from TP_Flights with (nolock)
				where TF_CodeNew = @oldChId
					and TF_PRKeyNew is not null
					and TF_PKKey is not null
				
				union
				
				select distinct SCP_Date, SC_PRKey, SCP_PKKey, SC_SubCode1, 1
				from TP_ServiceComponents with (nolock)
				left join TP_ServiceCalculateParametrs with (nolock) on SC_Id = SCP_SCId
				where SC_Code = @oldChId
					and SC_PRKey is not null
					and SCP_PKKey is not null
					and sc_svkey = 1
				
				union
				
				select distinct DL_DATEBEG, DL_PARTNERKEY, DL_PAKETKEY, DL_SUBCODE1, 1
				from tbl_DogovorList with (nolock)
				where DL_CODE = @oldChId
					and DL_PARTNERKEY is not null
					and DL_PAKETKEY is not null
					and dl_svkey = 1

				union

				select distinct (select top 1 dateadd(day, ts_day - 1, td_date) from turdate where td_trkey = ts_trkey and td_date >= @curDate), TS_PARTNERKEY, TS_PKKEY, TS_SUBCODE1, 0
				from TurService
				where ts_code = @oldChId
					and TS_PARTNERKEY is not null
					and TS_PKKEY is not null
					and ts_svkey = 1
					and exists(select top 1 dateadd(day, ts_day - 1, td_date) from turdate where td_trkey = ts_trkey and td_date >= @curDate)

				union

				select distinct (select top 1 dateadd(day, ts_day - 1, td_date) from tp_turdates where td_tokey = ts_tokey and td_date >= @curDate), TS_OpPartnerKey, TS_OpPacketKey, TS_SubCode1, 1
				from tp_services
				where ts_code = @oldChId
						and TS_OpPartnerKey is not null
						and TS_OpPacketKey is not null
						and ts_svkey = 1
						and exists (select top 1 dateadd(day, ts_day - 1, td_date) from tp_turdates where td_tokey = ts_tokey and td_date >= @curDate)
			) as variants
			where variants.TF_Date >= @curDate

			-- теперь для каждого варианта подберем перелет
			declare @key int, @flightDate datetime, @partnerkey int, @packetKey int, @airServiceKey int
			
			-- запомним параметр DATEFIRST, чтобы после отбора данных восстановить его
			declare @nDateFirst smallint
			select @nDateFirst = @@DATEFIRST
			set DATEFIRST 1
			
			declare varCursor cursor for
			select id, flightDate, partnerkey, packetKey, asKey
			from #flights
			
			open varCursor
			fetch next from varCursor into @key, @flightDate, @partnerkey, @packetKey, @airServiceKey
			while @@FETCH_STATUS = 0
			begin
			
				declare @curCharter int, @curPartner int, @curTariff int
				set @curCharter = null
				set @curPartner = null
				set @curTariff = null

				select top 1 @curCharter = ch_key, @curPartner = CS_PRKEY, @curTariff = CS_SubCode1
				from 
				(
					select top 1 ch_key, 1 as partnerMatch, CS_PRKEY, CS_SubCode1
					from Charter with (nolock)
					inner join tbl_costs with(nolock) on (cs_svkey = 1 
															and cs_code = ch_key
															and CS_PRKEY = @partnerkey
															and CS_PKKEY = @packetKey
														)
					left join Airport portFrom with (nolock) on portFrom.AP_CODE = CH_PORTCODEFROM
					left join Airport portTo with (nolock) on portTo.AP_CODE = CH_PORTCODETO
					left join AirSeason with (nolock) on AS_CHKEY = CH_KEY
					where ch_citykeyfrom = @cityFrom
							and ch_citykeyto = @cityTo
							and ch_key <> @oldChId
							and CH_KEY not in (select charterIdToReplace from CharterDeleteQueue with (nolock))
							and @flightDate BETWEEN AS_DateFrom AND AS_DateTo 
							and @flightDate BETWEEN CS_Date and CS_DateEnd
							and AS_Week LIKE '%'+cast(datepart(weekday, @flightDate)as varchar(1))+'%'
							and (
								isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = CS_SubCode1), str(CS_SubCode1))
								=
								isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = @airServiceKey), str(@airServiceKey))
								)
					order by ch_key
									
					union all
					
					select top 1 ch_key, 0 as partnerMatch, CS_PRKEY, CS_SubCode1
					from Charter with (nolock)
					inner join tbl_costs with(nolock) on (cs_svkey = 1 
															and cs_code = ch_key
															and CS_PKKEY = @packetKey
														)
					left join Airport portFrom with (nolock) on portFrom.AP_CODE = CH_PORTCODEFROM
					left join Airport portTo with (nolock) on portTo.AP_CODE = CH_PORTCODETO
					left join AirSeason with (nolock) on AS_CHKEY = CH_KEY
					where ch_citykeyfrom = @cityFrom 
							and ch_citykeyto = @cityTo
							and ch_key <> @oldChId
							and CH_KEY not in (select charterIdToReplace from CharterDeleteQueue with (nolock))
							and @flightDate BETWEEN AS_DateFrom AND AS_DateTo
							and @flightDate BETWEEN CS_Date and CS_DateEnd
							and AS_Week LIKE '%'+cast(datepart(weekday, @flightDate)as varchar(1))+'%'
							and (
								isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = CS_SubCode1), str(CS_SubCode1))
								=
								isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = @airServiceKey), str(@airServiceKey))
								)
					order by ch_key
				) as res
				order by partnerMatch desc
				
				if @curCharter is not null and @curPartner is not null
				begin
					update #flights
					set newCharterKey = @curCharter, newPartnerKey = @curPartner, newAsKey = @curTariff
					where id = @key
				end
				
				fetch next from varCursor into @key, @flightDate, @partnerkey, @packetKey, @airServiceKey
			
			end
			close varCursor
			deallocate varCursor

			delete from #flights where checkForNull = 0 and (newCharterKey is null or newPartnerKey is null)

			if exists (select top 1 1 from #flights where checkForNull = 1 and (newCharterKey is null or newPartnerKey is null))
			begin
				declare @newSsId as int
				declare @msg as nvarchar(max), @nullDates as nvarchar(max)
				set @nullDates = ''
				select @nullDates = @nullDates 
							+ convert(nvarchar, flightDate) + ' (packet ' 
							+ ltrim(rtrim(str(packetKey))) + ', '
							+ (select top 1 ltrim(rtrim(as_namerus)) from airService with (nolock) where as_key=asKey)
							+ '), ' from #flights where newCharterKey is null or newPartnerKey is null
							order by flightDate
				
				set @msg = 'для перелета ' + ltrim(rtrim(str(@oldChId))) + ' найдены перелеты не на все даты: ' + @nullDates

				insert into SystemLog (sl_message) values (@msg)
				
				set @newSsId = SCOPE_IDENTITY()
				set @msg = 'заменяющие перелеты найдены не на все даты! Подробнее см. в systemLog: select * from systemLog where sl_id = ' + ltrim(rtrim(str(@newSsId)))
				
				RAISERROR(@msg, 16, 1)
				return
			end

			-- восстановим параметр DATEFIRST
			set DATEFIRST @nDateFirst

			BEGIN TRY
				declare @updatePortion int
				set @updatePortion = 10000
				
				declare @curChId as int, @curPartnerid as int, @curTariffId as int

				-- TurService
				declare tsCursor cursor for
				select TS_Key from TurService with (nolock)
				where TS_CODE = @oldChId 
				and TS_SVKEY = 1
				
				declare @tsKey as int
				open tsCursor
				fetch next from tsCursor into @tsKey
				while @@FETCH_STATUS = 0
				begin				
					select @nCountry = TS_CNKEY, @nCity = TS_CTKEY, @nSvKey = TS_SVKEY, @nNDays = TS_NDAYS
						, @nCode1 = TS_SUBCODE1, @nCode2 = TS_SUBCODE2
					from TurService
					where TS_key = @tsKey
					
					set @curChId = null
					set @curPartnerid = null
					set @curTariffId = null
					set @svName = null
					set @svNameLat = null

					select top 1 @curChId = #flights.newCharterKey, @curPartnerid = #flights.newPartnerKey, @curTariffId = #flights.newAsKey
					from #flights
					left join TurService on TS_PKKEY = #flights.packetKey
						and TS_PARTNERKEY = #flights.partnerkey
						and (
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = #flights.asKey), str(#flights.asKey))
							=
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = TS_SUBCODE1), str(TS_SUBCODE1))
							)
					where ts_key = @tsKey

					if @curChId is not null
					begin
						exec dbo.MakeFullSVName @nCountry, @nCity, @nSvKey, @curChId, @nNDays, @curTariffId, @nCode2, @curPartnerid, @dServDate, null, @svName output, @svNameLat output
					
						update TurService
						set ts_code = @curChId, TS_PARTNERKEY = @curPartnerid, TS_SUBCODE1 = @curTariffId, ts_name = @svName, TS_NameLat = @svNameLat
						where TS_key = @tsKey
					end

					fetch next from tsCursor into @tsKey				
				end
				close tsCursor
				deallocate tsCursor

				-- tp_flights
				declare dateCursor cursor local fast_forward for
				select distinct TF_Date
				from TP_Flights with(nolock)
				where TF_CodeOld = @oldChId
				order by TF_Date asc

				open dateCursor
				fetch dateCursor into @flightDate
				while (@@FETCH_STATUS = 0)
				begin
					-- сначала обрабатываем перелеты с тем же поставщиком
					update TP_Flights
					set TF_CodeOld = #flights.newCharterKey, TF_PRKeyOld = #flights.newPartnerKey, TF_SubCode1 = #flights.newAsKey
					from #flights
					where TF_CodeOld = @oldChId
						and TF_Date = #flights.flightDate
						and TF_Date = @flightDate
						and TF_PRKeyOld = #flights.partnerkey
						and TF_PKKey = #flights.packetKey
						and (
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = #flights.asKey), str(#flights.asKey))
							=
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = TF_SubCode1), str(TF_SubCode1))
							)

					fetch dateCursor into @flightDate	
				end
				close dateCursor
				deallocate dateCursor

				declare dateCursor cursor local fast_forward for
				select distinct TF_Date
				from TP_Flights with(nolock)
				where TF_CodeNew = @oldChId
				order by TF_Date asc

				open dateCursor
				fetch dateCursor into @flightDate
				while (@@FETCH_STATUS = 0)
				begin

					update TP_Flights
					set TF_CodeNew = #flights.newCharterKey, TF_PRKeyNew = #flights.newPartnerKey, TF_SubCode1 = #flights.newAsKey
					OUTPUT deleted.TF_TOKEY, inserted.TF_CodeNew, inserted.TF_SubCode1, inserted.TF_SubCode2 INTO #CharterTour
					from #flights  
					where TF_CodeNew = @oldChId
						and TF_Date = #flights.flightDate
						and TF_PRKeyNew = #flights.partnerkey
						and TF_PKKey = #flights.packetKey
						and TF_Date = @flightDate
						and (
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = #flights.asKey), str(#flights.asKey))
							=
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = TF_SubCode1), str(TF_SubCode1))
							)

					fetch dateCursor into @flightDate	
				end
				close dateCursor
				deallocate dateCursor
				
				-- tp_lists
				while exists(select top 1 1 from TP_Lists with (nolock) where ti_chkey = @oldChId)
				begin
					update top (@updatePortion) TP_Lists
					set ti_chkey = newCharterKey, ti_chprkey = newPartnerKey, ti_apkeyfrom = ap_key
					from #flights
					join Charter on CH_Key = newCharterKey
					join Airport on AP_CODE = CH_PORTCODEFROM
					where ti_chkey = @oldChId
					and ti_chpkkey = packetKey
					and ti_chprkey = partnerkey
				end
				
				while exists(select top 1 1 from TP_Lists with (nolock) where ti_chbackkey = @oldChId)
				begin
					update top (@updatePortion) TP_Lists
					set ti_chbackkey = newCharterKey, ti_chbackprkey = newPartnerKey, ti_apkeyto = ap_key
					from #flights
					join Charter on CH_Key = newCharterKey
					join Airport on AP_CODE = CH_PORTCODEFROM
					where ti_chbackkey = @oldChId
					and ti_chbackpkkey = packetKey
					and ti_chbackprkey = partnerkey
				end
				
				-- TP_ServiceComponents
				-- подбор и замена в TP_ServiceComponents и TP_ServiceCalculateParametrs
				declare scpCursor cursor for
				select distinct scp_id, SCP_Date, SC_PRKey, SCP_PKKey, SC_SubCode1, SC_SubCode2
				from TP_ServiceCalculateParametrs with (nolock)
				join TP_ServiceComponents with (nolock) on SCP_SCId = SC_Id
				where SC_Code = @oldChId
					and SC_SVKey = 1
					and SCP_Date >= getdate()
				
				declare @scpId int, @scpDate datetime, @scpPrKey int, @scpPkKey int, @scSubCode1 int, @scSubCode2 int
				open scpCursor
				
				fetch next from scpCursor into @scpId, @scpDate, @scpPrKey, @scpPkKey, @scSubCode1, @scSubCode2
				while @@FETCH_STATUS = 0
				begin
				
					-- найдем, с каким перелетом надо искать запись в TP_ServiceComponents для текущего TP_ServiceCalculateParametrs
					select top 1 @curCharter = #flights.newCharterKey, @curPartner = #flights.newPartnerKey, @scSubCode1 = #flights.newAsKey
					from #flights
					where #flights.flightDate = @scpDate
						and #flights.partnerkey = @scpPrKey
						and #flights.packetKey = @scpPkKey
						and (
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = #flights.asKey), str(#flights.asKey))
							=
							isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = @scSubCode1), str(@scSubCode1))
							)
						
					-- попробуем найти соответствующую запись в TP_ServiceComponents
					declare @newScId as int
					select top 1 @newScId = sc_id
					from TP_ServiceComponents with (nolock)
					where SC_SVKey = 1
						and SC_SubCode1 = @scSubCode1
						and SC_SubCode2 = @scSubCode2
						and SC_Code = @curCharter
					
					if @newScId is not null
					begin
					
						update TP_ServiceCalculateParametrs
						set SCP_SCId = @newScId
						where SCP_Id = @scpId
					
					end
					else
					begin
						insert into TP_ServiceComponents (SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey)
						values (1, @curCharter, @scSubCode1, @scSubCode2, @scpPrKey)
						
						set @newScId = SCOPE_IDENTITY()
						
						update TP_ServiceCalculateParametrs
						set SCP_SCId = @newScId
						where SCP_Id = @scpId
						
						-- курсор по турам
						declare toCursor cursor for
						select distinct to_key from #CharterTour where tf_code=@curCharter and tf_subcode1 = @scSubCode1 and tf_subcode2 = @scSubCode2 and to_key is not null
						declare @toKey int
						declare @trKey int
						
						open toCursor
						fetch next from toCursor into @toKey
						
						while @@FETCH_STATUS = 0
						begin
							--ключ тура
							select @trKey = TO_TRKey from TP_Tours where TO_Key=@toKey

							-- добавляем запись с новыми параметрами в TP_ServiceTours
							insert into TP_ServiceTours (ST_SVKey, ST_SCId, ST_TRKey, ST_TOKey)
							values (1, @newScId, @trKey, @toKey)
							
							fetch next from toCursor into @toKey
						end

						close toCursor
						deallocate toCursor
					end
				
					fetch next from scpCursor into @scpId, @scpDate, @scpPrKey, @scpPkKey, @scSubCode1, @scSubCode2
				
				end
				
				-- в конце удалим записи из TP_ServiceComponents, на которые нет ссылок из TP_ServiceCalculateParametrs
				delete from TP_ServiceComponents
				where not exists (select top 1 1 from TP_ServiceCalculateParametrs with (nolock) where SCP_SCId = SC_Id)
				and SC_SVKey = 1

				-- в конце удалим записи из TP_ServiceTours, на которые нет ссылок из TP_ServiceCalculateParametrs
				delete from TP_ServiceTours
				where not exists (select top 1 1 from TP_ServiceCalculateParametrs with (nolock) where SCP_SCId = ST_SCId)
				and ST_SVKey = 1
				
				close scpCursor
				deallocate scpCursor
				
				-- TP_Services
				update tp_services
				set ts_code = newCharterKey, TS_OpPartnerKey = newPartnerKey, TS_SUBCODE1 = newAsKey
				from #flights
				where TS_SVKey = 1
				and TS_CODE = @oldChId
				and TS_OpPartnerKey = partnerkey
				and TS_OpPacketKey = packetKey
				and (
					isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = asKey), str(asKey))
					=
					isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = TS_SubCode1), str(TS_SubCode1))
					)

				-- tbl_DogovorList
				declare dlCursor cursor for
				select dl_key
				from tbl_DogovorList
				where DL_CODE = @oldChId
					and dl_svkey = 1
					and DL_DATEBEG >= getdate()
				
				declare @dlKey int
				declare @wasError bit
				set @wasError = 0
				
				declare @innerErMsg nvarchar(max)
				begin try
					open dlCursor
					
					fetch next from dlCursor into @dlKey

					while @@FETCH_STATUS = 0
					begin
					
						select @nCountry = DL_CNKEY, @nCity = DL_CTKEY, @nSvKey = DL_SVKEY, @nNDays = DL_NDAYS
							, @nCode1 = DL_SUBCODE1, @nCode2 = DL_SUBCODE2, @dServDate = DL_DATEBEG
						from tbl_DogovorList
						where DL_KEY = @dlKey
						
						set @curChId = null
						set @curPartnerid = null
						set @curTariffId = null
						set @svName = null
						set @svNameLat = null

						select top 1 @curChId = #flights.newCharterKey, @curPartnerid = #flights.newPartnerKey, @curTariffId = #flights.newAsKey
						from #flights
						inner join tbl_DogovorList with (nolock) on #flights.flightDate = DL_DATEBEG
									and #flights.packetKey = DL_PAKETKEY
									and (
										isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = #flights.asKey), str(#flights.asKey))
										=
										isnull((select top 1 coalesce(AS_GROUP, str(as_key)) from AirService with(nolock) where AS_KEY = DL_SubCode1), str(DL_SubCode1))
										)
						where DL_KEY = @dlKey 
						order by (case when #flights.partnerkey = DL_PARTNERKEY then 1 else 0 end) desc
						
						exec dbo.MakeFullSVName @nCountry, @nCity, @nSvKey, @curChId, @nNDays, @curTariffId, @nCode2, @newPrId, @dServDate, null, @svName output, @svNameLat output
 
						update tbl_DogovorList
						set DL_CODE = @curChId, DL_PARTNERKEY = @curPartnerid, dl_subcode1 = @curTariffId, DL_NAME = @svName, dl_namelat = @svNameLat
						where DL_KEY = @dlKey

						delete from ServiceByDate where SD_DLKey = @dlKey
						exec DogListToQuotas @DLKey = @dlKey
					
						fetch next from dlCursor into @dlKey
					
					end
				end try
				begin catch
					set @wasError = 1
					set @innerErMsg = ERROR_MESSAGE()
				end catch
				
				close dlCursor
				deallocate dlCursor	
				
				drop table #flights
				
				if @wasError = 1
				begin
					RAISERROR(@innerErMsg, 16, 1)
				end
			
			END TRY
			BEGIN CATCH
								
				declare @errMsg nvarchar(max)
				set @errMsg = 'Ошибка замены рейса ' + STR(@oldChId) + ': ' + error_message()
				RAISERROR(@errMsg, 16, 1)
				return
			
			END CATCH

		end
	end

	if @newChId is not null
	begin
		if (dbo.mwReplIsPublisher() <= 0 and dbo.mwReplIsSubscriber() <= 0) or dbo.mwReplIsSubscriber() > 0
		begin
			-- 4. Подписчик (при репликации) или репликации нет
			-- Обновим ценовые таблицы				
			declare @mwSearchType int
			select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
			where SS_ParmName = 'MWDivideByCountry'
			
			declare @sql as nvarchar(max)
			declare @tablesCondition as nvarchar(100)
			
			if @mwSearchType = 0
				set @tablesCondition = 'mwPriceDataTable'
			else
				set @tablesCondition = 'mwPriceDataTable[_]%'
			
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition
			
			declare @tableName nvarchar(100)
			open tableCursor
			
			fetch next from tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
			
				set @sql = '
				
					while exists(select top 1 1 from #tableName with (nolock) where pt_chkey = @oldChId)
					begin
						update top (50000) #tableName
						set 
							pt_chkey = @newChId
							, pt_chprkey = @newPrId
							, pt_chdirectkeys = dbo.mwGetTourCharters(pt_pricelistkey, 1)
						where pt_chkey = @oldChId
					end
					
					while exists(select top 1 1 from #tableName with (nolock) where pt_chbackkey = @oldChId)
					begin
						update top (50000) #tableName
						set 
							pt_chbackkey = @newChId
							, pt_chbackprkey = @newPrId
							, pt_chbackkeys = dbo.mwGetTourCharters(pt_pricelistkey, 0)
						where pt_chbackkey = @oldChId
					end
					'
				
				set @sql = REPLACE(@sql, '#tableName', @tableName)
				set @sql = REPLACE(@sql, '@newChId', @newChId)
				set @sql = REPLACE(@sql, '@newPrId', @newPrId)
				set @sql = REPLACE(@sql, '@oldChId', @oldChId)
				exec (@sql)
				
				fetch next from tableCursor into @tableName
			
			end
			
			close tableCursor
			deallocate tableCursor
			
		end
	end

	-- 5. Теперь удалим запись из таблицы Charter
	update CharterDeleteQueue
	set isProcessed = 1
	where charterIdToReplace = @oldChId
		
	delete from Charter where CH_KEY = @oldChId
	
	update CharterDeleteQueue
	set endDate = GETDATE()
	where id = @queueId

END
GO

GRANT EXEC on [dbo].[ProcessCharterDeleteQueue] to public
GO
/*********************************************************************/
/* end sp_ProcessCharterDeleteQueue.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_LoadProtourQuotes.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[LoadProtourQuotes]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[LoadProtourQuotes]
GO
CREATE PROCEDURE [dbo].[LoadProtourQuotes]
(
	--<VERSION>2009.2.25</VERSION>
	--<DATA>15.10.2013</DATA>
	@hotelKey int = null,	-- ключ отеля
	@startDate datetime = null,		-- дата начала интервала, по которому изменялись квоты (для стопов передается null)
	@endDate datetime = null,		-- дата окончания интервала, по которому изменялись квоты (для стопов передается null)
	@quotesUpdate bit = null			-- признак того, что обновлять надо квоты (т.е. 1 - обновление квот, 0 - обновление стопов)
)
AS
BEGIN
	if (dbo.mwReplIsSubscriber() = 1)
		return;

	declare @qtid int, @qoid int, @qdid int, @qdbusy int, @uskey int, @str nvarchar(max), @str1 nvarchar(max), @str3 nvarchar(max), @hdname varchar(100), 
			@partnerName varchar(100), @rcname varchar(100), @ss_allotmentAndCommitment int, @email varchar(1000), @bkid int, @isErrorState bit  
	
	if (@startDate is null)
		set @startDate = '1900-01-01'
	if (@endDate is null)
		set @endDate = '2099-12-01'
	
	set @str = 'Количество квот, полученное из ProTour меньше, чем число занятых мест. Параметры квот:'
	set @str1 = 'Из ProTour пришло отрицательное количество мест. Параметры квот:'
	set @str3 = 'Запрет на заезд не был проставлен, в связи с тем, что не существует квоты в Мастер-Туре. Параметры квот:'
	
	set @isErrorState = 0			
	set @uskey = 0 
	select @uskey = ISNULL(US_Key,0) from dbo.UserList where US_USERID = SYSTEM_USER
	
	declare @ptq_Id	int, @ptq_PartnerKey int, @ptq_HotelKey	int, @ptq_RoomCategoryKey int, @ptq_Date datetime,
	@ptq_State smallint, @ptq_CommitmentTotal int, @ptq_AllotmentTotal int, @ptq_Release int, @ptq_StopSale bit, -- 0 - квоты, 1 - стопы 
	@ptq_CancelStopSale bit, -- 1 - удаление стопов, 0 - добавление стопов 
	@ptq_IsByCheckin bit, -- признак "запрет заезда"
	@ptq_ErrorState tinyint -- если равен 1, то заново письмо менеджерам не отправляем
	
	-- ключи квот, которые нужно удалить
	declare @tmpDeleteQuotаs table(
		tmpQoid int,
		tmpQtid int
		)
	
	if (@quotesUpdate = 1 or @quotesUpdate is null)
	begin
		DECLARE qCur CURSOR FOR
		SELECT	PTQ_Id, Ptq_PartnerKey, Ptq_HotelKey, Ptq_RoomCategoryKey, Ptq_Date, Ptq_State, Ptq_CommitmentTotal, Ptq_AllotmentTotal, 
				Ptq_Release, Ptq_StopSale, Ptq_CancelStopSale, PTQ_ErrorState	
				FROM ProtourQuotes where 	PTQ_State not in (2, 6)
											and ((@hotelKey IS NOT NULL AND PTQ_HotelKey = @hotelKey) or (@hotelKey is null))
											--and PTQ_Date between @startDate and @endDate
											and PTQ_StopSale=0 
											and (PTQ_IsByCheckin <> 1 or PTQ_IsByCheckin is null)
		
		OPEN qCur
		FETCH NEXT FROM qCur INTO	@ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, 
							@ptq_CommitmentTotal, @ptq_AllotmentTotal, @ptq_Release, @ptq_StopSale, @ptq_CancelStopSale, @ptq_ErrorState
						
		WHILE @@FETCH_STATUS = 0
		BEGIN 
			BEGIN TRY
				if (@ptq_CommitmentTotal >= 0 or (@ptq_CommitmentTotal = 0 and @ptq_AllotmentTotal = 0))
				begin
					-- проверяем если сегодня закачки квот из ProTour не было (SYSExistsProtourQuotesHistory = 0), то если @ptq_State=3 проверяем наличие квоты в МТ 
					if (@ptq_State=1 or @ptq_State=3) -- если квота новая
					begin
						if not exists (select TOP 1 1
									from Quotas with(nolock)
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QT_ByRoom = 1
									and QT_IsByCheckIn = 0) 
							and (@ptq_CommitmentTotal > 0)
						begin
							insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment, QT_IsByCheckIn) 
							values (@ptq_PartnerKey, 1, '', 0)
							set @qtid = SCOPE_IDENTITY()
							
							insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
							values (@qtid, 3, @ptq_HotelKey, 0, @ptq_RoomCategoryKey)
							set @qoid = SCOPE_IDENTITY()
							
							insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
							values (@qtid, @ptq_Date, 2, nullif(@ptq_Release, 0), @ptq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
							set @qdid = SCOPE_IDENTITY()
					
							insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
							values (@qdid, @ptq_Date, @ptq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0) 
							
							update QuotaObjects
							set QO_CTKey = (select HD_CTKey from HotelDictionary where HD_Key = QO_Code)
							where QO_SVKey = 3 and QO_ID = @qoid and QO_CTKey is null
						
							update QuotaObjects
							set QO_CNKey= (select CT_CNKey from CityDictionary where CT_Key=QO_CTKey) 
							where QO_CNKey is null and QO_CTKey is not null and QO_ID = @qoid
							
							update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
						end
						else
						begin
							if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 2
									and QT_IsByCheckIn = 0)
							begin
								select @qdid = QD_ID, @qdbusy = QD_Busy 
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 2
									and QT_IsByCheckIn = 0
								
								if (@qdbusy > @ptq_CommitmentTotal)
								begin
									-- если число занятых мест в МТ больше числа мест пришедших из Протура, то в Places = Busy
									update QuotaDetails set QD_Places = QD_Busy, QD_Release = nullif(@ptq_Release, 0), QD_IsDeleted = null where QD_ID = @qdid 
									update QuotaParts set QP_Places = QP_Busy, QP_IsDeleted = null where QP_QDID = @qdid
									
									-- чтобы несколько раз письмо не отправлять	
									if (@ptq_ErrorState is null)
									begin
										-- и дальше отправляем письмо
										select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
										select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
										select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
										set @str = @str + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13) +
																	'Количество мест:' + convert(varchar(100),@ptq_CommitmentTotal) + CHAR(13)
										print @str
									end
									
									set @isErrorState = 1									
								end 
								else 
								begin
									-- если из Протура приходит 0 и в МТ кол-во занятых мест равно 0, то удаляем квоту, вне зависимости от значения кол-ва мест в МТ
									if (@ptq_CommitmentTotal = 0 and @qdbusy = 0) 
									begin
										update QuotaDetails
										set QD_IsDeleted = 4 -- Request
										where QD_ID = @qdid
											
										update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
									end
									else
									begin
										update QuotaDetails set QD_Places = @ptq_CommitmentTotal, QD_Release = nullif(@ptq_Release, 0), QD_IsDeleted = null where QD_ID = @qdid 
										update QuotaParts set QP_Places = @ptq_CommitmentTotal, QP_IsDeleted = null where QP_QDID = @qdid
										update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
									end
								end 
							end
							else
							begin
								if (@ptq_CommitmentTotal > 0)
								begin
								select top 1 @qtid = QT_ID, @qoid = QO_ID 
									from Quotas with(nolock)
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QT_ByRoom = 1
									and QT_IsByCheckIn = 0
									order by QT_ID	
									
									insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
									values (@qtid, @ptq_Date, 2, nullif(@ptq_Release, 0), @ptq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
									set @qdid = SCOPE_IDENTITY()
						
									insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
									values (@qdid, @ptq_Date, @ptq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
									
									update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
								end								
							end
						end
					end
					
					if (@ptq_State=4) --удаляемая
					begin 
						update QuotaDetails
						set QD_IsDeleted = 4 -- Request
						from Quotas join QuotaDetails on QT_ID = QD_QTID
						join QuotaObjects on QT_ID = QO_QTID
						where QT_PRKey = @ptq_PartnerKey
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QD_Date = @ptq_Date
							and QT_ByRoom = 1
							and QD_Type = 2
							and QT_IsByCheckIn = 0
						
						insert into @tmpDeleteQuotаs (tmpQoid) 
						SELECT	QO_ID	
							FROM QuotaObjects join Quotas on QO_QTID = QT_ID
							where not exists (select 1 from StopSales where SS_QOID = QO_ID)
							and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QT_ByRoom = 1	
							and QT_IsByCheckIn = 0
						
						insert into @tmpDeleteQuotаs (tmpQtid) 
						SELECT	QT_ID	
							from Quotas join QuotaObjects on QT_ID = QO_QTID
							where not exists (select 1 from QuotaObjects where QO_QTID = QT_ID)
							and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
							and QT_ByRoom = 1 and QT_IsByCheckIn = 0
						
						delete ProtourQuotes where PTQ_Id = @ptq_Id
					end
				end 
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage2 as nvarchar(max)
				SET @errorMessage2 = 'Error in SyncProtourQuotes commitment: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage2)
			END CATCH
			
			BEGIN TRY
				if (@ptq_AllotmentTotal >= 0 or (@ptq_CommitmentTotal = 0 and @ptq_AllotmentTotal = 0)) 
				begin
					-- проверяем если сегодня закачки квот из ProTour не было (SYSExistsProtourQuotesHistory = 0), то если @ptq_State=3 проверяем наличие квоты в МТ 
					if (@ptq_State=1 or @ptq_State=3) -- если квота новая
					begin
						if not exists (select TOP 1 1
									from Quotas with(nolock) 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QT_ByRoom = 1
									and QT_IsByCheckIn = 0) 
							and (@ptq_AllotmentTotal > 0) 
						begin
							insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment, QT_IsByCheckIn) 
							values (@ptq_PartnerKey, 1, '', 0)
							set @qtid = SCOPE_IDENTITY()
							
							insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
							values (@qtid, 3, @ptq_HotelKey, 0, @ptq_RoomCategoryKey)
							set @qoid = SCOPE_IDENTITY()
							
							insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
							values (@qtid, @ptq_Date, 1, nullif(@ptq_Release, 0), @ptq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
							set @qdid = SCOPE_IDENTITY()
					
							insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
							values (@qdid, @ptq_Date, @ptq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0) 
							
							update QuotaObjects
							set QO_CTKey = (select HD_CTKey from HotelDictionary where HD_Key = QO_Code)
							where QO_SVKey = 3 and QO_ID = @qoid and QO_CTKey is null
						
							update QuotaObjects
							set QO_CNKey= (select CT_CNKey from CityDictionary where CT_Key=QO_CTKey) 
							where QO_CNKey is null and QO_CTKey is not null and QO_ID = @qoid
							
							update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
						end
						else
						begin
							if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0)
							begin
								select @qdid = QD_ID, @qdbusy = QD_Busy 
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0
									
								if (@qdbusy > @ptq_AllotmentTotal)
								begin
									-- если число занятых мест в МТ больше числа мест пришедших из Протура, то в Places = Busy
									update QuotaDetails set QD_Places = QD_Busy, QD_Release = nullif(@ptq_Release, 0), QD_IsDeleted = null where QD_ID = @qdid 
									update QuotaParts set QP_Places = QP_Busy, QP_IsDeleted = null where QP_QDID = @qdid
									
									-- чтобы несколько раз письмо не отправлять	
									if (@ptq_ErrorState is null)
									begin									
										-- и дальше отправляем письмо
										select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
										select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
										select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
										set @str = @str + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13) +
																	'Количество мест:' + convert(varchar(100),@ptq_AllotmentTotal) + CHAR(13)																											
									end	
									
									set @isErrorState = 1								
								end 
								else 
								begin
									-- если из Протура приходит 0 и в МТ кол-во занятых мест равно 0, то удаляем квоту, вне зависимости от значения кол-ва мест в МТ
									if (@ptq_AllotmentTotal = 0 and @qdbusy = 0) 
									begin
										update QuotaDetails
										set QD_IsDeleted = 4 -- Request
										where QD_ID = @qdid
											
										update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
									end
									else
									begin
										update QuotaDetails set QD_Places = @ptq_AllotmentTotal, QD_Release = nullif(@ptq_Release, 0), QD_IsDeleted = null where QD_ID = @qdid 
										update QuotaParts set QP_Places = @ptq_AllotmentTotal, QP_IsDeleted = null where QP_QDID = @qdid
										update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
									end									
								end 
							end
							else
							begin
								if (@ptq_AllotmentTotal > 0) 
								begin
								select top 1 @qtid = QT_ID, @qoid = QO_ID 
									from Quotas with(nolock) 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @ptq_RoomCategoryKey
									and QT_ByRoom = 1
									and QT_IsByCheckIn = 0
									order by QT_ID	
									
									insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
									values (@qtid, @ptq_Date, 1, nullif(@ptq_Release, 0), @ptq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
									set @qdid = SCOPE_IDENTITY()
						
									insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
									values (@qdid, @ptq_Date, @ptq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
									
									update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
								end 							
							end
						end
					end
					
					if (@ptq_State=4) --удаляемая
					begin 
						update QuotaDetails
						set QD_IsDeleted = 4 -- Request
						from Quotas join QuotaDetails on QT_ID = QD_QTID
						join QuotaObjects on QT_ID = QO_QTID
						where QT_PRKey = @ptq_PartnerKey
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QD_Date = @ptq_Date
							and QT_ByRoom = 1
							and QD_Type = 1
							and QT_IsByCheckIn = 0
			
						insert into @tmpDeleteQuotаs (tmpQoid) 
						SELECT	QO_ID	
							from QuotaObjects join Quotas on QO_QTID = QT_ID
							where not exists (select 1 from StopSales where SS_QOID = QO_ID)
							and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
							and QO_SVKey = 3
							and QO_Code = @ptq_HotelKey
							and QO_SubCode1 = 0
							and QO_SubCode2 = @ptq_RoomCategoryKey
							and QT_ByRoom = 1
							and QT_IsByCheckIn = 0
						
						insert into @tmpDeleteQuotаs (tmpQtid) 
						SELECT	QT_ID	
							from Quotas join QuotaObjects on QT_ID = QO_QTID
							where not exists (select 1 from QuotaObjects where QO_QTID = QT_ID)
							and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
							and QT_ByRoom = 1 and QT_IsByCheckIn = 0
						
						delete ProtourQuotes where PTQ_Id = @ptq_Id
					end
				end
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage3 as nvarchar(max)
				SET @errorMessage3 = 'Error in SyncProtourQuotes allotment: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage3)
			END CATCH
			
			if (@ptq_CommitmentTotal < 0 and @ptq_AllotmentTotal < 0 and @ptq_State in (1,3))
			begin
				-- и дальше отправляем письмо
				select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
				select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
				select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
				set @str1 = @str1 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
														'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
														'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
														'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13) +
														'Количество мест:' + convert(varchar(100),@ptq_AllotmentTotal) + CHAR(13)
				print @str1
				
				update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
			end
			
			-- рассадка в квоты по раннее оформленным услугам, т.е. зажаем в квоты услуги, которые сидят на запросе
			if exists (select TOP 1 1
						from Dogovorlist with(nolock) join HotelRooms with(nolock) on DL_SUBCODE1 = HR_KEY
						where dl_svkey = 3
						and dl_code = @ptq_HotelKey
						and ((@ptq_RoomCategoryKey = 0) or (HR_RCKEY = @ptq_RoomCategoryKey))
						and (select COALESCE(min(SD_State), 4) from ServiceByDate where SD_DLKey = DL_Key) = 4
						and @ptq_Date between DL_DateBeg and DL_DATEEND)
			begin
				exec ProtourSetServiceToQuota @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date
			end
			
			if (@isErrorState = 1)
			begin
				-- проставляем PTQ_ErrorState = 1, чтобы не отправлять в след раз письмо, так оно уже было отправлено в первый раз
				-- проставляем Ptq_CommitmentTotal = -1 и Ptq_AllotmentTotal = -1, чтобы запись снова смогла загрузиться из плагина Протура  
				update ProtourQuotes set PTQ_ErrorState = 1, PTQ_State = 6, Ptq_CommitmentTotal = -1, Ptq_AllotmentTotal = -1 
				where PTQ_Id = @ptq_Id	
			end
			else if (@isErrorState = 0 and @ptq_CommitmentTotal <= 0 and @ptq_AllotmentTotal <= 0)
			begin
				update ProtourQuotes set PTQ_State = 2, PTQ_ErrorState = null where PTQ_Id = @ptq_Id
			end
			
			set @isErrorState = 0
		
			FETCH NEXT FROM qCur INTO @ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, 
							@ptq_CommitmentTotal, @ptq_AllotmentTotal, @ptq_Release, @ptq_StopSale, @ptq_CancelStopSale, @ptq_ErrorState
						
		END
		CLOSE qCur
		DEALLOCATE qCur	
		
		-- удаление квот
		exec QuotaDetailAfterDelete
		
		delete QuotaObjects where QO_ID in (select tmpQoid from @tmpDeleteQuotаs)
		delete Quotas where QT_ID in (select tmpQtid from @tmpDeleteQuotаs)
		--
				
		BEGIN TRY
			if exists (select 1 from SystemSettings where SS_ParmName='SYSEmailProtourQuotes')
				select @email = SS_ParmValue from SystemSettings where SS_ParmName='SYSEmailProtourQuotes'
				
			if (@str <> 'Количество квот, полученное из ProTour меньше, чем число занятых мест. Параметры квот:')
			begin
				-- отправка письма, если количество квот, полученное из ProTour меньше, чем число занятых мест				
				insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
			end
			
			if (@str1 <> 'Из ProTour пришло отрицательное количество мест. Параметры квот:')
			begin
				-- отправка письма, если из ProTour пришло отрицательное количество мест
				insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str1, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
			end
		END TRY
		BEGIN CATCH
			DECLARE @errorMessage4 as nvarchar(max)
			SET @errorMessage4 = 'Error in SyncProtourQuotes insert Blanks: ' + ERROR_MESSAGE()
			
			INSERT INTO SystemLog (sl_date, sl_message)
			VALUES (getdate(), @errorMessage4)
		END CATCH
	end
	--обрабатываем стопы
	if (@quotesUpdate = 0 or @quotesUpdate is null) 
	begin
		declare @tmpQuotаs table(
		ptqId int,
		ptqPartnerKey int,
		ptqHotelKey int,
		ptqRoomCategoryKey int,
		ptqDate datetime,
		ptqState smallint,
		ptqCommitmentTotal int,
		ptqAllotmentTotal int,
		ptqRelease int,
		ptqStopSale bit,
		ptqCancelStopSale bit
		)
		
		insert into @tmpQuotаs select * from
		(SELECT	PTQ_Id, Ptq_PartnerKey, Ptq_HotelKey, Ptq_RoomCategoryKey, Ptq_Date, Ptq_State, PTQ_CommitmentTotal, PTQ_AllotmentTotal, Ptq_Release, Ptq_StopSale, Ptq_CancelStopSale	
			FROM ProtourQuotes where (PTQ_HotelKey = @hotelKey or @hotelKey is null) and PTQ_StopSale=1 and PTQ_CancelStopSale = 0 and PTQ_State in (1, 3) and PTQ_Date < '2079-06-05'
			and (PTQ_IsByCheckin <> 1 or PTQ_IsByCheckin is null)
		) as innerQuotas 
		
		DECLARE qCur CURSOR FOR
		
		SELECT	PTQ_Id, Ptq_PartnerKey, Ptq_HotelKey, Ptq_RoomCategoryKey, Ptq_Date, Ptq_State, PTQ_CommitmentTotal, PTQ_AllotmentTotal, Ptq_Release, Ptq_StopSale, Ptq_CancelStopSale, PTQ_IsByCheckin	
			FROM ProtourQuotes where (PTQ_HotelKey = @hotelKey or @hotelKey is null) and PTQ_StopSale=1 and PTQ_State <> 2 and PTQ_Date < '2079-06-05'
										
		OPEN qCur
		FETCH NEXT FROM qCur INTO	@ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, @ptq_CommitmentTotal, @ptq_AllotmentTotal,
									@ptq_Release, @ptq_StopSale, @ptq_CancelStopSale, @ptq_IsByCheckin
						
		WHILE @@FETCH_STATUS = 0
		BEGIN
			BEGIN TRY
				if (@ptq_CommitmentTotal = 1 and @ptq_AllotmentTotal = 1)
				set @ss_allotmentAndCommitment = 1
				else if (@ptq_AllotmentTotal = 1 and @ptq_CommitmentTotal = 0) 
					set @ss_allotmentAndCommitment = 0
				else 
					set @ss_allotmentAndCommitment = 1
					
				if ((@ptq_State = 1 or @ptq_State = 3) and @ptq_CancelStopSale = 0 and (@ptq_IsByCheckin <> 1 or @ptq_IsByCheckin is null)) -- 0 - добавление стопов, 1 - удаление стопов
				begin
					if exists (select TOP 1 1 from QuotaObjects where QO_Code = @ptq_HotelKey and QO_SVKey = 3 and QO_SubCode1 = 0 and QO_SubCode2 = @ptq_RoomCategoryKey and QO_QTID is null) -- при передаче стопов, здесь лежит RM_Key
					begin
						if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @ptq_PartnerKey
								and QO_Code = @ptq_HotelKey
								and SS_Date = @ptq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3) -- при передаче стопов, здесь лежит RM_Key
						begin
							select @qoid = QO_ID from QuotaObjects where QO_Code = @ptq_HotelKey and QO_SVKey = 3 and QO_SubCode1 = 0 and QO_SubCode2 = @ptq_RoomCategoryKey and QO_QTID is null 
							
							insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey, SS_LastUpdate)
								values (@qoid, null, @ptq_PartnerKey, @ptq_Date, @ss_allotmentAndCommitment, '', GETDATE(), ISNULL(@uskey,0), GETDATE())
								
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else if exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @ptq_PartnerKey
								and QO_Code = @ptq_HotelKey
								and SS_Date = @ptq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3
								and SS_IsDeleted = 1)
						begin
							update StopSales
							set SS_IsDeleted = 0
							from StopSales join QuotaObjects on SS_QOID=QO_ID
							where SS_PRKey = @ptq_PartnerKey
								and QO_Code = @ptq_HotelKey
								and SS_Date = @ptq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3
								and SS_IsDeleted = 1
							
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id								
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id	
							-- временно, для того чтобы отловить ошибку
							if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @ptq_PartnerKey
								and QO_Code = @ptq_HotelKey
								and SS_Date = @ptq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3)	
							begin
								DECLARE @errorMessage as nvarchar(max)
								SET @errorMessage = 'Error in SyncProtourQuotes stop (not exists):  ' + convert(nvarchar(max), @ptq_Id)

								INSERT INTO SystemLog (sl_date, sl_message)
								VALUES (getdate(), @errorMessage)
								
								update ProtourQuotes set PTQ_State = 3 where PTQ_Id = @ptq_Id	
							end
							--	
						end										
					end
					else
					begin
						insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
						values (null, 3, @ptq_HotelKey, 0, @ptq_RoomCategoryKey)
						set @qoid = SCOPE_IDENTITY()
						
						insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey, SS_LastUpdate)
								values (@qoid, null, @ptq_PartnerKey, @ptq_Date, @ss_allotmentAndCommitment, '', GETDATE(), ISNULL(@uskey,0), GETDATE())
								
						update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
					end
					
					-- временно, для того чтобы отловить ошибку
					if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
						where SS_PRKey = @ptq_PartnerKey
						and QO_Code = @ptq_HotelKey
						and SS_Date = @ptq_Date
						and QO_SubCode1 = 0
						and QO_SubCode2 = @ptq_RoomCategoryKey
						and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
						and QO_QTID is null
						and QO_SVKey = 3)	
					begin
						DECLARE @errorMessage1 as nvarchar(max)
						SET @errorMessage1 = 'Error in SyncProtourQuotes stop (not exists):  ' + convert(nvarchar(max), @ptq_Id)

						INSERT INTO SystemLog (sl_date, sl_message)
						VALUES (getdate(), @errorMessage1)
								
						update ProtourQuotes set PTQ_State = 3 where PTQ_Id = @ptq_Id	
					end
					--
							
					update QuotaObjects
							set QO_CTKEY = (select HD_CTKEY from HotelDictionary where HD_KEY = QO_Code)
							where QO_ID = @qoid
						
					update QuotaObjects
							set QO_CNKey = (select CT_CNKEY from CityDictionary where CT_KEY = QO_CTKey)
							where QO_CNKey is null
							and QO_CTKey is not null
							and QO_ID = @qoid
				end
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage_1 as nvarchar(max)
				SET @errorMessage_1 = 'Error in SyncProtourQuotes stop: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage_1)
			END CATCH
			BEGIN TRY
				if ((@ptq_State = 1 or @ptq_State = 3) and @ptq_CancelStopSale = 1 and (@ptq_IsByCheckin <> 1 or @ptq_IsByCheckin is null)) 
				begin
					if (@ptq_CommitmentTotal = 1 and @ptq_AllotmentTotal = 1)
						set @ss_allotmentAndCommitment = 2
					else if (@ptq_AllotmentTotal = 1 and @ptq_CommitmentTotal = 0) 
						set @ss_allotmentAndCommitment = 0
					else if (@ptq_AllotmentTotal = 0 and @ptq_CommitmentTotal = 1) 
						set @ss_allotmentAndCommitment = 1
						
					if (@ss_allotmentAndCommitment = 0 or @ss_allotmentAndCommitment = 1)
					begin
						if exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID = QO_ID
						where QO_Code = @ptq_HotelKey
						and QO_SVKey = 3
						and SS_Date = @ptq_Date
						and SS_PRKey = @ptq_PartnerKey
						and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
						and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
						and QO_QTID is null)
						begin
							delete StopSales
							from StopSales join QuotaObjects on SS_QOID = QO_ID
							where QO_Code = @ptq_HotelKey
							and QO_SVKey = 3
							and SS_Date = @ptq_Date
							and SS_PRKey = @ptq_PartnerKey
							and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
							and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
							and QO_QTID is null
						
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							print 'Стоп-сейл был уже ранее удален'
						end
					end
					else if (@ss_allotmentAndCommitment = 2) -- если пришла отмена на все (на allotment+commitment и на allotment)
					begin
						if exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID = QO_ID
						where QO_Code = @ptq_HotelKey
						and QO_SVKey = 3
						and SS_Date = @ptq_Date
						and SS_PRKey = @ptq_PartnerKey
						and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
						and QO_QTID is null)
						begin
							delete StopSales
							from StopSales join QuotaObjects on SS_QOID = QO_ID
							where QO_Code = @ptq_HotelKey
							and QO_SVKey = 3
							and SS_Date = @ptq_Date
							and SS_PRKey = @ptq_PartnerKey
							and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
							and QO_QTID is null
						
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							print 'Стоп-сейл был уже ранее удален'
						end				
					end
				end
				if (@ptq_State = 4 and @ptq_CancelStopSale = 1)
				begin
					delete ProtourQuotes where PTQ_Id = @ptq_Id
				end
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage9 as nvarchar(max)
				SET @errorMessage9 = 'Error in SyncProtourQuotes cancel stop: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage9)
			END CATCH
			
			-- запретить заезд, т.е если @ptq_IsByCheckin = 1
			BEGIN TRY			
				if (@ptq_IsByCheckin = 1 and (@ptq_State = 1 or @ptq_State = 3) and (@ptq_CancelStopSale = 0 or @ptq_CancelStopSale is null))
				begin
					if (@ptq_CommitmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 2
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 1 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								and QT_IsByCheckIn = 0)
								
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)							
							
						end
						
					end
					if (@ptq_AllotmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 1 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 1
								and QT_IsByCheckIn = 0)
							
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)
						end
					end
				end
				
				--отправляем письмо
				if exists (select 1 from SystemSettings where SS_ParmName='SYSEmailProtourQuotes')
					select @email = SS_ParmValue from SystemSettings where SS_ParmName='SYSEmailProtourQuotes'
				
				if (@str3 <> 'Запрет на заезд не был проставлен, в связи с тем, что не существует квоты в Мастер-Туре. Параметры квот:')
				begin			
					insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str3, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
				end
			
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage_20 as nvarchar(max)
				SET @errorMessage_20 = 'Error in SyncProtourQuotes ByCheckin: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage_20)
			END CATCH
			
			-- отмена запрета на заезд, т.е если @ptq_IsByCheckin = 1 и @ptq_CancelStopSale = 1
			BEGIN TRY			
				if (@ptq_IsByCheckin = 1 and (@ptq_State = 1 or @ptq_State = 3) and @ptq_CancelStopSale = 1)
				begin
					if (@ptq_CommitmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 2
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 0 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								and QT_IsByCheckIn = 0)
								
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)				
							
						end						
					end
					if (@ptq_AllotmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @ptq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @ptq_HotelKey
									and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
									and QD_Date = @ptq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 0 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @ptq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @ptq_HotelKey
								and (QO_SubCode2 = @ptq_RoomCategoryKey or @ptq_RoomCategoryKey = 0)
								and QD_Date = @ptq_Date
								and QT_ByRoom = 1
								and QD_Type = 1
								and QT_IsByCheckIn = 0)
							
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
						end
						else
						begin
							update ProtourQuotes set PTQ_State = 2 where PTQ_Id = @ptq_Id
							
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @ptq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @ptq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @ptq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@ptq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@ptq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@ptq_Date, 105) + CHAR(13)
						end
					end
				end
				
				--отправляем письмо
				if exists (select 1 from SystemSettings where SS_ParmName='SYSEmailProtourQuotes')
					select @email = SS_ParmValue from SystemSettings where SS_ParmName='SYSEmailProtourQuotes'
				
				if (@str3 <> 'Запрет на заезд не был снят, в связи с тем, что не существует квоты в Мастер-Туре. Параметры квот:')
				begin			
					insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str3, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
				end
			
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage_21 as nvarchar(max)
				SET @errorMessage_21 = 'Error in SyncProtourQuotes cancel ByCheckin: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage_21)
			END CATCH
			
			FETCH NEXT FROM qCur INTO @ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, @ptq_CommitmentTotal, @ptq_AllotmentTotal,
							@ptq_Release, @ptq_StopSale, @ptq_CancelStopSale, @ptq_IsByCheckin
		END
		CLOSE qCur
		DEALLOCATE qCur
	end
	
	-- Контрольная проверка (проверяем попали ли записи из Протура в МТ). 
	DECLARE Cur CURSOR FOR
	select * from @tmpQuotаs
	
	OPEN Cur
	FETCH NEXT FROM Cur INTO	@ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, @ptq_CommitmentTotal, @ptq_AllotmentTotal,
								@ptq_Release, @ptq_StopSale, @ptq_CancelStopSale
						
	WHILE @@FETCH_STATUS = 0
	BEGIN
		if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @ptq_PartnerKey
								and QO_Code = @ptq_HotelKey
								and SS_Date = @ptq_Date
								and QO_SubCode2 = @ptq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3)
		begin
			DECLARE @error as nvarchar(max)
			SET @error = 'Error in SyncProtourQuotes stop not exists: ' + ERROR_MESSAGE() + convert(nvarchar(max), @ptq_Id)

			INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @error)
		end
		FETCH NEXT FROM Cur INTO @ptq_Id, @ptq_PartnerKey, @ptq_HotelKey, @ptq_RoomCategoryKey, @ptq_Date, @ptq_State, @ptq_CommitmentTotal, @ptq_AllotmentTotal,
								@ptq_Release, @ptq_StopSale, @ptq_CancelStopSale
	END
	CLOSE Cur
	DEALLOCATE Cur
	
	
	if not exists (select TOP 1 1 from History where (HI_Date between dateadd(dd,datediff(dd,0,getdate()),0) and getdate()) and HI_Text = 'Произошла закачка квот из ProtourQuotes')
	begin
		insert into History (HI_Date, HI_Text) values (getdate(), 'Произошла закачка квот из ProtourQuotes')
		--update SystemSettings set SS_ParmValue=convert(varchar(100), getdate(), 105) where SS_ParmName = 'SYSProtourQuotesHistory'
	end
															
END
GO
grant exec on [dbo].[LoadProtourQuotes] to public
go



/*********************************************************************/
/* end sp_LoadProtourQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_DogListToQuotas.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DogListToQuotas]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DogListToQuotas]
GO

CREATE PROCEDURE [dbo].[DogListToQuotas]
(
	--<VERSION>9.2</VERSION>
	--<DATA>27.06.2013</DATA>
@DLKey int,
	@SetQuotaCheck bit = null,			--если передается этот признак, то по услуге проверяются актуальные квоты, и в случае не актуальности номер/место снимается с квоты целиком и пытается поставиться на квоту заново
										--остальные квоты занимаемые услугой не снимаются, остаются как есть
	@SetQuotaRLKey int = null,
	@SetQuotaRPKey int = null,
	@SetQuotaQPID int = null,			--передается только из руч.режима (только для одной даты!!!!!!)	
	@SetQuotaDateBeg datetime = null,
	@SetQuotaDateEnd datetime = null,
	@SetQuotaAgentKey int = null, 
	@SetQuotaType smallint = null,		--при переходе на 2008.1 в этот параметр передается отрицательное число (-1 Allotment, -2 Коммитемент)
	@SetQuotaByRoom bit = null, 
	@SetQuotaPartner int = null, 
	@SetQuotaDuration smallint = null,
	@SetQuotaSubCode1 int = null,
	@SetQuotaSubCode2 int = null,
	@SetQuotaFilialKey int = null, 
	@SetQuotaCityDepartments int = null,
	@SetQuotaDateFirst datetime = null,
	@SetOkIfRequest bit = 0, -- запуск из тригера T_UpdDogListQuota
	@OldSetToQuota bit = 0, -- запустить старый механизм посадки
	@ToSetQuotaDateFrom datetime = null,
	@ToSetQuotaDateTo datetime = null
) 
AS

--insert into Debug (db_n1, db_n2, db_n3) values (@DLKey, @SetQuotaType, 999)
declare @SVKey int, @Code int, @SubCode1 int, @PRKey int, @AgentKey int, @DgKey int,
		@TourDuration int, @FilialKey int, @CityDepartment int,
		@ServiceDateBeg datetime, @ServiceDateEnd datetime, @Pax smallint, @IsWait smallint,@SVQUOTED smallint,
		@SdStateOld int, @SdStateNew int, @nHIID int, @dgCode nvarchar(10), @dlName nvarchar(max), @Long smallint
		
declare @sOldValue nvarchar(max), @sNewValue nvarchar(max)

-- если включена настройка то отрабатывает новый метод посадки и рассадки в квоту
if exists (select top 1 1 from SystemSettings where SS_ParmName = 'NewSetToQuota' and SS_ParmValue = 1) and @OldSetToQuota = 0
begin
	-- запоминаем старый статус услуги
	select @SdStateOld = max(SD_State) from ServiceByDate where SD_DLKey = @DLKey


	exec WcfSetServiceToQuota @DLKey, @SetQuotaType, @ToSetQuotaDateFrom, @ToSetQuotaDateTo
	
	-- находим новый статус
	select @SdStateNew = max(SD_State) from ServiceByDate where SD_DLKey = @DLKey

	-- устанавливаем новый статус
	Declare @dlControlNew int
	exec SetServiceStatusOk @DLKey, @dlControlNew output

	-- запись в историю, только если статус услуги поменялся
	if exists(select top 1 1 from SystemSettings where SS_ParmName like 'SYSServiceStatusToHistory' and SS_ParmValue = '1') and @SdStateOld != @SdStateNew
	begin
		IF ISNULL(@SdStateOld, 0) = 0
			SET @sOldValue = ''
		ELSE IF @SdStateOld = 1
			SET @sOldValue = 'Allotment'
		ELSE IF @SdStateOld = 2
			SET @sOldValue = 'Commitment'
		ELSE IF @SdStateOld = 3
			SET @sOldValue = 'Confirmed'
		ELSE IF @SdStateOld = 4
			SET @sOldValue = 'Wait'

		IF ISNULL(@SdStateNew, 0) = 0
			SET @sNewValue = ''
		ELSE IF @SdStateNew = 1
			SET @sNewValue = 'Allotment'
		ELSE IF @SdStateNew = 2
			SET @sNewValue = 'Commitment'
		ELSE IF @SdStateNew = 3
			SET @sNewValue = 'Confirmed'
		ELSE IF @SdStateNew = 4
			SET @sNewValue = 'Wait'

		EXEC @nHIID = dbo.InsHistory @dgCode, @DgKey, 19, '', 'UPD', @dlName, '', 0, ''
		EXECUTE dbo.InsertHistoryDetail @nHIID, 19001, @sOldValue, @sNewValue, @SdStateOld, @SdStateNew, '', '', 0
	end

	return;
end

SELECT	@SVKey=DL_SVKey, @Code=DL_Code, @SubCode1=DL_SubCode1, @PRKey=DL_PartnerKey, 
		@ServiceDateBeg=DL_DateBeg, @ServiceDateEnd=DL_DateEnd, @Pax=DL_NMen,
		@AgentKey=DG_PartnerKey, @TourDuration=DG_NDay, @FilialKey=DG_FilialKey, @CityDepartment=DG_CTDepartureKey, @IsWait=ISNULL(DL_Wait,0),
		@DgKey = DL_DGKEY,
		@dgCode = DG_CODE,
		@dlName = DL_NAME
FROM	DogovorList join Dogovor on DL_DGKey = DG_Key
WHERE	DL_Key = @DLKey

-- сохраним старое значение квотируемости
select @SdStateOld = MAX(SD_State) from ServiceByDate where SD_DLKey = @DLKey

if @IsWait=1 and (@SetQuotaType in (1,2) or @SetQuotaType is null)  --Установлен признак "Не снимать квоту при бронировании". На квоту не ставим
BEGIN
	UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null	-- изменение
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0 and @SVKey = 3
	begin
		exec SetStatusInRoom @dlkey
	end
	return 0
END

SELECT @SVQUOTED=isnull(SV_Quoted,0) from service where sv_key=@SVKEY
if @SVQUOTED=0
BEGIN
	UPDATE ServiceByDate SET SD_State=3 WHERE SD_DLKey=@DLKey	
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0 and @SVKey = 3
	begin
		exec SetStatusInRoom @dlkey
	end
	return 0
END

-- ДОБАВЛЕНА НАСТРОЙКА ЗАПРЕЩАЮЩАЯ СНЯТИЕ КВОТЫ ДЛЯ УСЛУГИ, 
-- ТАК КАК В КВОТАХ НЕТ РЕАЛЬНОЙ ИНФОРМАЦИИ, А ТОЛЬКО ПРИЗНАК ИХ НАЛИЧИЯ (ПЕРЕДАЕТСЯ ИЗ INTERLOOK)
IF (@SetQuotaType in (1,2) or @SetQuotaType is null) and  EXISTS (SELECT 1 FROM dbo.SystemSettings WHERE SS_ParmName='IL_SyncILPartners' and SS_ParmValue LIKE '%/' + CAST(@PRKey as varchar(20)) + '/%')
Begin
	UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0 and @SVKey = 3
	begin
		exec SetStatusInRoom @dlkey
	end
	return 0
End

-- проверим если это доп место в комнате, то ее нельзя посадить в квоты, сажаем внеквоты и эта квота за человека
if exists(select 1 from systemsettings where ss_parmname='SYSSetQuotaForAddPlaces' and SS_ParmValue=1)
begin
	if ( exists (select top 1 1 from ServiceByDate join RoomPlaces on SD_RPID = RP_ID where SD_DLKey = @DLKey and RP_Type = 1) and (@SetQuotaByRoom = 0))
	begin
		set @SetQuotaType = 3
	end
end

declare @Q_Count smallint, @Q_AgentKey int, @Q_Type smallint, @Q_ByRoom bit, 
		@Q_PRKey int, @Q_FilialKey int, @Q_CityDepartments int, @Q_Duration smallint, @Q_DateBeg datetime, @Q_DateEnd datetime, @Q_DateFirst datetime, @Q_SubCode1 int, @Q_SubCode2 int,
		@Query nvarchar(max), @SubQuery varchar(1500), @Current int, @CurrentString varchar(50), @QTCount_Need smallint, @n smallint, @Result_Exist bit, @nTemp smallint, @Quota_CheckState smallint, @dTemp datetime

--karimbaeva 19-04-2012  по умолчанию если не хватает квот на всех туристов, то ставим их всех на запрос, если установлена настройка 
-- SYSSetQuotaToTourist - 1 - ставим туристов на запрос, 0- снимаем квоты на кого хватает, остальных ставим на запрос
if not exists(select 1 from systemsettings where ss_parmname='SYSSetQuotaToTourist' and SS_ParmValue=0)
begin
	If exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null)
	BEGIN
	declare @QT_ByRoom_1 bit
	create table #DlKeys_1
	(
		dlKey int
	)

	insert into #DLKeys_1
		select dl_key 
		from dogovorlist 
		where dl_dgkey in (
							select dl_dgkey 
							from dogovorlist 
							where dl_key = @DLKey
						   )
		and dl_svkey = 3
		
		SELECT @QT_ByRoom_1=QT_ByRoom FROM Quotas,QuotaDetails,QuotaParts WHERE QD_QTID=QT_ID and QD_ID=QP_QDID 
		and QP_ID = (select top 1 SD_QPID
					from ServiceByDate join RoomPlaces on SD_RLID = RP_RLID  
					where RP_Type = 0 and sd_dlkey in (select dlKey from #DlKeys_1) and SD_RLID = (select TOP 1 SD_RLID from ServiceByDate where sd_dlkey=@DlKey))
		
		
		if (@QT_ByRoom_1=0 or @QT_ByRoom_1 is null)
		begin	
		SET @Q_DateBeg=@ServiceDateBeg
		SET @Q_DateEnd=@ServiceDateEnd
		SET @Q_DateFirst=@ServiceDateBeg
	
		EXEC dbo.[CheckQuotaExist] @SVKey, @Code, @SubCode1, @Q_DateBeg,
				@Q_DateEnd, @Q_DateFirst, @PRKey, @AgentKey, @TourDuration, 
				@FilialKey,	@CityDepartment, 2, @Pax,@IsWait, 
				@Quota_CheckState output, @dTemp output, @nTemp output,
				@Q_Count output, @Q_AgentKey output, @Q_Type output, @Q_ByRoom output, @Q_PRKey output, 
				@Q_FilialKey output, @Q_CityDepartments output,	@Q_Duration output, @Q_SubCode1 output, @Q_SubCode2 output
						
		if @Quota_CheckState = 0	
		begin
			UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null
			-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
			if @SetQuotaByRoom = 0 and @SVKey = 3
			begin
				exec SetStatusInRoom @dlkey
			end
			return 0
		end	
		end	
END
end 

--Если идет полная постановка услуги на квоту (@SetQuotaType is null) обычно после бронирования
--Или прошло удаление какой-то квоты и сейчас требуется освободить эту квоту и занять другую
--То требуется найти оптимально подходящую квоту и ее использовать

If @SetQuotaType is null or @SetQuotaType<0 --! @SetQuotaType<0 <--при переходе на 2008.1
BEGIN
	IF @SetQuotaCheck=1 
	begin
		UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey and SD_RPID in (SELECT DISTINCT SD_RPID FROM QuotaDetails,QuotaParts,ServiceByDate WHERE SD_QPID=QP_ID and QP_QDID=QD_ID and QD_IsDeleted=1 and SD_DLKey=@DLKey)
	end
	ELSE
	BEGIN
		IF @SetQuotaRLKey is not null
			UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey and SD_RLID=@SetQuotaRLKey
		ELSE IF @SetQuotaRPKey is not null
			UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey and SD_RPID=@SetQuotaRPKey
		ELSE
			UPDATE ServiceByDate SET SD_State=null, SD_QPID=null where SD_DLKey=@DLKey
	END
	SET @Q_DateBeg=@ServiceDateBeg
	SET @Q_DateEnd=@ServiceDateEnd
	SET @Q_DateFirst=@ServiceDateBeg
	IF @SetQuotaType=-1
		SET @Q_Type=1
	ELSE IF @SetQuotaType=-2
		SET @Q_Type=2
	
	EXEC dbo.[CheckQuotaExist] @SVKey, @Code, @SubCode1, @Q_DateBeg,
						@Q_DateEnd, @Q_DateFirst, @PRKey, @AgentKey, @TourDuration, 
						@FilialKey,	@CityDepartment, 1, @Pax, @IsWait,
						@nTemp output, @dTemp output, @nTemp output,
						@Q_Count output, @Q_AgentKey output, @Q_Type output, @Q_ByRoom output, @Q_PRKey output, 
						@Q_FilialKey output, @Q_CityDepartments output,	@Q_Duration output, @Q_SubCode1 output, @Q_SubCode2 output
END
ELSE
BEGIN
	IF @SetQuotaType=4 or @SetQuotaType=3  --если новый статус Wait-list или Ok(вне квоты), то меняем статус и выходим из хранимки
		Set @Q_Type=@SetQuotaType
	Else If @SetQuotaQPID is not null
	BEGIN
		If @SetQuotaType is not null and @SetQuotaType>=0
			Set @Q_Type=@SetQuotaType
		Else
			Select @Q_Type=QD_Type from QuotaDetails,QuotaParts Where QP_QDID=QD_ID and QP_ID=@SetQuotaQPID
	END
	Else
		Set @Q_Type=null		
	--@SetQuotaQPID это конкретная квота, ее заполнение возможно только из режима ручного постановки услуги на квоту
	IF @SetQuotaByRoom=1 and @SVKey=3
	BEGIN
		if @SetQuotaRLKey is null
		begin
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
		end
		else
		begin
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_RLID=@SetQuotaRLKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
		end
	END
	ELSE
	BEGIN
		if @SetQuotaRPKey is null
		begin
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
		end
		else
		begin
			UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=@SetQuotaQPID where SD_DLKey=@DLKey and SD_RPID=@SetQuotaRPKey and SD_Date between @SetQuotaDateBeg and @SetQuotaDateEnd
		end
	END
	IF @SetQuotaType=4 or @SetQuotaType=3 or @SetQuotaQPID is not null --собственно выход (либо не надо ставить на квоту либо квота конкретная)
	begin
		-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
		if @SetQuotaByRoom = 0 and @SVKey = 3
		begin
			exec SetStatusInRoom @dlkey
		end
		-- запускаем хранимку на установку статуса путевки
		--exec SetReservationStatus @DgKey
		return 0
	end

	--	select * from ServiceByDate where SD_DLKey=202618 and SD_RLID=740
	SET @Q_AgentKey=@SetQuotaAgentKey
	SET @Q_Type=@SetQuotaType
	SET @Q_ByRoom=@SetQuotaByRoom
	SET @Q_PRKey=@SetQuotaPartner
	SET @Q_FilialKey=@SetQuotaFilialKey
	SET @Q_CityDepartments=@SetQuotaCityDepartments
	SET @Q_Duration=@SetQuotaDuration
	SET @Q_SubCode1=@SetQuotaSubCode1
	SET @Q_SubCode2=@SetQuotaSubCode2
	SET @Q_DateBeg=@SetQuotaDateBeg
	SET @Q_DateEnd=@SetQuotaDateEnd
	SET @Q_DateFirst=ISNULL(@SetQuotaDateFirst,@Q_DateBeg)
	SET @Result_Exist=0	
END

set @n=0

If not exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null)
	print 'WARNING_DogListToQuotas_1'
If @Q_Count is null
	print 'WARNING_DogListToQuotas_2'
If @Result_Exist > 0
	print 'WARNING_DogListToQuotas_3'

CREATE table #StopSales (SS_QDID int,SS_QOID int,SS_DATE dateTime)
CREATE table #Quotas1(QP_ID int,QD_QTID int,QD_ID int,QO_ID int,QD_Release smallint,QP_Durations varchar(20),
	QD_Date DateTime,QP_IsNotCheckIn bit,QP_CheckInPlaces smallint,QP_CheckInPlacesBusy smallint,
	QP_Places smallint,QP_Busy smallint,QT_ID int,QO_QTID int,QO_SVKey int,QO_Code int,QO_SubCode1 int,QO_SubCode2 int)

DECLARE @DATETEMP datetime
SET @DATETEMP = GetDate()
-- Разрешим посадить в квоту с релиз периодом 0 текущим числом
set @DATETEMP = DATEADD(day, -1, @DATETEMP)

if exists (select top 1 1 from systemsettings where SS_ParmName='SYSCheckQuotaRelease' and SS_ParmValue=1) OR exists (select top 1 1 from systemsettings where SS_ParmName='SYSAddQuotaPastPermit' and SS_ParmValue=1 and @Q_DateFirst < @DATETEMP)
	SET @DATETEMP='10-JAN-1900'

IF exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null) and @n<5 and (@Q_Count is not null or @Result_Exist=0)
BEGIN
	SET @Long=DATEDIFF(DAY,@Q_DateBeg,@Q_DateEnd)+1
	
	insert into #Quotas1 (QP_ID,QD_QTID,QD_ID,QO_ID,QD_Release,QP_Durations,QD_Date,QP_IsNotCheckIn,QP_CheckInPlaces,QP_CheckInPlacesBusy,QP_Places,QP_Busy,QT_ID,QO_QTID,QO_SVKey,QO_Code,QO_SubCode1,QO_SubCode2)
		select QP_ID,QD_QTID,QD_ID,QO_ID,QD_Release,QP_Durations,QD_Date,QP_IsNotCheckIn,QP_CheckInPlaces,QP_CheckInPlacesBusy,QP_Places,QP_Busy,QT_ID,QO_QTID,QO_SVKey,QO_Code,QO_SubCode1,QO_SubCode2
		FROM QuotaParts as QP1
		inner join QuotaDetails as QD1 on QP_QDID=QD_ID and QD_Date = QP_Date
		inner join Quotas on QT_ID=QD_QTID
		inner join QuotaObjects on QO_QTID=QT_ID
		WHERE QD_Type=@Q_Type
		and QT_ByRoom=@Q_ByRoom
		and QD_IsDeleted is null
		and QP_IsDeleted is null
		and QO_SVKey=@SVKey
		and QO_Code=@Code
		and QO_SubCode1=@Q_SubCode1
		and QO_SubCode2=CASE WHEN @SVKey=3 THEN @Q_SubCode2 ELSE QO_SubCode2 END
		and ISNULL(QP_FilialKey, -100) = ISNULL(@Q_FilialKey, -100)
		and ISNULL(QP_CityDepartments, -100) = ISNULL(@Q_CityDepartments, -100)
		and ISNULL(QP_AgentKey, -100) = ISNULL(@Q_AgentKey, -100)
		and ISNULL(QT_PRKey, -100) = ISNULL(@Q_PRKey, -100)
		and QP_Durations = CASE WHEN @Q_Duration=0 THEN '' ELSE QP_Durations END
		and QD_Date between @Q_DateBeg and DATEADD(DAY,@Long,@Q_DateBeg)
		and (QP_Places-QP_Busy) > 0
		and (isnull(QP_Durations, '') = ''
		or (isnull(QP_Durations, '') != '' and (QP_IsNotCheckIn = 1 or QP_CheckInPlaces - QP_CheckInPlacesBusy > 0))
		or (isnull(QP_Durations, '') != '' and (QP_IsNotCheckIn = 0 or QP_Places - QP_Busy > 0))
		or (isnull(QP_Durations, '') != '' and QD_Date = @Q_DateFirst))
		and (QD1.QD_Date > @DATETEMP + ISNULL(QD1.QD_Release,-1) OR (QD1.QD_Date < getdate() - 1))
		and ((QP_IsNotCheckIn = 0) or (QP_IsNotCheckIn = 1 and exists (select top 1 1 from QuotaDetails as tblQD
																		inner join QuotaParts as tblQP
																		on tblQP.QP_QDID = tblQD.QD_ID and tblQP.QP_Date = tblQD.QD_Date
																		where tblQP.QP_IsNotCheckIn = 0
																		and tblQD.QD_Date=@Q_DateFirst
																		and tblQD.QD_QTID=QD1.QD_QTID)))
		and QP_ID not in
		(SELECT QP_ID FROM QuotaParts QP2 inner join QuotaDetails QD2 on QP_QDID=QD_ID and QD_Date=QP_Date inner join Quotas QT2 on QT_ID=QD_QTID
			WHERE QD2.QD_Type=@Q_Type
			and QT2.QT_ByRoom=@Q_ByRoom
			and QD2.QD_IsDeleted is null
			and QP2.QP_IsDeleted is null
			and ISNULL(QP2.QP_FilialKey, -100) = ISNULL(@Q_FilialKey, -100)
			and ISNULL(QP2.QP_CityDepartments, -100) = ISNULL(@Q_CityDepartments, -100)
			and ISNULL(QP2.QP_AgentKey, -100) = ISNULL(@Q_AgentKey, -100)
			and ISNULL(QT2.QT_PRKey, -100) = ISNULL(@Q_PRKey, -100)
			and ((@Q_Duration=0 and QP2.QP_Durations = '') or (@Q_Duration <> 0 and QP2.QP_ID in (Select QL_QPID From QuotaLimitations Where QL_Duration = @Q_Duration)))
			and QD2.QD_Date=@Q_DateFirst
			and (QP2.QP_IsNotCheckIn=1 or QP2.QP_CheckInPlaces-QP2.QP_CheckInPlacesBusy <= 0)
			and QO_QTID=QT2.QT_ID
			and ISNULL(QD2.QD_Release,0)=ISNULL(QD1.QD_Release,0)
			and QP2.QP_Durations COLLATE DATABASE_DEFAULT = QP1.QP_Durations COLLATE DATABASE_DEFAULT)
	
	if (@Q_Duration<>0)
	begin
		delete from #Quotas1 where QP_ID not in (Select QL_QPID From QuotaLimitations Where QL_Duration=@Q_Duration)
	end
	
	insert into #StopSales SELECT SS_QDID, SS_QOID, SS_Date FROM StopSales inner join #Quotas1 on SS_QOID=#Quotas1.QO_ID and SS_QDID=#Quotas1.QD_ID WHERE isnull(SS_IsDeleted, 0) = 0
	
	delete from #Quotas1 where exists (SELECT top 1 1 FROM #StopSales WHERE SS_QDID=QD_ID and SS_QOID=QO_ID and SS_Date=QD_Date)
END

WHILE exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null and SD_Date between @ServiceDateBeg and @ServiceDateEnd) and @n<5 and (@Q_Count is not null or @Result_Exist=0)
BEGIN
	DECLARE @n1 smallint, @n2 smallint, @prev bit, @durations_prev varchar(25), @release_prev smallint, @QP_ID int, @SK_Current int, @Temp smallint, @Error bit
	DECLARE @ServiceKeys Table (SK_ID int identity(1,1), SK_Key int, SK_QPID int, SK_Date smalldatetime)
	
	set @n=@n+1
	
	IF (@SetQuotaType is null or @SetQuotaType < 0) --! @SetQuotaType<0 <--при переходе на 2008.1
	BEGIN
		IF (@Q_ByRoom = 1)
			INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT SD_RLID, SD_Date FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null
		ELSE
			INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT SD_RPID, SD_Date FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null
	END
	ELSE IF @Q_ByRoom=1
	BEGIN
		INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT SD_RLID, SD_Date FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_RLID=@SetQuotaRLKey and SD_State is null
	END
	ELSE IF @Q_ByRoom=0
	BEGIN
		INSERT INTO @ServiceKeys (SK_Key,SK_Date) SELECT DISTINCT SD_RPID, SD_Date FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_RPID=@SetQuotaRPKey and SD_State is null
	END
	
	SET @Error=0
	SELECT @SK_Current=MIN(SK_Key) FROM @ServiceKeys WHERE SK_QPID is null
		
	WHILE @SK_Current is not null and @Error=0
	BEGIN
		SET @n1=1
		
		WHILE @n1<=@Long and @Error=0
		BEGIN
			SET @QP_ID=null
			SET @n2=0
			
			WHILE (@QP_ID is null) and @n2<2
			BEGIN
				IF @prev=1
					SELECT TOP 1 @QP_ID=QP_ID, @durations_prev=QP_Durations, @release_prev=QD_Release
						FROM #Quotas1 AS Q1
						WHERE QD_Date=DATEADD(DAY,@n1-1,@Q_DateBeg) and QP_Durations=@durations_prev and QD_Release=@release_prev
						ORDER BY ISNULL(QD_Release,0) DESC, (select count(distinct QD_QTID) from QuotaDetails as QDP
																join QuotaParts as QPP on QDP.QD_ID = QPP.QP_QDID and QDP.QD_Date = QPP.QP_Date
																where exists (select top 1 1 from @ServiceKeys as SKP
																				where SKP.SK_QPID = QPP.QP_ID)
																and QDP.QD_QTID = Q1.QD_QTID)
						DESC
				ELSE
					SELECT TOP 1 @QP_ID=QP_ID, @durations_prev=QP_Durations, @release_prev=QD_Release
						FROM #Quotas1 as Q1
						WHERE QD_Date=DATEADD(DAY,@n1-1,@Q_DateBeg)
						ORDER BY ISNULL(QD_Release,0) DESC, (select count(distinct QD_QTID) from QuotaDetails as QDP
																join QuotaParts as QPP on QDP.QD_ID = QPP.QP_QDID and QDP.QD_Date = QPP.QP_Date
																where exists (select top 1 1 from @ServiceKeys as SKP
																				where SKP.SK_QPID = QPP.QP_ID)
																and QDP.QD_QTID = Q1.QD_QTID)
						DESC
				
				SET @n2=@n2+1
				
				IF @QP_ID is null
				BEGIN
					SET @prev=1
					SET @Error=1
				END
				ELSE
					UPDATE @ServiceKeys SET SK_QPID=@QP_ID WHERE SK_Key=@SK_Current and SK_Date=DATEADD(DAY,@n1-1,@Q_DateBeg)
				END
				
				SET @n1=@n1+1
			END
			
			IF @Error=0
				begin
				IF @Q_ByRoom = 1
				begin
					if exists(select 1 from systemsettings where ss_parmname='SYSSetQuotaToTourist' and SS_ParmValue=0)
					begin
						UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=(SELECT SK_QPID FROM @ServiceKeys join QuotaParts on SK_QPID=QP_ID WHERE SK_Date=SD_Date and SK_Key=SD_RLID and QP_Places-QP_Busy>0) WHERE SD_DLKey=@DLKey and SD_RLID=@SK_Current and SD_State is null
							 and SD_Date between @ServiceDateBeg and @ServiceDateEnd
					end
					else
					begin
							UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=(SELECT SK_QPID FROM @ServiceKeys WHERE SK_Date=SD_Date and SK_Key=SD_RLID) WHERE SD_DLKey=@DLKey and SD_RLID=@SK_Current and SD_State is null
							 and SD_Date between @ServiceDateBeg and @ServiceDateEnd
					end
				end
				ELSE
				begin
					if exists(select 1 from systemsettings where ss_parmname='SYSSetQuotaToTourist' and SS_ParmValue=0)
					begin
						UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=(SELECT SK_QPID FROM @ServiceKeys join QuotaParts on SK_QPID=QP_ID WHERE SK_Date=SD_Date and SK_Key=SD_RPID and QP_Places-QP_Busy>0) WHERE SD_DLKey=@DLKey and SD_RPID=@SK_Current and SD_State is null
							and SD_Date between @ServiceDateBeg and @ServiceDateEnd
					end
					else
					begin
						UPDATE ServiceByDate SET SD_State=@Q_Type, SD_QPID=(SELECT SK_QPID FROM @ServiceKeys WHERE SK_Date=SD_Date and SK_Key=SD_RPID) WHERE SD_DLKey=@DLKey and SD_RPID=@SK_Current and SD_State is null
							and SD_Date between @ServiceDateBeg and @ServiceDateEnd
					end
				end
			end
		SET @SK_Current=null
		SELECT @SK_Current=MIN(SK_Key) FROM @ServiceKeys WHERE SK_QPID is null
	END
	
	set @n=@n+1
	--все квоты уже заняты (такие услуги попали в условие QP_Places-QP_Busy>0), для оставшихся проставляем статус запрос
	UPDATE ServiceByDate SET SD_State = 4 where SD_DLKey=@DLKey and SD_QPID is null

	declare @@SVKey int, @RPType int, @SDState int, @QTByRoom bit
	
	SELECT top 1 @QTByRoom = QT_ByRoom 
		FROM Quotas
		join QuotaObjects on QT_ID = QO_QTID
		where QO_Code = @Code
		and QO_SVKey = 3
	
	-- Хранимка в зависисмости от статусов, основных мест в комнате устанавливает статус квотирования на доп местах
	if @SetQuotaByRoom = 0 and @SVKey = 3 and @QTByRoom = 0
	begin
		exec SetStatusInRoom @dlkey
	end

	--если @SetQuotaType is null -значит это начальная постановка услги на квоту и ее надо делать столько раз
	--сколько номеров или людей в услуге.
	If @SetQuotaType is null or @SetQuotaType<0 --! @SetQuotaType<0 <--при переходе на 2008.1
	BEGIN		
		If exists (SELECT top 1 1 FROM ServiceByDate WHERE SD_DLKey=@DLKey and SD_State is null)
		BEGIN
			EXEC dbo.[CheckQuotaExist] @SVKey, @Code, @SubCode1, @Q_DateBeg,
						@Q_DateEnd, @Q_DateFirst, @PRKey, @AgentKey, @TourDuration, 
						@FilialKey,	@CityDepartment, 1, @Pax,@IsWait, 
						@nTemp output, @dTemp output, @nTemp output,
						@Q_Count output, @Q_AgentKey output, @Q_Type output, @Q_ByRoom output, @Q_PRKey output, 
						@Q_FilialKey output, @Q_CityDepartments output,	@Q_Duration output, @Q_SubCode1 output, @Q_SubCode2 output
		END
	END	
	ELSE --а если @SetQuotaType is not null -значит ставим на услугу конкретное место, а раз так то оно должно встать на квоту должно было с первого раза, устанавливаем бит выхода.	
		SET @Result_Exist=1		--бит выхода
END

if exists(select top 1 1 from ServiceByDate where SD_DLKey=@DLKey and SD_State is null) and @SVKey = 3
begin
	exec SetStatusInRoom @dlkey
end

drop table #StopSales
drop table #Quotas1

UPDATE ServiceByDate SET SD_State=4 WHERE SD_DLKey=@DLKey and SD_State is null

-- сохраним новое значение квотируемости
select @SdStateNew = MAX(SD_State) from ServiceByDate where SD_DLKey = @DLKey

-- запись в историю
if exists(select top 1 1 from SystemSettings where SS_ParmName like 'SYSServiceStatusToHistory' and SS_ParmValue = '1')
begin
	IF ISNULL(@SdStateOld, 0) = 0
		SET @sOldValue = ''
	ELSE IF @SdStateOld = 1
		SET @sOldValue = 'Allotment'
	ELSE IF @SdStateOld = 2
		SET @sOldValue = 'Commitment'
	ELSE IF @SdStateOld = 3
		SET @sOldValue = 'Confirmed'
	ELSE IF @SdStateOld = 4
		SET @sOldValue = 'Wait'

	IF ISNULL(@SdStateNew, 0) = 0
		SET @sNewValue = ''
	ELSE IF @SdStateNew = 1
		SET @sNewValue = 'Allotment'
	ELSE IF @SdStateNew = 2
		SET @sNewValue = 'Commitment'
	ELSE IF @SdStateNew = 3
		SET @sNewValue = 'Confirmed'
	ELSE IF @SdStateNew = 4
		SET @sNewValue = 'Wait'

	EXEC @nHIID = dbo.InsHistory @dgCode, @DgKey, 19, '', 'UPD', @dlName, '', 0, ''
	EXECUTE dbo.InsertHistoryDetail @nHIID, 19001, @sOldValue, @sNewValue, @SdStateOld, @SdStateNew, '', '', 0
end

-- 2012-10-12 tkachuk, task 8473 - меняем статус для услуг, привязанных к изменившимся квотам
DECLARE @dlControl int
EXEC dbo.SetServiceStatusOk @DlKey,@dlControl

GO

GRANT EXEC ON [dbo].[DogListToQuotas] TO PUBLIC
GO
/*********************************************************************/
/* end sp_DogListToQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_ServiceByDateChanged.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='TR' and name='T_ServiceByDateChanged')
	-- удаляю лишний триггер
	drop trigger dbo.T_ServiceByDateChanged
go

CREATE TRIGGER [dbo].[T_ServiceByDateChanged] ON [dbo].[ServiceByDate]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-06-17</DATE>
--<VERSION>2009.2.20.0</VERSION>
DECLARE @sMod varchar(3), @nHIID int, @sDGCode varchar(10), @nDGKey int, @sDLName varchar(150), @sTemp varchar(25), @sTemp2 varchar(255), @sTuristName varchar(55)
DECLARE @sOldValue varchar(255), @sNewValue varchar(255), @nOldValue int, @nNewValue int, @SDDate datetime
DECLARE @nRowsCount int, @sServiceStatusToHistory varchar(255)

DECLARE @SDID int, @N_SD_DLKey int, @N_SD_RLID int, @N_SD_TUKEY int, @N_SD_QPID int, @N_SD_State int, @N_SD_Date datetime,
		@O_SD_DLKey int, @O_SD_RLID int, @O_SD_TUKEY int, @O_SD_QPID int, @O_SD_State int, @O_SD_Date datetime, @QT_ByRoom bit,
		@nDelCount int, @nInsCount int, @DLDateBeg datetime, @DLNDays int, @QState int, @NewQState int, @QD_ID int

SELECT @nDelCount = COUNT(*) FROM DELETED
SELECT @nInsCount = COUNT(*) FROM INSERTED
IF (@nInsCount = 0)
BEGIN
    DECLARE cur_ServiceByDateChanged CURSOR FOR 
    SELECT 	O.SD_ID,
			O.SD_DLKey, O.SD_RLID, O.SD_TUKey, O.SD_QPID, O.SD_State, O.SD_Date,
			null, null, null, null, null, null
    FROM DELETED O
END
ELSE IF (@nDelCount = 0)
BEGIN
    DECLARE cur_ServiceByDateChanged CURSOR FOR 
    SELECT 	N.SD_ID,
			null, null, null, null, null, null,
			N.SD_DLKey, N.SD_RLID, N.SD_TUKey, N.SD_QPID, N.SD_State, N.SD_Date
			--DL_DateBeg, DL_NDays
    FROM	INSERTED N
	--LEFT OUTER JOIN tbl_DogovorList ON N.SD_DLKey = DL_Key
	-- CRM01871H3T9 30.05.2012 kolbeshkin: отсеиваем неквотируемые услуги, для них триггер не должен отрабатывать
	where exists (select 1 from DogovorList,[Service] where DL_KEY=N.SD_DLKey and DL_SVKEY=SV_KEY 
    and ISNULL(SV_QUOTED,0)<>0)
END
ELSE 
BEGIN
    DECLARE cur_ServiceByDateChanged CURSOR FOR 
    SELECT 	N.SD_ID,
			O.SD_DLKey, O.SD_RLID, O.SD_TUKey, O.SD_QPID, O.SD_State, O.SD_Date,
	  		N.SD_DLKey, N.SD_RLID, N.SD_TUKey, N.SD_QPID, N.SD_State, N.SD_Date
			--DL_DateBeg, DL_NDays
    FROM DELETED O, INSERTED N
	--LEFT OUTER JOIN tbl_DogovorList ON N.SD_DLKey = DL_Key 
    WHERE N.SD_ID = O.SD_ID
	-- CRM01871H3T9 30.05.2012 kolbeshkin: отсеиваем неквотируемые услуги, для них триггер не должен отрабатывать
	and exists (select 1 from DogovorList,[Service] where DL_KEY=N.SD_DLKey and DL_SVKEY=SV_KEY 
    and ISNULL(SV_QUOTED,0)<>0)
END

select @sServiceStatusToHistory = SS_ParmValue from SystemSettings where SS_ParmName like 'SYSServiceStatusToHistory'

declare @RLIDCount int

OPEN cur_ServiceByDateChanged
FETCH NEXT FROM cur_ServiceByDateChanged 
	INTO @SDID, @O_SD_DLKey, @O_SD_RLID, @O_SD_TUKEY, @O_SD_QPID, @O_SD_State, @O_SD_Date,
				@N_SD_DLKey, @N_SD_RLID, @N_SD_TUKEY, @N_SD_QPID, @N_SD_State, @N_SD_Date
				--@DLDateBeg, @DLNDays
WHILE @@FETCH_STATUS = 0
BEGIN
	IF ISNULL(@O_SD_QPID,0)!=ISNULL(@N_SD_QPID,0) OR ISNULL(@O_SD_RLID,0)!=ISNULL(@N_SD_RLID,0)
	BEGIN
		If @O_SD_QPID is not null
		BEGIN			
			SELECT @QT_ByRoom=QT_ByRoom FROM Quotas inner join QuotaDetails on QD_QTID=QT_ID inner join QuotaParts on QD_ID=QP_QDID where QP_ID=@O_SD_QPID
			IF @QT_ByRoom = 1
			BEGIN
				set @RLIDCount = (SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate WHERE SD_QPID=@O_SD_QPID)
				UPDATE QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=@RLIDCount WHERE QP_ID=@O_SD_QPID
				
				set @RLIDCount = (SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate inner join QuotaParts on SD_QPID=QP_ID inner join QuotaDetails on QP_QDID=QD_ID WHERE QP_ID=@O_SD_QPID)
				UPDATE QuotaDetails SET QD_Busy=@RLIDCount WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@O_SD_QPID)
				
				set @RLIDCount = (SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate inner join tbl_DogovorList on SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key inner join [Service] on DL_SVKey = SV_KEY
					WHERE SD_QPID=@O_SD_QPID AND isnull(SV_IsDuration, 0) = 1)
				UPDATE QuotaParts SET QP_CheckInPlacesBusy=@RLIDCount WHERE QP_ID=@O_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
			ELSE
			BEGIN
				set @RLIDCount = (SELECT COUNT(*) FROM ServiceByDate WHERE SD_QPID=@O_SD_QPID)
				UPDATE QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=@RLIDCount WHERE QP_ID=@O_SD_QPID
				
				set @RLIDCount = (SELECT COUNT(*) FROM ServiceByDate inner join QuotaParts on SD_QPID=QP_ID inner join QuotaDetails on QD_ID=QP_QDID where QP_ID=@O_SD_QPID)
				UPDATE QuotaDetails SET QD_Busy=(@RLIDCount) WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@O_SD_QPID)
				
				set @RLIDCount = (SELECT COUNT(*) FROM ServiceByDate inner join tbl_DogovorList on SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key inner join [Service] on DL_SVKey = SV_KEY
					WHERE SD_QPID=@O_SD_QPID and isnull(SV_IsDuration, 0) = 1)
				UPDATE QuotaParts SET QP_CheckInPlacesBusy=@RLIDCount WHERE QP_ID=@O_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
		END
		
		If @N_SD_QPID is not null
		BEGIN
			SELECT @QT_ByRoom=QT_ByRoom FROM Quotas,QuotaDetails,QuotaParts WHERE QD_QTID=QT_ID and QD_ID=QP_QDID and QP_ID=@N_SD_QPID
			IF @QT_ByRoom = 1
			BEGIN
				set @RLIDCount=(SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate WHERE SD_QPID=@N_SD_QPID)
				UPDATE QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=@RLIDCount WHERE QP_ID=@N_SD_QPID
				
				select @QD_ID = QP_QDID from QuotaParts where QP_ID = @N_SD_QPID
				set @RLIDCount= (SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate inner join QuotaParts on SD_QPID=QP_ID inner join QuotaDetails on QP_QDID=QD_ID where QP_QDID=@QD_ID)
				UPDATE QuotaDetails SET QD_Busy=@RLIDCount WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@N_SD_QPID)
				
				set @RLIDCount = (SELECT COUNT(DISTINCT SD_RLID) FROM ServiceByDate inner join tbl_DogovorList on SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key inner join [Service] on DL_SVKey = SV_KEY
					WHERE SD_QPID=@N_SD_QPID AND isnull(SV_IsDuration, 0) = 1)
				UPDATE QuotaParts SET QP_CheckInPlacesBusy=@RLIDCount WHERE QP_ID=@N_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
			ELSE
			BEGIN
				set @RLIDCount=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_QPID=@N_SD_QPID)
				UPDATE QuotaParts SET QP_LastUpdate = GetDate(), QP_Busy=@RLIDCount WHERE QP_ID=@N_SD_QPID
				
				set @RLIDCount=(SELECT COUNT(*) FROM ServiceByDate inner join QuotaParts on SD_QPID=QP_ID inner join QuotaDetails on QP_QDID=QD_ID where QP_ID=@N_SD_QPID)
				UPDATE QuotaDetails SET QD_Busy=@RLIDCount WHERE QD_ID in (SELECT QP_QDID FROM QuotaParts WHERE QP_ID=@N_SD_QPID)
				
				set @RLIDCount=(SELECT COUNT(*) FROM ServiceByDate inner join tbl_DogovorList on SD_DATE=DL_DATEBEG AND SD_DLKey = DL_Key inner join [Service] on DL_SVKey = SV_KEY
					WHERE SD_QPID=@N_SD_QPID and isnull(SV_IsDuration, 0) = 1)
				UPDATE QuotaParts SET QP_CheckInPlacesBusy=@RLIDCount WHERE QP_ID=@N_SD_QPID AND QP_CheckInPlaces IS NOT NULL
			END
		END
	END
	
	IF (ISNULL(@O_SD_STATE, 0) != ISNULL(@N_SD_STATE, 0) or 
		ISNULL(@O_SD_TUKEY,0)!=ISNULL(@N_SD_TUKEY,0)) and ISNULL(@sServiceStatusToHistory, '0') != '0'
	BEGIN
		Select @QState = QS_STATE from QuotedState where QS_DLID = @N_SD_DLKey and ISNULL(QS_TUID,0) = ISNULL(@N_SD_TUKEY,0)
		IF @QState is NULL and @N_SD_DLKey is not NULL
		BEGIN
			Set @QState = 4
			Insert into QuotedState (QS_DLID, QS_TUID, QS_STATE) values (@N_SD_DLKey, @N_SD_TUKEY, @QState)
		END

		Select @NewQState = MAX(SD_STATE) from ServiceByDate where SD_DLKey = @N_SD_DLKey and ISNULL(SD_TUKEY,0) = ISNULL(@N_SD_TUKEY,0)
		
		if @NewQState is null
		 	set @NewQState = 4
		IF @QState <> @NewQState
			IF @N_SD_DLKey is not NULL
				Update QuotedState set QS_STATE = @NewQState where QS_DLID=@N_SD_DLKey and ISNULL(QS_TUID,0)=ISNULL(@N_SD_TUKEY,0)
			ELSE
				IF @O_SD_DLKey is not NULL
					Update QuotedState set QS_STATE = @NewQState where QS_DLID=@O_SD_DLKey and ISNULL(QS_TUID,0)=ISNULL(@N_SD_TUKEY,0)
	END
	FETCH NEXT FROM cur_ServiceByDateChanged 
		INTO @SDID, @O_SD_DLKey, @O_SD_RLID, @O_SD_TUKEY, @O_SD_QPID, @O_SD_State, @O_SD_Date,
					@N_SD_DLKey, @N_SD_RLID, @N_SD_TUKEY, @N_SD_QPID, @N_SD_State, @N_SD_Date
					--@DLDateBeg, @DLNDays
END
IF @O_SD_DLKey is not null and @N_SD_DLKey is null
	IF exists (SELECT 1 FROM RoomNumberLists WHERE RL_ID not in (SELECT SD_RLID FROM ServiceByDate))
		DELETE FROM RoomNumberLists WHERE RL_ID not in (SELECT SD_RLID FROM ServiceByDate)

CLOSE cur_ServiceByDateChanged
DEALLOCATE cur_ServiceByDateChanged
GO
/*********************************************************************/
/* end T_ServiceByDateChanged.sql */
/*********************************************************************/

/*********************************************************************/
/* begin job_mwReplDisableDeletedPrices.sql */
/*********************************************************************/
-- job mwReplDisableDeletedPrices runs only at subscriber (if replication) or at main server (if no replication)
if dbo.mwReplIsPublisher() > 0 
begin
	if not exists (select top 1 1 from distribution.dbo.msArticles with (nolock) where article = 'mwReplDeletedPricesTemp')
	begin
		-- include mwReplDeletedPricesTemp in replication articles
		exec sp_addarticle @publication = N'MW_PUB', @article = N'mwReplDeletedPricesTemp', @source_owner = N'dbo', 
				@source_object = N'mwReplDeletedPricesTemp', @type = N'logbased', @description = N'', @creation_script = N'', @pre_creation_cmd = N'drop', 
				@schema_option = 0x00, @identityrangemanagementoption = N'none', @destination_table = N'mwReplDeletedPricesTemp', @destination_owner = N'dbo', 
				@status = 8, @vertical_partition = N'false', @ins_cmd = N'SQL', @del_cmd = N'SQL', @upd_cmd = N'SQL'
	end
	
	-- remove job from publisher
	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'mwReplDisableDeletedPrices')
	begin
		EXEC msdb.dbo.sp_delete_job @job_name=N'mwReplDisableDeletedPrices', @delete_unused_schedule=1
	end	
end

GO
/*********************************************************************/
/* end job_mwReplDisableDeletedPrices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwCleaner.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwCleaner]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwCleaner]
GO

create proc [dbo].[mwCleaner] @priceCount int = 1000000, @deleteToday smallint = 0
as
begin
	--<DATE>2013-07-31</DATE>
	--<VERSION>9.2.20.1</VERSION>
	declare @counter bigint
	declare @deletedRowCount bigint

	insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Запуск mwCleaner', 1)

	declare @today datetime
	set @today = getdate()
	if (@deleteToday <> 1)
	begin
		set @today = dateadd(day, -1, @today)
	end

	IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplDeletedPricesTemp]') AND type in (N'U'))
	begin
		delete from mwReplDeletedPricesTemp
		where rdp_date < DATEADD(MONTH, -1, @today)

		if not exists(select top 1 1 from mwReplDeletedPricesTemp)
		begin
			truncate table mwReplDeletedPricesTemp
		end
	end

	truncate table CacheQuotas
	
	if dbo.mwReplIsSubscriber() <= 0
	begin
		-- очистка таблиц только на основной базе в случае репликации или если репликации нет

		-- Удаляем записи из таблицы TP_ServiceTours, если таких туров больше нету
		-- Тут количество записей будет не большим, поэтому можно не делить на пачки, туры удаляются редко в ДЦ
		SELECT ST_Id 
		into #Keys
		FROM TP_ServiceTours with(nolock)
		where not exists (select top 1 1 from TP_Tours with(nolock) where TO_Key = ST_TOKey)
		and st_tokey not in (select CP_PriceTourKey from CalculatingPriceLists with(nolock) where CP_StartTime is not null)
	
		delete TP_ServiceTours WHERE ST_Id in (select x.ST_Id from #Keys as x)
	
		drop table #Keys
	
		-- Удаляем неактуальные цены
		set @counter = 0
		while(1 = 1)
		begin
	
			delete 
			from dbo.tp_prices with(rowlock) 
			where tp_key in (SELECT top (@priceCount/10) tp_key 
							 from dbo.tp_prices with(nolock) 
							 WHERE tp_dateend < @today 
								   and tp_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
								   and tp_tokey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
							)
					
			set @deletedRowCount = @@ROWCOUNT
			if @deletedRowCount = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_prices завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				--print 'Удаление tp_prices завершено. Удалено ' + ltrim(str(@counter)) + ' записей'
				break
			end
			else
			begin
				print 'Удалено из tp_prices ' + ltrim(str(@deletedRowCount)) + ' записей'
				set @counter = @counter + @deletedRowCount
			end
		end

		-- Удаляем неактуальные удаленные цены из TP_PricesDeleted (ДЦ)
		set @counter = 0
		while(1 = 1)
		begin
			delete 
			from dbo.tp_pricesDeleted with(rowlock) 
			where tpd_id in (select top (@priceCount/5) tpd_id 
							 from dbo.tp_pricesDeleted with(nolock)
							 where tpd_dateend < @today 
								   and tpd_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
								   and tpd_tokey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
			)
		
			set @deletedRowCount = @@ROWCOUNT
			if @deletedRowCount = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_pricesDeleted завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				print 'Удаление tp_pricesDeleted завершено. Удалено ' + ltrim(str(@counter)) + ' записей'
				break
			end
			else
			begin
				print 'Удалено из tp_pricesDeleted ' + ltrim(str(@deletedRowCount)) + ' записей'
				set @counter = @counter + @deletedRowCount
			end
		end	
	
		-- Удаляем неактуальные удаленные цены из TP_PriceComponents (ДЦ)
		set @counter = 0
		while(1 = 1)
		begin
			delete 
			from dbo.TP_PriceComponents with(rowlock) 
			where PC_ID in (SELECT top (@priceCount/50) PC_ID 
							FROM dbo.TP_PriceComponents with(nolock) 
							WHERE PC_TourDate < @today
							and pc_tokey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
			)
		
			set @deletedRowCount = @@ROWCOUNT
			if @deletedRowCount = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление TP_PriceComponents завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				--print 'Удаление TP_PriceComponents завершено. Удалено ' + ltrim(str(@counter)) + ' записей'
				break
			end
			else
			begin
				print 'Удалено из TP_PriceComponents ' + ltrim(str(@deletedRowCount)) + ' записей'
				set @counter = @counter + @deletedRowCount
			end			
		end	
	
		-- Удаляем неактуальные удаленные цены из TP_ServiceCalculateParametrs (ДЦ)
		set @counter = 0
		while(1 = 1)
		begin
			delete 
			from dbo.TP_ServiceCalculateParametrs with(rowlock) 
			where SCP_ID in (select top (@priceCount) SCP_ID 
							 from dbo.TP_ServiceCalculateParametrs 
							 WHERE SCP_DateCheckIn < @today)
						 
			set @deletedRowCount = @@ROWCOUNT
			if @deletedRowCount = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление TP_ServiceCalculateParametrs завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				break
			end
			else
				set @counter = @counter + @deletedRowCount
		end	
	end

	-- Удаляем неактуальные удаленные цены из tp_turdates
	set @counter = 0
	while (1 = 1)
	begin
		delete 
		from dbo.tp_turdates with(rowlock) 
		where td_key in (select top (@priceCount/10) td_key 
							from dbo.tp_turdates with(nolock) 
							where td_date < @today 
							and td_tokey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
							and td_tokey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расче
		)
			
		set @deletedRowCount = @@ROWCOUNT
		if @deletedRowCount = 0
		begin
			insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_turdates завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
			break
		end
		else
			set @counter = @counter + @deletedRowCount
	end
		
	if dbo.mwReplIsSubscriber() <= 0
	begin
		-- tp_servicelists, tp_lists, tp_services		
		create table #tikeys (tikey int, tokey int)
		CREATE NONCLUSTERED INDEX [IX_Index1]
		ON #tikeys ([tokey])
		INCLUDE ([tikey])

		declare @toKey int
		declare tourCursor cursor local fast_forward for
		select to_key
		from tp_tours with(nolock)
		where TO_Key not in (select CP_PriceTourKey from CalculatingPriceLists with(nolock) where CP_StartTime is not null)
		and TO_Key not in (select to_key from tp_tours with(nolock) where to_update <> 0)
		order by to_key desc

		set @counter = 0

		open tourCursor
		fetch tourCursor into @toKey
		while (@@FETCH_STATUS = 0)
		begin
			insert into #tikeys 
			select ti_key, ti_tokey 
			from dbo.tp_lists with(nolock) 
			where not exists (select 1 from tp_prices with(nolock) where ti_key = tp_tikey and tp_tokey = TI_TOKey)
			and not exists (select 1 from TP_PricesDeleted with(nolock) where ti_key = tpd_tikey and tpd_tokey = TI_TOKey)
			and ti_tokey = @toKey

			delete 
			from dbo.tp_servicelists
			where exists (select 1 from #tikeys where tikey = TL_TIKey and tokey = TL_TOKey)
			and tl_tokey = @toKey

			set @counter = @counter + @@ROWCOUNT

			delete 
			from dbo.tp_lists with(rowlock) 
			where ti_key in (select tikey from #tikeys where tokey = TI_TOKey) 
			and ti_tokey = @toKey

			set @counter = @counter + @@ROWCOUNT

			delete 
			from dbo.tp_services 
			where TS_Key not in (select TL_TSKey from TP_ServiceLists with(nolock) where TL_TOKey = TS_TOKey)
			and TS_TOKey = @toKey

			set @counter = @counter + @@ROWCOUNT

			truncate table #tikeys

			fetch tourCursor into @toKey
		end
		close tourCursor
		deallocate tourCursor

		drop table #tikeys

		insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление tp_servicelists, tp_lists, tp_services завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)		
	end
	else
	begin
		exec dbo.mwCleanerQuotes
	end

	declare @mwSearchType int
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'
	
	if dbo.mwReplIsSubscriber() <= 0
	begin
		-- Удаляем неактуальные туры
		set @counter = 0
		while(1 = 1)
		begin

			delete 
			from dbo.TP_Tours with(rowlock) 
			where to_key in (SELECT TOP 1 TO_Key 
							 FROM TP_Tours 
							 WHERE to_datevalid < @today
							 and to_key not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
			)
			
			set @deletedRowCount = @@ROWCOUNT
			if @deletedRowCount = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление TP_Tours завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)		
				break
			end
			else
				set @counter = @counter + @deletedRowCount
		end

		create table #tours
		(
			xKey int identity(1,1),
			xToKey int
		)
	
		insert into #tours (xToKey)
		select TO_Key
		from tp_tours with(nolock) where to_update = 0 and exists(select top 1 1 from dbo.tp_turdates with(nolock) where td_tokey = to_key and td_date < @today)

		declare @currentKey int, @maxKey int
		set @currentKey = 0
		select @maxKey = MAX(xKey) from #tours
		while (@currentKey < @maxKey)
		begin
			set @currentKey = @currentKey + 1
		
			update dbo.tp_tours
			set to_pricecount = (select count(1) from dbo.tp_prices with(nolock) where tp_tokey = to_key), 
				to_updatetime = getdate()
			where to_key = (select xToKey from #tours where xKey = @currentKey)
		
		end
	
		drop table #tours
		insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Обновление tp_tours завершено. Обновлено ' + ltrim(@deletedRowCount) + ' записей', 1)
	end

	if dbo.mwReplIsPublisher() <= 0
	begin

		if exists(select 1 from mwReplQueue with(nolock) where rq_tokey not in (select to_key from tp_tours with(nolock)) and rq_mode <> 4)
		begin
			delete 
			from mwReplQueue
			where rq_tokey not in (select to_key from tp_tours with(nolock))
			and rq_mode <> 4
		end

		if(@mwSearchType = 0)
		begin
			set @counter = 0
			while(1 = 1)
			begin
				delete top (@priceCount) from dbo.mwPriceDataTable with(rowlock) where pt_tourdate < @today and pt_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
							and pt_tourkey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
				set @deletedRowCount = @@ROWCOUNT
				if @deletedRowCount = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwPriceDataTable завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @deletedRowCount
			end
			
			set @counter = 0
			while(1 = 1)
			begin
				delete top (@priceCount) from dbo.mwSpoDataTable with(rowlock) where sd_tourkey not in (select pt_tourkey from dbo.mwPriceDataTable with(nolock)) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
							and sd_tourkey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
				set @deletedRowCount = @@ROWCOUNT
				if @deletedRowCount = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwSpoDataTable завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @deletedRowCount
			end
			
			set @counter = 0
			while(1 = 1)
			begin
				delete top (@priceCount) from dbo.mwPriceDurations with(rowlock) where not exists(select 1 from dbo.mwPriceDataTable with(nolock) where pt_tourkey = sd_tourkey and pt_days = sd_days and pt_nights = sd_nights) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
							and sd_tourkey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null) --за исключением отложенного расчета
				set @deletedRowCount = @@ROWCOUNT
				if @deletedRowCount = 0
				begin
					insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwPriceDurations завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
					break
				end
				else
					set @counter = @counter + @deletedRowCount
			end
		end
		else
		begin
			declare @objName nvarchar(50), @counterPart int
			declare @sql nvarchar(500), @params nvarchar(500)
			declare delCursor cursor fast_forward read_only for select distinct sd_cnkey, sd_ctkeyfrom from dbo.mwSpoDataTable
			declare @cnkey int, @ctkeyfrom int
			open delCursor
			fetch next from delCursor into @cnkey, @ctkeyfrom
			while(@@fetch_status = 0)
			begin
				set @objName = dbo.mwGetPriceTableName(@cnkey, @ctkeyfrom)
				set @counter = 0
				while(1 = 1)
				begin
					set @sql = 'delete top (' + ltrim(rtrim(str(@priceCount))) + ') from ' + @objName + ' with(rowlock) where pt_tourdate < @today and pt_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0) and pt_tourkey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null); set @counterOut = @@ROWCOUNT'
					set @params = '@today datetime, @counterOut int output'
				
					EXECUTE sp_executesql @sql, @params, @today = @today, @counterOut = @counterPart output
				
					if @counterPart = 0
					begin
						insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление ' + @objName + ' завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
						break
					end
					else
						set @counter = @counter + @counterPart
				end

				set @counter = 0
				while(1 = 1)
				begin
					set @sql = 'delete top (' + ltrim(rtrim(str(@priceCount))) + ') from dbo.mwSpoDataTable with(rowlock) where sd_cnkey = ' + ltrim(rtrim(str(@cnkey))) + ' and sd_ctkeyfrom = ' + ltrim(rtrim(str(@ctkeyfrom))) + ' and sd_tourkey not in (select pt_tourkey from ' + @objName + ' with(nolock)) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0) and sd_tourkey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null); set @counterOut = @@ROWCOUNT'
					set @params = '@counterOut int output'
					EXECUTE sp_executesql @sql, @params, @counterOut = @counterPart output
				
					if @counterPart = 0
					begin
						insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwSpoDataTable завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)	
						break
					end
					else
						set @counter = @counter + @counterPart
				end
				fetch next from delCursor into @cnkey, @ctkeyfrom
			end
			close delCursor
			deallocate delCursor
		end
	
		set @counter = 0
		while(1 = 1)
		begin
			delete top (@priceCount) from dbo.mwPriceHotels with(rowlock) where sd_tourkey not in (select sd_tourkey from dbo.mwSpoDataTable with(nolock)) and sd_tourkey not in (select to_key from tp_tours with(nolock) where to_update <> 0)
						and sd_tourkey not in (select CP_PriceTourKey from CalculatingPriceLists where CP_StartTime is not null)
			set @deletedRowCount = @@ROWCOUNT
			if @deletedRowCount = 0
			begin
				insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление mwPriceHotels завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
				break
			end
			else
				set @counter = @counter + @deletedRowCount
		end
	end

	-- Удаляем неактуальные логи (остаются логи за последние 7 дней)
	set @counter = 0
	while(1 = 1)
	begin
		delete top (@priceCount) from dbo.SystemLog with(rowlock) where SL_DATE < DATEADD(day, -7, @today)
		set @deletedRowCount = @@ROWCOUNT
		if @deletedRowCount = 0
		begin
			insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Удаление systemLog завершено. Удалено ' + ltrim(str(@counter)) + ' записей', 1)
			break
		end
		else
			set @counter = @counter + @deletedRowCount
	end

	insert into SystemLog (SL_Type, SL_Date, SL_Message, SL_AppID) values(1, GETDATE(), 'Окончание выполнения mwCleaner', 1)
end
GO

grant exec on dbo.mwCleaner to public
GO
/*********************************************************************/
/* end sp_mwCleaner.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetTableQuotaDetails.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetTableQuotaDetails]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetTableQuotaDetails]
GO

CREATE procedure [dbo].[GetTableQuotaDetails]
(
--<VERSION>2009.15</VERSION>
--<DATE>2013-05-23</DATE>
@DL_Key int =null,
@QT_ID int  =null,
@DateStart datetime = null,
@DaysCount int  =null,
@QT_Type int  =null,
@QT_Release int  =null,
@DL_SVKey int  =null, 
@DL_Code int  =null, 
@DL_SubCode1 int  =null, 
@DL_PRKey int  =null,
@GroupByQD bit = null
)
AS
/*
возвращает таблицу со стопами по всем комбинациям услуг

есть 5 вариантов вызова
1. экран "Наличие мест на квоте" - @QT_ID, @DateStart, @DaysCount !!! до 2008.1.1 (после 2008.1.2 см.пункт 5 )
2. экран "Выбрать квоту (основной режим)" - @DL_Key, @DateStart, @DaysCount
3. функция проверки наличия мест [CheckQuotaExist] @QT_ID, @DateStart, @DaysCount, @DL_SVKey, @DL_Code, @DL_SubCode1, @DL_PRKey
4. из экрана Стоп по квоте @QT_ID, @DateStart, @DaysCount, @QT_Type
5. экран "Наличие мест на квоте" - @DateStart, @DaysCount, @DL_SVKey, @DL_Code, @GroupByQD !!! после 2008.1.2 (до 2008.1.1 см.пункт 1 ) 
*/
DECLARE @DateEnd datetime
Set @DateEnd = DATEADD(DAY, @DaysCount-1, @DateStart)

DECLARE @QO_SubCode1 int, @QO_SubCode2 int
IF @DL_Key is not null --значит смотрим из конкретной услуги
	SELECT @DL_SVKey=DL_SVKey, @DL_Code=DL_Code, @DL_SubCode1=DL_SubCode1, @DL_PRKey=DL_PartnerKey FROM DogovorList WHERE DL_Key=@DL_Key
IF @DL_SVKey is not null and @DL_SubCode1 is not null
BEGIN
	SET @QO_SubCode2=0
	IF @DL_SVKey=3
		SELECT @QO_SubCode1=HR_RMKey, @QO_SubCode2=HR_RCKey FROM HotelRooms WHERE HR_Key=@DL_SubCode1
	ELSE
		SET @QO_SubCode1=@DL_SubCode1

	IF @DL_SVKey=1
		set @QO_SubCode2 = -1
END

--проверка стопов
--начало
CREATE TABLE #StopSaleTemp_Local
(
SST_Code int,
SST_SubCode1 int,
SST_SubCode2 int,
SST_QOID int,
SST_PRKey int,
SST_Date smalldatetime,
SST_QDID int,
SST_Type smallint,
SST_State smallint,
SST_Comment varchar(255)
)

IF @DL_Key is not null --значит смотрим по конкретной услуги
BEGIN
	INSERT INTO #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		SELECT	QO_Code,QO_SubCode1,QO_SubCode2,QO_ID,QT_PRKey,QD_Date,QD_ID,QD_Type
		FROM	QuotaObjects,Quotas,QuotaDetails
		WHERE	QO_QTID=QT_ID and ((QT_ID=@QT_ID and @QT_ID is not null) or (@QT_ID is null)) and QD_QTID=QT_ID
				and QD_Date between @DateStart and @DateEnd
				and QO_SVKey=@DL_SVKey and QO_Code=@DL_Code and (QO_SubCode1=@QO_SubCode1 or QO_SubCode1=0)
				and (QO_SubCode2=@QO_SubCode2 or QO_SubCode2=0)
				and (QT_PRKey=@DL_PRKey or QT_PRKey=0)
END
ELSE IF @QT_ID is not null
BEGIN
	INSERT INTO #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		SELECT	QO_Code,QO_SubCode1,QO_SubCode2,QO_ID,QT_PRKey,QD_Date,QD_ID,QD_Type
		FROM	QuotaObjects,Quotas,QuotaDetails
		WHERE	QO_QTID=QT_ID and ((QT_ID=@QT_ID and @QT_ID is not null) or (@QT_ID is null)) and QD_QTID=QT_ID
				and QD_Date between @DateStart and @DateEnd
				and ((QO_SVKey=@DL_SVKey and @DL_SVKey is not null) or (@DL_SVKey is null))
				and ((QO_Code=@DL_Code and @DL_Code is not null) or (@DL_Code is null))
				and (((QO_SubCode1=0 or QO_SubCode1=@QO_SubCode1) and @QO_SubCode1 is not null) or (@QO_SubCode1 is null))
				and (((QO_SubCode2=0 or QO_SubCode2=@QO_SubCode2) and @QO_SubCode2 is not null) or (@QO_SubCode2 is null))
				and ((QD_Type=@QT_Type and @QT_Type is not null) or (@QT_Type is null))
				and ((ISNULL(QD_Release,0)=ISNULL(@QT_Release,0) and @QT_Type is not null) or (@QT_Type is null))	--специально смотрим @QT_Type, т.к. @QT_Release может прийти NULL
END
ELSE IF @QT_ID is null --экран "Наличие мест" (после 2008.1.2)
BEGIN
	INSERT INTO #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		SELECT	QO_Code,QO_SubCode1,QO_SubCode2,QO_ID,QT_PRKey,QD_Date,QD_ID,QD_Type
		FROM	Quotas join QuotaObjects on QO_QTID = QT_ID
				join QuotaDetails on QD_QTID = QT_ID
		WHERE QD_Date between @DateStart and @DateEnd
		and QO_SVKey = @DL_SVKey 
		and QO_Code = @DL_Code
END

		--AleXK добавил чтобы есл есть квота на SST_SubCode1 = все, то создавалиь бы все квоты по признакам
		insert into #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		select QO_Code, QO_SubCode1, QO_SubCode2, QO_ID, SS_PRKey, SS_Date, SST_QDID, SST_Type
		from QuotaObjects join StopSales on QO_ID = SS_QOID
		join #StopSaleTemp_Local on QO_Code = SST_Code and QO_SubCode2 = SST_SubCode2 and SS_PRKey = SST_PRKey and SS_Date = SST_Date
		where not exists (select 1 from #StopSaleTemp_Local where SST_QOID = QO_ID)
		and SST_SubCode1 = 0 and COALESCE(SS_IsDeleted, 0) = 0
		
		--AleXK добавил чтобы есл есть квота на SST_SubCode2 = все, то создавалиь бы все квоты по признакам
		insert into #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		select QO_Code, QO_SubCode1, QO_SubCode2, QO_ID, SS_PRKey, SS_Date, SST_QDID, SST_Type
		from QuotaObjects join StopSales on QO_ID = SS_QOID
		join #StopSaleTemp_Local on QO_Code = SST_Code and QO_SubCode1 = SST_SubCode1 and SS_PRKey = SST_PRKey and SS_Date = SST_Date
		where not exists (select 1 from #StopSaleTemp_Local where SST_QOID = QO_ID)
		and SST_SubCode2 = 0 and COALESCE(SS_IsDeleted, 0) = 0
		
		--AleXK добавил чтобы есл есть квота на SST_SubCode1 = все и SST_SubCode2 = все, то создавалиь бы все квоты по признакам
		insert into #StopSaleTemp_Local (SST_Code,SST_SubCode1,SST_SubCode2,SST_QOID,SST_PRKey,SST_Date,SST_QDID,SST_Type)
		select QO_Code, QO_SubCode1, QO_SubCode2, QO_ID, SS_PRKey, SS_Date, SST_QDID, SST_Type
		from QuotaObjects join StopSales on QO_ID = SS_QOID
		join #StopSaleTemp_Local on QO_Code = SST_Code and SS_PRKey = SST_PRKey and SS_Date = SST_Date
		where not exists (select 1 from #StopSaleTemp_Local where SST_QOID = QO_ID)
		and SST_SubCode1 = 0 and SST_SubCode2 = 0 and COALESCE(SS_IsDeleted, 0) = 0

--if exists (select SS_ParmValue from systemsettings where SS_ParmName='SYSCheckQuotaRelease' and SS_ParmValue=1) OR exists (select SS_ParmValue from systemsettings where SS_ParmName='SYSAddQuotaPastPermit' and SS_ParmValue=1)
BEGIN
	-- оборобатываем стопы которые висят на QuotaDetails
	IF @DL_Key is not null --значит по услуге, значит не надо смотреть в QuotaObjects, так как объекты уже отобраны
	begin
		Update #StopSaleTemp_Local Set SST_State=1, SST_Comment= (SELECT TOP 1 REPLACE(SS_Comment,'''','"') FROM StopSales,QuotaObjects WHERE SS_QOID=QO_ID and SS_QDID=SST_QDID and QO_Code=@DL_Code and SS_Date between @DateStart and @DateEnd and COALESCE(SS_IsDeleted, 0) = 0
				and (QO_SubCode1=SST_SubCode1 or QO_SubCode1=0)	and (QO_SubCode2=SST_SubCode2 or QO_SubCode2=0))
			WHERE exists (SELECT SS_ID FROM StopSales,QuotaObjects WHERE SS_QOID=QO_ID and SS_QDID=SST_QDID and QO_Code=@DL_Code and SS_Date between @DateStart and @DateEnd and COALESCE(SS_IsDeleted, 0) = 0
				and (QO_SubCode1=SST_SubCode1 or QO_SubCode1=0)	and (QO_SubCode2=SST_SubCode2 or QO_SubCode2=0))
	end
	Else
	begin
		Update #StopSaleTemp_Local
		Set SST_State=1, SST_Comment = (SELECT TOP 1 REPLACE(SS_Comment,'''','"') 
										FROM StopSales 
										WHERE SS_QDID = SST_QDID 
										and SS_QOID = SST_QOID 
										and SS_Date between @DateStart and @DateEnd 
										and COALESCE(SS_IsDeleted, 0) = 0)
		WHERE exists (SELECT SS_ID 
						FROM StopSales 
						WHERE SS_QDID = SST_QDID 
						and SS_QOID = SST_QOID 
						and SS_Date between @DateStart and @DateEnd 
						and COALESCE(SS_IsDeleted, 0) = 0)
	end
		
	-- обрабатывались так же стопы которые висят не на QuotaDetails
	Update #StopSaleTemp_Local Set SST_State = 2, SST_Comment = 
		(
			SELECT TOP 1 REPLACE(SS_Comment,'''','"') 
			FROM StopSales,QuotaObjects
			WHERE	SS_QDID is null
					and SS_Date between @DateStart and @DateEnd
					and (SS_PRKey=SST_PRKey or SS_PRKey=0)					
					and SS_QOID = QO_ID
					and SS_Date=SST_Date
					and (QO_SVKey = @DL_SVKey or @DL_SVKey is null)
					and (QO_Code = SST_Code or QO_Code=0)
					and (QO_SubCode1 = SST_SubCode1 or QO_SubCode1 = 0 or SST_SubCode1 = 0)
					and (QO_SubCode2 = SST_SubCode2 or QO_SubCode2 = 0 or SST_SubCode2 = 0)
					and COALESCE(SS_IsDeleted, 0) = 0
		)
		WHERE exists ( SELECT 1
						FROM QuotaObjects join StopSales on QO_ID = SS_QOID
						WHERE SS_QDID is null
						and SS_Date between @DateStart and @DateEnd
						and (SS_PRKey = SST_PRKey or SS_PRKey = 0)
						and SS_Date = SST_Date
						and (QO_SVKey = @DL_SVKey or @DL_SVKey is null)
						and (QO_Code = SST_Code or QO_Code=0)
						and (QO_SubCode1 = SST_SubCode1 or QO_SubCode1 = 0)
						and (QO_SubCode2 = SST_SubCode2 or QO_SubCode2 = 0)
						and COALESCE(SS_IsDeleted, 0) = 0
						and (SST_Type = 1 or isnull(SS_AllotmentAndCommitment,0) = 1)
					)
END
 --where sst_QDID=2602
--проверка стопов
--окончание
if @GroupByQD=1
	select	SST_QDID, Count(*) as SST_QO_Count, 
			(SELECT count(*) from #StopSaleTemp_Local s2 WHERE s2.SST_QDID = s1.SST_QDID and (SST_State=2 or SST_State=1)) as SST_QO_CountWithStop,
			(SELECT TOP 1 SST_Comment FROM #StopSaleTemp_Local s3 WHERE s3.SST_QDID=s1.SST_QDID and SST_Comment is not null and SST_Comment != '') as SST_Comment
	from #StopSaleTemp_Local s1
	group by SST_QDID	
	having (SELECT count(*) from #StopSaleTemp_Local s2 WHERE s2.SST_QDID = s1.SST_QDID and SST_State is not null) > 0
else
	select * from #StopSaleTemp_Local
GO

GRANT EXECUTE ON [dbo].[GetTableQuotaDetails] TO Public
GO
/*********************************************************************/
/* end sp_GetTableQuotaDetails.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.21)_Create_Table_QuestionnaireTouristCase.sql */
/*********************************************************************/
-- buryak Создание таблицы "Туристский вариант поля анкеты"
--<DATE>2013-05-21</DATE>
--<VERSION>2009.2.20.0</VERSION>
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[QuestionnaireTouristCase]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[QuestionnaireTouristCase](
	[QTC_Key] [int] IDENTITY(1,1) NOT NULL,
	[QTC_TUKey] [int] NOT NULL,
	[QTC_QFKey] [int] NOT NULL,
	[QTC_QFCKey] [int] NULL,
	[QTC_Value] [nvarchar](200) NULL,
	[QTC_ValueLat] [nvarchar](200) NULL,
 CONSTRAINT [PK_QuestionnaireTouristCase] PRIMARY KEY CLUSTERED 
(
	[QTC_Key] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[QuestionnaireTouristCase] ADD CONSTRAINT [FK_QuestionnaireTouristCase_tbl_Turist] 
FOREIGN KEY([QTC_TUKey]) REFERENCES [dbo].[tbl_Turist] ([TU_KEY]) ON DELETE CASCADE

ALTER TABLE [dbo].[QuestionnaireTouristCase] ADD CONSTRAINT [FK_QuestionnaireTouristCase_QuestionnaireField] 
FOREIGN KEY([QTC_QFKey]) REFERENCES [dbo].[QuestionnaireField] ([QF_Key])

ALTER TABLE [dbo].[QuestionnaireTouristCase] ADD CONSTRAINT [FK_QuestionnaireTouristCase_QuestionnaireFieldCase] 
FOREIGN KEY([QTC_QFCKey]) REFERENCES [dbo].[QuestionnaireFieldCase] ([QFC_Key]) ON DELETE CASCADE

grant select, insert, delete, update on [dbo].[QuestionnaireTouristCase] to public

END
GO

/*********************************************************************/
/* end (2013.05.21)_Create_Table_QuestionnaireTouristCase.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.21)_Alter_Table_VisaDocumentContents.sql */
/*********************************************************************/
if not exists( select 1 from dbo.sysobjects  where id = object_id(N'[dbo].[PK_VisaDocumentContents]')  and OBJECTPROPERTY(id, N'IsPrimaryKey') = 1) 
begin
 ALTER TABLE [dbo].[VisaDocumentContents] ADD CONSTRAINT [PK_VisaDocumentContents] PRIMARY KEY CLUSTERED 
 (
  [VC_ID] ASC
 )WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) 
 ON [PRIMARY]
end
GO
/*********************************************************************/
/* end (2013.05.21)_Alter_Table_VisaDocumentContents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.30)_Alter_Table_Questionnaire.sql */
/*********************************************************************/
if not exists (select * from dbo.syscolumns where name = 'QU_RPKey' and id = object_id(N'[dbo].[Questionnaire]'))
begin
	ALTER TABLE [dbo].[Questionnaire] ADD QU_RPKey INT
end
go
/*********************************************************************/
/* end (2013.05.30)_Alter_Table_Questionnaire.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.30)_Alter_Table_QuestionnaireField.sql */
/*********************************************************************/
if not exists (select * from dbo.syscolumns where name = 'QF_Bookmark' and id = object_id(N'[dbo].[QuestionnaireField]'))
begin
	ALTER TABLE [dbo].[QuestionnaireField] ADD QF_Bookmark nvarchar(50)
end
go
/*********************************************************************/
/* end (2013.05.30)_Alter_Table_QuestionnaireField.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.26)_Create_Table_BonusWithDrawalRules.sql */
/*********************************************************************/
--<DATE>2013-06-26</DATE>
--<VERSION>2009.2.20.0</VERSION>
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BonusWithDrawalRules]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].BonusWithDrawalRules(
	[BR_ID] [int] IDENTITY(1,1) NOT NULL,
	[BR_Name] [nvarchar](200) NULL,
	[BR_NameLat] [nvarchar](200) NULL,
	[BR_MinBonusCount] [float](4) NULL,
	[BR_MaxPricePercent] [float](4) NULL,
	[BR_SVKey] [int] NOT NULL,
	[BR_AllowedCheckinDateBegin] [datetime] NULL,
	[BR_AllowedCheckinDateEnd] [datetime] NULL,
	[BR_UnallowedCheckinDateBegin] [datetime] NULL,
	[BR_UnallowedCheckinDateEnd] [datetime] NULL,	
	[BR_AllowedSaleDateBegin] [datetime] NULL,
	[BR_AllowedSaleDateEnd] [datetime] NULL,
	[BR_UnallowedSaleDateBegin] [datetime] NULL,
	[BR_UnallowedSaleDateEnd] [datetime] NULL,
	[BR_CreateDate] [datetime] NOT NULL,
	[BR_Priority] [int] NOT NULL
	
 CONSTRAINT [PK_BonusWithDrawalRules] PRIMARY KEY CLUSTERED 
(
	[BR_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].BonusWithDrawalRules ADD CONSTRAINT [FK_BonusWithDrawalRules_Service] 
FOREIGN KEY([BR_SVKey]) REFERENCES [dbo].[Service] ([SV_Key]) ON DELETE CASCADE

END

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].BonusWithDrawalRules TO PUBLIC
GO

/*********************************************************************/
/* end (2013.06.26)_Create_Table_BonusWithDrawalRules.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.26)_Create_Table_BonusWithDrawalRuleCourses.sql */
/*********************************************************************/
--<DATE>2013-06-26</DATE>
--<VERSION>2009.2.20.0</VERSION>

IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BonusWithDrawalRuleCourses]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].BonusWithDrawalRuleCourses(
	[BRC_ID] [int] IDENTITY(1,1) NOT NULL,
	[BRC_MinBonusCount] [float](4)	NOT NULL,
	[BRC_MaxBonusCount] [float](4)	NOT NULL,
	[BRC_Course] [decimal](19,6) NOT NULL,
	[BRC_BRID] [int] NOT NULL
 CONSTRAINT [PK_BonusWithDrawalRuleCourses] PRIMARY KEY CLUSTERED 
(
	[BRC_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].BonusWithDrawalRuleCourses ADD CONSTRAINT [FK_BonusWithDrawalRuleCourses_BonusWithDrawalRules] 
FOREIGN KEY([BRC_BRID]) REFERENCES [dbo].[BonusWithDrawalRules] ([BR_ID]) ON DELETE CASCADE

END

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].BonusWithDrawalRuleCourses TO PUBLIC

GO

/*********************************************************************/
/* end (2013.06.26)_Create_Table_BonusWithDrawalRuleCourses.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.28)_Delete_job_ChangeQuotaPlaces.sql */
/*********************************************************************/
declare @dbName nvarchar(128);
declare @jobName varchar(255);

set @dbName = DB_NAME();
set @jobName = N'ChangeQuotaPlaces_' + @dbName;

IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = @jobName)
	EXEC msdb.dbo.sp_delete_job @job_name=@jobName, @delete_unused_schedule=1
GO



/*********************************************************************/
/* end (2013.05.28)_Delete_job_ChangeQuotaPlaces.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.28)_Delete_sp_ChangeQuotaPlaces.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ChangeQuotaPlaces]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[ChangeQuotaPlaces]
GO



/*********************************************************************/
/* end (2013.05.28)_Delete_sp_ChangeQuotaPlaces.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_IX_NullQuotas.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[ServiceByDate]') AND name = N'IX_NullQuotas')
begin
	DROP INDEX [IX_NullQuotas] ON [dbo].[ServiceByDate] WITH ( ONLINE = OFF )
end
GO
CREATE NONCLUSTERED INDEX [IX_NullQuotas]
ON [dbo].[ServiceByDate] 
(
	[SD_QPID],
	[SD_State]
) 
WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]

GO
/*********************************************************************/
/* end INDEX_ADD_IX_NullQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.28)_DROP_COLUMNS_ServiceByDate.sql */
/*********************************************************************/
if exists (select 1 from dbo.syscolumns where name = 'SD_QPIDOld' and id = object_id(N'[dbo].[ServiceByDate]'))
begin
	alter table dbo.ServiceByDate drop column SD_QPIDOld 
end
go


/*********************************************************************/
/* end (2013.05.28)_DROP_COLUMNS_ServiceByDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.06)_Insert_ObjectAliases.sql */
/*********************************************************************/
IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 46))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (46, 'VisaDocumentContents', 'Содержимое визовых документов', 'VisaDocumentContents', 84, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 46001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (46001, 'VC_TUKEY', 'Ключ туриста для визового документа', 'TU_KEY from tbl_Turist', 84, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 46002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (46002, 'VC_VDID', 'Ключ типа визового документа', 'VD_ID from VisaDocuments', 84, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 46003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (46003, 'VC_Contents', 'Содержимое визового документа', 'Binary data of visa document', 84, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47, 'FileHeaders', 'Заголовки файлов', 'File headers', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47001, 'FH_FileName', 'Название файла', 'File name', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47002, 'FH_FileSize', 'Размер файла', 'File size', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47003, 'FH_Date', 'Дата создания файла', 'File creation date', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47004))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47004, 'FH_Md5', 'Хэш-код файла', 'Hash value of file', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47005))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47005, 'FH_Guid', 'GUID файла', 'GUID of file', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47006))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47006, 'FH_IsCompressed', 'Файл заархивирован', 'File is compressed', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47007))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47007, 'FH_USKEY', 'Ключ пользователя', 'User key', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47008))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47008, 'FH_DocType', 'Тип документа', 'Document type', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47009))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47009, 'FH_Comment', 'Комментарий', 'Comment', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47010))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47010, 'FH_IsPublic', 'Уровень доступа', 'Access level', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47011))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47011, 'FH_FileExtension', 'Расширение файла', 'File extension', 85, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 47012))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (47012, 'FH_FileTitle', 'Заголовок файла', 'File title', 85, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 48))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (48, 'FileRepos', 'Хранилище файлов', 'File repository', 86, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 48001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (48001, 'FR_Data', 'Содержимое файла', 'File data', 86, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 48002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (48002, 'FR_FHID', 'Ключ заголовка файла для хранилища файла', 'FH_ID from FileHeaders', 86, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 49))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (49, 'ServiceList', 'Услуги', 'ServiceLists', 21, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 49018))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (49018, 'SL_quKey', 'Ключ анкеты для услуги', 'QU_Key from Questionnaire', 21, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 50))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (50, 'Questionnaire', 'Визовые анкеты', 'Application forms', 78, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 50001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (50001, 'QU_Name', 'Наименование анкеты', 'Questionnaire name', 78, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 50002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (50002, 'QU_NameLat', 'Латинское название анкеты', 'Questionnaire name (latin letters)', 78, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 50003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (50003, 'QU_RPKey', 'Ключ профиля отчета для печати анкеты', 'RP_Key from Rep_Profiles', 78, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 51))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (51, 'QuestionnaireFieldTemplate', 'Шаблоны полей анкет', 'Application form field templates', 79, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 51001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (51001, 'QFT_Name', 'Название шаблона поля анкеты', 'Questionnaire field template name', 79, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 51002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (51002, 'QFT_NameLat', 'Латинское название шаблона поля анкеты', 'Questionnaire field template name (latin letters)', 79, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52, 'QuestionnaireField', 'Поля анкет по странам', 'Application form fields', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52001, 'QF_QUKey', 'Ключ анкеты для поля', 'QUKey from Questionnaire', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52002, 'QF_QFTKey', 'Ключ шаблона поля для поля анкеты', 'QUKey from Questionnaire', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52003, 'QF_Name', 'Наименование поля анкеты', 'Questionnaire field name', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52004))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52004, 'QF_NameLat', 'Латинское название поля анкеты', 'Questionnaire field name (latin letters)', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52005))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52005, 'QF_Order', 'Порядок поля анкеты', 'Questionnaire field order', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52006))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52006, 'QF_BitAttributes', 'Аттрибуты поля анкеты, зашифрованные битами в одном числе', 'Questionnaire field bit attributes', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52007))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52007, 'QF_DefaultValue', 'Значение поля по умолчанию', 'Questionnaire field default value', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52008))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52008, 'QF_TableId', 'Код таблицы связанной сущности поля анкеты', 'Related entity table id', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52009))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52009, 'QF_ColumnId', 'Код колонки связанной сущности поля анкеты', 'Related entity column id', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52010))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52010, 'QF_Comment', 'Комментарий к полю анкеты', 'Comments for questionnaire field', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52011))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52011, 'QF_TagXML', 'XML-тэг для поля анкеты', 'TagXML for questionnaire field', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52012))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52012, 'QF_Format', 'Формат заполняемых в поле анкеты данных', 'Questionnaire field value format', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52013))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52013, 'QF_Example', 'Пример заполнения поля анкеты', 'Questionnaire field filling example', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52014))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52014, 'QF_QuerySQL', 'SQL-запрос для автоматического заполнения поля анкеты', 'SQL-Query for questionnaire field filling', 80, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 52015))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (52015, 'QF_Bookmark', 'Закладка в шаблоне для печати визовой анкеты, соответствующая полю анкеты', 'Questionnaire field bookmark for print', 80, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 53))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (53, 'QuestionnaireFieldCase', 'Варианты полей анкет', 'Application form field options', 81, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 53001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (53001, 'QFC_QFKey', 'Ключ поля для варианта заполнения анкеты', 'QF_Key from questionnaire field', 81, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 53002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (53002, 'QFC_Value', 'Значение варианта заполнения поля анкеты', 'Questionnaire field case value', 81, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 53003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (53003, 'QFC_ValueLat', 'Латинское значение варианта заполнения поля анкеты', 'Questionnaire field case value (latin letters)', 81, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 53004))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (53004, 'QFC_Order', 'Порядок варианта заполнения поля анкеты', 'Questionnaire field case order', 81, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 54))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (54, 'QuestionnaireTouristCase', 'Заполнения полей анкет туристов', 'Tourists application form fillings', 82, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 54001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (54001, 'QTC_TUKey', 'Ключ туриста для заполнения анкеты', 'TU_KEY from tbl_Turist', 82, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 54002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (54002, 'QTC_QFKey', 'Ключ поля анкеты для заполнения', 'QF_Key from QuestionnaireField', 82, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 54003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (54003, 'QTC_QFCKey', 'Ключ варианта поля анкеты для заполнения', 'QFC_Key from QuestionnaireFieldCase', 82, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 54004))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (54004, 'QTC_Value', 'Значение заполнения поля анкеты', 'Questionnaire field value', 82, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 54005))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (54005, 'QTC_ValueLat', 'Латинское значение заполнения поля анкеты', 'Questionnaire field value (latin letters)', 82, null)
go
/*********************************************************************/
/* end (2013.07.06)_Insert_ObjectAliases.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuestionnaireUpdate.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuestionnaireUpdate')
	drop trigger dbo.T_QuestionnaireUpdate
go

CREATE TRIGGER [dbo].[T_QuestionnaireUpdate] ON [dbo].[Questionnaire]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-07-08</DATE>
--<VERSION>2009.2.20.0</VERSION>
  DECLARE @QU_Key int
  
  DECLARE @OQU_Name nvarchar(200)
  DECLARE @OQU_NameLat nvarchar(200)
  DECLARE @OQU_RPKey int
  
  DECLARE @NQU_Name nvarchar(200)
  DECLARE @NQU_NameLat nvarchar(200)
  DECLARE @NQU_RPKey int
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_Questionnaires CURSOR FOR 
	SELECT 	N.QU_Key,
	        null, null, null,
			N.QU_Name, N.QU_NameLat, N.QU_RPKey
	FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_Questionnaires CURSOR FOR 
	SELECT 	O.QU_Key,
			O.QU_Name, O.QU_NameLat, O.QU_RPKey,
			null, null, null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_Questionnaires CURSOR FOR 
	SELECT 	N.QU_Key,
			O.QU_Name, O.QU_NameLat, O.QU_RPKey,
			N.QU_Name, N.QU_NameLat, N.QU_RPKey
	FROM DELETED O, INSERTED N 
	WHERE N.QU_Key = O.QU_Key
  END
  
  OPEN cur_Questionnaires
	FETCH NEXT FROM cur_Questionnaires INTO 
		@QU_Key,
		@OQU_Name, @OQU_NameLat, @OQU_RPKey,
		@NQU_Name, @NQU_NameLat, @NQU_RPKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQU_Name, '') != ISNULL(@NQU_Name, '') OR
			ISNULL(@OQU_NameLat, '') != ISNULL(@NQU_NameLat, '') OR
			ISNULL(@OQU_RPKey, '') != ISNULL(@NQU_RPKey, '')
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NQU_Name, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OQU_Name, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NQU_Name, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 50, @QU_Key, @sMod, @sHI_Text, '', 0, ''
			
			--------Детализация--------------------------------------------------
	
			If (ISNULL(@OQU_Name, '') != ISNULL(@NQU_Name, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 50001, @OQU_Name, @NQU_Name, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQU_NameLat, '') != ISNULL(@NQU_NameLat, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 50002, @OQU_NameLat, @NQU_NameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQU_RPKey, '') != ISNULL(@NQU_RPKey, ''))
				BEGIN	
					declare @OQU_RP varchar(254), @NQU_RP varchar(254)
					
					If(@OQU_RPKey is not null)
						select @OQU_RP = RP_Name from Rep_Profiles where RP_Key = @OQU_RPKey
					else
						set @OQU_RP = null
						
					If(@NQU_RPKey is not null)
						select @NQU_RP = RP_Name from Rep_Profiles where RP_Key = @NQU_RPKey
					else
						set @NQU_RP = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 50003, @OQU_RP, @NQU_RP, @OQU_RPKey, @NQU_RPKey, null, null,  0, @bNeedCommunicationUpdate output
				END
		END
		FETCH NEXT FROM cur_Questionnaires INTO 
		@QU_Key,
		@OQU_Name, @OQU_NameLat, @OQU_RPKey,
		@NQU_Name, @NQU_NameLat, @NQU_RPKey
	END
  CLOSE cur_Questionnaires
  DEALLOCATE cur_Questionnaires
GO



/*********************************************************************/
/* end T_QuestionnaireUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuestionnaireFieldTemplateUpdate.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuestionnaireFieldTemplateUpdate')
	drop trigger dbo.T_QuestionnaireFieldTemplateUpdate
go

CREATE TRIGGER [dbo].[T_QuestionnaireFieldTemplateUpdate] ON [dbo].[QuestionnaireFieldTemplate]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-07-08</DATE>
--<VERSION>2009.2.20.0</VERSION>
  DECLARE @QFT_Key int
  
  DECLARE @OQFT_Name nvarchar(200)
  DECLARE @OQFT_NameLat nvarchar(200)
  
  DECLARE @NQFT_Name nvarchar(200)
  DECLARE @NQFT_NameLat nvarchar(200)
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_QuestionnaireFieldTemplates CURSOR FOR 
	SELECT 	N.QFT_Key,
	        null, null,
			N.QFT_Name, N.QFT_NameLat
	FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_QuestionnaireFieldTemplates CURSOR FOR 
	SELECT 	O.QFT_Key,
			O.QFT_Name, O.QFT_NameLat,
			null, null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_QuestionnaireFieldTemplates CURSOR FOR 
	SELECT 	N.QFT_Key,
			O.QFT_Name, O.QFT_NameLat,
			N.QFT_Name, N.QFT_NameLat
	FROM DELETED O, INSERTED N 
	WHERE N.QFT_Key = O.QFT_Key
  END
  
  OPEN cur_QuestionnaireFieldTemplates
	FETCH NEXT FROM cur_QuestionnaireFieldTemplates INTO 
		@QFT_Key,
		@OQFT_Name, @OQFT_NameLat,
		@NQFT_Name, @NQFT_NameLat
	WHILE @@FETCH_STATUS = 0
	BEGIN
	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQFT_Name, '') != ISNULL(@NQFT_Name, '') OR
			ISNULL(@OQFT_NameLat, '') != ISNULL(@NQFT_NameLat, '')
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NQFT_Name, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OQFT_Name, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NQFT_Name, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 51, @QFT_Key, @sMod, @sHI_Text, '', 0, ''
			
			--------Детализация--------------------------------------------------
	
			If (ISNULL(@OQFT_Name, '') != ISNULL(@NQFT_Name, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 51001, @OQFT_Name, @NQFT_Name, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQFT_NameLat, '') != ISNULL(@NQFT_NameLat, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 51002, @OQFT_NameLat, @NQFT_NameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END

		END
		FETCH NEXT FROM cur_QuestionnaireFieldTemplates INTO 
		@QFT_Key,
		@OQFT_Name, @OQFT_NameLat,
		@NQFT_Name, @NQFT_NameLat
	END
  CLOSE cur_QuestionnaireFieldTemplates
  DEALLOCATE cur_QuestionnaireFieldTemplates
GO



/*********************************************************************/
/* end T_QuestionnaireFieldTemplateUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuestionnaireFieldUpdate.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuestionnaireFieldUpdate')
	drop trigger dbo.T_QuestionnaireFieldUpdate
go

CREATE TRIGGER [dbo].[T_QuestionnaireFieldUpdate] ON [dbo].[QuestionnaireField]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-07-08</DATE>
--<VERSION>2009.2.20.0</VERSION>
  DECLARE @QF_Key int
  
  DECLARE @OQF_QUKey int
  DECLARE @OQF_QFTKey int
  DECLARE @OQF_Name nvarchar(200)
  DECLARE @OQF_NameLat nvarchar(200)
  DECLARE @OQF_Order int
  DECLARE @OQF_BitAttributes int
  DECLARE @OQF_DefaultValue nvarchar(200)
  DECLARE @OQF_RelatedTableId int
  DECLARE @OQF_RelatedColumnId int
  DECLARE @OQF_Comment nvarchar(200)
  DECLARE @OQF_TagXML nvarchar(50)
  DECLARE @OQF_Format nvarchar(50)
  DECLARE @OQF_Example nvarchar(200)
  DECLARE @OQF_QuerySQL nvarchar(200)
  DECLARE @OQF_Bookmark nvarchar(50)
  
  DECLARE @NQF_QUKey int
  DECLARE @NQF_QFTKey int
  DECLARE @NQF_Name nvarchar(200)
  DECLARE @NQF_NameLat nvarchar(200)
  DECLARE @NQF_Order int
  DECLARE @NQF_BitAttributes int
  DECLARE @NQF_DefaultValue nvarchar(200)
  DECLARE @NQF_RelatedTableId int
  DECLARE @NQF_RelatedColumnId int
  DECLARE @NQF_Comment nvarchar(200)
  DECLARE @NQF_TagXML nvarchar(50)
  DECLARE @NQF_Format nvarchar(50)
  DECLARE @NQF_Example nvarchar(200)
  DECLARE @NQF_QuerySQL nvarchar(200)
  DECLARE @NQF_Bookmark nvarchar(50)
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_QuestionnaireFields CURSOR FOR 
	SELECT 	N.QF_Key,
	        null, null, null, null, null, null, null, null, null, null, null, 
	            null, null, null, null,
			N.QF_QUKey, N.QF_QFTKey, N.QF_Name, N.QF_NameLat, N.QF_Order, N.QF_BitAttributes, N.QF_DefaultValue, N.QF_RelatedTableId, N.QF_RelatedColumnId, N.QF_Comment, N.QF_TagXML, 
				N.QF_Format, N.QF_Example, N.QF_QuerySQL, N.QF_Bookmark
	FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_QuestionnaireFields CURSOR FOR 
	SELECT 	O.QF_Key,
			O.QF_QUKey, O.QF_QFTKey, O.QF_Name, O.QF_NameLat, O.QF_Order, O.QF_BitAttributes, O.QF_DefaultValue, O.QF_RelatedTableId, O.QF_RelatedColumnId, O.QF_Comment, O.QF_TagXML, 
				O.QF_Format, O.QF_Example, O.QF_QuerySQL, O.QF_Bookmark,
	        null, null, null, null, null, null, null, null, null, null, null, 
	            null, null, null, null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_QuestionnaireFields CURSOR FOR 
	SELECT 	N.QF_Key,
			O.QF_QUKey, O.QF_QFTKey, O.QF_Name, O.QF_NameLat, O.QF_Order, O.QF_BitAttributes, O.QF_DefaultValue, O.QF_RelatedTableId, O.QF_RelatedColumnId, O.QF_Comment, O.QF_TagXML, 
				O.QF_Format, O.QF_Example, O.QF_QuerySQL, O.QF_Bookmark,
			N.QF_QUKey, N.QF_QFTKey, N.QF_Name, N.QF_NameLat, N.QF_Order, N.QF_BitAttributes, N.QF_DefaultValue, N.QF_RelatedTableId, N.QF_RelatedColumnId, N.QF_Comment, N.QF_TagXML, 
				N.QF_Format, N.QF_Example, N.QF_QuerySQL, N.QF_Bookmark
	FROM DELETED O, INSERTED N 
	WHERE N.QF_Key = O.QF_Key
  END
  
  OPEN cur_QuestionnaireFields
	FETCH NEXT FROM cur_QuestionnaireFields INTO 
		@QF_Key,
		@OQF_QUKey, @OQF_QFTKey, @OQF_Name, @OQF_NameLat, @OQF_Order, @OQF_BitAttributes, @OQF_DefaultValue, @OQF_RelatedTableId, @OQF_RelatedColumnId, @OQF_Comment, 
			@OQF_TagXML, @OQF_Format, @OQF_Example, @OQF_QuerySQL, @OQF_Bookmark, 
		@NQF_QUKey, @NQF_QFTKey, @NQF_Name, @NQF_NameLat, @NQF_Order, @NQF_BitAttributes, @NQF_DefaultValue, @NQF_RelatedTableId, @NQF_RelatedColumnId, @NQF_Comment, 
			@NQF_TagXML, @NQF_Format, @NQF_Example, @NQF_QuerySQL, @NQF_Bookmark
	WHILE @@FETCH_STATUS = 0
	BEGIN
	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQF_QUKey, '') != ISNULL(@NQF_QUKey, '') OR
			ISNULL(@OQF_QFTKey, '') != ISNULL(@NQF_QFTKey, '') OR
			ISNULL(@OQF_Name, '') != ISNULL(@NQF_Name, '') OR
			ISNULL(@OQF_NameLat, '') != ISNULL(@NQF_NameLat, '') OR
			ISNULL(@OQF_Order, '') != ISNULL(@NQF_Order, '') OR
			ISNULL(@OQF_BitAttributes, '') != ISNULL(@NQF_BitAttributes, '') OR
			ISNULL(@OQF_DefaultValue, '') != ISNULL(@NQF_DefaultValue, '') OR
			ISNULL(@OQF_RelatedTableId, '') != ISNULL(@NQF_RelatedTableId, '') OR
			ISNULL(@OQF_RelatedColumnId, '') != ISNULL(@NQF_RelatedColumnId, '') OR
			ISNULL(@OQF_Comment, '') != ISNULL(@NQF_Comment, '') OR
			ISNULL(@OQF_TagXML, '') != ISNULL(@NQF_TagXML, '') OR
			ISNULL(@OQF_Format, '') != ISNULL(@NQF_Format, '') OR
			ISNULL(@OQF_Example, '') != ISNULL(@NQF_Example, '') OR
			ISNULL(@OQF_QuerySQL, '') != ISNULL(@NQF_QuerySQL, '') OR
			ISNULL(@OQF_Bookmark, '') != ISNULL(@NQF_Bookmark, '')
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NQF_Name, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OQF_Name, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NQF_Name, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 52, @QF_Key, @sMod, @sHI_Text, '', 0, ''
			
			--------Детализация--------------------------------------------------
	
			If (ISNULL(@OQF_QUKey, '') != ISNULL(@NQF_QUKey, ''))
				BEGIN	
					declare @OQF_QU varchar(200), @NQF_QU varchar(200)
					
					If(@OQF_QUKey is not null)
						select @OQF_QU = QU_Name from Questionnaire where QU_Key = @OQF_QUKey
					else
						set @OQF_QU = null
						
					If(@NQF_QUKey is not null)
						select @NQF_QU = QU_Name from Questionnaire where QU_Key = @NQF_QUKey
					else
						set @NQF_QU = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52001, null, null, @OQF_QUKey, @NQF_QUKey, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQF_QFTKey, '') != ISNULL(@NQF_QFTKey, ''))
				BEGIN	
					declare @OQF_QFT varchar(200), @NQF_QFT varchar(200)
					
					If(@OQF_QFTKey is not null)
						select @OQF_QFT = QFT_Name from QuestionnaireFieldTemplate where QFT_Key = @OQF_QFTKey
					else
						set @OQF_QFT = null
						
					If(@NQF_QFTKey is not null)
						select @NQF_QFT = QFT_Name from QuestionnaireFieldTemplate where QFT_Key = @NQF_QFTKey
					else
						set @NQF_QFT = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52002, @OQF_QFT, @NQF_QFT, @OQF_QFTKey, @NQF_QFTKey, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQF_Name, '') != ISNULL(@NQF_Name, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52003, @OQF_Name, @NQF_Name, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQF_NameLat, '') != ISNULL(@NQF_NameLat, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52004, @OQF_NameLat, @NQF_NameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQF_Order, '') != ISNULL(@NQF_Order, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52005,  null, null, @OQF_Order, @NQF_Order, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQF_BitAttributes, '') != ISNULL(@NQF_BitAttributes, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52006, null, null, @OQF_BitAttributes, @NQF_BitAttributes, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQF_DefaultValue, '') != ISNULL(@NQF_DefaultValue, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52007, @OQF_DefaultValue, @NQF_DefaultValue, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQF_RelatedTableId, '') != ISNULL(@NQF_RelatedTableId, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52008, null, null, @OQF_RelatedTableId, @NQF_RelatedTableId, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQF_RelatedColumnId, '') != ISNULL(@NQF_RelatedColumnId, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52009, null, null, @OQF_RelatedColumnId, @NQF_RelatedColumnId, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQF_Comment, '') != ISNULL(@NQF_Comment, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52010, @OQF_Comment, @NQF_Comment, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQF_TagXML, '') != ISNULL(@NQF_TagXML, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52011, @OQF_TagXML, @NQF_TagXML, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQF_Format, '') != ISNULL(@NQF_Format, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52012, @OQF_Format, @NQF_Format, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQF_Example, '') != ISNULL(@NQF_Example, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52013, @OQF_Example, @NQF_Example, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQF_QuerySQL, '') != ISNULL(@NQF_QuerySQL, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52014, @OQF_QuerySQL, @NQF_QuerySQL, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQF_Bookmark, '') != ISNULL(@NQF_Bookmark, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 52015, @OQF_Bookmark, @NQF_Bookmark, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END

		END
		FETCH NEXT FROM cur_QuestionnaireFields INTO 
		@QF_Key,
		@OQF_QUKey, @OQF_QFTKey, @OQF_Name, @OQF_NameLat, @OQF_Order, @OQF_BitAttributes, @OQF_DefaultValue, @OQF_RelatedTableId, @OQF_RelatedColumnId, @OQF_Comment, 
			@OQF_TagXML, @OQF_Format, @OQF_Example, @OQF_QuerySQL, @OQF_Bookmark, 
		@NQF_QUKey, @NQF_QFTKey, @NQF_Name, @NQF_NameLat, @NQF_Order, @NQF_BitAttributes, @NQF_DefaultValue, @NQF_RelatedTableId, @NQF_RelatedColumnId, @NQF_Comment, 
			@NQF_TagXML, @NQF_Format, @NQF_Example, @NQF_QuerySQL, @NQF_Bookmark
	END
  CLOSE cur_QuestionnaireFields
  DEALLOCATE cur_QuestionnaireFields
GO



/*********************************************************************/
/* end T_QuestionnaireFieldUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuestionnaireFieldCaseUpdate.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuestionnaireFieldCaseUpdate')
	drop trigger dbo.T_QuestionnaireFieldCaseUpdate
go

CREATE TRIGGER [dbo].[T_QuestionnaireFieldCaseUpdate] ON [dbo].[QuestionnaireFieldCase]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-07-08</DATE>
--<VERSION>2009.2.20.0</VERSION>
  DECLARE @QFC_Key int
  
  DECLARE @OQFC_QFKey int
  DECLARE @OQFC_Value nvarchar(200)
  DECLARE @OQFC_ValueLat nvarchar(200)
  DECLARE @OQF_Order int
  
  DECLARE @NQFC_QFKey int
  DECLARE @NQFC_Value nvarchar(200)
  DECLARE @NQFC_ValueLat nvarchar(200)
  DECLARE @NQF_Order int
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_QuestionnaireFieldCases CURSOR FOR 
	SELECT 	N.QFC_Key,
	        null, null, null, null,
			N.QFC_QFKey, N.QFC_Value, N.QFC_ValueLat, N.QFC_Order
	FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_QuestionnaireFieldCases CURSOR FOR 
	SELECT 	O.QFC_Key,
	        O.QFC_QFKey, O.QFC_Value, O.QFC_ValueLat, O.QFC_Order,
			null, null, null, null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_QuestionnaireFieldCases CURSOR FOR 
	SELECT 	N.QFC_Key,
			O.QFC_QFKey, O.QFC_Value, O.QFC_ValueLat, O.QFC_Order,
			N.QFC_QFKey, N.QFC_Value, N.QFC_ValueLat, N.QFC_Order
	FROM DELETED O, INSERTED N 
	WHERE N.QFC_Key = O.QFC_Key
  END
  
  OPEN cur_QuestionnaireFieldCases
	FETCH NEXT FROM cur_QuestionnaireFieldCases INTO 
		@QFC_Key, 
		@OQFC_QFKey, @OQFC_Value, @OQFC_ValueLat, @OQF_Order, 
		@NQFC_QFKey, @NQFC_Value, @NQFC_ValueLat, @NQF_Order
	WHILE @@FETCH_STATUS = 0
	BEGIN
	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQFC_QFKey, '') != ISNULL(@NQFC_QFKey, '') OR
			ISNULL(@OQFC_Value, '') != ISNULL(@NQFC_Value, '') OR
			ISNULL(@OQFC_ValueLat, '') != ISNULL(@NQFC_ValueLat, '') OR
			ISNULL(@OQF_Order, '') != ISNULL(@NQF_Order, '')
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NQFC_Value, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OQFC_Value, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NQFC_Value, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 53, @QFC_Key, @sMod, @sHI_Text, '', 0, ''
			
			--------Детализация--------------------------------------------------
	
			If (ISNULL(@OQFC_QFKey, '') != ISNULL(@NQFC_QFKey, ''))
				BEGIN	
					declare @OQFC_QF varchar(200), @NQFC_QF varchar(200)
					
					If(@OQFC_QFKey is not null)
						select @OQFC_QF = QF_Name from QuestionnaireField where QF_Key = @OQFC_QFKey
					else
						set @OQFC_QF = null
						
					If(@NQFC_QFKey is not null)
						select @NQFC_QF = QF_Name from QuestionnaireField where QF_Key = @NQFC_QFKey
					else
						set @NQFC_QF = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 53001, @OQFC_QF, @NQFC_QF, @OQFC_QFKey, @NQFC_QFKey, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQFC_Value, '') != ISNULL(@NQFC_Value, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 53002, @OQFC_Value, @NQFC_Value, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQFC_ValueLat, '') != ISNULL(@NQFC_ValueLat, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 53003, @OQFC_ValueLat, @NQFC_ValueLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQF_Order, '') != ISNULL(@NQF_Order, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 53004, null, null, @OQF_Order, @NQF_Order, null, null, 0, @bNeedCommunicationUpdate output
				END

		END
		FETCH NEXT FROM cur_QuestionnaireFieldCases INTO 
		@QFC_Key, 
		@OQFC_QFKey, @OQFC_Value, @OQFC_ValueLat, @OQF_Order, 
		@NQFC_QFKey, @NQFC_Value, @NQFC_ValueLat, @NQF_Order
	END
  CLOSE cur_QuestionnaireFieldCases
  DEALLOCATE cur_QuestionnaireFieldCases
GO



/*********************************************************************/
/* end T_QuestionnaireFieldCaseUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuestionnaireTouristCaseUpdate.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuestionnaireTouristCaseUpdate')
	drop trigger dbo.T_QuestionnaireTouristCaseUpdate
go

CREATE TRIGGER [dbo].[T_QuestionnaireTouristCaseUpdate] ON [dbo].[QuestionnaireTouristCase]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-07-08</DATE>
--<VERSION>2009.2.20.0</VERSION>
  DECLARE @QTC_Key int
  
  DECLARE @OQTC_TUKey int
  DECLARE @OQTC_QFKey int
  DECLARE @OQTC_QFCKey int
  DECLARE @OQTC_Value nvarchar(200)
  DECLARE @OQFC_ValueLat nvarchar(200)
  
  DECLARE @NQTC_TUKey int
  DECLARE @NQTC_QFKey int
  DECLARE @NQTC_QFCKey int
  DECLARE @NQTC_Value nvarchar(200)
  DECLARE @NQFC_ValueLat nvarchar(200)
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_QuestionnaireTouristCases CURSOR FOR 
	SELECT 	N.QTC_Key,
	        null, null, null, null, null,
			N.QTC_TUKey, N.QTC_QFKey, N.QTC_QFCKey, N.QTC_Value, N.QTC_ValueLat
	FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_QuestionnaireTouristCases CURSOR FOR 
	SELECT 	O.QTC_Key,
	        O.QTC_TUKey, O.QTC_QFKey, O.QTC_QFCKey, O.QTC_Value, O.QTC_ValueLat,
			null, null, null, null, null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_QuestionnaireTouristCases CURSOR FOR 
	SELECT 	N.QTC_Key,
			O.QTC_TUKey, O.QTC_QFKey, O.QTC_QFCKey, O.QTC_Value, O.QTC_ValueLat,
			N.QTC_TUKey, N.QTC_QFKey, N.QTC_QFCKey, N.QTC_Value, N.QTC_ValueLat
	FROM DELETED O, INSERTED N 
	WHERE N.QTC_Key = O.QTC_Key
  END
  
  OPEN cur_QuestionnaireTouristCases
	FETCH NEXT FROM cur_QuestionnaireTouristCases INTO 
		@QTC_Key, 
		@OQTC_TUKey, @OQTC_QFKey, @OQTC_QFCKey, @OQTC_Value, @OQFC_ValueLat, 
		@NQTC_TUKey, @NQTC_QFKey, @NQTC_QFCKey, @NQTC_Value, @NQFC_ValueLat
	WHILE @@FETCH_STATUS = 0
	BEGIN
	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQTC_TUKey, '') != ISNULL(@NQTC_TUKey, '') OR
			ISNULL(@OQTC_QFKey, '') != ISNULL(@NQTC_QFKey, '') OR
			ISNULL(@OQTC_QFCKey, '') != ISNULL(@NQTC_QFCKey, '') OR
			ISNULL(@OQTC_Value, '') != ISNULL(@NQTC_Value, '') OR
			ISNULL(@OQFC_ValueLat, '') != ISNULL(@NQFC_ValueLat, '')
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			declare @TUKey int 
			
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NQTC_Value, '')
				SET @TUKey = ISNULL(@NQTC_TUKey, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OQTC_Value, '')
					SET @TUKey = ISNULL(@OQTC_TUKey, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NQTC_Value, '')
				SET @TUKey = ISNULL(@NQTC_TUKey, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 54, @QTC_Key, @sMod, @sHI_Text, '', 0, '', 0, null, @TUKey
			
			--------Детализация--------------------------------------------------
	
			If (ISNULL(@OQTC_TUKey, '') != ISNULL(@NQTC_TUKey, ''))
				BEGIN	
					declare @OQTC_TU varchar(70), @NQTC_TU varchar(70)
					
					If(@OQTC_TUKey is not null)
						select @OQTC_TU = TU_NAMERUS from tbl_Turist where TU_KEY = @OQTC_TUKey
					else
						set @OQTC_TU = null
						
					If(@NQTC_TUKey is not null)
						select @NQTC_TU = TU_NAMERUS from tbl_Turist where TU_KEY = @NQTC_TUKey
					else
						set @NQTC_TU = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 54001, @OQTC_TU, @NQTC_TU, @OQTC_TUKey, @NQTC_TUKey, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQTC_QFKey, '') != ISNULL(@NQTC_QFKey, ''))
				BEGIN	
					declare @OQTC_QF varchar(200), @NQTC_QF varchar(200)
					
					If(@OQTC_QFKey is not null)
						select @OQTC_QF = QF_Name from QuestionnaireField where QF_Key = @OQTC_QFKey
					else
						set @OQTC_QF = null
						
					If(@NQTC_QFKey is not null)
						select @NQTC_QF = QF_Name from QuestionnaireField where QF_Key = @NQTC_QFKey
					else
						set @NQTC_QF = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 54002, @OQTC_QF, @NQTC_QF, @OQTC_QFKey, @NQTC_QFKey, null, null, 0, @bNeedCommunicationUpdate output
				END
				
			If (ISNULL(@OQTC_QFCKey, '') != ISNULL(@NQTC_QFCKey, ''))
				BEGIN	
					declare @OQTC_QFC varchar(200), @NQTC_QFC varchar(200)
					
					If(@OQTC_QFCKey is not null)
						select @OQTC_QFC = QFC_Value from QuestionnaireFieldCase where QFC_Key = @OQTC_QFCKey
					else
						set @OQTC_QFC = null
						
					If(@NQTC_QFCKey is not null)
						select @NQTC_QFC = QFC_Value from QuestionnaireFieldCase where QFC_Key = @NQTC_QFCKey
					else
						set @NQTC_QFC = null
					
					EXECUTE dbo.InsertHistoryDetail @nHIID , 54003, @OQTC_QFC, @NQTC_QFC, @OQTC_QFCKey, @NQTC_QFCKey, null, null, 0, @bNeedCommunicationUpdate output
				END
			
			If (ISNULL(@OQTC_Value, '') != ISNULL(@NQTC_Value, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 54004, @OQTC_Value, @NQTC_Value, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END	
			
			If (ISNULL(@OQFC_ValueLat, '') != ISNULL(@NQFC_ValueLat, ''))
				BEGIN	
					EXECUTE dbo.InsertHistoryDetail @nHIID , 54005, @OQFC_ValueLat, @NQFC_ValueLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
				END

		END
		FETCH NEXT FROM cur_QuestionnaireTouristCases INTO 
		@QTC_Key, 
		@OQTC_TUKey, @OQTC_QFKey, @OQTC_QFCKey, @OQTC_Value, @OQFC_ValueLat, 
		@NQTC_TUKey, @NQTC_QFKey, @NQTC_QFCKey, @NQTC_Value, @NQFC_ValueLat
	END
  CLOSE cur_QuestionnaireTouristCases
  DEALLOCATE cur_QuestionnaireTouristCases
GO



/*********************************************************************/
/* end T_QuestionnaireTouristCaseUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_ServiceListUpdate.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_ServiceListUpdate')
	drop trigger dbo.T_ServiceListUpdate
go

CREATE TRIGGER [dbo].[T_ServiceListUpdate] ON [dbo].[ServiceList]
AFTER INSERT, UPDATE, DELETE
AS
--<DATE>2013-07-08</DATE>
--<VERSION>2009.2.20.0</VERSION>
  DECLARE @SL_Key int
  
  DECLARE @OSL_NAME varchar(60)
  DECLARE @OSL_quKey int
  
  DECLARE @NSL_NAME varchar(60)
  DECLARE @NSL_quKey int
  
  DECLARE @sMod varchar(3)
  DECLARE @nDelCount int
  DECLARE @nInsCount int
  DECLARE @nHIID int
  DECLARE @sHI_Text varchar(254)
  
  DECLARE @bNeedCommunicationUpdate smallint
	  
  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
	DECLARE cur_ServiceLists CURSOR FOR 
	SELECT 	N.SL_Key,
	        null, null,
			N.SL_NAME, N.SL_quKey
	FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
	DECLARE cur_ServiceLists CURSOR FOR 
	SELECT 	O.SL_Key,
	        O.SL_NAME, O.SL_quKey,
			null, null
	FROM DELETED O
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
	DECLARE cur_ServiceLists CURSOR FOR 
	SELECT 	N.SL_Key,
			O.SL_NAME, O.SL_quKey,
			N.SL_NAME, N.SL_quKey
	FROM DELETED O, INSERTED N 
	WHERE N.SL_Key = O.SL_Key
  END
  
  OPEN cur_ServiceLists
	FETCH NEXT FROM cur_ServiceLists INTO 
		@SL_Key, 
		@OSL_NAME, @OSL_quKey,
		@NSL_NAME, @NSL_quKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
	------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (ISNULL(@OSL_quKey, '') != ISNULL(@NSL_quKey, ''))
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			if (@sMod = 'INS')
			BEGIN
				SET @sHI_Text = ISNULL(@NSL_NAME, '')
			END
			else if (@sMod = 'DEL')
				BEGIN
					SET @sHI_Text = ISNULL(@OSL_NAME, '')
				END
			else if (@sMod = 'UPD')
			BEGIN
				SET @sHI_Text = ISNULL(@NSL_NAME, '')
			END
			
			EXEC @nHIID = dbo.InsHistory null, null, 49, @SL_Key, @sMod, @sHI_Text, '', 0, ''
			
			--------Детализация--------------------------------------------------
				declare @OSL_qu varchar(200), @NSL_qu varchar(200)
					
					If(@OSL_quKey is not null)
						select @OSL_qu = QU_Name from Questionnaire where QU_Key = @OSL_quKey
					else
						set @OSL_qu = null
						
					If(@NSL_quKey is not null)
						select @NSL_qu = QU_Name from Questionnaire where QU_Key = @NSL_quKey
					else
						set @NSL_qu = null
						
				EXECUTE dbo.InsertHistoryDetail @nHIID , 49018, @OSL_qu, @NSL_qu, @OSL_quKey, @NSL_quKey, null, null, 0, @bNeedCommunicationUpdate output
				
		END
		FETCH NEXT FROM cur_ServiceLists INTO 
		@SL_Key, 
		@OSL_NAME, @OSL_quKey,
		@NSL_NAME, @NSL_quKey
	END
  CLOSE cur_ServiceLists
  DEALLOCATE cur_ServiceLists
GO



/*********************************************************************/
/* end T_ServiceListUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (28.06.2013)_Insert_SystemSettings.sql */
/*********************************************************************/
-- по умолчанию пересадка услуг в приоритетные квоты будет работать для услуги проживание
declare @s int
select @s = dbo.mwReplIsPublisher()

if (@s = 1 and not exists (select 1 from SystemSettings where SS_ParmName='SYSServiceKeyToTransfer'))
begin
	insert into SystemSettings(SS_ParmName,SS_ParmValue, SS_Name)
	values ('SYSServiceKeyToTransfer', '3', 'Классы услуг для которых будет работать пересадка в приоритетные квоты.')
end
go



/*********************************************************************/
/* end (28.06.2013)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.11)_Delete_sp_GetServiceListQuotaTypeTransfer.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetServiceListQuotaTypeTransfer]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetServiceListQuotaTypeTransfer]
GO




/*********************************************************************/
/* end (2013.07.11)_Delete_sp_GetServiceListQuotaTypeTransfer.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.11)_Delete_sp_QuotaTypeTransfer.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[QuotaTypeTransfer]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[QuotaTypeTransfer]
GO



/*********************************************************************/
/* end (2013.07.11)_Delete_sp_QuotaTypeTransfer.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.15)_Grant_On_QuestionnaireTables.sql */
/*********************************************************************/
grant select, insert, delete, update on [dbo].[Questionnaire] to public
go

grant select, insert, delete, update on [dbo].[QuestionnaireFieldTemplate] to public
go

grant select, insert, delete, update on [dbo].[QuestionnaireField] to public
go

grant select, insert, delete, update on [dbo].[QuestionnaireFieldCase] to public
go

grant select, insert, delete, update on [dbo].[QuestionnaireTouristCase] to public
go
/*********************************************************************/
/* end (2013.07.15)_Grant_On_QuestionnaireTables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.31)_Insert_Action.sql */
/*********************************************************************/
--добавление action заполнение анкет туристов
IF NOT EXISTS (SELECT 1 FROM Actions WHERE ac_key = 76) 
	INSERT INTO Actions (AC_Key, AC_Name, AC_NameLat, AC_IsActionForRestriction) VALUES (76, 'Разрешить работу с анкетой туристов', 'Allow to work with tourists application form', 0)
Go

--добавление action справочник визовых анкет
IF NOT EXISTS (SELECT 1 FROM Actions WHERE ac_key = 99) 
	INSERT INTO Actions (AC_Key, AC_Name, AC_NameLat, AC_IsActionForRestriction) VALUES (99, 'Справочники -> Скрыть справочник визовых анкет', null, 1)
Go
/*********************************************************************/
/* end (2013.07.31)_Insert_Action.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_WcfTransferServicesInDatePeriod.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WcfTransferServicesInDatePeriod]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[WcfTransferServicesInDatePeriod]
GO
CREATE PROCEDURE [dbo].[WcfTransferServicesInDatePeriod]
--<VERSION>2011.1</VERSION>
--<DATE>2013-08-09</DATE>
	(
		@useCache BIT,
		@dateFrom DATETIME,
		@dateTo DATETIME
	)
AS
BEGIN
	declare @commandLine varchar(2000), @path varchar(2000)
	
	select @path = SS_ParmValue from SystemSettings where SS_ParmName = 'PathToWcfClient'
	
	if (@path is not null)
	begin
		set @commandLine = @path + ' TransferServicesInDatePeriod'
		set @commandLine = @commandLine + ' ' + (case when @useCache = 1 then ' true' else ' false' end)
		set @commandLine = @commandLine + ' "' + convert(varchar, @dateFrom) + '"'
		set @commandLine = @commandLine + ' "' + convert(varchar, @dateTo) + '"'
	end
	else
	begin
		RAISERROR('Ошибка: не указан пусть к сервису', 16, 1)
	end
	
	print @commandLine
	exec xp_cmdshell @commandLine
END

GO	
grant exec on [dbo].[WcfTransferServicesInDatePeriod] to public
GO
/*********************************************************************/
/* end sp_WcfTransferServicesInDatePeriod.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_TransferServices.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TransferServices]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[TransferServices]
GO
CREATE PROCEDURE [dbo].[TransferServices]
--<VERSION>2011.1</VERSION>
--<DATE>2013-09-25</DATE>
	(
		@useCache BIT
	)
AS
BEGIN 
	DECLARE @quotasResult TABLE ( serviceResult NVARCHAR(MAX) )
	DECLARE @endServiceDate DATETIME
	DECLARE @nextServiceDate DATETIME
	DECLARE @step INT
	
	-- Шаг пересадки
	SET @step = 7
	
	SELECT @endServiceDate = MAX(SD_Date) FROM ServiceByDate WITH(NOLOCK) WHERE SD_State = 1 OR SD_State = 2
	SET @nextServiceDate = DATEADD(dd, 0, DATEDIFF(dd, 0, GETDATE())) 
	DECLARE @rowId VARCHAR(50)
	SELECT @rowId = CAST(@@dbts AS VARCHAR(50))

	WHILE @nextServiceDate <= @endServiceDate
	BEGIN
		DECLARE @startTransferDate DATETIME
		DECLARE @endTransferDate DATETIME
		
		SET @startTransferDate = @nextServiceDate
		SET @nextServiceDate = DATEADD(dd, @step, @nextServiceDate)
		IF @nextServiceDate < @endServiceDate
			SET @endTransferDate = DATEADD(dd, -1, @nextServiceDate)
		ELSE
			SET @endTransferDate = @endServiceDate
		
		DELETE FROM @quotasResult
		
		INSERT INTO @quotasResult EXEC WcfTransferServicesInDatePeriod @useCache, @startTransferDate, @endTransferDate
		IF (SELECT COUNT(*) FROM @quotasResult) > 1
		BEGIN 
			DECLARE @errorText NVARCHAR(MAX)  
			SELECT @errorText = COALESCE(@errorText + ' ', '') + serviceResult FROM @quotasResult
			SET @errorText = 'Ошибка сервиса пересадки квот: ' + @errorText;
			RAISERROR(@errorText, 16, 1)
		END
	END
	
	UPDATE SystemSettings SET SS_ParmValue = @rowId WHERE SS_ParmName = 'SYSCurrentRowIdForQuotas'
END

GO	
grant exec on [dbo].[TransferServices] to public
GO
/*********************************************************************/
/* end sp_TransferServices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CheckDoubleReservation.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckDoubleReservation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckDoubleReservation]
GO

create procedure [dbo].[CheckDoubleReservation]
(	
	--<VERSION>2009.2.20<VERSION/>
	--<DATE>2013-08-01<DATE/>
	-- процедура определяет есть ли дублирующая путевка
	-- ключ договора
	@dogovorKey int,
	-- ключ дублирующего договора, если значение null то дублирующего договора не найдено
	@doubledogovorKey int output
)
AS
begin
	set @doubledogovorKey = null
	declare @dg_nday int
	declare @dg_turdate datetime
	
	select @dg_nday=DG_NDAY,@dg_turdate=DG_TURDATE from tbl_Dogovor where DG_Key=@dogovorKey

	select top 1 @doubledogovorKey = TU1.TU_DGKEY
	from  tbl_turist as TU1
	inner join tbl_turist as TU2 on TU2.TU_DGKEY = @dogovorKey
	where TU1.TU_DGKEY != @dogovorKey
	and TU1.TU_DGKEY in (select dg_key from dogovor where DG_TURDATE > GETDATE()-100 and
	(DG_TURDATE between @dg_turdate and DATEADD(DAY, @dg_nday - 1, @dg_turdate)
	or @dg_turdate between DG_TURDATE and DATEADD(DAY, DG_NDAY - 1, DG_TURDATE)))
	AND  RTRIM(LTRIM(UPPER(TU1.TU_NAMERUS))) = RTRIM(LTRIM(UPPER(TU2.TU_NAMERUS)))
	and RTRIM(LTRIM(UPPER(TU1.TU_FNAMERUS))) = RTRIM(LTRIM(UPPER(TU2.TU_FNAMERUS)))
	and (TU1.TU_BIRTHDAY IS NULL or TU2.TU_BIRTHDAY IS NULL or TU1.TU_BIRTHDAY = TU2.TU_BIRTHDAY)
	and (
		TU1.TU_PASPORTTYPE IS NULL 
		or TU2.TU_PASPORTTYPE IS NULL 
		or RTRIM(LTRIM(UPPER(TU1.TU_PASPORTTYPE))) = RTRIM(LTRIM(UPPER(TU2.TU_PASPORTTYPE)))
	)
	and (
		TU1.TU_PASPORTNUM IS NULL 
		or TU2.TU_PASPORTNUM IS NULL 
		or RTRIM(LTRIM(UPPER(TU1.TU_PASPORTNUM))) = RTRIM(LTRIM(UPPER(TU2.TU_PASPORTNUM)))
	)
end
go

grant exec on [dbo].[CheckDoubleReservation] to public
go
/*********************************************************************/
/* end sp_CheckDoubleReservation.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CheckDoubleDogovor.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='CheckDoubleDogovor')
	drop proc dbo.CheckDoubleDogovor
go

create procedure [dbo].[CheckDoubleDogovor]  
	--<VERSION>2009.2.20.1<VERSION/>
	--<DATA>2013-08-29<DATA/>
	@TourDate varchar (10),
	@TourDuration int,
	@LastName varchar (25),
	@FirstName varchar (25),
	@Sex int,	
	@HotelKey int,
	@HotelStartDate varchar (10) = null,
	@HotelEndDate varchar (10) = null,
	@Birthday varchar (10) = null,
	@PassportType varchar(5) = null,
	@PassportNum varchar(13) = null
AS
begin
	begin try 
		-- Task 13501 19.04.2013 kolbeshkin: сделано READ UNCOMMITTED
		SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
		BEGIN TRANSACTION
			--CRM01804K4X8 27.07.2012 kolbeshkin: переделал хранимку проверки дублирования туристов
			SET @LastName = REPLACE (@LastName,'''','')
			SET @FirstName = REPLACE (@FirstName,'''','')
			-- проверяем только: 
			-- 1.Взрослых
			-- 2.Если есть отель, т.к. остальные услуги могут быть по 2 и более и разнесены по разным путевкам
			IF @Sex NOT IN (0,1) OR @HotelKey < 0 OR @HotelStartDate IS NULL OR @HotelEndDate IS NULL
				BEGIN
					COMMIT TRANSACTION
					RETURN
				END
			-- Сравнение:
			-- 1.Фамилия
			-- 2.Имя
			-- 3.Пересекаются ли даты тура
			-- 4.Пол
			-- 5.Существует ли проживание и пересекаются ли его даты
			DECLARE @sql nvarchar(max)
			SET @sql = 'SELECT TU_DGCOD, TU_KEY 
					From [dbo].[tbl_turist] 
					where RTRIM(LTRIM((UPPER(TU_NAMERUS)))) = RTRIM(LTRIM((UPPER(''' + @LastName + ''')))) 
					AND RTRIM(LTRIM((UPPER(TU_FNAMERUS)))) = RTRIM(LTRIM((UPPER(''' + @FirstName + ''')))) 
					AND EXISTS (SELECT DG_KEY 
								FROM tbl_dogovor 
								where DG_CODE = TU_DGCOD
								and (''' + @TourDate + ''' between DG_TURDATE and DATEADD(DAY, DG_NDAY - 1, DG_TURDATE)
										or DG_TURDATE between ''' + @TourDate + ''' and DATEADD(DAY, ' + CAST(@TourDuration AS varchar(3)) + ' - 1, ''' + @TourDate + '''))) 
					AND ISNULL(TU_SEX,0) in (0,1) AND ISNULL(TU_SEX,0) = ' + CAST(@Sex AS varchar(2)) + '
					AND EXISTS (SELECT 1 FROM tbl_DogovorList,TuristService WHERE DL_SVKey=3 and TU_DLKey=DL_Key and DL_DGCOD=TU_DGCOD and TU_TUKey=TU_Key
								AND (''' + @HotelStartDate + ''' between DL_DATEBEG and DL_DATEEND OR DL_DATEBEG between ''' + @HotelStartDate + ''' and ''' + @HotelEndDate + ''') )'
			-- 6.Дата рождения (если задана у бронирующего)						
			IF @Birthday IS NOT NULL
				SET @sql = @sql + '
				 AND (TU_BIRTHDAY IS NULL OR TU_BIRTHDAY = ''' + @Birthday + ''')'
			-- 7.Серия паспорта (если задана у бронирующего)			
			IF @PassportType IS NOT NULL
				SET @sql = @sql + '
				 AND (TU_PASPORTTYPE IS NULL OR TU_PASPORTTYPE = ''' + @PassportType + ''')'
			-- 8.Серия паспорта (если задана у бронирующего)	
			IF @PassportNum IS NOT NULL
				SET @sql = @sql + '
				 AND (TU_PASPORTNUM IS NULL OR TU_PASPORTNUM = ''' + @PassportNum + ''')'
		
		 --print @sql
		 EXECUTE sp_executesql @sql
		 COMMIT TRANSACTION
	end try 
	begin catch 
		ROLLBACK TRANSACTION
		insert into SystemLog (SL_Message,SL_Date) values ('Error executing stored procedure CheckDoubleDogovor. Parameters: '
		+ '''' + @TourDate + ''',' + cast(@TourDuration as varchar(12)) + ',''' + @LastName + ''',''' + @FirstName + ''',' 
		+ cast(@Sex as varchar(12)) + ',' + cast(@HotelKey as varchar(12)) + ',''' + isnull(@HotelStartDate,'null') + ''',''' 
		+ isnull(@HotelEndDate,'null') + ''',''' + isnull(@Birthday,'null') + ''',''' + isnull(@PassportType,'null') + ''','''
		+ isnull(@PassportNum,'null') + '''', GETDATE())

		DECLARE @ErrorMessage NVARCHAR(4000)
		DECLARE @ErrorSeverity INT
		DECLARE @ErrorState INT
		SELECT @ErrorMessage = ERROR_MESSAGE(),
           @ErrorSeverity = ERROR_SEVERITY(),
           @ErrorState = ERROR_STATE()

		RAISERROR (@ErrorMessage,@ErrorSeverity,@ErrorState)
	end catch
end
go

grant exec on [dbo].[CheckDoubleDogovor] to public
go


/*********************************************************************/
/* end sp_CheckDoubleDogovor.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwUpdateHotelDetails.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwUpdateHotelDetails]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwUpdateHotelDetails]
GO

CREATE procedure [dbo].[mwUpdateHotelDetails] 
	@onlyNew smallint = 0 
as
begin

	--<VERSION>9.2.20</VERSION>
	--<DATA>29.08.2013</DATA>

	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	declare @mwSearchType int
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'

	delete from mwHotelDetails
	where htd_hdkey not in (select htr_hdkey from HotelTypeRelations)

	insert into mwHotelDetails(htd_hdkey, htd_minpricectfrom, htd_needupdate)
	select distinct sd_hdkey, sd_ctkeyfrom, 1
	from mwSpoDataTable 
	where sd_hdkey in (select htr_hdkey from HotelTypeRelations)
	and not exists (select 1 from mwHotelDetails where htd_hdkey = sd_hdkey and htd_minpricectfrom = sd_ctkeyfrom)

	if (@mwSearchType = 0)
	begin
		update mwHotelDetails 
		set htd_minprice = pt_price, 
			htd_minpricedate = pt_tourdate,
			htd_minpricerate = pt_rate,
			htd_minpricekey = pt_pricekey,
			htd_needupdate = 0
		from mwPriceTable
		inner join 
		(
			select distinct pt_hdkey hdkey, pt_ctkeyfrom ctkeyfrom, min(pt_pricekey) pricekey
			from mwPriceTable,
			(
				select pt_hdkey hdkey, pt_ctkeyfrom ctkeyfrom, min(pt_price) minprice
				from mwPriceTable with(nolock) 
				where pt_hdkey in
				( 
					select htd_hdkey
					from mwHotelDetails
					where  htd_needupdate = 1 or @onlyNew = 0
				)
				and pt_main > 0 
				group by pt_hdkey, pt_ctkeyfrom
			) tbl
			where pt_hdkey = hdkey and pt_price = minprice and pt_ctkeyfrom = ctkeyfrom 
			group by pt_hdkey, pt_ctkeyfrom
		) tbl2 on pt_pricekey = pricekey
		where htd_hdkey = pt_hdkey
		and htd_minpricectfrom = pt_ctkeyfrom
	end
	else
	begin
		declare @cnKey int, @ctKeyFrom int, @tableName nvarchar(1024), @sql nvarchar(max)

		declare hotelCursor cursor local fast_forward for
		select distinct sd_cnkey, sd_ctkeyfrom
		from mwHotelDetails
		join HotelDictionary on htd_hdkey = HD_KEY
		join mwSpoDataTable on sd_cnkey = HD_CNKEY
		where  htd_needupdate = 1 or @onlyNew = 0

		open hotelCursor
		fetch hotelCursor into @cnKey, @ctKeyFrom
		while (@@FETCH_STATUS = 0)
		begin
			set @tableName = dbo.mwGetPriceTableName(@cnKey, @ctKeyFrom)
			set @sql = 'update mwHotelDetails 
						set htd_minprice = pt_price, 
							htd_minpricedate = pt_tourdate,
							htd_minpricerate = pt_rate,
							htd_minpricekey = pt_pricekey,
							htd_needupdate = 0
						from @mwPriceTable
						inner join 
						(
							select distinct pt_hdkey hdkey, pt_ctkeyfrom ctkeyfrom, min(pt_pricekey) pricekey
							from @mwPriceTable,
							(
								select pt_hdkey hdkey, pt_ctkeyfrom ctkeyfrom, min(pt_price) minprice
								from @mwPriceTable with(nolock) 
								where pt_hdkey in
								( 
									select htd_hdkey
									from mwHotelDetails
									where (htd_needupdate = 1 or @onlyNew = 0)
								)
								and pt_main > 0 
								group by pt_hdkey, pt_ctkeyfrom
							) tbl
							where pt_hdkey = hdkey and pt_price = minprice and pt_ctkeyfrom = ctkeyfrom 
							group by pt_hdkey, pt_ctkeyfrom
						) tbl2 on pt_pricekey = pricekey
						where htd_hdkey = pt_hdkey
						and htd_minpricectfrom = pt_ctkeyfrom'

			set @sql = REPLACE(@sql, '@cnKey', ltrim(str(@cnKey)))
			set @sql = REPLACE(@sql, '@onlyNew', ltrim(str(@onlyNew)))
			set @sql = REPLACE(@sql, '@mwPriceTable', @tableName)

			exec (@sql)
				
			fetch hotelCursor into @cnKey, @ctKeyFrom
		end
		close hotelCursor
		deallocate hotelCursor
	end
end
GO

GRANT EXEC ON [dbo].[mwUpdateHotelDetails] TO PUBLIC
GO
/*********************************************************************/
/* end sp_mwUpdateHotelDetails.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.09.10)_Alter_mwHotelDetails.sql */
/*********************************************************************/
if exists (select * from dbo.syscolumns where name ='htd_minpricectfrom' and id = object_id(N'[dbo].[mwHotelDetails]'))
and not exists (select * from sys.sysobjects where xtype = 'D' and name like 'htd_minpricectfrom_default')
begin
	TRUNCATE TABLE mwHotelDetails

	ALTER TABLE mwHotelDetails DROP COLUMN htd_minpricectfrom

	ALTER TABLE mwHotelDetails ADD [htd_minpricectfrom] [int] NOT NULL

	ALTER TABLE mwHotelDetails ADD CONSTRAINT [htd_minpricectfrom_default] DEFAULT 0 FOR [htd_minpricectfrom]

	if exists(select * from sys.sysobjects where name like 'PK_mwHotelDetails' and xtype = 'PK')
	begin
		ALTER TABLE mwHotelDetails drop constraint PK_mwHotelDetails

		ALTER TABLE [dbo].[mwHotelDetails] ADD  CONSTRAINT [PK_mwHotelDetails] PRIMARY KEY CLUSTERED 
		(
			[htd_hdkey] ASC,
			[htd_minpricectfrom] ASC
		)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	end

	exec mwUpdateHotelDetails
end
GO
/*********************************************************************/
/* end (2013.09.10)_Alter_mwHotelDetails.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetTpPricesKey.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetTpPricesKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetTpPricesKey]
GO
CREATE PROCEDURE [dbo].[GetTpPricesKey]
  (@nNewKey int = null output)
AS
--<VERSION>9.2.20</VERSION>
--<DATE>2013-10-08</DATE>
--<SUMMARY>Возвращает ключ для таблицы</SUMMARY>
begin
	-- Скрипт устанавливает новый ключ для таблицы tp_prices
	-- Для этого ищет наибольший промежуток разрыва используемых ключей

	declare @newKey as int, @newMaxKey as int
	set @newKey = null
	set @newMaxKey = null

	create table #keys
	(
		id int
	)

	begin try
		insert into #keys
		select TP_Key
		from TP_Prices with (nolock)

		select top 1 @newKey = id+1, @newMaxKey = (select MIN(i.id)-1 from #keys i with (nolock) where i.id > o.id)
		from #keys o with (nolock)
		where id not in(
		select f.id
		from #keys f with (nolock)
		inner join #keys s with (nolock) on s.id-1 = f.id)
		order by -id + (select MIN(id) from #keys i with (nolock) where i.id > o.id) desc

		if @newKey is null or @newMaxKey is null
		begin
			print 'GetTpPricesKey: новый ключ не найден!'
		end
		else
		if exists (select top 1 1 from TP_Prices with (nolock) where TP_Key = @newKey)
		begin
			print 'GetTpPricesKey: новый ключ найден неправильно! Перезапустите скирпт и сообщите разработчикам в случае повторения ошибки.'
		end
		else
		begin
			if ((select (2147483000 - max(id)) from #keys) > @newMaxKey - @newKey)
			begin
				select  @nNewKey = max(id) + 1 from #keys
			end
			else begin
				set @nNewKey = @newKey
			end
		end
	end try
	begin catch
		select ERROR_MESSAGE()
	end catch

	drop table #keys
end
GO
GRANT EXECUTE ON [dbo].[GetTpPricesKey] TO Public
GO
/*********************************************************************/
/* end sp_GetTpPricesKey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.09.10)_Create_Table_Key_TP_Tables.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPQueueAddCosts]') AND type in (N'U'))
begin
	drop table Key_TPQueueAddCosts
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPTourMarginActualDate]') AND type in (N'U'))
begin
	drop table Key_TPTourMarginActualDate
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPFlights]') AND type in (N'U'))
begin
	drop table Key_TPFlights
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPPriceDetails]') AND type in (N'U'))
begin
	drop table Key_TPPriceDetails
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPPricesCleaner]') AND type in (N'U'))
begin
	drop table Key_TPPricesCleaner
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServicePriceNextDate]') AND type in (N'U'))
begin
	drop table Key_TPServicePriceNextDate
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServiceTours]') AND type in (N'U'))
begin
	drop table Key_TPServiceTours
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPTourParametrs]') AND type in (N'U'))
begin
	drop table Key_TPTourParametrs
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPPricesDeleted]') AND type in (N'U'))
begin
	drop table Key_TPPricesDeleted
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServiceComponents]') AND type in (N'U'))
begin
	drop table Key_TPServiceComponents
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServiceCalculateParametrs]') AND type in (N'U'))
begin
	drop table Key_TPServiceCalculateParametrs
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServicePriceActualDate]') AND type in (N'U'))
begin
	drop table Key_TPServicePriceActualDate
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPPriceComponents]') AND type in (N'U'))
begin
	drop table Key_TPPriceComponents
end
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPPricesUpdated]') AND type in (N'U'))
begin
	drop table Key_TPPricesUpdated
end
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPLists]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TP_Lists
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TPLists](
		[ID] [int] NULL
	) ON [PRIMARY]	

	insert into [Key_TPLists] (id) Select top 1 id from Keys where Key_Table like 'TP_Lists'
end
go

grant select, insert, delete, update on [dbo].[Key_TPLists] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPPrices]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TP_Prices
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TPPrices](
		[ID] [int] NULL
	) ON [PRIMARY]	
		
	insert into [Key_TPPrices] (id) Select top 1 id from Keys where Key_Table like 'TP_Prices'
end
go

grant select, insert, delete, update on [dbo].[Key_TPPrices] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServiceLists]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TP_ServiceLists
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TPServiceLists](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_TPServiceLists] (id) Select top 1 id from Keys where Key_Table like 'TP_ServiceLists'
end
go

grant select, insert, delete, update on [dbo].[Key_TPServiceLists] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPServices]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TP_Services
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TPServices](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_TPServices] (id) Select top 1 id from Keys where Key_Table like 'TP_Services'
end
go

grant select, insert, delete, update on [dbo].[Key_TPServices] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPTours]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TP_Tours
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TPTours](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_TPTours] (id) Select top 1 id from Keys where Key_Table like 'TP_Tours'
end
go

grant select, insert, delete, update on [dbo].[Key_TPTours] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TPTurDates]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TP_TurDates
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TPTurDates](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_TPTurDates] (id) Select top 1 id from Keys where Key_Table like 'TP_TurDates'
end
go

grant select, insert, delete, update on [dbo].[Key_TPTurDates] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TURSERVICE]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TURSERVICE
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TURSERVICE](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_TURSERVICE] (id) Select top 1 id from Keys where Key_Table like 'TurService'
end
go

grant select, insert, delete, update on [dbo].[Key_TURSERVICE] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TurList]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей tbl_TurList
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TurList](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_TurList] (id) Select top 1 id from Keys where Key_Table like 'TurList'
end
go

grant select, insert, delete, update on [dbo].[Key_TurList] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_Turist]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей tbl_Turist
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_Turist](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_Turist] (id) Select top 1 id from Keys where Key_Table like 'Turist'
end
go

grant select, insert, delete, update on [dbo].[Key_Turist] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_TURMARGIN]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей TURMARGIN
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_TURMARGIN](
		[ID] [int] NULL
	) ON [PRIMARY]	

	insert into [Key_TURMARGIN] (id) Select top 1 id from Keys where Key_Table like 'TURMARGIN'
end
go

grant select, insert, delete, update on [dbo].[Key_TURMARGIN] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_PriceList]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей PriceList
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_PriceList](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_PriceList] (id) Select top 1 id from Keys where Key_Table like 'PriceList'
end
go

grant select, insert, delete, update on [dbo].[Key_PriceList] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_PriceServiceLink]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей PriceServiceLink
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_PriceServiceLink](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_PriceServiceLink] (id) Select top 1 id from Keys where Key_Table like 'PriceServiceLink'
end
go

grant select, insert, delete, update on [dbo].[Key_PriceServiceLink] to public
go

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Key_Partners]') AND type in (N'U'))
begin
	--<VERSION>9.2.20</VERSION>
	--<DATE>2013-08-30</DATE>
	--<SUMMARY>
	--Создает таблицу ключей tbl_Partners
	--</SUMMARY>
	CREATE TABLE [dbo].[Key_Partners](
		[ID] [int] NULL
	) ON [PRIMARY]	
	
	insert into [Key_Partners] (id) Select top 1 id from Keys where Key_Table like 'Partners'
end
go

grant select, insert, delete, update on [dbo].[Key_Partners] to public
go
/*********************************************************************/
/* end (2013.09.10)_Create_Table_Key_TP_Tables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.10.10)Update_Key_Dogovor_Key_DogovorList_Key_Turist.sql */
/*********************************************************************/
update Key_DogovorList set ID = (select top 1 dl_key + 100 from tbl_DogovorList order by DL_KEY desc)

update Key_Dogovor set ID = (select top 1 DG_key + 100 from tbl_Dogovor order by DG_KEY desc)

update Key_Turist set ID = (select top 1 TU_key + 100 from tbl_Turist order by TU_KEY desc)

go
/*********************************************************************/
/* end (2013.10.10)Update_Key_Dogovor_Key_DogovorList_Key_Turist.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetNKey.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetNKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetNKey]
GO
CREATE PROCEDURE [dbo].[GetNKey]
  (@sTable varchar(50) = null,
  @nNewKey int = null output)
AS
--<VERSION>9.2.20</VERSION>
--<DATE>2013-11-09</DATE>
--<SUMMARY>Возвращает ключ для таблицы</SUMMARY>

declare @transactionIsolationLevel int
declare @nID int
declare @keyTable varchar(100)
declare @query nvarchar (1000)

SELECT @transactionIsolationLevel = transaction_isolation_level 
FROM sys.dm_exec_sessions 
where session_id = @@spid

SET TRANSACTION ISOLATION LEVEL Serializable;

if @sTable like 'TP_TOURDATES'
	set @sTable = 'TP_TURDATES'

set nocount on
select @keyTable = 
		case 
		when @sTable like 'TP_TURDATES' then 'Key_TPTurDates'
		when @sTable like 'TP_Lists' then 'Key_TPLists'
		when @sTable like 'TP_Services' then 'Key_TPServices'
		when @sTable like 'TP_Tours' then 'Key_TPTours'
		when @sTable like 'TP_ServiceLists' then 'Key_TPServiceLists'
		when @sTable like 'TP_Prices' then 'Key_TPPrices'
		when @sTable like 'TURSERVICE' then 'Key_TURSERVICE'
		when @sTable like 'TURIST' then 'Key_TURIST'
		when @sTable like 'TURLIST' then 'Key_TURLIST'
		when @sTable like 'TurMargin' then 'Key_TurMargin'
		when @sTable like 'PRICELIST' then 'Key_PRICELIST'
		when @sTable like 'PRICESERVICELINK' then 'Key_PRICESERVICELINK'
		when @sTable like 'PARTNERS' then 'Key_PARTNERS'
		when @sTable like 'DogovorList' then 'Key_DogovorList'
		when @sTable like 'Dogovor' then 'Key_Dogovor'
	end

if @keyTable is not null
begin
	set @query = N'
	declare @maxKeyFromTable int 
	declare @maxKeyFromKeys int
	
	Select @maxKeyFromTable = id from @keyTable (updlock) 
	Select @maxKeyFromKeys = id from Keys WITH (UPDLOCK) where Key_Table = ''@sTable''
	If @maxKeyFromKeys < @maxKeyFromTable
		Set @nNewKeyOut = @maxKeyFromTable
	Else
		Set @nNewKeyOut = @maxKeyFromKeys
	--
	Set @nNewKeyOut = @nNewKeyOut + 1
	update @keyTable set Id = @nNewKeyOut
	update Keys set Id = @nNewKeyOut where Key_Table = ''@sTable''
	'
	begin tran
	set @query = REPLACE(@query, '@keyTable', @keyTable)
	set @query = REPLACE(@query, '@sTable', @sTable)
	EXECUTE sp_executesql @query, N'@nNewKeyOut int output', @nNewKeyOut = @nNewKey  output
	commit tran
end
else
begin 	
	begin tran
	if exists (select top 1 1 from Keys where Key_Table = @sTable)
	begin
		Select @nNewKey = id + 1 from Keys WITH (UPDLOCK) where Key_Table = @sTable
		update Keys set Id = @nNewKey where Key_Table = @sTable
	end
	else
	begin
		insert into Keys (Key_Table, Id) values (@sTable, 1)
		set @nNewKey=1
	end	
	commit tran
end

if (@transactionIsolationLevel = 1) SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
if (@transactionIsolationLevel = 2) SET TRANSACTION ISOLATION LEVEL READ COMMITTED
if (@transactionIsolationLevel = 3) SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
if (@transactionIsolationLevel = 4) SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
if (@transactionIsolationLevel = 5) SET TRANSACTION ISOLATION LEVEL SNAPSHOT

return 0
GO
GRANT EXECUTE ON [dbo].[GetNKey] TO Public
GO
/*********************************************************************/
/* end sp_GetNKey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.08.28)_Create_Type_CheckQuotasSourceTable.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.types st JOIN sys.schemas ss ON st.schema_id = ss.schema_id WHERE st.name = N'CheckQuotasSourceTable' AND ss.name = N'dbo')
	DROP TYPE [dbo].[CheckQuotasSourceTable] 
GO

CREATE TYPE [dbo].[CheckQuotasSourceTable] AS TABLE(
		[qt_svkey] [int] NULL,
		[qt_code] [int] NULL,
		[qt_subcode1] [int] NULL,
		[qt_subcode2] [int] NULL,
		[qt_agent] [int] NULL,
		[qt_prkey] [int] NULL,
		[qt_bycheckin] [int] NULL,
		[qt_release] [int] NULL,
		[qt_places] [int] NULL,
		[qt_date] [datetime] NULL,
		[qt_byroom] [int] NULL,
		[qt_type] [int] NULL,
		[qt_long] [int] NULL,
		[qt_placesAll] [int] NULL,
		[qt_stop] [smallint] NULL,
		[qt_qoid] [int] NULL,
		[qt_qdid] [int] NULL
	)
GO
GRANT EXECUTE ON TYPE::dbo.[CheckQuotasSourceTable] TO public
go

/*********************************************************************/
/* end (2013.08.28)_Create_Type_CheckQuotasSourceTable.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwCheckQuotesFlights.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwCheckQuotesFlights]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
	DROP FUNCTION [dbo].[mwCheckQuotesFlights]
GO

CREATE FUNCTION [dbo].[mwCheckQuotesFlights]
(	
	--<VERSION>2009.2.04</VERSION>
	--<DATE>2013-11-08</DATE>
	@code int, 
	@subcode1 int,	
	@agentKey int, 
	@partnerKey int, 
	@date datetime,	
	@requestOnRelease smallint, 
	@noPlacesResult int, 
	@checkAgentQuotes smallint, 
	@checkCommonQuotes smallint,
	@checkNoLongQuotes smallint,
	@findFlight smallint,
	@cityFrom int,
	@cityTo int,
	@flightpkkey int,
	@tourDuration int,
	@expiredReleaseResult int,
	@linked_day int = null)

returns @tmpResQuotes table(
	qt_svkey int,
	qt_code int,
	qt_subcode1 int,
	qt_subcode2 int,
	qt_agent int,
	qt_prkey int,
	qt_bycheckin int,
	qt_byroom int,
	qt_places int,
	qt_allPlaces int,
	qt_type int,
	qt_long int,
	qt_additional varchar(2000))
begin
	declare @tariffToStop varchar(20), @isNewSetToQuota bit
	set @tariffToStop = ',' + ltrim(str(@subcode1)) + ','
	set @isNewSetToQuota = 0
	if exists(select 1 from dbo.systemsettings where ss_parmname='MWTariffsToStop' and charindex(@tariffToStop, ',' + ss_parmvalue + ',') > 0)
		set @noPlacesResult = 0
		
	if exists(select 1 from dbo.systemsettings where ss_parmname='NewSetToQuota' and ss_parmvalue = 1)
		set @isNewSetToQuota = 1
		
	if(COALESCE(@cityFrom, 0) <= 0 or COALESCE(@cityTo, 0) <= 0)
		select @cityFrom = ch_citykeyfrom, @cityTo = ch_citykeyto from charter with(nolock) where ch_key = @code	
	
	-- если стоп ставится плагином Stop-sale на авиаперелеты
	declare @linked_date datetime, @dt1 datetime, @dt2 datetime, @ctFromStop int, @ctToStop int
	if @linked_day is not null
	begin
		set @linked_date = dateadd(day, @linked_day - 1, @date)
		if(@linked_date > @date)
		begin
			set @dt1 = @date
			set @dt2 = @linked_date
			set @ctFromStop = @cityFrom
			set @ctToStop =@cityTo
		end
		else
		begin
			set @dt1 = @linked_date
			set @dt2 = @date
			set @ctFromStop = @cityTo
			set @ctToStop = @cityFrom
		end
	end	
	
	declare @dayOfWeek int	
	set @dayOfWeek = datepart(dw, @date) - 1
	if(@dayOfWeek = 0)
		set @dayOfWeek = 7

	declare @chartersKeyTable table(
			ch_key int
		)		
	
	-- подбираем подходящие нам перелеты
	-- проверяем наличие расписания и не стоит ли стоп на перелет, через плагин Stop-Avia	
	-- если ключ пакета больше или равен нулю (@flightpkkey >= 0), то проверяем заведена ли цена на авиаперелет
	insert into @chartersKeyTable (ch_key)
	select ch_key
	FROM charter with(nolock) inner join airseason with(nolock) on as_chkey = ch_key
	where ((@findFlight <= 0 and ch_key = @code) or (@findFlight > 0 and ch_citykeyfrom = @cityFrom and ch_citykeyto = @cityTo)) 
		and (as_week is null or len(as_week)=0 or as_week like ('%' + cast(@dayOfWeek as varchar) + '%'))
		and (as_dateFrom is null or @date >= as_dateFrom)
		and (as_dateTo is null or @date <= as_dateTo)
		and not exists (select 1 from dbo.stopavia with(nolock) 
						where sa_ctkeyfrom = @ctFromStop and sa_ctkeyto = @ctToStop
						and COALESCE(sa_stop, 0) > 0
						and sa_dbeg = @dt1 and sa_dend = @dt2)
		and ((@flightpkkey >= 0 
				and exists (select top 1 1 from tbl_costs 
					where cs_svkey = 1 
					and cs_code = ch_key 
					and cs_subcode1 in (@subcode1, 0) 
					and (@date between cs_date and cs_dateend
						or @date between cs_checkindatebeg and cs_checkindateend)
					and (COALESCE(cs_week, '') = '' or cs_week LIKE ('%' + cast(@dayOfWeek as varchar) + '%'))
					and cs_pkkey = @flightpkkey))
				or (@flightpkkey < 0))
		
	if not exists (select top 1 1 from @chartersKeyTable)
	begin
		insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
								qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
		values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
		return
	end	
	
	declare @currentDate datetime
	set @currentDate = getdate()		
	
	declare @oldPartnerKey int
	-- сохраняем ключ партнера, чтобы находить стопы, только от данного партнера
	set @oldPartnerKey = @partnerKey
	if (@findFlight > 0)
	begin 
		-- подбираем перелеты от разных партнеров
		set @partnerKey = -1 
	end
	
	declare @quotasSourceTable as CheckQuotasSourceTable
		
	-- формируем таблицу с квотами, со стопами: общими и частными
	insert into @quotasSourceTable 
	select distinct
			1, qo_code,
			COALESCE(qo_subcode1, 0) as qo_subcode1, -1,				
			COALESCE(qp_agentkey, 0) as qp_agentkey,
			COALESCE(qt_prkey, 0) as qt_prkey,
			COALESCE(qp_isnotcheckin, 0) as qp_isnotcheckin, 
			qd_release as qt_release, 
			COALESCE(qp_places, 0) - COALESCE(qp_busy, 0),
			qd_date, qt_byroom, qd_type,
			COALESCE(ql_duration, 0) as ql_duration,
			COALESCE(qp_places, 0), 0 as qt_stop,
			qo_id as qt_qoid, qd_id as qt_qdid
			from Quotas q with(nolock) 
			right outer join QuotaObjects qo with(nolock) on qt_id = qo_qtid 
			inner join @chartersKeyTable on qo_code = ch_key
			inner join QuotaDetails qd with(nolock) on qt_id = qd_qtid 
			inner join QuotaParts qp with(nolock) on qd_id = qp_qdid
			left outer join QuotaLimitations ql with(nolock) on qp_id = ql_qpid								
			where
			qo_svkey = 1 and COALESCE(QD_IsDeleted, 0) = 0 and COALESCE(qo_subcode1, 0) in (0, @subcode1)
			and ((@checkAgentQuotes > 0 and coalesce(qp_agentkey, 0) in (0, @agentKey))
				or (@checkAgentQuotes <= 0 and coalesce(qp_agentkey, 0) = 0)) 
			and (@partnerKey < 0 or COALESCE(qt_prkey, 0) in (0, @partnerKey))
			and qd_date = @date	
			and (@tourDuration < 0 or (COALESCE(ql_duration, 0) in (0, @tourDuration)))					
			-- нужно учитывать стопы общие и частные, даже если квот нету
			union
			select
				1, qo_code,
				COALESCE(qo_subcode1, 0) as qo_subcode1,
				COALESCE(qo_subcode2, 0) as qo_subcode2,
				0,
				COALESCE(ss_prkey, 0) as qt_prkey,
				0,null,0,ss_date,null,COALESCE(SS_AllotmentAndCommitment, 0) + 1,0,0,1,
				qo_id as qt_qoid, null
			from StopSales
				inner join QuotaObjects on qo_id=ss_qoid
			where ss_date = @date
					and ss_qdid is null
					and COALESCE(ss_isdeleted, 0) = 0
					and qo_svkey = 1
					and qo_code = @code
					and (COALESCE(qo_subcode1, 0) in (0, @subcode1) or qo_subcode1 = 0)
					and (@oldPartnerKey < 0 or COALESCE(ss_prkey, 0) in (COALESCE(@oldPartnerKey, 0), 0))
	order by
			qd_date, qt_stop desc, qp_agentkey DESC, qd_type DESC, QT_PrKey DESC, qp_isnotcheckin, ql_duration DESC, qo_subcode1 DESC	
	
	-- если нет ни одной квоты и ни одного стопа, то возвращаем запрос
	if not exists (select top 1 1 from @quotasSourceTable) 
	begin
		insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
		values(0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0)		
		return
	end	
	
	-- если нет ни одной квоты, но есть стопы, то возвращаем нет мест
	if not exists (select top 1 1 from @quotasSourceTable where qt_stop = 0)
	begin
		insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
		values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')		
		return
	end
	
	declare @quotasTableWithStops as CheckQuotasSourceTable
	-- теперь проверяем наличие частных стопов, отбрасываем квоты на которые стоит частный стоп
	insert into @quotasTableWithStops
	select * from @quotasSourceTable
	where (qt_stop = 0
		and not exists (select top 1 1 from StopSales where SS_QDID = qt_qdid and COALESCE(ss_isdeleted, 0) = 0))
	or qt_stop = 1
	
	-- если после проверки на стопы не осталось квот, значит на все квоты стоят стопы, то возвращаем нет мест
	if not exists (select top 1 1 from @quotasTableWithStops where qt_stop = 0) 
	begin
		insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
		values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')		
		return
	end
	
	declare @datePlaces int, @dateAllPlaces int, @additional varchar(2000), @result varchar(2000), @existsRecord bit
	set @additional = ''
	set @result = ''
	set @existsRecord = 0
	set @datePlaces = 0
	set @dateAllPlaces = 0
	
	declare @durations table(
					duration int)
	
	-- выбираем подходящие продолжительности, на которые будем выбирать квоты
	if (@tourDuration >= 0)
	begin
		if (@checkNoLongQuotes = 1)
		begin
			-- подбираем агентские и общие квоты
			insert into @durations select distinct qt_long from @quotasTableWithStops where qt_long in (0, @tourDuration) order by qt_long	desc		 
		end	
		else
		begin
			-- подбираем агентские квоты
			insert into @durations select distinct qt_long from @quotasTableWithStops where qt_long = @tourDuration order by qt_long
			-- если агентские квоты не заведены, то подбираем общие квоты
			if not exists(select top 1 1 from @durations)
				insert into @durations(duration) values (0)
		end		
	end
	else
	begin
		-- подбираем квоты на все продолжительности
		insert into @durations select distinct qt_long from @quotasTableWithStops order by qt_long
	end
	
	declare @rowCount int
	select @rowCount = COUNT(*) from @durations
	
	if(@rowCount > 0)
	begin
		declare @tmpQuotes as CheckQuotasSourceTable
		declare @quotaDuration int
		declare durationCur cursor fast_forward read_only for
			select duration from @durations
	
		open durationCur
	
		fetch next from durationCur into @quotaDuration
		while(@@fetch_status = 0)
		begin
			if (@tourDuration < 0 and len(@additional) > 0)
				set @additional = @additional + '|'
			
			-- формируем таблицу с квотами, со стопами: общими и частными
			insert into @tmpQuotes
				select * from @quotasTableWithStops where qt_long = @quotaDuration or qt_stop = 1			
			
			-- если нет ни одной квоты и ни одного стопа, то возвращаем запрос
			if not exists (select top 1 1 from @tmpQuotes)
			begin
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
				values(0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0)		
				set @datePlaces = -1
				set @dateAllPlaces = 0
					
				set @existsRecord = 1
			end	
			-- если нет ни одной квоты, но есть стопы, то возвращаем нет мест
			if @existsRecord = 0 and not exists (select top 1 1 from @tmpQuotes where qt_stop = 0)
			begin
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')	
				set @datePlaces = 0
				set @dateAllPlaces = 0	
				
				set @existsRecord = 1
			end
			
			-- теперь проверяем наличие стоп-сейла
			if @existsRecord = 0 
			begin
				-- если стоит общий стоп на тип квоты Allotment+Commitment, то удаляем квоту Commitment и Allotment
				if exists(select top 1 1 from @tmpQuotes where qt_stop = 1 and qt_type = 2) 			
				begin
					delete from @tmpQuotes 
					from @tmpQuotes qt2 where qt2.qt_stop = 0 
					and exists (select top 1 1 from @tmpQuotes qt1 where qt1.qt_stop = 1 and qt1.qt_type = 2
								and (qt2.qt_subcode1 = qt1.qt_subcode1 or qt1.qt_subcode1 = 0 or qt2.qt_subcode1 = 0) and qt2.qt_code = qt1.qt_code)
				end
				
				-- если стоит общий стоп на тип квоты Allotment, то удаляем квоту Allotment
				if exists(select top 1 1 from @tmpQuotes where qt_stop = 1 and qt_type = 1) 		
				begin
					delete from @tmpQuotes 
					from @tmpQuotes qt2 where qt_stop = 0 and qt_type = 1 
					and exists (select top 1 1 from @tmpQuotes qt1 where qt1.qt_stop = 1 and qt1.qt_type = 1
								and (qt2.qt_subcode1 = qt1.qt_subcode1 or qt1.qt_subcode1 = 0 or qt2.qt_subcode1 = 0) and qt2.qt_code = qt1.qt_code)
				end
				
				-- если после проверки на стопы не осталось квот, значит на все квоты стоят стопы, то возвращаем нет мест
				if not exists (select top 1 1 from @tmpQuotes where qt_stop = 0) 
				begin
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
					values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')		
					set @datePlaces = 0
					set @dateAllPlaces = 0
					
					set @existsRecord = 1
				end
			end		
			
			-- теперь проверяем наличие запрета на заезд
			if @existsRecord = 0 
			begin	
				if exists(select top 1 1 from @tmpQuotes where qt_stop = 0 and qt_bycheckin = 1)
				begin
					delete from @tmpQuotes 
					from @tmpQuotes qt2 where qt2.qt_stop = 0 and qt2.qt_subcode1 = 0
					and exists (select top 1 1 from @tmpQuotes qt1 where qt1.qt_stop = 0 and qt1.qt_bycheckin = 1 and qt2.qt_code = qt1.qt_code)
								
					delete from @tmpQuotes where qt_stop = 0 and qt_bycheckin = 1
				end
				
				-- если после проверки на запрет на заезд не осталось квот, значит на всех квотах стоят запреты на заезд, то возвращаем нет мест
				if not exists(select top 1 1 from @tmpQuotes where qt_stop = 0)
				begin		
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
					values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
					set @datePlaces = 0
					set @dateAllPlaces = 0
					
					set @existsRecord = 1
				end	
			end
			
			-- теперь проверяем наличие релиз-периода 
			if @existsRecord = 0 
			begin
				if exists(select top 1 1 from @tmpQuotes where qt_stop = 0 and qt_release > 0 and datediff(day, qt_release, qt_date) < @currentDate) 			
				begin
					delete from @tmpQuotes where qt_stop = 0 and qt_release > 0 and datediff(day, qt_release, qt_date) < @currentDate
				end
			
				-- если после проверки на релиз-период не осталось квот, значит на всех квотах наступил релиз-период, то возвращаем запрос
				if not exists(select top 1 1 from @tmpQuotes where qt_stop = 0)
				begin		
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, 
						qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
					values(0, 0, 0, 0, 0, 0, 0, 0, @expiredReleaseResult, 0, 0, 0, '0=' + ltrim(rtrim(str(@expiredReleaseResult))) + ':0')
					set @datePlaces = @expiredReleaseResult
					set @dateAllPlaces = 0
					
					set @existsRecord = 1
				end	
			end

			-- если после всех проверок есть квоты, но них нет мест, то возвращаем @noPlacesResult
			if @existsRecord = 0 and not exists(select top 1 1 from @tmpQuotes where qt_stop = 0 and qt_places > 0)
			begin
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, 
					qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, @noPlacesResult, 0, 0, 0, '0=' + ltrim(rtrim(str(@noPlacesResult))) + ':0')
				set @datePlaces = @noPlacesResult
				set @dateAllPlaces = 0
				
				set @existsRecord = 1
			end	
			
			-- если после всех проверок есть квоты и на них есть места
			if @existsRecord = 0 and @checkAgentQuotes > 0 
			begin
				-- сначала проверяем агентскую квоту, если она существует, то выводим ее
				if exists(select top 1 1 from @tmpQuotes where qt_stop = 0 and qt_agent > 0)
				begin
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
					select top 1 qt_svkey, qt_code, qt_subcode1, 0, qt_agent, qt_prkey, qt_bycheckin,
					qt_byroom, qt_places, qt_placesAll, qt_type, qt_long from @tmpQuotes where qt_stop = 0 and qt_agent > 0
					set @datePlaces = 0
					set @dateAllPlaces = 0
					
					select @datePlaces = qt_places, @dateAllPlaces = qt_allPlaces  from @tmpResQuotes
						
					set @existsRecord = 1
				end
				
				-- проверяется общая квота, если:
				--		агентская квота закончилась или не заведена (@checkCommonQuotes > 0)
				--		агентская квота не заведена (@checkCommonQuotes = 0)
				if (@checkCommonQuotes > 0 and (@existsRecord = 0 or @datePlaces = 0))
					or (@checkCommonQuotes = 0 and @existsRecord = 0)
				begin
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
						qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
					select top 1 qt_svkey, qt_code, qt_subcode1, 0, qt_agent, qt_prkey, qt_bycheckin,
						qt_byroom, qt_places, qt_placesAll, qt_type, qt_long 
					from @tmpQuotes 
					where qt_stop = 0 and qt_agent = 0 and qt_places > 0
					order by qt_places desc
					
					select @datePlaces = qt_places, @dateAllPlaces = qt_allPlaces  from @tmpResQuotes
					
					if exists (select top 1 1 from @tmpResQuotes where qt_places > 0)
					begin
						delete from @tmpResQuotes where qt_places = 0
						set @existsRecord = 1
					end
				end
			end	
			
			-- если после всех проверок есть квоты и на них есть места
			if @existsRecord = 0 
			begin
				if exists (select top 1 1 from @tmpQuotes where qt_prkey = @oldPartnerKey and qt_stop = 0 and qt_places > 0) and @findFlight > 0
				begin
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
					select top 1 qt_svkey, qt_code, qt_subcode1, 0, qt_agent, qt_prkey, qt_bycheckin,
					qt_byroom, qt_places, qt_placesAll, qt_type, qt_long from @tmpQuotes 
					where qt_prkey = @oldPartnerKey and qt_stop = 0 and qt_places > 0
				end
				else 
				if exists (select top 1 1 from @tmpQuotes where qt_stop = 0 and qt_places > 0)
				begin
					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
					select top 1 qt_svkey, qt_code, qt_subcode1, 0, qt_agent, qt_prkey, qt_bycheckin,
					qt_byroom, qt_places, qt_placesAll, qt_type, qt_long from @tmpQuotes where qt_stop = 0 and qt_places > 0
				end
			end
			
			if (@requestOnRelease <= 0 and @findFlight <= 0)
			begin
				if (@existsRecord = 0)
				begin
					if (@isNewSetToQuota = 1)
					begin					
						select @datePlaces = SUM(qt_Places), @dateAllPlaces = SUM(qt_placesAll) from @tmpQuotes where qt_stop = 0
					end
					else
					begin
						select @datePlaces = qt_Places, @dateAllPlaces = qt_placesAll
						from @tmpQuotes where qt_stop = 0 and qt_Places = (select MAX(qt_Places) from @tmpQuotes)					
					end
				end
				
				if (@tourDuration < 0)
				begin
					set @result = ltrim(str(@datePlaces)) + ':' + ltrim(str(@dateAllPlaces))		
					set @additional = @additional + ltrim(str(@quotaDuration)) + '=' + @result											
				end
			end	
			
			set @existsRecord = 0
			set @datePlaces = 0
			set @dateAllPlaces = 0
			
			fetch next from durationCur into @quotaDuration
		end	
		
		if (len(@additional) > 0)	
		begin
			update @tmpResQuotes set qt_additional = @additional, qt_places = @datePlaces, qt_allPlaces = @dateAllPlaces
		end
			
		close durationCur
		deallocate durationCur
	
		return
	end
	else
	begin
		-- не нашли квот подходящих по продолжительности
		insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, 
			qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
		values(0, 0, 0, 0, 0, 0, 0, 0, @noPlacesResult, 0, 0, 0, '0=' + ltrim(rtrim(str(@noPlacesResult))) + ':0')		
		return				
	end			
	return
end
GO

GRANT SELECT ON [dbo].[mwCheckQuotesFlights] TO PUBLIC
GO

/*********************************************************************/
/* end fn_mwCheckQuotesFlights.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwCheckQuotesEx2.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwCheckQuotesEx2]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
	DROP FUNCTION [dbo].[mwCheckQuotesEx2]
GO

CREATE FUNCTION [dbo].[mwCheckQuotesEx2]
(
	@svkey int, 
	@code int, 
	@subcode1 int,
	@subcode2 int, 
	@agentKey int, 
	@partnerKey int, 
	@date datetime,
	@day int,
	@days int,
	@requestOnRelease smallint, 
	@noPlacesResult int, 
	@checkAgentQuotes smallint, 
	@checkCommonQuotes smallint,
	@checkNoLongQuotes smallint,
	@findFlight smallint,
	@cityFrom int,
	@cityTo int,
	@flightpkkey int,
	@tourDuration int,
	@expiredReleaseResult int,
	@linked_day int = null)

returns @tmpResQuotes table(
	qt_svkey int,
	qt_code int,
	qt_subcode1 int,
	qt_subcode2 int,
	qt_agent int,
	qt_prkey int,
	qt_bycheckin int,
	qt_byroom int,
	qt_places int,
	qt_allPlaces int,
	qt_type int,
	qt_long int,
	qt_additional varchar(2000))
begin
	--<VERSION>9.2.19.15</VERSION>
	--<DATE>2013-09-17</DATE>

    declare @isSubCode2 smallint
    select @isSubCode2 = COALESCE(SV_ISSUBCODE2, 0) from [Service] where SV_key = @svkey
    if(@isSubCode2 <= 0)
		set @subcode2 = 0  		
	if(@svkey = 1)
		set @subcode2 = -1      
	
	-- настройка указывает, что отображать если нет мест
    if exists(select 1 from systemsettings where ss_parmname like 'NoPlacesQuoteResult_' + convert(varchar, @svkey))
    begin
		select @noPlacesResult = cast(COALESCE(ss_parmvalue,@noPlacesResult) as int) from systemsettings where ss_parmname like 'NoPlacesQuoteResult_' + convert(varchar, @svkey)          
    end

	declare @ALLDAYS_CHECK int
	set @ALLDAYS_CHECK = -777

	-- для квот на продолжительность
	declare @long int
	if(@svkey = 1 or @svkey = 2 or @svkey = 4 or @checkNoLongQuotes = @ALLDAYS_CHECK)
		set @long = @tourDuration
	else
		set @long = @days

	if(@day <= 0 or @day is null)
		set @day = 1
	if(@days <= 0 or @days is null)
		set @days = 1

	declare @dateFrom datetime, @dateTo datetime
	set @dateFrom = dateadd(day, @day - 1, @date)
	set @dateTo = dateadd(day, @day + @days - 2, @date)		

	if(@svkey = 1)
	begin
		
		insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
									qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
		-- функция проверки квот на авиаперелеты
		select *
		from dbo.mwCheckQuotesFlights(@code, @subcode1, @agentKey, @partnerKey, 
			@dateFrom, @requestOnRelease, @noPlacesResult, @checkAgentQuotes, 
			@checkCommonQuotes, @checkNoLongQuotes, @findFlight, @cityFrom,	@cityTo, @flightpkkey,
			@tourDuration, @expiredReleaseResult, @linked_day)
		
		return
	end
	else
	begin
		declare @tmpSubcode1 int
		if(@svkey = 3 and @subcode1 > 0 and @subcode2 <= 0) 
		begin
			select @tmpSubcode1 = hr_rmkey, @subcode2 = hr_rckey from hotelrooms with(nolock) where hr_key = @subcode1
			set @subcode1 = @tmpSubcode1
		end
		
		declare @currentDate datetime
		select @currentDate = currentDate from dbo.mwCurrentDate
		
		declare @tmpQuotes as CheckQuotasSourceTable
		
		declare @qtSvkey int, @qtCode int, @qtSubcode1 int, @qtSubcode2 int, @qtAgent int,
		@qtPrkey int, @qtNotcheckin int, @qtRelease int, @qtPlaces int, @qtDate datetime,
		@qtByroom int, @qtType int, @qtLong int, @qtPlacesAll int, @qtStop smallint, @qtQoId int

		declare	@svkeyRes int, @codeRes int, @subcode1Res int, 
			@subcode2Res int, @agentRes int, @prkeyRes int,
			@bycheckinRes int, @byroomRes int, @placesRes int,
			@allPlacesRes int, @typeRes int, @longRes int, @releaseRes int, @additional varchar(2000), @stopSale smallint

		set @svkeyRes = 0
		set @codeRes = 0
		set @subcode1Res = 0
		set @subcode2Res = 0
		set @agentRes = 0
		set @prkeyRes = 0
		set @bycheckinRes = 0
		set @byroomRes = 0
		set @typeRes = 0
		set @allPlacesRes = 0
		set @longRes = 0
		set @releaseRes = -1
		set @additional = ''
		
		insert into @tmpQuotes select * from 
		(select 
			qo_svkey,
			qo_code,
			isnull(qo_subcode1, 0) as qo_subcode1,
			isnull(qo_subcode2, 0) as qo_subcode2,
			isnull(qp_agentkey, 0) as qp_agentkey,
			isnull(qt_prkey, 0) as qt_prkey,
			isnull(qp_isnotcheckin, 0) as qp_isnotcheckin, 
			qd_release, 
			isnull(qp_places, 0) - isnull(qp_busy, 0) as qt_freePlaces,
			qd_date,
			qt_byroom,
			qd_type,
			isnull(ql_duration, 0) as ql_duration,
			isnull(qp_places, 0) as qp_places,
			(case when (isnull(ss_id, 0) > 0 and isnull(ss_isdeleted, 0) = 0) then 1 else 0 end) as qt_stop,
			qo_id as qt_qoid, qd_id as qt_qdid
		from quotas q with(nolock) inner join 
			quotadetails qd with(nolock) on qt_id = qd_qtid inner join quotaparts qp with(nolock) on qd_id = qp_qdid
			left outer join quotalimitations ql with(nolock) on qp_id = ql_qpid
			right outer join quotaobjects qo with(nolock) on qt_id = qo_qtid 
			left outer join StopSales ss with(nolock) on (qd_id = ss_qdid and isnull(ss_isdeleted, 0) = 0)
		where
			qo_svkey = @svkey
			and ISNULL(QD_IsDeleted, 0) = 0
			and qo_code = @code
			and isnull(qo_subcode1, 0) in (0, @subcode1)
			and (@svKey = 1 or isnull(qo_subcode2, 0) in (0, @subcode2))
			and ((@checkAgentQuotes > 0 and @checkCommonQuotes > 0 and isnull(qp_agentkey, 0) in (0, @agentKey)) or
				(@checkAgentQuotes <= 0 and isnull(qp_agentkey, 0) = 0) or
				(@checkAgentQuotes > 0 and @checkCommonQuotes <= 0 and isnull(qp_agentkey, 0) in (0, @agentKey)))
			and (@partnerKey < 0 or isnull(qt_prkey, 0) in (0, @partnerKey))
			and ((@days = 1 and qd_date = @dateFrom) or (@days > 1 and qd_date between @dateFrom and @dateTo))
			and (@tourDuration < 0 or (@checkNoLongQuotes <> @ALLDAYS_CHECK and isnull(ql_duration, 0) in (0, @long)) or (@checkNoLongQuotes = @ALLDAYS_CHECK and isnull(ql_duration, 0) = @long))
			and not exists (select top 1 1 
									from StopSales inner join QuotaObjects on qo_id=ss_qoid
									where ((@days = 1 and ss_date = @dateFrom) or (@days > 1 and ss_date between @dateFrom and @dateTo))
									and ss_qdid is null
									and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
									and isnull(ss_isdeleted, 0) = 0
									and qd.QD_Type = (SS_AllotmentAndCommitment + 1)
									and qo_svkey = @svkey
									and qo_code = @code
									and isnull(qo_subcode1, 0) in (@subcode1)
									and isnull(qo_subcode2, 0) in (0, @subcode2))
		-- Paul G 07.02.2011 MEG00031547, MEG00031454
		-- Не отлавливались такие дни, на которые нет квот, но есть стоп-сейл.
		-- Да и вообще не учитывались стопы с пустой ссылкой на QuotaDetails.
		-- Добавил union, который учитывает стопы с пустой ссылкой на QuotaDetails.
		union
			select
				qo_svkey,
				qo_code,
				isnull(qo_subcode1, 0) as qo_subcode1,
				isnull(qo_subcode2, 0) as qo_subcode2,
				0,
				isnull(ss_prkey, 0) as qt_prkey,
				0,null,0,ss_date,null,isnull(SS_AllotmentAndCommitment, 0) + 1,0,0,1,
				qo_id as qt_qoid, null
			from StopSales
				inner join QuotaObjects on qo_id=ss_qoid
			where ((@days = 1 and ss_date = @dateFrom) or (@days > 1 and ss_date between @dateFrom and @dateTo))
					and ss_qdid is null
					and isnull(ss_isdeleted, 0) = 0
					and qo_svkey = @svkey
					and qo_code = @code
					and isnull(qo_subcode1, 0) in (0, @subcode1)
					and isnull(qo_subcode2, 0) in (0, @subcode2)
					and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
			union
			select
				qo_svkey,
				qo_code,
				isnull(qo_subcode1, 0) as qo_subcode1,
				isnull(qo_subcode2, 0) as qo_subcode2,
				0,
				isnull(ss_prkey, 0) as qt_prkey,
				0,null,0,ss_date,null,isnull(SS_AllotmentAndCommitment, 0) + 1,QL_Duration,0,1,
				qo_id as qt_qoid, QD_ID as qt_qdid
			from StopSales
				inner join QuotaObjects on qo_id=ss_qoid
				inner join QuotaDetails on QD_ID=SS_QDID
				left join QuotaParts on QP_QDID = qd_id
				left join QuotaLimitations on QL_QPID = qp_id
			where ((@days = 1 and ss_date = @dateFrom) or (@days > 1 and ss_date between @dateFrom and @dateTo))
					and ss_qdid is not null
					and isnull(ss_isdeleted, 0) = 0
					and qo_svkey = @svkey
					and qo_code = @code
					and isnull(qo_subcode1, 0) in (@subcode1)
					and isnull(qo_subcode2, 0) in (0, @subcode2)
					and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
		) as innerQuotas
		order by
			qd_date, qp_agentkey DESC, qt_freePlaces, QD_Release desc, qd_type DESC, QT_PrKey DESC, qp_isnotcheckin, ql_duration DESC, qo_subcode1 DESC, qo_subcode2 DESC
		-- тут вставлю логику проверки для отелей
		
		-- если квота проверяется из экрана HotelQuotes, проверка на наличие общего стопа
		if (@tourDuration < 0 and @svkey = 3)
		begin
			if exists(select 1 
					from stopsales with(nolock) 
						inner join quotaobjects qo with(nolock) on ss_qoid = qo_id
					where qo_svkey = @svkey and qo_code = @code and isnull(qo_subcode1, 0) in (0, @subcode1)
						and isnull(qo_subcode2, 0) in (0, @subcode2) and ss_date between @dateFrom and @dateTo
						and (ss_qdid is null ) 
						and isnull(ss_isdeleted, 0) = 0 
						and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
						and (IsNull(ss_allotmentandcommitment, 0) = 1 
							or not exists(select 1 from
							quotas with(nolock) inner join quotaobjects qo1 with(nolock) on
							qo1.qo_qtid = qt_id inner join quotadetails with(nolock) on qd_qtid = qt_id
							 where qo.qo_svkey = qo1.qo_svkey and qo.qo_code = qo1.qo_code and (qo.qo_subcode1 in (qo1.qo_subcode1, 0) or qo1.qo_subcode1 = 0)
							 and (qo.qo_subcode2 in (qo1.qo_subcode2, 0) or qo1.qo_subcode2 = 0) and qd_date = ss_date and qd_places > qd_busy and qd_type = 2)))
			begin
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
				qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
				
				return
			end							 
		end
		
		-- для экрана HotelQuotes
		-- если не существует не одной квоты, то возвращаем запрос
		-- если есть места, но стоит стоп, то возвращаем нет мест	
		if (not exists (select top 1 1 from @tmpQuotes) and @tourDuration < 0
			and not exists(select top 1 1 from quotas q with(nolock) inner join 
											quotadetails qd with(nolock) on qt_id = qd_qtid inner join quotaparts qp with(nolock) on qd_id = qp_qdid
											left outer join quotalimitations ql with(nolock) on qp_id = ql_qpid
											right outer join quotaobjects qo with(nolock) on qt_id = qo_qtid
											where qo_svkey = @svkey
											and ISNULL(QD_IsDeleted, 0) = 0
											and qo_code = @code
											and isnull(qo_subcode1, 0) in (0, @subcode1)
											and isnull(qo_subcode2, 0) in (0, @subcode2)
											and ((@checkAgentQuotes > 0 and @checkCommonQuotes > 0 and isnull(qp_agentkey, 0) in (0, @agentKey)) or
												(@checkAgentQuotes <= 0 and isnull(qp_agentkey, 0) = 0) or
												(@checkAgentQuotes > 0 and @checkCommonQuotes <= 0 and isnull(qp_agentkey, 0) in (0, @agentKey)))
											and (@partnerKey < 0 or isnull(qt_prkey, 0) in (0, @partnerKey))
											and ((@days = 1 and qd_date = @dateFrom) or (@days > 1 and qd_date between @dateFrom and @dateTo))
											and (@tourDuration < 0 or (@checkNoLongQuotes <> @ALLDAYS_CHECK 
											and isnull(ql_duration, 0) in (0, @long)) or (@checkNoLongQuotes = @ALLDAYS_CHECK and isnull(ql_duration, 0) = @long))))
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, @noPlacesResult, 0, 0, 0, '0=-1:0')
			return
		end
		else if (not exists (select top 1 1 from @tmpQuotes) and @tourDuration < 0)
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
			return
		end
		
		-- пробуем удалить стопы по следующему принципу: если стоит стоп на один тип квоты, но на другом типе с квотами все в порядке
		if ((select count(distinct qt_date) from @tmpQuotes where qt_places > 0 and qt_stop = 0 and qt_type = 1) = @days
			and exists(select 1 from @tmpQuotes where qt_stop = 1 and qt_type = 2))
		begin
			delete from @tmpQuotes where qt_stop = 1 and qt_type = 2
		end
		
		if ((select count(distinct qt_date) from @tmpQuotes where qt_places > 0 and qt_stop = 0 and qt_type = 2) = @days
			and exists(select 1 from @tmpQuotes where qt_stop = 1 and qt_type = 1)
		)
		begin
			delete from @tmpQuotes where qt_stop = 1 and qt_type = 1
		end

		if (exists(select top 1 1 from @tmpQuotes where qt_date=@dateFrom and qt_bycheckin=1)
			and not exists(select top 1 1 from @tmpQuotes where qt_date=@dateFrom and qt_places>0 and qt_placesAll>0 and isNull(qt_release,0) <= (@dateFrom - GETDATE()))
			and exists(select top 1 1 from @tmpQuotes where qt_date=@dateFrom and isNull(qt_release,0) > (@dateFrom - GETDATE())))
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
			return
		end
		
		-- если одновременно на alotment и commitment нет мест, возвращаем отсутствие мест
		if
		(
			(
				exists(select 1 from @tmpQuotes as tq1 where ((qt_stop = 1 or qt_places = 0) and qt_type = 2) and not exists(select 1 from @tmpQuotes as tq2 where tq2.qt_stop=0 and tq2.qt_places>0 and tq2.qt_date=tq1.qt_date))
			)
			and
			(
				exists(select 1 from @tmpQuotes as tq1 where ((qt_stop = 1 or qt_places = 0) and qt_type = 1) and not exists(select 1 from @tmpQuotes as tq2 where tq2.qt_stop=0 and tq2.qt_places>0 and tq2.qt_date=tq1.qt_date))
			)
		)
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent, qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, @noPlacesResult, 0, 0, 0, '0=0:0')
				
			return
		end
		
		if(@tourDuration < 0) -- надо проверить все возможные квоты по дням на все возможные продолжительности (используется при проверке наличия мест в отеле и на перелете)
		begin
			set @checkNoLongQuotes = @ALLDAYS_CHECK

			declare @durations table(
				duration int
			)

			insert into @durations select distinct qt_long from @tmpQuotes order by qt_long

			declare @rowCount int
			set @rowCount = @@rowCount

			if(@rowCount > 1)
			begin
				declare @quotaDuration int
				declare durationCur cursor fast_forward read_only for
					select duration from @durations
	
				open durationCur
	
				fetch next from durationCur into @quotaDuration
				while(@@fetch_status = 0)
				begin
					if(len(@additional) > 0)
						set @additional = @additional + '|'
	
					select 
						@additional = @additional + qt_additional
					from dbo.mwCheckQuotesEx(@svkey, @code, @subcode1, @subcode2, @agentKey, @partnerKey, 
						@date, @day, @days, @requestOnRelease, @noPlacesResult, @checkAgentQuotes, 
						@checkCommonQuotes, @ALLDAYS_CHECK, @findFlight, @cityFrom,	@cityTo, @flightpkkey,
						@quotaDuration,	@expiredReleaseResult)
	
					fetch next from durationCur into @quotaDuration
				end
	
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, @additional)
			
				close durationCur
				deallocate durationCur
	
				return
			end
			else if(@rowCount = 1)
				select @long = duration from @durations
			else
				set @long = 0
		end
		else
		begin
			-- check stopsale
			-- MT ignore stop on object for commitment quotas
			if exists(select 1 
					from stopsales with(nolock) 
						inner join quotaobjects qo with(nolock) on ss_qoid = qo_id
					where qo_svkey = @svkey and qo_code = @code and isnull(qo_subcode1, 0) in (0, @subcode1)
						and isnull(qo_subcode2, 0) in (0, @subcode2) and ss_date between @dateFrom and @dateTo
						and (ss_qdid is null ) 
						and isnull(ss_isdeleted, 0) = 0 
						and (@partnerkey < 0 or isnull(ss_prkey, 0) in (isnull(@partnerkey, 0), 0))
						-- MEG00032187 Paul G 14.02.2011
						-- Отсеиваем те стопы, которые ставятся только на allotment (ss_allotmentandcommitment = 0)
						-- и по которым на соответствующие дни есть квоты commitment.
						and (IsNull(ss_allotmentandcommitment, 0) = 1 
							or not exists(select 1 from
							quotas with(nolock) inner join quotaobjects qo1 with(nolock) on
							qo1.qo_qtid = qt_id inner join quotadetails with(nolock) on qd_qtid = qt_id
						--MEG00029495 Paul G 18.02.2010
						--Добавил условие qd_places > qd_busy
						--Смысл в том, что это условие должно проверять существование квот commitment на некоторые дни, но только тех
						--на которые еще есть места. Иначе возможна ситуация, когда на все commitment закончились места, а allotment на стопе
						--и проверка на наличие стопа не сработает
							 where qo.qo_svkey = qo1.qo_svkey and qo.qo_code = qo1.qo_code and (qo.qo_subcode1 in (qo1.qo_subcode1, 0) or qo1.qo_subcode1 = 0)
							 and (qo.qo_subcode2 in (qo1.qo_subcode2, 0) or qo1.qo_subcode2 = 0) and qd_date = ss_date and qd_places > qd_busy and qd_type = 2 /*commitment*/)))
			begin
						insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
							return 
			end

		end
		
		if (isnull((select min(qt_bycheckin)
					from @tmpQuotes
					where qt_date = @dateFrom), 0) = 1 AND @checkNoLongQuotes != @ALLDAYS_CHECK AND (SELECT CASE WHEN (SELECT COUNT(*) FROM @tmpQuotes) > 0 THEN 1 ELSE 0 END)=1)
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
									qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
								values(0, 0, 0, 0, 0, 0, 0, 0, case when @stopSale > 0 then 0 else @noPlacesResult end, 0, 0, 0)
								return
		end

		if isnull((select max(stopSale)
					from (select min(qt_stop) as stopSale
							from @tmpQuotes
							where qt_qoid = (select top 1 qt_qoid from @tmpQuotes where qt_date = @dateFrom) and isnull(qt_prkey, 0) = isnull(@partnerkey, 0)
							group by qt_date) as tbl), 0) = 1
		begin
			insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
							return 
		end
		
		-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
		declare @prevSubCode1 int, @prevSubCode2 int, @prevQtType int, @result int, @tmpDate datetime
		-- MEG00024921 End

		declare qCur cursor fast_forward read_only for 
		select
			qt_svkey,
			qt_code,
			qt_subcode1,
			qt_subcode2,
			qt_agent,
			qt_prkey,
			qt_bycheckin,
			qt_release,
			qt_places,
			qt_date,
			qt_byroom,
			qt_type,
			qt_long,
			qt_placesAll,
			qt_stop,
			qt_qoid
		from @tmpQuotes

		open qCur

		fetch next from qCur 
			into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
				@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, 
				@qtByroom, @qtType, @qtLong, @qtPlacesAll, @qtStop, @qtQoId

		-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
		set @prevSubCode1 = @qtSubcode1
		set @prevSubCode2 = @qtSubcode2
		set @prevQtType = @qtType
		-- MEG00024921 End
		
		if(@@fetch_status = 0)
		begin
			set @result = 1000000

			declare @prevDate datetime, @dateRes int, @dateAllPlaces int, @wasLongQuota smallint, @wasAgentQuota smallint, 
			@checkAfterWasLong smallint, @checkAfterWasAgent smallint, @isFirstDate bit, @prevDateRes int, @prevDateOld datetime

			set @prevDate = @dateFrom
			if(@qtDate = @dateFrom)
				set @dateRes = 0
			else
				set @dateRes = -1
			set @dateAllPlaces = 0
			set @stopSale = 1
			set @wasLongQuota = 0
			set @wasAgentQuota = 0
			set @checkAfterWasLong = 0
			set @checkAfterWasAgent = 0
			set @isFirstDate = 1
			set @prevDateRes = 0

			declare @quoteOnFirstDayExist smallint -- признак существования квоты на ПЕРВЫЙ день
				set @quoteOnFirstDayExist = 0

			while(@@fetch_status = 0)
			begin
				if(@qtStop > 0) -- stop sale
				begin
					close qCur
					deallocate qCur

					insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
						qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
					values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '0=0:0')
					return
				end

				if(@checkNoLongQuotes != @ALLDAYS_CHECK)
				begin
					-- Если обрабатываемая квота - квота на первый день, то выставляем индикатор в true
					if (@qtDate = @dateFrom and @qtNotcheckin = 0)
						set @quoteOnFirstDayExist = 1

					-- Если обрабатываемая квота - квота НЕ на первый день и в первый день ее не обнаруживалось, то возвращаем ЗАПРОС
					if (@qtDate != @dateFrom and @quoteOnFirstDayExist = 0)
					begin
						--MEG00032854 Paul G 05.04.2011
						--раньше в этом месте анализ квот прекращался и возвращался запрос, но это неправильно. 
						set @dateRes = -1
					end
				end

				--MEG00035270 Paul G 14.06.2011
				--для дальнейшего анализа квоты необходимо выполнение условия:
				--если она не на заезд, то должна найтись другая квота на заезд, на день предоставления услуги, но в том же объекте квотирования
				--эта проверка нужна для того, чтобы при наличии 2-х объектов квотирования с разными разбиениями на заезды не пересекались
				if (@qtNotcheckin = 1 and not exists(select 1 from @tmpQuotes where qt_qoid = @qtQoId and qt_bycheckin = 0 and qt_date = @dateFrom))
				begin
					fetch next from qCur 
						into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
							@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, 
							@qtByroom, @qtType, @qtLong, @qtPlacesAll, @qtStop, @qtQoId

					continue
				end
				--End MEG00035270

				if(@qtNotcheckin <= 0 or @qtDate <> @dateFrom or @checkNoLongQuotes = @ALLDAYS_CHECK)
				begin
					if(@prevDate != @qtDate)
					begin

						if(@dateRes = 0 /*and @stopSale <= 0*/ and ((@wasLongQuota > 0 and @checkAfterWasLong <= 0 and @checkNoLongQuotes > 0) or (@wasAgentQuota > 0 and @checkAfterWasAgent <= 0 and @checkCommonQuotes > 0)))
							set @dateRes = -1
				
						if(@checkNoLongQuotes = @ALLDAYS_CHECK)
						begin
							if(len(@additional) > 0)
								set @additional = @additional + ','

							if(@dateRes = 0 and @stopSale <= 0)
								set @dateRes = @noPlacesResult

							set @additional = @additional + ltrim(str(@dateRes)) + ':' + ltrim(str(@dateAllPlaces))
						end
						else
						if(@dateRes <= 0 or @dateRes < @result or @qtStop > 0)
						begin
							set @result = @dateRes
							set @allPlacesRes = @dateAllPlaces -- total places in quota

							if(@result = 0 or @qtStop > 0) -- no places
							begin
								close qCur
								deallocate qCur

								insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
									qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
								values(0, 0, 0, 0, 0, 0, 0, 0, case when @qtStop > 0 then 0 else @noPlacesResult end, 0, 0, 0, '0=0:0')
								return
							end
						end
						else
						begin
							if(@wasLongQuota > 0)
								set @checkAfterWasLong = 1

							if(@wasAgentQuota > 0)
								set @checkAfterWasAgent = 1
						end
		
						if(datediff(day, @prevDate, @qtDate) > 1) -- there are days for wich quota doesn't exist
						begin
							set @result = -1 -- request
							if(@checkNoLongQuotes = @ALLDAYS_CHECK)
							begin
								set @tmpDate = dateadd(day, 1, @prevDate)
								while(@tmpDate < @qtDate)
								begin
									if(len(@additional) > 0)
										set @additional = @additional + ','

									set @additional = @additional + '-1:0'
									set @tmpDate = dateadd(day, 1, @tmpDate)
								end
							end
						end
							
						set @prevDate = @qtDate
						set @dateRes = 0
						set @dateAllPlaces = 0
						set @stopSale = 1
						set @wasLongQuota = 0
						set @wasAgentQuota = 0
						set @checkAfterWasLong = 0
						set @checkAfterWasAgent = 0

						-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
						set @prevSubCode1 = @qtSubcode1
						set @prevSubCode2 = @qtSubcode2
						set @prevQtType = @qtType
						-- MEG00024921 End

					end
					
					if( -- MEG00024921, Danil, 10.02.2010: это условие было странным образом закомментарено + добавлена проверка на qtStop.
						-- Привел логику в соответствие с версией хранимки для 2007.2, где в аналогичной ситуации все работает.
						-- Проверку на qtStop перенес в следующий if
						(@stopSale <= 0 or ((@prevSubCode1 = @qtSubcode1 and @prevSubCode2 = @qtSubcode2) or @prevQtType <> @qtType))
						and not(@agentKey > 0 and @qtAgent = 0 and @wasAgentQuota > 0 and (@checkCommonQuotes <= 0))
								and not(@long > 0 and @qtLong = 0 and @wasLongQuota > 0 and (@checkNoLongQuotes <= 0)))
					begin
						if((@qtRelease is null or datediff(day, @currentDate, @qtDate) >= isnull(@qtRelease, 0))
							-- MEG00024921, Danil, 10.02.2010: сюда перенес проверку на qtStop из условия выше (по аналогии с версией 2007.2)
							and isnull(@qtStop, 0) = 0)
							-- MEG00024921 End
						begin
							if((@requestOnRelease <= 0 or @qtRelease is null or @qtRelease > 0) and
								@qtPlaces > 0 and not(@stopSale > 0 and @wasAgentQuota > 0 /*request for agents if they have agent quota and this quota is stopped (they try to reserve general quota by low cost)*/))
							begin

								--koshelev
								--TFS 7661 28.08.2012
								if (@days = 1)
								begin
									set @dateRes = @qtPlaces--@dateRes + @qtPlaces
								end
								else
								begin
									if (@qtPlaces = 1)
										set @dateRes = @qtPlaces
									else									
										set @dateRes = @dateRes + @qtPlaces
								end
								set @dateAllPlaces = @dateAllPlaces + @qtPlacesAll
								
								if (@qtPlaces < @result) -- result перезапишется
								begin
									set @svkeyRes = @qtSvkey
									set @codeRes = @qtCode
									set @subcode1Res = @qtSubcode1
									set @subcode2Res = @qtSubcode2
									set @agentRes = @qtAgent
									set @prkeyRes = @qtPrkey										
									set @byroomRes = @qtByroom
									set @typeRes = @qtType
									set @longRes = @qtLong
									set @releaseRes = @qtRelease
								end
							end
							else if(@qtPlaces > 0)
								set @dateRes = -1
						end
						else 
						begin
							if(isnull(@qtStop, 0) = 0 and @qtPlaces > 0)
								set @dateRes = @expiredReleaseResult -- no or request (0 or -1)
							else
							-- MEG00024921, Danil, 10.02.2010: добавил эту секцию, чтобы в случае, если не стоп, 
							-- а просто закончились места возвращалось @noPlacesResult
							if(isnull(@qtStop, 0) = 0)
							begin
								set @dateRes = @noPlacesResult -- no places
							end
							else
							-- MEG00024921 End
							begin
								set @dateRes = 0 -- stop sale
								set @result = 0
							end
						end
						--set @bycheckinRes =  1 - @qtNotcheckin
--set @bycheckinRes =  0
						
						-- MEG00024921, Danil, 10.02.2010: простановка признака "был ли стоп" для проверяемой даты
						-- опять же по аналогии с 2007.2
						if (isnull(@qtStop, 0) = 0)
							set @stopSale = 0
						-- MEG00024921 End
					end
					else if(@dateRes = 0 and @checkNoLongQuotes <> @ALLDAYS_CHECK)
					begin
						close qCur
						deallocate qCur
						insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
						-- MEG00024921, Danil, 10.02.2010: добавил значение qt_additional и его заполнение
							qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
						values(0, 0, 0, 0, 0, 0, 0, 0, case when @stopSale > 0 then 0 else @noPlacesResult end, 0, 0, 0, '0=0:0')
						-- MEG00024921 End
						return 
					end

					if(@wasAgentQuota <= 0 and @qtAgent > 0) -- признак того, что агентская квота заведена, но закончилась
						set @wasAgentQuota = 1
					if(@wasLongQuota <= 0 and @qtLong > 0)  -- признак того, что квота на продолжительность заведена, но закончилась
						set @wasLongQuota = 1
				end

				-- MEG00024921, Danil, 10.02.2010: значения переменных предыдущей проверенной строки
				set @prevSubCode1 = @qtSubcode1
				set @prevSubCode2 = @qtSubcode2
				set @prevQtType = @qtType
				-- MEG00024921 End
				if (@isFirstDate = 0 and @prevDateOld = @qtDate and @prevDateRes > 0)
				begin
					set @dateRes = @prevDateRes
				end
				set @isFirstDate = 0
				set @prevDateRes = @dateRes
				set @prevDateOld = @qtDate
				fetch next from qCur into @qtSvkey, @qtCode, @qtSubcode1, @qtSubcode2, @qtAgent,
					@qtPrkey, @qtNotcheckin, @qtRelease, @qtPlaces, @qtDate, @qtByroom, @qtType, 
					@qtLong, @qtPlacesAll, @qtStop, @qtQoId
			end

			if(@checkNoLongQuotes = @ALLDAYS_CHECK)
			begin
				if(len(@additional) > 0)
					set @additional = @additional + ','

				if(@dateRes = 0 and @stopSale <= 0)
					set @dateRes = @noPlacesResult
				
				set @additional = @additional + ltrim(str(@dateRes)) + ':' + ltrim(str(@dateAllPlaces))
			end
			else
			if(@dateRes <= 0 or @dateRes < @result)
			begin
				set @result = @dateRes
				set @allPlacesRes = @dateAllPlaces -- total places in quota

				if(@result = 0) -- iano iao
					set @result = case when @stopSale > 0 then 0 else @noPlacesResult end
			end

			if(@qtDate <> @dateTo and ((@result > 0 and @bycheckinRes <= 0) or @checkNoLongQuotes = @ALLDAYS_CHECK)) -- ia iaio ec aao aeaiaciia eaioa ia caaaaaia
			begin
				set @result = -1 -- cai?in
				if(@checkNoLongQuotes = @ALLDAYS_CHECK)
				begin
					set @tmpDate = dateadd(day, 1, @qtDate)
					while(@tmpDate <= @dateTo)
					begin
						if(len(@additional) > 0)
							set @additional = @additional + ','

						set @additional = @additional + '-1:0'
						set @tmpDate = dateadd(day, 1, @tmpDate)
					end
				end
			end
		end
		else
		begin
			set @result = -1
			if(@checkNoLongQuotes = @ALLDAYS_CHECK)
			begin
				set @tmpDate = @dateFrom
				while(@tmpDate <= @dateTo)
				begin
					if(len(@additional) > 0)
						set @additional = @additional + ','

					set @additional = @additional + '-1:0'
					set @tmpDate = dateadd(day, 1, @tmpDate)								
				end
			end
		end	
		
		if(@checkNoLongQuotes <> @ALLDAYS_CHECK)
		begin
			if (@result > 0)
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
				values(@svkeyRes, @codeRes, @subcode1Res, @subcode2Res, @agentRes, 
					@prkeyRes, @bycheckinRes, @byroomRes, @result, @allPlacesRes, @typeRes, @longRes)
			else
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long)
				values(0, 0, 0, 0, 0, 0, 0, 0, @result, 0, 0, 0)
		end
		else
		begin
				set @additional = ltrim(str(@long)) + '=' + @additional
				insert into @tmpResQuotes(qt_svkey, qt_code, qt_subcode1, qt_subcode2, qt_agent,
					qt_prkey, qt_bycheckin, qt_byroom, qt_places, qt_allPlaces, qt_type, qt_long, qt_additional)
				values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, @additional)
		end
		
		return 
	end
	return  
end
GO

GRANT SELECT ON [dbo].[mwCheckQuotesEx2] TO PUBLIC
GO

/*********************************************************************/
/* end fn_mwCheckQuotesEx2.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (04.09.2013)_Insert_SystemSettings.sql */
/*********************************************************************/
-- адрес веб-панели управления расчетом туров

if (dbo.mwReplIsPublisher() = 1 and not exists (select 1 from SystemSettings where SS_ParmName='SYSCalcTourWebPanelURL'))
begin
	insert into SystemSettings(SS_ParmName,SS_ParmValue, SS_Name)
	values ('SYSCalcTourWebPanelURL', '', 'Адрес веб-панели управления расчетом туров')
end
go



/*********************************************************************/
/* end (04.09.2013)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (16.10.2013)_Insert_SystemSettings_InsuranceTuristAge.sql */
/*********************************************************************/
--<VERSION>9.2.20</VERSION>
--<DATE>2013-10-16</DATE>
--Добавил настройку для задения возраста туристов у страховок
IF dbo.mwReplIsPublisher() > 0 or (dbo.mwReplIsPublisher() <= 0 and dbo.mwReplIsSubscriber() <= 0)	-- это публикатор или нет репликации
BEGIN
	if (select count(*) from [dbo].[SystemSettings] where [SS_ParmName] = 'SYSTuristAgeForInsurance') = 0 begin

	INSERT INTO [dbo].[SystemSettings]
			   ([SS_ParmName]
			   ,[SS_ParmValue]
			   ,[SS_Name])
		 VALUES
			   ('SYSTuristAgeForInsurance'
			   ,''
			   , 'Возраст туриста, при превышении которого выдается предупреждение.')
	end
END
GO

/*********************************************************************/
/* end (16.10.2013)_Insert_SystemSettings_InsuranceTuristAge.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (19.07.2013)_Insert_SystemSettings.sql */
/*********************************************************************/
--<VERSION>9.2.20</VERSION>
--<DATE>2013-07-19</DATE>
--Добавил настройки для динамических категорий
if dbo.mwReplIsPublisher() = 1 and (select count(*) from [dbo].[SystemSettings] where [SS_ParmName] = 'DynamicBoard') = 0 begin

INSERT INTO [dbo].[SystemSettings]
           ([SS_ParmName]
           ,[SS_ParmValue]
		   ,[SS_Name])
     VALUES
           ('DynamicBoard'
		   ,'[]'
		   , 'Динамические категории для типов питания')


end

GO

if dbo.mwReplIsPublisher() = 1 and (select count(*) from [dbo].[SystemSettings] where [SS_ParmName] = 'DynamicHotelCategories') = 0 begin

INSERT INTO [dbo].[SystemSettings]
           ([SS_ParmName]
           ,[SS_ParmValue]
		   ,[SS_Name])
     VALUES
           ('DynamicHotelCategories'
		   ,'[]'
		   , 'Динамические категории для категорий отелей')

end

GO
/*********************************************************************/
/* end (19.07.2013)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20.06.2013)_Insert_SystemSettings.sql */
/*********************************************************************/
if (dbo.mwReplIsPublisher() = 1 and not exists (select 1 from SystemSettings where SS_ParmName='SYSCurrentRowIdForQuotas'))
begin
	insert into SystemSettings(SS_ParmName,SS_ParmValue, SS_Name)
	values ('SYSCurrentRowIdForQuotas', '', 'Возвращает значение rowId для текущей базы данных, с которого можно выбирать измененные квоты.')
end
go
/*********************************************************************/
/* end (20.06.2013)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20.09.2013)_Alter_Table_mwSpoDataTable_AlterIndex.sql */
/*********************************************************************/
declare @IndexName varchar(max)
SELECT @IndexName = name FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[mwSpoDataTable]') AND name like N'PK__mwSpo%'
and not exists(SELECT 1 FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[mwSpoDataTable]') and [type] = 1)
if (@IndexName is not null)
begin
	exec ('ALTER TABLE [dbo].[mwSpoDataTable] DROP CONSTRAINT ' + @IndexName)

	exec sp_executesql N'
	ALTER TABLE [dbo].[mwSpoDataTable] ADD CONSTRAINT [PK_mwSpoDataTable] PRIMARY KEY CLUSTERED 
	(
		[sd_key] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	'
end
GO
/*********************************************************************/
/* end (20.09.2013)_Alter_Table_mwSpoDataTable_AlterIndex.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.20)_Insert_ObjectAliases.sql */
/*********************************************************************/
if not exists (select 1 from ObjectAliases where OA_Id=200004)
insert into ObjectAliases (OA_Id,OA_Alias,OA_Name,OA_NameLat)
values (200004,'MS_PaxportBookingCreating','Создание заказа в Paxport','Paxport booking creating')
go

if not exists (select 1 from ObjectAliases where OA_Id=200005)
insert into ObjectAliases (OA_Id,OA_Alias,OA_Name,OA_NameLat)
values (200005,'MS_PaxportBookingDeleting','Удаление заказа в Paxport','Paxport booking deleting')
go

if not exists (select 1 from ObjectAliases where OA_Id=200006)
insert into ObjectAliases (OA_Id,OA_Alias,OA_Name,OA_NameLat)
values (200006,'MS_PaxportBookingChanging','Изменение заказа в Paxport','Paxport booking changing')
go

if not exists (select 1 from ObjectAliases where OA_Id=200007)
insert into ObjectAliases (OA_Id,OA_Alias,OA_Name,OA_NameLat)
values (200007,'MS_PaxportBookingError','Ошибка при создании/изменении заказа в Paxport','Paxport booking creating/changing error')
go
/*********************************************************************/
/* end (2013.05.20)_Insert_ObjectAliases.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_CostOfferActivations.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[CostOfferActivations]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[CostOfferActivations]'))
	ALTER TABLE [dbo].[CostOfferActivations] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_CostOfferActivations.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_CostOffers.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[CostOffers]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[CostOffers]'))
	ALTER TABLE [dbo].[CostOffers] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_CostOffers.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_CostOfferServices.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[CostOfferServices]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[CostOfferServices]'))
	ALTER TABLE [dbo].[CostOfferServices] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_CostOfferServices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_CostsInsertNumber.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[CostsInsertNumber]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[CostsInsertNumber]'))
	ALTER TABLE [dbo].[CostsInsertNumber] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_CostsInsertNumber.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_QuotaDetails.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[QuotaDetails]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[QuotaDetails]'))
	ALTER TABLE [dbo].[QuotaDetails] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_QuotaDetails.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_QuotaLimitations.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[QuotaLimitations]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[QuotaLimitations]'))
	ALTER TABLE [dbo].[QuotaLimitations] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_QuotaLimitations.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_QuotaObjects.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[QuotaObjects]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[QuotaObjects]'))
	ALTER TABLE [dbo].[QuotaObjects] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_QuotaObjects.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_QuotaParts.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[QuotaParts]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[QuotaParts]'))
	ALTER TABLE [dbo].[QuotaParts] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_QuotaParts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_Quotas.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[Quotas]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[Quotas]'))
	ALTER TABLE [dbo].[Quotas] Add rowId timestamp 
GO

IF  EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[Quotes]') AND xtype in (N'V'))
	exec sp_RefreshViewForAll Quotes
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_Quotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_StopSales.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[StopSales]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[StopSales]'))
	ALTER TABLE [dbo].[StopSales] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_StopSales.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.24)_Add_rowId_Tariffs.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-24</DATE>
--добавление колонки с временной печатью

--[Tariffs]
if not exists (select 1 from dbo.syscolumns where name = 'rowId' and id = object_id(N'[dbo].[Tariffs]'))
	ALTER TABLE [dbo].[Tariffs] Add rowId timestamp 
GO
/*********************************************************************/
/* end (2013.05.24)_Add_rowId_Tariffs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.05.31)_Update_ObjectAlias_OA_NameLat.sql */
/*********************************************************************/
--<VERSION>9.2</VERSION>
--<DATE>2013-05-31</DATE>
--добавление английского названия алиса (для локализации данных в окне истории по путевке - HistoryDetails)

update ObjectAliases
set OA_NameLat = 'Reservations'
where OA_Id = 1
update ObjectAliases
set OA_NameLat = 'Services in reservation'
where OA_Id = 2
update ObjectAliases
set OA_NameLat = 'Tourists'
where OA_Id = 3
update ObjectAliases
set OA_NameLat = 'Tourists by service'
where OA_Id = 4
update ObjectAliases
set OA_NameLat = 'Payments'
where OA_Id = 5
update ObjectAliases
set OA_NameLat = 'Currency rate'
where OA_Id = 20

update ObjectAliases
set OA_NameLat = 'No currency on the date of creation of reservation'
where OA_Id = 21

update ObjectAliases
set OA_NameLat = 'Recalculation in national currency'
where OA_Id = 22
update ObjectAliases
set OA_NameLat = 'Number of reservation'
where OA_Id = 1001
update ObjectAliases
set OA_NameLat = 'Currency of reservation'
where OA_Id = 1002

update ObjectAliases
set OA_NameLat = 'Surname of buyer representative'
where OA_Id = 1003

update  ObjectAliases  
set OA_NameLat = 'Email of buyer representative'
where OA_Id = 1004
update  ObjectAliases  
set OA_NameLat = 'Telephone of buyer representative'
where OA_Id = 1005

update  ObjectAliases  
set OA_NameLat = 'Reservation price'
where OA_Id = 1006
update  ObjectAliases  
set OA_NameLat = 'Buyer''s discount'
where OA_Id = 1007

update  ObjectAliases  
set OA_NameLat = 'Reservation buyer'
where OA_Id = 1008
update  ObjectAliases  
set OA_NameLat = 'Basic tourist package'
where OA_Id = 1009
update  ObjectAliases  
set OA_NameLat = 'Departure date of reservation'
where OA_Id = 1010
update  ObjectAliases  
set OA_NameLat = 'Arrival city of reservation'
where OA_Id = 1011
update  ObjectAliases  
set OA_NameLat = 'Number of people in reservation'
where OA_Id = 1012
update  ObjectAliases  
set OA_NameLat = 'Duration of reservation'
where OA_Id = 1013
update  ObjectAliases  
set OA_NameLat = 'Prepayment date'
where OA_Id = 1014
update  ObjectAliases  
set OA_NameLat = 'Full payment date'
where OA_Id = 1015
update  ObjectAliases  
set OA_NameLat = 'Prepayment amount'
where OA_Id = 1016

update  ObjectAliases  
set OA_NameLat = 'Prepayment in %'
where OA_Id = 1017

update  ObjectAliases  
set OA_NameLat = 'Block / Unblock reservation'
where OA_Id = 1018

update  ObjectAliases  
set OA_NameLat = 'Status of reservation'
where OA_Id = 1019

update  ObjectAliases  
set OA_NameLat = 'Prescribed documents status'
where OA_Id = 1020

update  ObjectAliases  
set OA_NameLat = 'Date of documents submission for issuing visa'
where OA_Id = 1021

update  ObjectAliases  
set OA_NameLat = 'Reason for getting discounts'
where OA_Id = 1022

update  ObjectAliases  
set OA_NameLat = 'Manager dealing with the reservation'
where OA_Id = 1023
update  ObjectAliases  
set OA_NameLat = 'Department dealing with the reservation'
where OA_Id = 1024

update  ObjectAliases  
set OA_NameLat = 'Information about buyer''s representative'
where OA_Id = 1025

update  ObjectAliases  
set OA_NameLat = 'Partner''s number of reservation'
where OA_Id = 1026

update  ObjectAliases  
set OA_NameLat = 'Flight Number'
where OA_Id = 1027

update  ObjectAliases  
set OA_NameLat = 'Transfer name'
where OA_Id = 1028

update  ObjectAliases  
set OA_NameLat = 'Hotel name'
where OA_Id = 1029

update  ObjectAliases  
set OA_NameLat = 'Excursion name'
where OA_Id = 1030

update  ObjectAliases  
set OA_NameLat = 'Cruise ship name'
where OA_Id = 1031

update  ObjectAliases  
set OA_NameLat = 'Service name'
where OA_Id = 1032

update  ObjectAliases  
set OA_NameLat = 'Flight tariff'
where OA_Id = 1033

update  ObjectAliases  
set OA_NameLat = 'Transport'
where OA_Id = 1034

update  ObjectAliases  
set OA_NameLat = 'Accomodation'
where OA_Id = 1035

update  ObjectAliases  
set OA_NameLat = 'Add. Description1'
where OA_Id = 1036

update  ObjectAliases  
set OA_NameLat = 'Meal'
where OA_Id = 1037

update  ObjectAliases  
set OA_NameLat = 'Add. Description2'
where OA_Id = 1038

update  ObjectAliases  
set OA_NameLat = 'Provider'
where OA_Id = 1039

update  ObjectAliases  
set OA_NameLat = 'Service status'
where OA_Id = 1040

update  ObjectAliases  
set OA_NameLat = 'City'
where OA_Id = 1041

update  ObjectAliases  
set OA_NameLat = 'Country'
where OA_Id = 1042

update  ObjectAliases  
set OA_NameLat = 'Number of tourists'
where OA_Id = 1043

update  ObjectAliases  
set OA_NameLat = 'Nett'
where OA_Id = 1044

update  ObjectAliases  
set OA_NameLat = 'Gross'
where OA_Id = 1045

update  ObjectAliases  
set OA_NameLat = 'Beginning date'
where OA_Id = 1046

update  ObjectAliases  
set OA_NameLat = 'End date'
where OA_Id = 1047

update  ObjectAliases  
set OA_NameLat = 'Duration'
where OA_Id = 1048

update  ObjectAliases  
set OA_NameLat = 'Do not release quota'
where OA_Id = 1049

update  ObjectAliases  
set OA_NameLat = 'Full service name'
where OA_Id = 1050

update  ObjectAliases  
set OA_NameLat = 'Tourist surname'
where OA_Id = 1051

update  ObjectAliases  
set OA_NameLat = 'Tourist surname (latin letters)'
where OA_Id = 1052

update  ObjectAliases  
set OA_NameLat = 'Tourist name'
where OA_Id = 1053

update  ObjectAliases  
set OA_NameLat = 'Tourist name (latin letters)'
where OA_Id = 1054

update  ObjectAliases  
set OA_NameLat = 'Tourist patronymic'
where OA_Id = 1055

update  ObjectAliases  
set OA_NameLat = 'Tourist patronymic (latin letters)'
where OA_Id = 1056

update  ObjectAliases  
set OA_NameLat = 'Tourist date of birth'
where OA_Id = 1057

update  ObjectAliases
set OA_NameLat = 'Passport for travelling abroad series'
where OA_Id = 1058

update  ObjectAliases  
set OA_NameLat = 'Passport for travelling abroad number'
where OA_Id = 1059

update  ObjectAliases  
set OA_NameLat = 'National passport series'
where OA_Id = 1060

update  ObjectAliases  
set OA_NameLat = 'National passport number'
where OA_Id = 1061

update  ObjectAliases  
set OA_NameLat = 'Passport for travelling abroad issue date'
where OA_Id = 1062

update  ObjectAliases  
set OA_NameLat = 'Passport for travelling abroad expiry date'
where OA_Id = 1063

update  ObjectAliases  
set OA_NameLat = 'Passport for travelling abroad issuing authority'
where OA_Id = 1064

update  ObjectAliases  
set OA_NameLat = 'National passport issue date'
where OA_Id = 1065

update  ObjectAliases  
set OA_NameLat = 'National passport issue autority'
where OA_Id = 1066

update  ObjectAliases  
set OA_NameLat = 'Age'
where OA_Id = 1067

update  ObjectAliases  
set OA_NameLat = 'Gender'
where OA_Id = 1068

update  ObjectAliases  
set OA_NameLat = 'Tourist''s key'
where OA_Id = 1069

update  ObjectAliases  
set OA_NameLat = 'Service''s key'
where OA_Id = 1070

update  ObjectAliases  
set OA_NameLat = 'Document number (air ticket)'
where OA_Id = 1071

update  ObjectAliases  
set OA_NameLat = 'Room number (cabin)'
where OA_Id = 1072

update  ObjectAliases  
set OA_NameLat = 'Place number (in room, cabin), place in transport'
where OA_Id = 1073

update  ObjectAliases  
set OA_NameLat = 'Zone (deck) in hotel, cruise'
where OA_Id = 1074

update  ObjectAliases  
set OA_NameLat = 'Document date (air ticket)'
where OA_Id = 1075

update  ObjectAliases  
set OA_NameLat = 'Reservation creator'
where OA_Id = 1117

update  ObjectAliases  
set OA_NameLat = 'Net by partner''s invoice'
where OA_Id = 1119

update  ObjectAliases  
set OA_NameLat = 'Net by partner''s payment'
where OA_Id = 1120

update  ObjectAliases  
set OA_NameLat = 'Departure city'
where OA_Id = 1121
update  ObjectAliases  
set OA_NameLat = 'Creation of reservation'
where OA_Id = 1122

update  ObjectAliases  
set OA_NameLat = 'Reservation cancellation'
where OA_Id = 1123

update  ObjectAliases  
set OA_NameLat = 'Time of service beginning'
where OA_Id = 1125
update  ObjectAliases  
set OA_NameLat = 'Country of birth'
where OA_Id = 1126
update  ObjectAliases  
set OA_NameLat = 'City of birth'
where OA_Id = 1127
update  ObjectAliases  
set OA_NameLat = 'Citizenship'
where OA_Id = 1128
update  ObjectAliases  
set OA_NameLat = 'Zip code'
where OA_Id = 1129
update  ObjectAliases  
set OA_NameLat = 'City of residence'
where OA_Id = 1130
update  ObjectAliases  
set OA_NameLat = 'Street of residence'
where OA_Id = 1131
update  ObjectAliases  
set OA_NameLat = 'House of residence'
where OA_Id = 1132
update  ObjectAliases  
set OA_NameLat = 'Apartment of residence'
where OA_Id = 1133
update  ObjectAliases  
set OA_NameLat = 'Airline'
where OA_Id = 1139
update  ObjectAliases  
set OA_NameLat = 'Departure airport'
where OA_Id = 1135
update  ObjectAliases  
set OA_NameLat = 'Arrival airport'
where OA_Id = 1136
update  ObjectAliases  
set OA_NameLat = 'Time of departure'
where OA_Id = 1137
update  ObjectAliases  
set OA_NameLat = 'Time of arrival'
where OA_Id = 1138
update  ObjectAliases  
set OA_NameLat = 'Tourist filled the form'
where OA_Id = 1143
update  ObjectAliases  
set OA_NameLat = 'Insurance name'
where OA_Id = 1146
update  ObjectAliases  
set OA_NameLat = 'Date of service price calculation'
where OA_Id = 1147
update  ObjectAliases  
set OA_NameLat = 'Tourist surname/name change from online'
where OA_Id = 1148
update  ObjectAliases  
set OA_NameLat = 'Booking Status'
where OA_Id = 19001

update  ObjectAliases  
set OA_NameLat = 'Quota type'
where OA_Id = 34001
update  ObjectAliases  
set OA_NameLat = 'Quota date'
where OA_Id = 34002
update  ObjectAliases  
set OA_NameLat = 'Places in quota'
where OA_Id = 34003
update  ObjectAliases  
set OA_NameLat = 'Occupied places in quota'
where OA_Id = 34004
update  ObjectAliases  
set OA_NameLat = 'Release period in quota'
where OA_Id = 34005
update  ObjectAliases  
set OA_NameLat = 'Quota removal'
where OA_Id = 34006

update  ObjectAliases  
set OA_NameLat = 'Currency date'
where OA_Id = 1103
update  ObjectAliases  
set OA_NameLat = 'Currency rate'
where OA_Id = 1104
update  ObjectAliases  
set OA_NameLat = 'Percentage'
where OA_Id = 1105
update  ObjectAliases  
set OA_NameLat = 'Amount in payment''s currency'
where OA_Id = 1106
update  ObjectAliases  
set OA_NameLat = 'Amount in national currency'
where OA_Id = 1107
update  ObjectAliases  
set OA_NameLat = 'Amount in reservation''s currency'
where OA_Id = 1108
update  ObjectAliases  
set OA_NameLat = 'Tax 1'
where OA_Id = 1109
update  ObjectAliases  
set OA_NameLat = 'Tax 1 in percentage'
where OA_Id = 1110
update  ObjectAliases  
set OA_NameLat = 'Tax 2'
where OA_Id = 1111
update  ObjectAliases  
set OA_NameLat = 'Tax 2 in percentage'
where OA_Id = 1112
update  ObjectAliases  
set OA_NameLat = 'Amount in national currency (in words)'
where OA_Id = 1113
update  ObjectAliases  
set OA_NameLat = 'Reason'
where OA_Id = 1114
update  ObjectAliases  
set OA_NameLat = 'Resevation'
where OA_Id = 1115
update  ObjectAliases  
set OA_NameLat = 'Payment'
where OA_Id = 1116

go
/*********************************************************************/
/* end (2013.05.31)_Update_ObjectAlias_OA_NameLat.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.03)_Drop_Tables_TPD.sql */
/*********************************************************************/
--<VERSION>9.2.19</VERSION>
--<DATE>2013-06-03</DATE>
--удалям TPD таблицы, так как удален плагин TPD

if exists (select 1 from sys.objects where object_id = object_id(N'[dbo].[TPDAccesses]') and type in (N'U'))
begin
	drop table [dbo].[TPDAccesses]
end
go

if exists (select 1 from sys.objects where object_id = object_id(N'[dbo].[TPDOperations]') and type in (N'U'))
begin
	drop table [dbo].[TPDOperations]
end
go


/*********************************************************************/
/* end (2013.06.03)_Drop_Tables_TPD.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.11)_Alter_Table_OnlinePenalty.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM dbo.syscolumns WHERE NAME = 'OP_SLKEY' AND ID = object_id(N'[dbo].[OnlinePenalty]'))

BEGIN
	ALTER TABLE [dbo].OnlinePenalty ALTER COLUMN op_slkey INT NULL 
END

GO
/*********************************************************************/
/* end (2013.06.11)_Alter_Table_OnlinePenalty.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.19)_AlterTable_DUP_USER_AlterColumns_Address_Prhone_Fax_Inn.sql */
/*********************************************************************/
ALTER TABLE dbo.Dup_User
ALTER COLUMN us_address varchar(330)
GO
ALTER TABLE dbo.Dup_User
ALTER COLUMN us_phone varchar(254)
GO
ALTER TABLE dbo.Dup_User
ALTER COLUMN us_fax varchar(120)
GO
ALTER TABLE dbo.Dup_User
ALTER COLUMN us_inn varchar(30)
GO

/*********************************************************************/
/* end (2013.06.19)_AlterTable_DUP_USER_AlterColumns_Address_Prhone_Fax_Inn.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.25)_Create_Index_x_main_3.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_TurDates]') AND name = N'x_main_3')
begin
	CREATE NONCLUSTERED INDEX [x_main_3] ON [dbo].[TP_TurDates]
	(
		 [TD_TOKey] ASC,
		 [TD_Date] ASC,
		 [TD_AUTODISABLED]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end (2013.06.25)_Create_Index_x_main_3.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.06.25)_Create_Index_x_web_4.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QuotaObjects]') AND name = N'x_web_4')
begin
	CREATE NONCLUSTERED INDEX [x_web_4] ON [dbo].[QuotaObjects]
	(
		[QO_QTID] ASC,
		[QO_SVKEY] ASC,
		[QO_CODE] ASC
	)
	INCLUDE
	(
		[QO_SUBCODE1],
		[QO_SUBCODE2]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end (2013.06.25)_Create_Index_x_web_4.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.11)_Insert_ObjectTypes.ql.sql */
/*********************************************************************/
if not exists (select 1 from ObjectTypes where ot_id = 75 and ot_code = 'BonusWithdrawalRules')
	insert into ObjectTypes	values (75, 'BonusWithdrawalRules', 'Правила списания бонусов', NULL, NULL)
go

/*********************************************************************/
/* end (2013.07.11)_Insert_ObjectTypes.ql.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.16)_Insert_ObjectAliases.sql */
/*********************************************************************/
IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300001))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300001, 'WriteOffBonuses', 'Списание бонусов в счет оплаты путевки', 'Write-off bonuses', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300002))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300002, 'ReturnBonuses', 'Возврат бонусов при аннуляции', 'Return bonuses', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300003))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300003, 'WriteOffBonusesByCourse', 'Курс списания', 'Write-off bonuses course', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300004))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300004, 'WriteOffBonusesToPrice', 'Списано бонусов на сумму', 'Write-off bonuses price', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300005))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300005, 'WriteOffBonusesByUserId', 'Id пользователя', 'Write-off bonuses user id', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300006))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300006, 'WriteOffBonusesCount', 'Списано бонусов в количестве', 'Write-off bonuses count', 0, null)
go

IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300007))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300007, 'WriteOffBonusesCurrency', 'Списано бонусов в валюте', 'Write-off bonuses currency', 0, null)
go


IF (NOT EXISTS(SELECT 1 FROM [dbo].[ObjectAliases] WHERE OA_ID = 300008))
 insert into ObjectAliases (OA_Id, OA_Alias, OA_Name, OA_NameLat, OA_TABLEID, OA_CommunicationInfo) 
 values (300008, 'WriteOffBonusesByUserKey', 'Ключ пользователя', 'Write-off user key', 0, null)
go

/*********************************************************************/
/* end (2013.07.16)_Insert_ObjectAliases.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.07.24)_Alter_IX_Paging.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[CacheQuotas]') AND name = N'IX_Paging')
begin
	DROP INDEX [IX_Paging] ON [dbo].[CacheQuotas] WITH ( ONLINE = OFF )
end
GO

CREATE NONCLUSTERED INDEX [IX_Paging] ON [dbo].[CacheQuotas]
(
	[cq_svkey] ASC,
	[cq_code] ASC,
	[cq_date] ASC,
	[cq_day] ASC,
	[cq_days] ASC,
	[cq_prkey] ASC,
	[cq_pkkey] ASC,
	[cq_findflight] ASC,
	[cq_places] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 70) ON [PRIMARY]
GO
/*********************************************************************/
/* end (2013.07.24)_Alter_IX_Paging.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.08.01)_Alter_Table_History.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM dbo.syscolumns WHERE NAME = 'HI_WHO' AND ID = object_id(N'[dbo].[History]'))
begin
	alter table [dbo].[History] alter column HI_WHO VARCHAR(50)			
end
go
/*********************************************************************/
/* end (2013.08.01)_Alter_Table_History.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.08.13)_Alter_Table_SendMail.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM dbo.syscolumns WHERE NAME = 'SM_EMAIL' AND ID = object_id(N'[dbo].[SendMail]'))
begin
	alter table [dbo].[SendMail] alter column SM_EMAIL VARCHAR(510)			
end
go
/*********************************************************************/
/* end (2013.08.13)_Alter_Table_SendMail.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.08.15)_Add_CalculatingPriceLists_PriceTourKey_FK.sql */
/*********************************************************************/
if exists (select 1 from CalculatingPriceLists with(nolock) where CP_PriceTourKey not in (select to_key from tp_tours with(nolock)))
begin
	delete 
	from CalculatingPriceLists
	where CP_PriceTourKey not in (select to_key from tp_tours with(nolock))
end
GO

if not exists (select 1 from sys.foreign_keys where name like 'CalculatingPriceLists_PriceTourKey_FK')
begin
	alter table CalculatingPriceLists 
	add constraint CalculatingPriceLists_PriceTourKey_FK FOREIGN KEY ( CP_PriceTourKey ) 
	references TP_Tours (TO_Key) ON DELETE CASCADE	
end
GO
/*********************************************************************/
/* end (2013.08.15)_Add_CalculatingPriceLists_PriceTourKey_FK.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.08.19)_Create_Type_StructToExportAllDCTables.sql */
/*********************************************************************/
IF not EXISTS (SELECT * FROM sys.types st JOIN sys.schemas ss ON st.schema_id = ss.schema_id WHERE st.name = N'StructToExportAllDCTables' AND ss.name = N'dbo')
begin
	CREATE TYPE [dbo].[StructToExportAllDCTables] AS TABLE(
		[TPKey] [int] NOT NULL,		
		[ToKey] [int] NOT NULL,
		[TiKey] [int] NOT NULL,
		[TRKey] [int] NOT NULL,
		[TourDate] [datetime] NOT NULL,
		[Days] [int] NOT NULL,
		[Rate] [nvarchar](10) NOT NULL,
		[HotelKey] [int] NOT NULL,
		[DepartureKey] [int] NOT NULL,
		[SVKey] [int] NOT NULL,
		[Code] [int] NOT NULL,
		[SubCode1] [int] NOT NULL,
		[SubCode2] [int] NOT NULL,
		[PRKey] [int] NOT NULL,
		[Date] [datetime] NOT NULL,
		[Men] [int] NOT NULL,
		[ServiceDays] [int] NOT NULL,
		[PkKey] [int] NOT NULL,
		[Netto] [money] NULL,
		[Brutto] [money] NULL,
		[IsCommission] [bit] NOT NULL,
		[Margin] [money] NULL,
		[CommissionOnly] [bit] NOT NULL,
		[AddCostIsCommission] [money] NULL,
		[AddCostNoCommission] [money] NULL
	)
end
GO
GRANT EXECUTE ON TYPE::dbo.[StructToExportAllDCTables] TO public
go

/*********************************************************************/
/* end (2013.08.19)_Create_Type_StructToExportAllDCTables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.09.04)_Create_Table_BasketStatistics.sql */
/*********************************************************************/
--<DATE>2013-09-04</DATE>
--<VERSION>2009.2.20.0</VERSION>

IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BasketStatistics]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].BasketStatistics (
	[BS_Id] [int] IDENTITY(1,1) NOT NULL,
	[BS_Date] [datetime] DEFAULT(GetDate()) NOT NULL,
	[BS_RequestType] [varchar](4) NOT NULL,
	[BS_Time] [int] NOT NULL,
	[BS_Result] text NOT NULL,
	[BS_URL] [nvarchar](128) NOT NULL,
	[BS_Page] [nvarchar](64) NOT NULL
 CONSTRAINT [PK_BasketStatistics] PRIMARY KEY CLUSTERED 
(
	[BS_Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
END

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].BasketStatistics TO PUBLIC

GO

/*********************************************************************/
/* end (2013.09.04)_Create_Table_BasketStatistics.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.09.04)_Insert_ObjectAliases.sql */
/*********************************************************************/
if not exists (select 1 from objectaliases where oa_id=1150)
insert into objectaliases (OA_ID, OA_Alias, OA_Name)
values (1150,'DG_PriceKey','Ключ прайса, по которому создана путевка')
go
/*********************************************************************/
/* end (2013.09.04)_Insert_ObjectAliases.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.09.19)Create_Table_ExchangeQuotaStops.sql */
/*********************************************************************/
--<DATE>2013-09-20</DATE>
--<VERSION>2009.2.20.0</VERSION>
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ExchangeQuotaStops]') AND type in (N'U'))
BEGIN
	CREATE TABLE [dbo].[ExchangeQuotaStops](
		[EQS_ID] [int] IDENTITY(1,1) NOT NULL,
		[EQS_SvKey] [int] NOT NULL,
		[EQS_Code] [int] NOT NULL,
		[EQS_SubCode1] [int] NOT NULL,
		[EQS_SubCode2] [int] NOT NULL,
		[EQS_SubCode3] [int] NOT NULL,
		[EQS_Date] [datetime] NOT NULL,
		[EQS_IsStop] [bit] NOT NULL,
		[EQS_Places] [int] NOT NULL,
		[EQS_PartnerKey] [int] NOT NULL,
		[EQS_UpdateDate] [datetime] NOT NULL,
		[EQS_IsProcessed] [smallint] NOT NULL
	 CONSTRAINT [PK_ExchangeQuotaStops] PRIMARY KEY CLUSTERED 
	(
		[EQS_ID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	ALTER TABLE [dbo].[ExchangeQuotaStops] ADD  DEFAULT ((0)) FOR [EQS_SubCode1]
	ALTER TABLE [dbo].[ExchangeQuotaStops] ADD  DEFAULT ((0)) FOR [EQS_SubCode2]
	ALTER TABLE [dbo].[ExchangeQuotaStops] ADD  DEFAULT ((0)) FOR [EQS_SubCode3]
	ALTER TABLE [dbo].[ExchangeQuotaStops] ADD  DEFAULT (getdate()) FOR [EQS_UpdateDate]
	ALTER TABLE [dbo].[ExchangeQuotaStops] ADD  DEFAULT ((0)) FOR [EQS_IsProcessed]
END
ELSE
IF not exists(select top 1 1 from sys.columns where Name = N'EQS_IsProcessed' and Object_ID = Object_ID(N'[dbo].[ExchangeQuotaStops]'))
BEGIN
	ALTER TABLE [dbo].[ExchangeQuotaStops] ADD [EQS_IsProcessed] [smallint] NOT NULL  DEFAULT (0)
END

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].ExchangeQuotaStops TO PUBLIC
GO


/*********************************************************************/
/* end (2013.09.19)Create_Table_ExchangeQuotaStops.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.09.24)_AlterTable_DupUser_AlterColumn_USCountry.sql */
/*********************************************************************/
alter table dup_user alter column us_country varchar(25) null

go
/*********************************************************************/
/* end (2013.09.24)_AlterTable_DupUser_AlterColumn_USCountry.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.10.22)_Alter_Table_InsTurists.sql */
/*********************************************************************/
IF EXISTS (select * from sys.foreign_keys where name='FK_InsTurists_tbl_Turist')
BEGIN
	ALTER TABLE dbo.InsTurists DROP CONSTRAINT FK_InsTurists_tbl_Turist; 
END
GO
/*********************************************************************/
/* end (2013.10.22)_Alter_Table_InsTurists.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.10.22)_Insert_SystemSettings.sql */
/*********************************************************************/
-- СЌС‚Рѕ РїСѓР±Р»РёРєР°С‚РѕСЂ РёР»Рё РЅРµС‚ СЂРµРїР»РёРєР°С†РёРё
IF dbo.mwReplIsPublisher() > 0 or (dbo.mwReplIsPublisher() <= 0 and dbo.mwReplIsSubscriber() <= 0)
BEGIN
	IF NOT EXISTS (SELECT 1 FROM SYSTEMSETTINGS WHERE SS_PARMNAME='SYSAnnulPolSrvDateBegin')
	BEGIN
		INSERT INTO SYSTEMSETTINGS(SS_PARMNAME,SS_PARMVALUE, SS_NAME)
		VALUES ('SYSAnnulPolSrvDateBegin', '0', 'РђРЅРЅСѓР»РёСЂРѕРІР°С‚СЊ РїРѕР»РёСЃ РїСЂРё РёР·РјРµРЅРµРЅРёРё РґР°С‚С‹ РЅР°С‡Р°Р»Р° СѓСЃР»СѓРіРё СЃС‚СЂР°С…РѕРІР°РЅРёСЏ.')
	END
	IF NOT EXISTS (SELECT 1 FROM SYSTEMSETTINGS WHERE SS_PARMNAME='SYSAnnulPolSrvNDays')
	BEGIN
		INSERT INTO SYSTEMSETTINGS(SS_PARMNAME,SS_PARMVALUE, SS_NAME)
		VALUES ('SYSAnnulPolSrvNDays', '0', 'РђРЅРЅСѓР»РёСЂРѕРІР°С‚СЊ РїРѕР»РёСЃ РїСЂРё РёР·РјРµРЅРµРЅРёРё РїСЂРѕРґРѕР»Р¶РёС‚РµР»СЊРЅРѕСЃС‚Рё СѓСЃР»СѓРіРё СЃС‚СЂР°С…РѕРІР°РЅРёСЏ.')
	END
	IF NOT EXISTS (SELECT 1 FROM SYSTEMSETTINGS WHERE SS_PARMNAME='SYSAnnulPolSrvTuristChang')
	BEGIN
		INSERT INTO SYSTEMSETTINGS(SS_PARMNAME,SS_PARMVALUE, SS_NAME)
		VALUES ('SYSAnnulPolSrvTuristChang', '0', 'РђРЅРЅСѓР»РёСЂРѕРІР°С‚СЊ РїРѕР»РёСЃ РїСЂРё РёР·РјРµРЅРµРЅРёРё С‚СѓСЂРёСЃС‚РѕРІ РїРѕ СѓСЃР»СѓРіРµ СЃС‚СЂР°С…РѕРІР°РЅРёСЏ.')
	END
END
GO

/*********************************************************************/
/* end (2013.10.22)_Insert_SystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.10.31)_Alter_Function_mwGetVisaDeadlineDate.sql */
/*********************************************************************/
/****** Object:  UserDefinedFunction [dbo].[mwGetVisaDeadlineDate]    Script Date: 10/31/2013 18:03:44 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

ALTER FUNCTION [dbo].[mwGetVisaDeadlineDate](@tlKey INTEGER, @arrivalDate datetime, @ctKey INTEGER)
RETURNS DATETIME
AS
BEGIN	
	declare @result datetime
	declare @pkkey int
	
	select @pkkey = ts_pkkey
	from turservice (nolock)
	where ts_svkey = 5 and ts_trkey = @tlKey
	
	if ISNULL(@pkkey, -1) <> -1
	begin
		select @result = max(CD_DeadLineAgencyDate)
		from costs (nolock)
			inner join CalendarDeadLines (nolock) on cd_slkey = cs_code
		where cs_pkkey = @pkkey and cs_svkey = 5 and cd_arrivaldate = @arrivalDate and cd_ctkey = @ctKey
	end
	else
	begin
		select @result = max(CD_DeadLineAgencyDate)
		from costs (nolock)
			inner join CalendarDeadLines (nolock) on cd_slkey = cs_code
		where cs_pkkey = 0 and cs_svkey = 5 and  cd_arrivaldate = @arrivalDate and cd_ctkey = @ctKey and
		exists (select 1 from ServiceList 
			where SL_SVKEY = 5 and SL_KEY = CD_SLKey and 
			SL_CNKEY = (select TL_CNKEY from Turlist where TL_KEY = @tlKey))
	end

	return @result
END

GO

/*********************************************************************/
/* end (2013.10.31)_Alter_Function_mwGetVisaDeadlineDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (2013.11.05)_ALTER_PROCEDURE_DogovorMonitor.sql */
/*********************************************************************/
/****** Object:  StoredProcedure [dbo].[DogovorMonitor]    Script Date: 11/05/2013 14:44:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

ALTER PROCEDURE [dbo].[DogovorMonitor]
--<VERSION>2009.2.18</VERSION>
--<DATE>2012-12-26</DATE>
	@dtStartDate datetime,			-- РЅР°С‡Р°Р»СЊРЅР°СЏ РґР°С‚Р° РїСЂРѕСЃРјРѕС‚СЂР° РёР·РјРµРЅРµРЅРёР№
	@dtEndDate datetime,			-- РєРѕРЅРµС‡РЅР°СЏ РґР°С‚Р° РїСЂРѕСЃРјРѕС‚СЂР° РёР·РјРµРЅРµРЅРёР№
	@nCountryKey int,				-- РєР»СЋС‡ СЃС‚СЂР°РЅС‹
	@nCityKey int,					-- РєР»СЋС‡ РіРѕСЂРѕРґР°
	@nDepartureCityKey int,			-- РєР»СЋС‡ РіРѕСЂРѕРґР° РІС‹Р»РµС‚Р°
	@nCreatorKey int,				-- РєР»СЋС‡ СЃРѕР·РґР°С‚РµР»СЏ
	@nOwnerKey int,					-- РєР»СЋС‡ РІРµРґСѓС‰РµРіРѕ РјРµРЅРµРґР¶РµСЂР°
	@nViewProceed smallint,			-- РЅРµ РїРѕРєР°Р·С‹РІР°С‚СЊ РѕР±СЂР°Р±РѕС‚Р°РЅРЅС‹Рµ: 0 - РїРѕРєР°Р·С‹РІР°С‚СЊ, 1 - РЅРµ РїРѕРєР°Р·С‹РІР°С‚СЊ
	@sFilterKeys varchar(255),		-- РєР»СЋС‡Рё РІС‹Р±СЂР°РЅРЅС‹С… С„РёР»СЊС‚СЂРѕРІ
	@nFilialKey int,				-- РєР»СЋС‡ С„РёР»РёР°Р»Р°
	@nBTKey int,					-- РєР»СЋС‡ С‚РёРїР° Р±СЂРѕРЅРёСЂРѕРІР°РЅРёСЏ: -1 - РІСЃРµ, 0 - РѕС„РёСЃ, 1 - РѕРЅР»Р°Р№РЅ
	@sLang varchar(10)				-- СЏР·С‹Рє (РµСЃР»Рё en, СЃРµР»РµРєС‚РёРј РїРѕР»СЏ NameLat, Р° РЅРµ Name)	       
AS
BEGIN

CREATE TABLE #DogovorMonitorTable
(
	DM_CreateDate datetime, -- DM_HistoryDate
	DM_FirstProcDate datetime, -- NEW
	DM_LastProcDate datetime, -- DM_ProcDate
	DM_DGCODE nvarchar(10),
	DM_CREATOR nvarchar(25),
	DM_TurDate datetime,
	DM_TurName nvarchar(160),
	DM_PartnerName nvarchar(80),
	DM_FilterName nvarchar(1024),
	DM_NotesCount int,
	DM_PaymentStatus nvarchar(4),
	DM_IsBilled bit,
	DM_MessageCount int,
    DM_MessageCountRead int,
	DM_MessageCountUnRead int,
	DM_AnnulReason varchar(60),
	DM_AnnulDate datetime,
	DM_PriceToPay money,
	DM_Payed money,
	DM_OrderStatus varchar(20)
)

CREATE TABLE #TempTable
(
	#dogovorCreateDate datetime,
	#lastDogovorActionDate datetime,
	#sDGCode varchar(10),
	#sCreator varchar(25),
	#dtTurDate datetime,
	#sTurName nvarchar(160),
	#sPartnerName nvarchar(80),
	#dgKey int,
	#sPaymentStatus nvarchar(4),
	#AnnulReason varchar(60),
	#PriceToPay money,
	#Payed money
)

declare @nObjectAliasFilter int, @sFilterType varchar(3)

DECLARE @dogovorCreateDate datetime, @lastDogovorActionDate datetime -- @dtHistoryDate
declare @sDGCode varchar(10), @nDGKey int
declare @sCreator varchar(25), @dtTurDate datetime, @sTurName varchar(160)
declare @sPartnerName varchar(80), @sFilterName varchar(255), @nHIID int
declare @sHistoryMod varchar(3), @sPaymentStatus as varchar(4)
declare @AnnulReason AS varchar(60), @AnnulDate AS datetime, @PriceToPay AS money, @Payed AS money

set @sHistoryMod = 'DMP'

declare @nFilterKey int, @nLastPos int

while len(@sFilterKeys) > 0
begin
	set @nLastPos = 0
	set @nLastPos = charindex(',', @sFilterKeys, @nLastPos)
	if @nLastPos = 0
		set @nLastPos = len(@sFilterKeys) + 1
	
	set @nFilterKey = cast(substring(@sFilterKeys, 0, @nLastPos) as int)
	if @nLastPos <> len(@sFilterKeys) + 1
		set @sFilterKeys = substring(@sFilterKeys, @nLastPos + 1, len(@sFilterKeys) - @nLastPos)
	else
		set @sFilterKeys = ''
	
	select @sFilterName = DS_Value from Descriptions where DS_KEY = @nFilterKey


	declare filterCursor cursor local fast_forward for
	select OF_OAId, OF_Type
	from ObjectAliasFilters
	where OF_DSKey = @nFilterKey
	order by OF_OAId
	
	open filterCursor
	fetch next from filterCursor into @nObjectAliasFilter, @sFilterType
	while(@@fetch_status = 0)
	begin
		
		declare @sql varchar(max)

		set @sql = N'insert into #TempTable
				select DISTINCT 
				(SELECT MIN(HI_DATE) FROM history h2 WHERE h2.HI_DGCOD = DG_CODE) AS DOGOVOR_CREATE_DATE, 
				(SELECT MAX(HI_DATE) FROM history h2 WHERE h2.HI_DGCOD = DG_CODE) AS LAST_DOGOVOR_ACTION_DATE, 
				DG_CODE, ISNULL(US_FullName,''''), DG_TurDate, TL_NAME, PR_NAME, DG_KEY,
				CASE
					WHEN DG_PRICE = 0 AND DG_PAYED = DG_PRICE THEN ''OK''
					WHEN DG_PAYED = 0 THEN ''NONE''
					WHEN DG_PAYED < DG_PRICE THEN ''LOW''
					WHEN DG_PAYED = DG_PRICE THEN ''OK''
					WHEN DG_PAYED > DG_PRICE THEN ''OVER''
					ELSE '''' 
				END AS DM_PAYMENTSTATUS, AR_Name, 
				CASE
					WHEN DG_PDTTYPE = 1 THEN DG_PRICE + DG_DISCOUNTSUM
					ELSE DG_PRICE					
				END AS DM_PriceToPay, DG_PAYED
			from dogovor with(nolock) 
			join  history with(nolock) on HI_DGCOD = DG_CODE
			join historydetail with(nolock) on HI_ID = HD_HIID
			join  TurList with(nolock) on TL_KEY = DG_TRKEY
			join Partners with(nolock) on PR_KEY = DG_PARTNERKEY 
			join AnnulReasons with(nolock) on AR_Key = DG_ARKEY
			left join userlist with(nolock) on US_KEY = DG_CREATOR
			where 
				HI_DATE BETWEEN ''' + convert(varchar, @dtStartDate, 120) + ''' and dateadd(day, 1, ''' + convert(varchar, @dtEndDate, 120) + ''') and
				((' + str(@nCountryKey) + ' < 0 and DG_CNKEY in (select CN_KEY from Country with(nolock))) OR (' + str(@nCountryKey) + ' >= 0 and DG_CNKEY = ' + str(@nCountryKey) + ')) and
				(' + str(@nCityKey) + ' < 0 OR DG_CTKEY = ' + str(@nCityKey) + ') and
				(' + str(@nDepartureCityKey) + ' < 0 OR DG_CTDepartureKey = ' + str(@nDepartureCityKey) + ') and
				(' + str(@nCreatorKey) + ' < 0 OR DG_CREATOR = ' + str(@nCreatorKey) + ') and
				(' + str(@nOwnerKey) + ' < 0 OR DG_OWNER = ' + str(@nOwnerKey) + ') and
				(' + str(@nFilialKey) + ' < 0 OR DG_FILIALKEY = ' + str(@nFilialKey) + ') and
				(' + str(@nBTKey) + ' < 0 OR (' + str(@nBTKey) + ' = 0 AND DG_BTKEY is NULL) OR DG_BTKEY = ' + str(@nBTKey) + ')'
				
-----------------------------------------------------------------------------------------------
-- MEG00037288 06.09.2011 Kolbeshkin: РґРѕР±Р°РІРёР» Р°Р»РёР°СЃС‹ 41-43 РґР»СЏ РїСЂРѕРІРµСЂРєРё РєРѕСЂСЂРµРєС‚РЅРѕСЃС‚Рё РїСѓС‚РµРІРєРё --
-----------------------------------------------------------------------------------------------
		DECLARE @sNotAnnuled varchar(max)
		SET @sNotAnnuled = ' and DG_TURDATE <> ''1899-12-30 00:00:00.000'' '
		SET @sql = @sql + 
		CASE 
		WHEN (@nObjectAliasFilter = 41) -- РџСѓС‚РµРІРєР° Р±РµР· СѓСЃР»СѓРі
			THEN ' and not exists (select 1 from dogovorlist where dl_dgkey = dg_key)' + @sNotAnnuled
		WHEN (@nObjectAliasFilter = 42) -- РџСѓС‚РµРІРєР° Р±РµР· С‚СѓСЂРёСЃС‚РѕРІ
			THEN ' and not exists (select 1 from Turist where TU_DGKEY = DG_KEY)' + @sNotAnnuled
		WHEN (@nObjectAliasFilter = 43) -- РЈСЃР»СѓРіРё СЃ РЅРµРїСЂРёРІСЏР·Р°РЅРЅС‹РјРё С‚СѓСЂРёСЃС‚Р°РјРё
			THEN ' and exists (select 1 from dogovorlist where dl_dgkey = dg_key and not exists (select 1 from TuristService where tu_dlkey = dl_key))' + @sNotAnnuled
		--o.omelchenko 10391 РґРѕР±Р°РІРёР»Р° С„РёР»СЊС‚СЂ РїРѕ РЅРѕРІС‹Рј СЃРѕРѕР±С‰РµРЅРёСЏРј РїСЂРёС€РµРґС€С‹Рј РёР· РІРµР±Р°
		-- Kirillov 19267 Р—Р°РјРµРЅРёР» С‚РёРї СЃРѕРѕР±С‰РµРЅРёСЏ СЃ WWW РЅР° MTM
		WHEN (@nObjectAliasFilter = 12005) -- РЅРѕРІС‹Рµ СЃРѕРѕР±С‰РµРЅРёСЏ
		     THEN ' and DG_CODE in (select distinct  HI_DGCOD from History
					where HI_MessEnabled >=2
					and HI_MOD like ''MTM'' 
					and HI_DATE BETWEEN ''' + convert(varchar, @dtStartDate, 120) + ''' and dateadd(day, 1, ''' + convert(varchar, @dtEndDate, 120) + ''') ) '
		
		--------- РћС‚СЃСѓС‚СЃС‚РІСѓСЋС‚ РѕР±СЏР·Р°С‚РµР»СЊРЅС‹Рµ(РЅРµСѓРґР°Р»СЏРµРјС‹Рµ) СѓСЃР»СѓРіРё СЂРµС€РµРЅРѕ РїРѕРєР° РЅРµ РґРµР»Р°С‚СЊ, РїРѕС‚РѕРјСѓ С‡С‚Рѕ РЅРµС‚ РїСЂСЏРјРѕР№ СЃРІСЏР·Рё DogovorList c TurService
		--WHEN (@nObjectAliasFilter = 44) -- РћС‚СЃСѓС‚СЃС‚РІСѓСЋС‚ РѕР±СЏР·Р°С‚РµР»СЊРЅС‹Рµ(РЅРµСѓРґР°Р»СЏРµРјС‹Рµ) СѓСЃР»СѓРіРё
		--	THEN ' and ((select (
		--	(select COUNT(1) from TurService ts where TS_TRKEY=dg.DG_TRKEY and TS_ATTRIBUTE % 2 = 0) -- РљРѕР»-РІРѕ РЅРµСѓРґР°Р»СЏРµРјС‹С… СѓСЃР»СѓРі РІ С‚СѓСЂРµ
		--	-
		--	(select COUNT(1) from Dogovorlist dl join TurService ts on -- РљРѕР»-РІРѕ СѓСЃР»СѓРі РїРѕРїР°РІС€РёС… РІ РїСѓС‚РµРІРєСѓ РёР· РЅРµСѓРґР°Р»СЏРµРјС‹С… РІ С‚СѓСЂРµ
		--	(ts.TS_TRKEY = dg.DG_TRKEY and ts.TS_ATTRIBUTE % 2 = 0
		--	and dl.DL_SVKEY = ts.TS_SVKEY and dl.DL_CODE = ts.TS_CODE
		--	) where dl.DL_DGKEY = dg.DG_Key and dl.DL_TRKEY = dg.DG_TRKEY )))
		--	> 0) ' 
		ELSE 
			 ' and (HD_OAId = ' + str(@nObjectAliasFilter) + ') 
			 and (''' + @sFilterType + '''= '''' OR HI_MOD = ''' + @sFilterType + ''')'
		END
		
-------------------------------------------------------------------------------------
-- MEG00037288 07.09.2011 Kolbeshkin: Р»РѕРєР°Р»РёР·Р°С†РёСЏ. Р•СЃР»Рё СЏР·С‹Рє En, СЃРµР»РµРєС‚РёРј РїРѕР»СЏ LAT --
-------------------------------------------------------------------------------------
		IF @sLang like 'en'
		BEGIN
		set @sql = REPLACE(@sql,'US_FullName','US_FullNameLat')
		set @sql = REPLACE(@sql,'TL_NAME','TL_NAMELAT')
		set @sql = REPLACE(@sql,'PR_NAME','PR_NAMEENG')
		set @sql = REPLACE(@sql,'AR_Name','AR_NameLat')
		END
		--print @sql
		exec (@sql)
		
		declare dogovorsCursor cursor local fast_forward for
		select * from #TempTable

		--РЅР°С€Р»Рё РїСѓС‚РµРІРєРё
		open dogovorsCursor
		fetch next from dogovorsCursor into @dogovorCreateDate, @lastDogovorActionDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @nDGKey, @sPaymentStatus, @AnnulReason, @PriceToPay, @Payed
		while(@@fetch_status = 0)
		begin
			--if not exists (select * from #DogovorMonitorTable where datediff(mi, DM_HistoryDate, @dtHistoryDate) = 0 and DM_DGCODE = @sDGCode and DM_FilterName LIKE @sFilterName)
			--begin
				DECLARE @firstDogovorProcessDate datetime 
				DECLARE @lastDogovorProcessDate datetime -- @hiDate

				SET @firstDogovorProcessDate = (select MIN(HI_DATE) from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod)
				SET @lastDogovorProcessDate = (select MAX(HI_DATE) from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod)

--				--select @hiDate = HI_DATE from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod
--				if exists (select HI_DATE from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod)
--					select @hiDate = HI_DATE from history where HI_DGCOD = @sDGCode and HI_MOD LIKE @sHistoryMod
--				else
--					set @hiDate = NULL


				------ РџРѕР»СѓС‡РµРЅРёРµ РґР°С‚С‹ С‚СѓСЂР° РґРѕ Р°РЅРЅСѓР»СЏС†РёРё ------
				IF (@dtTurDate = '12/30/1899')
				BEGIN
					SELECT @dtTurDate = DG_TURDATEBFRANNUL
					FROM Dogovor
					WHERE DG_Code = @sDGCode
				END
				----------------------------------------------

				SET @AnnulDate = NULL;
				------ РџРѕР»СѓС‡РµРЅРёРµ РґР°С‚С‹ Р°РЅРЅСѓР»СЏС†РёРё ------
				SELECT @AnnulDate = History.HI_DATE
				FROM HistoryDetail
				JOIN History 
					ON HI_ID = HD_HIID
				WHERE HistoryDetail.HD_Alias = 'DG_Annulate' AND History.HI_DgCod = @sDGCode
				--------------------------------------
				
				DECLARE @notesCount int 
				SET @notesCount =0
				SELECT @notesCount = COUNT(HI_TEXT) FROM HISTORY
				WHERE HI_DGCOD = @sDGCode AND HI_MOD = 'MTM'

				DECLARE @isBilled bit
				SET @isBilled = 0
				IF EXISTS(SELECT AC_KEY FROM ACCOUNTS WHERE AC_DGCOD = @sDGCode)
					SET @isBilled = 1

				DECLARE @messageCount int , @MessageCountRead int, @MessageCountUnRead int 
				SET @messageCount = 0
				SET @MessageCountRead  = 0
				SET @MessageCountUnRead  = 0
				SELECT @messageCount = COUNT(HI_TEXT)
			          ,@MessageCountRead = SUM(case when HI_MessEnabled <= 1 then 1 else 0 end)
			          ,@MessageCountUnRead = SUM(case when HI_MessEnabled >= 2 then 1 else 0 end)
			    FROM HISTORY
				-- Kirillov 19267 Р—Р°РјРµРЅРёР» С‚РёРї СЃРѕРѕР±С‰РµРЅРёСЏ СЃ WWW РЅР° MTM
				WHERE HI_DGCOD = @sDGCode AND HI_MOD = 'MTM'
				--AND HI_TEXT NOT LIKE 'РћС‚ Р°РіРµРЅС‚Р°: %' -- notes from web (copies of 'WWW' moded notes)
				
				--СѓР·РЅР°РµРј СЃС‚Р°С‚СѓСЃ РїСѓС‚РµРІРєРё
				DECLARE @orderStatus varchar(20);
				select @orderStatus  = case when @sLang='en' then o.OS_NameLat else o.OS_NAME_RUS end
				from Order_Status o
				left join Dogovor d on d.DG_SOR_CODE=o.OS_CODE
				where d.DG_Key = @nDGKey

				DECLARE @includeRecord bit
				SET @includeRecord = 0

				if (@nViewProceed = 0) OR (@lastDogovorProcessDate IS NULL)
				begin
					--insert into #DogovorMonitorTable (DM_HistoryDate, DM_ProcDate, DM_DGCODE, DM_CREATOR, DM_TurDate, DM_TurName, DM_PartnerName, DM_FilterName, DM_NotesCount, DM_PaymentStatus, DM_IsBilled, DM_MessageCount)
					--values (@dtHistoryDate, @hiDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @sFilterName, @notesCount, @sPaymentStatus, @isBilled, @messageCount)
					SET @includeRecord = 1
				end
				else
				begin
					--if @dtHistoryDate > @hiDate
					if @lastDogovorActionDate > @lastDogovorProcessDate
					begin
						--insert into #DogovorMonitorTable (DM_HistoryDate, DM_ProcDate, DM_DGCODE, DM_CREATOR, DM_TurDate, DM_TurName, DM_PartnerName, DM_FilterName, DM_NotesCount, DM_PaymentStatus, DM_IsBilled, DM_MessageCount) 
						--values (@dtHistoryDate, @hiDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @sFilterName, @notesCount, @sPaymentStatus, @isBilled, @messageCount)
						SET @includeRecord = 1
					end
				end
              
				-------------------
				IF @includeRecord = 1
				BEGIN
					IF EXISTS (SELECT dm_dgcode FROM #DogovorMonitorTable WHERE dm_dgcode = @sDGCode)
					BEGIN
						IF NOT EXISTS (SELECT 1 FROM #DogovorMonitorTable WHERE dm_dgcode = @sDGCode AND dm_filtername LIKE '%' + @sFilterName + '%')
							UPDATE #DogovorMonitorTable SET DM_FilterName = DM_FilterName + ', ' + @sFilterName WHERE dm_dgcode = @sDGCode
					END
					ELSE
					BEGIN
						INSERT INTO #DogovorMonitorTable
						VALUES (@dogovorCreateDate, @firstDogovorProcessDate, @lastDogovorProcessDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @sFilterName, @notesCount, @sPaymentStatus, @isBilled, @messageCount, @MessageCountRead , @MessageCountUnRead, @AnnulReason, @AnnulDate, @PriceToPay, @Payed,@orderStatus);
					END
				END
				-------------------

			--end
			fetch next from dogovorsCursor into @dogovorCreateDate, @lastDogovorActionDate, @sDGCode, @sCreator, @dtTurDate, @sTurName, @sPartnerName, @nDGKey, @sPaymentStatus, @AnnulReason, @PriceToPay, @Payed
		end
			
		close dogovorsCursor
		deallocate dogovorsCursor
		delete from #TempTable

		fetch next from filterCursor into @nObjectAliasFilter, @sFilterType
	end

	close filterCursor
	deallocate filterCursor
end
	SELECT *
	FROM #DogovorMonitorTable
	ORDER BY DM_CreateDate
	
	DROP TABLE #TempTable
	DROP TABLE #DogovorMonitorTable

END
GO

/*********************************************************************/
/* end (2013.11.05)_ALTER_PROCEDURE_DogovorMonitor.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (20131001)_CreateTable_ProTourQuotes.sql */
/*********************************************************************/
-- koshelev 01.10.2013
-- в случае если таблица вдруг не была создана
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ProTourQuotes]') AND type in (N'U'))
begin
	CREATE TABLE [dbo].[ProTourQuotes](
		[PTQ_Id] [int] IDENTITY(1,1) NOT NULL,
		[PTQ_PartnerKey] [int] NOT NULL,
		[PTQ_HotelKey] [int] NOT NULL,
		[PTQ_RoomCategoryKey] [int] NOT NULL,
		[PTQ_Date] [datetime] NOT NULL,
		[PTQ_State] [tinyint] NOT NULL,
		[PTQ_CommitmentFree] [int] NULL,
		[PTQ_CommitmentSold] [int] NULL,
		[PTQ_CommitmentTotal] [int] NOT NULL,
		[PTQ_AllotmentFree] [int] NULL,
		[PTQ_AllotmentSold] [int] NULL,
		[PTQ_AllotmentTotal] [int] NOT NULL,
		[PTQ_Release] [int] NOT NULL,
		[PTQ_StopSale] [bit] NOT NULL constraint PTQ_StopSale_Default default(0),
		[PTQ_CancelStopSale] [bit] NULL,
		[PTQ_RecordDate] [datetime] NULL,
		[PTQ_UpdateDate] [datetime] NULL,
		[PTQ_MethodType] [smallint] NULL,
		[PTQ_ErrorState] [tinyint] NULL,
		[PTQ_IsByCheckin] [bit] NULL,
		[PTQ_DurationMin] [int] NULL,
		[PTQ_DurationMax] [int] NULL,
	 CONSTRAINT [PK_ProTourQuotes] PRIMARY KEY CLUSTERED 
	(
		[PTQ_Id] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	) ON [PRIMARY]
end
GO

IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_ProTourQuotes_Partners]') AND parent_object_id = OBJECT_ID(N'[dbo].[ProTourQuotes]'))
	ALTER TABLE [dbo].[ProTourQuotes]  WITH CHECK ADD CONSTRAINT [FK_ProTourQuotes_Partners] FOREIGN KEY([PTQ_PartnerKey])
	REFERENCES [dbo].[tbl_Partners] ([PR_KEY])
	ON DELETE CASCADE
	NOT FOR REPLICATION 
GO

IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_ProTourQuotes_HotelDictionary]') AND parent_object_id = OBJECT_ID(N'[dbo].[ProTourQuotes]'))
	ALTER TABLE [dbo].[ProTourQuotes]  WITH CHECK ADD CONSTRAINT [FK_ProTourQuotes_HotelDictionary] FOREIGN KEY([PTQ_HotelKey])
	REFERENCES [dbo].[HotelDictionary] ([HD_KEY])
	ON DELETE CASCADE
	NOT FOR REPLICATION 
GO

GRANT SELECT, INSERT, UPDATE, DELETE ON [dbo].[ProTourQuotes] TO PUBLIC
GO
/*********************************************************************/
/* end (20131001)_CreateTable_ProTourQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin (26.09.2013)_Create_Table_MIS_Quotas.sql */
/*********************************************************************/
go
/**** Object:  Table [dbo].[MIS_Quotas]    Script Date: 04/03/2013 15:21:26 ****/
set ansi_nulls on
go
set quoted_identifier on
go
if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[MIS_Quotas]') and type in (N'U'))
begin
create table [dbo].[MIS_Quotas](
	[MQ_Id] [int] identity(1,1) not null,
	[ImportIdentificator] [nvarchar](100) null,
	[UpdateDate] [datetime] null,
	[Allotment_MT_Key] [int] NULL,
	[Commitment_MT_Key] [int] NULL,
	[External_Id] [int] not null,
	[MQ_PartnerKey] [int] not null,
	[MQ_HotelKey] [int] not null,
	[MQ_RoomCategoryKey] [int] not null,
	[MQ_Date] [datetime] not null,
	[MQ_CommitmentFree] [int] null,
	[MQ_CommitmentSold] [int] null,
	[MQ_CommitmenTotal] [int] not null,
	[MQ_AllotmentFree] [int] null,
	[MQ_AllotmentSold] [int] null,
	[MQ_AllotmentTotal] [int] not null,
	[MQ_Release] [int] not null,
	[MQ_Stopsale] [bit] not null,
	[MQ_CancelStopsale] [bit] null,
	[MQ_RecordDate] [datetime] null,
	[MQ_IsByCheckin] [bit] null,
	[MQ_DurationMin] [int] null,
	[MQ_DurationMax] [int] null,
	[MQ_ErrorState] [tinyint] null
	constraint [PK_MIS_Quotas] primary key clustered (
		[MQ_Id] asc
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
end
go

/*********************************************************************/
/* end (26.09.2013)_Create_Table_MIS_Quotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin 20130426_AlterTable_PriceServiceLink.sql */
/*********************************************************************/
if not exists 
	(
		select * from sys.columns col
		left join sys.tables tab on col.object_id = tab.object_id
		where tab.name = 'PriceServiceLink'
			and col.name = 'PS_Key'
			and is_identity = 1
	)
begin
	-- change primary key identity property to 1:
	-- first, delete all dependent objects
	if exists(select * from sys.sysobjects where name = 'PK_PriceServiceLink' and xtype = 'PK')
	begin
		ALTER TABLE PriceServiceLink drop constraint PK_PriceServiceLink
	end

	if exists (select top 1 1
			from sys.tables tab
			left join sys.indexes ix on ix.object_id = tab.object_id
			where tab.name = 'PriceServiceLink'
				and ix.name = 'PK_PriceServiceLink'
				and ix.type = 1)
	begin
		DROP INDEX PK_PriceServiceLink ON PriceServiceLink WITH ( ONLINE = OFF )
	end

	exec RecreateDependentObjects 'PriceServiceLink', 'PS_Key', '
	-- drop old column
	if exists (select * from dbo.syscolumns where name =''PS_Key'' and id = object_id(N''[dbo].[PriceServiceLink]''))
	begin
		ALTER TABLE PriceServiceLink drop column PS_Key
	end

	-- recreate primary key column with is_identity=1 property value
	if not exists (select * from dbo.syscolumns where name =''PS_Key'' and id = object_id(N''[dbo].[PriceServiceLink]''))
	begin
		ALTER TABLE PriceServiceLink add PS_Key int IDENTITY(1,1) NOT NULL
	end
	'
end
GO

if not exists(select * from sys.sysobjects where name like 'PK_PriceServiceLink' and xtype = 'PK')
begin
	if exists (select top 1 1
			from sys.tables tab
			left join sys.indexes ix on ix.object_id = tab.object_id
			where tab.name = 'PriceServiceLink'
				and ix.name = 'PK_PriceServiceLink'
				and ix.type = 1)
	begin
		DROP INDEX PK_PriceServiceLink ON PriceServiceLink WITH ( ONLINE = OFF )
	end

	ALTER TABLE PriceServiceLink add CONSTRAINT [PK_PriceServiceLink] PRIMARY KEY CLUSTERED 
	(
		[PS_Key] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end 20130426_AlterTable_PriceServiceLink.sql */
/*********************************************************************/

/*********************************************************************/
/* begin CreateTable_CommunicationServices.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CommunicationServices]') AND type in (N'U'))
BEGIN

create table [dbo].[CommunicationServices]
(
	[CMS_Key]    int not null identity(1,1) primary key,
	[CMS_CMKey]  int not null foreign key references [dbo].[Communications](CM_Id),
	[CMS_DLKey]  int not null foreign key references [dbo].[tbl_DogovorList](DL_Key),
	[CMS_Status] int not null,
	[CMS_Netto]  money not null,
)

grant select, insert, update, delete on [dbo].[CommunicationServices] to public

end

go

/*********************************************************************/
/* end CreateTable_CommunicationServices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin DeleteFromSystemSettings.sql */
/*********************************************************************/
-- delete obsolete setting from systemsettings
delete from systemsettings where ss_parmname = 'SYSCheckQuotaRelease'
delete from systemsettings where ss_parmname = 'SYSAllowErrorContinue'
GO
/*********************************************************************/
/* end DeleteFromSystemSettings.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_GetTPListsHash.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetTPListsHash]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
	DROP FUNCTION [dbo].[GetTPListsHash]
GO

CREATE function [dbo].[GetTPListsHash] (@tikey int) returns nvarchar(max) 	
as
begin
declare @res nvarchar(max)
set @res = ''
select 
	@res = @res + isnull(ltrim(str(tl_tskey)),'') + ','
from 
	tp_servicelists with(nolock)
where
	tl_tikey = @tikey
order by
	tl_tskey

if(len(@res) > 0)
	set @res = substring(@res, 1, len(@res) - 1)

return @res
end
GO

grant exec on [dbo].[GetTPListsHash] to public
GO
/*********************************************************************/
/* end fn_GetTPListsHash.sql */
/*********************************************************************/

/*********************************************************************/
/* begin fn_mwGetFlightAndCommissionServicesCosts.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[fn_mwGetFlightAndCommissionServicesCosts]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
	DROP FUNCTION [dbo].[fn_mwGetFlightAndCommissionServicesCosts]
GO

-- Хранимка возвращает суммарные стоимости всех перелетов и всех комиссионных услуг, на момент рассчета прайса
-- <date>2013-11-07</date>
-- <version>2009.02.20</version>

CREATE FUNCTION [dbo].[fn_mwGetFlightAndCommissionServicesCosts] ( @priceKey int )
RETURNS @result TABLE
(
	flightGross money,
	commissionGross money
)
BEGIN
	declare @flightGross money
	declare @commissionGross money
	
	-- Сумма стоимостей всех перелетов
	select @flightGross = (
		(case when [SVKEY_1] = 1 then (case when [SCPId_1] is not null then [Gross_1] else 0 end) * (1 + (isnull( [MarginPercent_1], 0)/100) * (1 + (isnull( [IsCommission_1], 0) - 1) * isnull( [CommissionOnly_1], 0))) + isnull( [AddCostIsCommission_1], 0) * (1 + (isnull( [MarginPercent_1], 0)/100)) + isnull( [AddCostNoCommission_1], 0) * (1 + (isnull( [MarginPercent_1], 0)/100) * (1 - isnull( [CommissionOnly_1], 0))) else 0 end) +
		(case when [SVKEY_2] = 1 then (case when [SCPId_2] is not null then [Gross_2] else 0 end) * (1 + (isnull( [MarginPercent_2], 0)/100) * (1 + (isnull( [IsCommission_2], 0) - 1) * isnull( [CommissionOnly_2], 0))) + isnull( [AddCostIsCommission_2], 0) * (1 + (isnull( [MarginPercent_2], 0)/100)) + isnull( [AddCostNoCommission_2], 0) * (1 + (isnull( [MarginPercent_2], 0)/100) * (1 - isnull( [CommissionOnly_2], 0))) else 0 end) +
		(case when [SVKEY_3] = 1 then (case when [SCPId_3] is not null then [Gross_3] else 0 end) * (1 + (isnull( [MarginPercent_3], 0)/100) * (1 + (isnull( [IsCommission_3], 0) - 1) * isnull( [CommissionOnly_3], 0))) + isnull( [AddCostIsCommission_3], 0) * (1 + (isnull( [MarginPercent_3], 0)/100)) + isnull( [AddCostNoCommission_3], 0) * (1 + (isnull( [MarginPercent_3], 0)/100) * (1 - isnull( [CommissionOnly_3], 0))) else 0 end) +
		(case when [SVKEY_4] = 1 then (case when [SCPId_4] is not null then [Gross_4] else 0 end) * (1 + (isnull( [MarginPercent_4], 0)/100) * (1 + (isnull( [IsCommission_4], 0) - 1) * isnull( [CommissionOnly_4], 0))) + isnull( [AddCostIsCommission_4], 0) * (1 + (isnull( [MarginPercent_4], 0)/100)) + isnull( [AddCostNoCommission_4], 0) * (1 + (isnull( [MarginPercent_4], 0)/100) * (1 - isnull( [CommissionOnly_4], 0))) else 0 end) +
		(case when [SVKEY_5] = 1 then (case when [SCPId_5] is not null then [Gross_5] else 0 end) * (1 + (isnull( [MarginPercent_5], 0)/100) * (1 + (isnull( [IsCommission_5], 0) - 1) * isnull( [CommissionOnly_5], 0))) + isnull( [AddCostIsCommission_5], 0) * (1 + (isnull( [MarginPercent_5], 0)/100)) + isnull( [AddCostNoCommission_5], 0) * (1 + (isnull( [MarginPercent_5], 0)/100) * (1 - isnull( [CommissionOnly_5], 0))) else 0 end) +
		(case when [SVKEY_6] = 1 then (case when [SCPId_6] is not null then [Gross_6] else 0 end) * (1 + (isnull( [MarginPercent_6], 0)/100) * (1 + (isnull( [IsCommission_6], 0) - 1) * isnull( [CommissionOnly_6], 0))) + isnull( [AddCostIsCommission_6], 0) * (1 + (isnull( [MarginPercent_6], 0)/100)) + isnull( [AddCostNoCommission_6], 0) * (1 + (isnull( [MarginPercent_6], 0)/100) * (1 - isnull( [CommissionOnly_6], 0))) else 0 end) +
		(case when [SVKEY_7] = 1 then (case when [SCPId_7] is not null then [Gross_7] else 0 end) * (1 + (isnull( [MarginPercent_7], 0)/100) * (1 + (isnull( [IsCommission_7], 0) - 1) * isnull( [CommissionOnly_7], 0))) + isnull( [AddCostIsCommission_7], 0) * (1 + (isnull( [MarginPercent_7], 0)/100)) + isnull( [AddCostNoCommission_7], 0) * (1 + (isnull( [MarginPercent_7], 0)/100) * (1 - isnull( [CommissionOnly_7], 0))) else 0 end) +
		(case when [SVKEY_8] = 1 then (case when [SCPId_8] is not null then [Gross_8] else 0 end) * (1 + (isnull( [MarginPercent_8], 0)/100) * (1 + (isnull( [IsCommission_8], 0) - 1) * isnull( [CommissionOnly_8], 0))) + isnull( [AddCostIsCommission_8], 0) * (1 + (isnull( [MarginPercent_8], 0)/100)) + isnull( [AddCostNoCommission_8], 0) * (1 + (isnull( [MarginPercent_8], 0)/100) * (1 - isnull( [CommissionOnly_8], 0))) else 0 end) +
		(case when [SVKEY_9] = 1 then (case when [SCPId_9] is not null then [Gross_9] else 0 end) * (1 + (isnull( [MarginPercent_9], 0)/100) * (1 + (isnull( [IsCommission_9], 0) - 1) * isnull( [CommissionOnly_9], 0))) + isnull( [AddCostIsCommission_9], 0) * (1 + (isnull( [MarginPercent_9], 0)/100)) + isnull( [AddCostNoCommission_9], 0) * (1 + (isnull( [MarginPercent_9], 0)/100) * (1 - isnull( [CommissionOnly_9], 0))) else 0 end) +
		(case when [SVKEY_10] = 1 then (case when [SCPId_10] is not null then [Gross_10] else 0 end) * (1 + (isnull([MarginPercent_10], 0)/100) * (1 + (isnull([IsCommission_10], 0) - 1) * isnull([CommissionOnly_10], 0))) + isnull([AddCostIsCommission_10], 0) * (1 + (isnull([MarginPercent_10], 0)/100)) + isnull([AddCostNoCommission_10], 0) * (1 + (isnull([MarginPercent_10], 0)/100) * (1 - isnull([CommissionOnly_10], 0))) else 0 end) +
		(case when [SVKEY_11] = 1 then (case when [SCPId_11] is not null then [Gross_11] else 0 end) * (1 + (isnull([MarginPercent_11], 0)/100) * (1 + (isnull([IsCommission_11], 0) - 1) * isnull([CommissionOnly_11], 0))) + isnull([AddCostIsCommission_11], 0) * (1 + (isnull([MarginPercent_11], 0)/100)) + isnull([AddCostNoCommission_11], 0) * (1 + (isnull([MarginPercent_11], 0)/100) * (1 - isnull([CommissionOnly_11], 0))) else 0 end) +
		(case when [SVKEY_12] = 1 then (case when [SCPId_12] is not null then [Gross_12] else 0 end) * (1 + (isnull([MarginPercent_12], 0)/100) * (1 + (isnull([IsCommission_12], 0) - 1) * isnull([CommissionOnly_12], 0))) + isnull([AddCostIsCommission_12], 0) * (1 + (isnull([MarginPercent_12], 0)/100)) + isnull([AddCostNoCommission_12], 0) * (1 + (isnull([MarginPercent_12], 0)/100) * (1 - isnull([CommissionOnly_12], 0))) else 0 end) +
		(case when [SVKEY_13] = 1 then (case when [SCPId_13] is not null then [Gross_13] else 0 end) * (1 + (isnull([MarginPercent_13], 0)/100) * (1 + (isnull([IsCommission_13], 0) - 1) * isnull([CommissionOnly_13], 0))) + isnull([AddCostIsCommission_13], 0) * (1 + (isnull([MarginPercent_13], 0)/100)) + isnull([AddCostNoCommission_13], 0) * (1 + (isnull([MarginPercent_13], 0)/100) * (1 - isnull([CommissionOnly_13], 0))) else 0 end) +
		(case when [SVKEY_14] = 1 then (case when [SCPId_14] is not null then [Gross_14] else 0 end) * (1 + (isnull([MarginPercent_14], 0)/100) * (1 + (isnull([IsCommission_14], 0) - 1) * isnull([CommissionOnly_14], 0))) + isnull([AddCostIsCommission_14], 0) * (1 + (isnull([MarginPercent_14], 0)/100)) + isnull([AddCostNoCommission_14], 0) * (1 + (isnull([MarginPercent_14], 0)/100) * (1 - isnull([CommissionOnly_14], 0))) else 0 end) +
		(case when [SVKEY_15] = 1 then (case when [SCPId_15] is not null then [Gross_15] else 0 end) * (1 + (isnull([MarginPercent_15], 0)/100) * (1 + (isnull([IsCommission_15], 0) - 1) * isnull([CommissionOnly_15], 0))) + isnull([AddCostIsCommission_15], 0) * (1 + (isnull([MarginPercent_15], 0)/100)) + isnull([AddCostNoCommission_15], 0) * (1 + (isnull([MarginPercent_15], 0)/100) * (1 - isnull([CommissionOnly_15], 0))) else 0 end)
    )
    from TP_PRICECOMPONENTS with(nolock) where pc_tpkey = @priceKey
                              
	
	-- Сумма стоимостей всех услуг, на которые дается скидка
	
	select @commissionGross = (
		(case when [IsCommission_1] = 1 then (case when [SCPId_1] is not null then [Gross_1] else 0 end) * (1 + (isnull( [MarginPercent_1], 0)/100) * (1 + (isnull( [IsCommission_1], 0) - 1) * isnull( [CommissionOnly_1], 0))) + isnull( [AddCostIsCommission_1], 0) * (1 + (isnull( [MarginPercent_1], 0)/100)) + isnull( [AddCostNoCommission_1], 0) * (1 + (isnull( [MarginPercent_1], 0)/100) * (1 - isnull( [CommissionOnly_1], 0))) else 0 end) +
		(case when [IsCommission_2] = 1 then (case when [SCPId_2] is not null then [Gross_2] else 0 end) * (1 + (isnull( [MarginPercent_2], 0)/100) * (1 + (isnull( [IsCommission_2], 0) - 1) * isnull( [CommissionOnly_2], 0))) + isnull( [AddCostIsCommission_2], 0) * (1 + (isnull( [MarginPercent_2], 0)/100)) + isnull( [AddCostNoCommission_2], 0) * (1 + (isnull( [MarginPercent_2], 0)/100) * (1 - isnull( [CommissionOnly_2], 0))) else 0 end) +
		(case when [IsCommission_3] = 1 then (case when [SCPId_3] is not null then [Gross_3] else 0 end) * (1 + (isnull( [MarginPercent_3], 0)/100) * (1 + (isnull( [IsCommission_3], 0) - 1) * isnull( [CommissionOnly_3], 0))) + isnull( [AddCostIsCommission_3], 0) * (1 + (isnull( [MarginPercent_3], 0)/100)) + isnull( [AddCostNoCommission_3], 0) * (1 + (isnull( [MarginPercent_3], 0)/100) * (1 - isnull( [CommissionOnly_3], 0))) else 0 end) +
		(case when [IsCommission_4] = 1 then (case when [SCPId_4] is not null then [Gross_4] else 0 end) * (1 + (isnull( [MarginPercent_4], 0)/100) * (1 + (isnull( [IsCommission_4], 0) - 1) * isnull( [CommissionOnly_4], 0))) + isnull( [AddCostIsCommission_4], 0) * (1 + (isnull( [MarginPercent_4], 0)/100)) + isnull( [AddCostNoCommission_4], 0) * (1 + (isnull( [MarginPercent_4], 0)/100) * (1 - isnull( [CommissionOnly_4], 0))) else 0 end) +
		(case when [IsCommission_5] = 1 then (case when [SCPId_5] is not null then [Gross_5] else 0 end) * (1 + (isnull( [MarginPercent_5], 0)/100) * (1 + (isnull( [IsCommission_5], 0) - 1) * isnull( [CommissionOnly_5], 0))) + isnull( [AddCostIsCommission_5], 0) * (1 + (isnull( [MarginPercent_5], 0)/100)) + isnull( [AddCostNoCommission_5], 0) * (1 + (isnull( [MarginPercent_5], 0)/100) * (1 - isnull( [CommissionOnly_5], 0))) else 0 end) +
		(case when [IsCommission_6] = 1 then (case when [SCPId_6] is not null then [Gross_6] else 0 end) * (1 + (isnull( [MarginPercent_6], 0)/100) * (1 + (isnull( [IsCommission_6], 0) - 1) * isnull( [CommissionOnly_6], 0))) + isnull( [AddCostIsCommission_6], 0) * (1 + (isnull( [MarginPercent_6], 0)/100)) + isnull( [AddCostNoCommission_6], 0) * (1 + (isnull( [MarginPercent_6], 0)/100) * (1 - isnull( [CommissionOnly_6], 0))) else 0 end) +
		(case when [IsCommission_7] = 1 then (case when [SCPId_7] is not null then [Gross_7] else 0 end) * (1 + (isnull( [MarginPercent_7], 0)/100) * (1 + (isnull( [IsCommission_7], 0) - 1) * isnull( [CommissionOnly_7], 0))) + isnull( [AddCostIsCommission_7], 0) * (1 + (isnull( [MarginPercent_7], 0)/100)) + isnull( [AddCostNoCommission_7], 0) * (1 + (isnull( [MarginPercent_7], 0)/100) * (1 - isnull( [CommissionOnly_7], 0))) else 0 end) +
		(case when [IsCommission_8] = 1 then (case when [SCPId_8] is not null then [Gross_8] else 0 end) * (1 + (isnull( [MarginPercent_8], 0)/100) * (1 + (isnull( [IsCommission_8], 0) - 1) * isnull( [CommissionOnly_8], 0))) + isnull( [AddCostIsCommission_8], 0) * (1 + (isnull( [MarginPercent_8], 0)/100)) + isnull( [AddCostNoCommission_8], 0) * (1 + (isnull( [MarginPercent_8], 0)/100) * (1 - isnull( [CommissionOnly_8], 0))) else 0 end) +
		(case when [IsCommission_9] = 1 then (case when [SCPId_9] is not null then [Gross_9] else 0 end) * (1 + (isnull( [MarginPercent_9], 0)/100) * (1 + (isnull( [IsCommission_9], 0) - 1) * isnull( [CommissionOnly_9], 0))) + isnull( [AddCostIsCommission_9], 0) * (1 + (isnull( [MarginPercent_9], 0)/100)) + isnull( [AddCostNoCommission_9], 0) * (1 + (isnull( [MarginPercent_9], 0)/100) * (1 - isnull( [CommissionOnly_9], 0))) else 0 end) +
		(case when [IsCommission_10] = 1 then (case when [SCPId_10] is not null then [Gross_10] else 0 end) * (1 + (isnull([MarginPercent_10], 0)/100) * (1 + (isnull([IsCommission_10], 0) - 1) * isnull([CommissionOnly_10], 0))) + isnull([AddCostIsCommission_10], 0) * (1 + (isnull([MarginPercent_10], 0)/100)) + isnull([AddCostNoCommission_10], 0) * (1 + (isnull([MarginPercent_10], 0)/100) * (1 - isnull([CommissionOnly_10], 0))) else 0 end) +
		(case when [IsCommission_11] = 1 then (case when [SCPId_11] is not null then [Gross_11] else 0 end) * (1 + (isnull([MarginPercent_11], 0)/100) * (1 + (isnull([IsCommission_11], 0) - 1) * isnull([CommissionOnly_11], 0))) + isnull([AddCostIsCommission_11], 0) * (1 + (isnull([MarginPercent_11], 0)/100)) + isnull([AddCostNoCommission_11], 0) * (1 + (isnull([MarginPercent_11], 0)/100) * (1 - isnull([CommissionOnly_11], 0))) else 0 end) +
		(case when [IsCommission_12] = 1 then (case when [SCPId_12] is not null then [Gross_12] else 0 end) * (1 + (isnull([MarginPercent_12], 0)/100) * (1 + (isnull([IsCommission_12], 0) - 1) * isnull([CommissionOnly_12], 0))) + isnull([AddCostIsCommission_12], 0) * (1 + (isnull([MarginPercent_12], 0)/100)) + isnull([AddCostNoCommission_12], 0) * (1 + (isnull([MarginPercent_12], 0)/100) * (1 - isnull([CommissionOnly_12], 0))) else 0 end) +
		(case when [IsCommission_13] = 1 then (case when [SCPId_13] is not null then [Gross_13] else 0 end) * (1 + (isnull([MarginPercent_13], 0)/100) * (1 + (isnull([IsCommission_13], 0) - 1) * isnull([CommissionOnly_13], 0))) + isnull([AddCostIsCommission_13], 0) * (1 + (isnull([MarginPercent_13], 0)/100)) + isnull([AddCostNoCommission_13], 0) * (1 + (isnull([MarginPercent_13], 0)/100) * (1 - isnull([CommissionOnly_13], 0))) else 0 end) +
		(case when [IsCommission_14] = 1 then (case when [SCPId_14] is not null then [Gross_14] else 0 end) * (1 + (isnull([MarginPercent_14], 0)/100) * (1 + (isnull([IsCommission_14], 0) - 1) * isnull([CommissionOnly_14], 0))) + isnull([AddCostIsCommission_14], 0) * (1 + (isnull([MarginPercent_14], 0)/100)) + isnull([AddCostNoCommission_14], 0) * (1 + (isnull([MarginPercent_14], 0)/100) * (1 - isnull([CommissionOnly_14], 0))) else 0 end) +
		(case when [IsCommission_15] = 1 then (case when [SCPId_15] is not null then [Gross_15] else 0 end) * (1 + (isnull([MarginPercent_15], 0)/100) * (1 + (isnull([IsCommission_15], 0) - 1) * isnull([CommissionOnly_15], 0))) + isnull([AddCostIsCommission_15], 0) * (1 + (isnull([MarginPercent_15], 0)/100)) + isnull([AddCostNoCommission_15], 0) * (1 + (isnull([MarginPercent_15], 0)/100) * (1 - isnull([CommissionOnly_15], 0))) else 0 end)
    )
    from TP_PRICECOMPONENTS with(nolock) where pc_tpkey = @priceKey
	
	insert into @result values (@flightGross, @commissionGross)
	
	RETURN
END
GO

/*********************************************************************/
/* end fn_mwGetFlightAndCommissionServicesCosts.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_InsPolicyList_InsPolicy_InsTurists.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[InsPolicyList]') AND name = N'X_IPL_IPID_IPL_KoefValue')
CREATE NONCLUSTERED INDEX [X_IPL_IPID_IPL_KoefValue]
ON [dbo].[InsPolicyList] ([IPL_IPID],[IPL_KoefValue])
WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[InsPolicy]') AND name = N'X_IP_CommisPrice_IP_AnnulDate')
CREATE NONCLUSTERED INDEX [X_IP_CommisPrice_IP_AnnulDate]
ON [dbo].[InsPolicy] ([IP_CommisPrice],[IP_AnnulDate])
WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[InsTurists]') AND name = N'X_IT_IPID')
CREATE NONCLUSTERED INDEX [X_IT_IPID]
ON [dbo].[InsTurists] ([IT_IPID])
INCLUDE ([IT_TUKey])
WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_InsPolicyList_InsPolicy_InsTurists.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_tbl_DogovorList_X_ForMainMenQueryInTrigger.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_Turist]') AND name = N'X_ForMainMenQueryInTrigger')
	DROP INDEX [X_ForMainMenQueryInTrigger] ON [dbo].[tbl_Turist] WITH ( ONLINE = OFF )
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_Turist]') AND name = N'X_ForMainMenQueryInTrigger')
begin
	CREATE NONCLUSTERED INDEX [X_ForMainMenQueryInTrigger] ON [dbo].[tbl_Turist] 
	(
		[TU_DGCOD] ASC,
		[TU_ISMAIN] ASC
	)
	INCLUDE
	(
		[TU_SEX]
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end INDEX_ADD_tbl_DogovorList_X_ForMainMenQueryInTrigger.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_tbl_DogovorList_X_ForSettlingQueryInTrigger.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_DogovorList]') AND name = N'X_ForSettlingQueryInTrigger')
	DROP INDEX [X_ForSettlingQueryInTrigger] ON [dbo].[tbl_DogovorList] WITH ( ONLINE = OFF )
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_DogovorList]') AND name = N'X_ForSettlingQueryInTrigger')
begin
	CREATE NONCLUSTERED INDEX [X_ForSettlingQueryInTrigger] ON [dbo].[tbl_DogovorList] 
	(
		[DL_DGKEY] ASC,
		[DL_SVKEY] ASC,
		[DL_CODE] ASC,
		[DL_DATEBEG] ASC,
		[DL_DATEEND] ASC
	)
	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
end
GO
/*********************************************************************/
/* end INDEX_ADD_tbl_DogovorList_X_ForSettlingQueryInTrigger.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_x_TP_PriceComponents_TourDate_TP_PriceComponents.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'X_TP_PriceComponents_TourDate')
	drop INDEX [X_TP_PriceComponents_TourDate] ON [dbo].[TP_PriceComponents] 
go
IF NOT  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_PriceComponents]') AND name = N'X_TP_PriceComponents_TourDate')
CREATE NONCLUSTERED INDEX [X_TP_PriceComponents_TourDate] ON [dbo].[TP_PriceComponents] 
(		
	PC_TourDate,
	PC_Rate,
	PC_TOKey,
	PC_Days	
)
include
(	
	[PC_Id],
	[Gross_1],[IsCommission_1],[SCPId_1],[SVKey_1],
	[Gross_2],[IsCommission_2],[SCPId_2],[SVKey_2],
	[Gross_3],[IsCommission_3],[SCPId_3],[SVKey_3],
	[Gross_4],[IsCommission_4],[SCPId_4],[SVKey_4],
	[Gross_5],[IsCommission_5],[SCPId_5],[SVKey_5],
	[Gross_6],[IsCommission_6],[SCPId_6],[SVKey_6],
	[Gross_7],[IsCommission_7],[SCPId_7],[SVKey_7],
	[Gross_8],[IsCommission_8],[SCPId_8],[SVKey_8],
	[Gross_9],[IsCommission_9],[SCPId_9],[SVKey_9],
	[Gross_10],[IsCommission_10],[SCPId_10],[SVKey_10],
	[Gross_11],[IsCommission_11],[SCPId_11],[SVKey_11],
	[Gross_12],[IsCommission_12],[SCPId_12],[SVKey_12],
	[Gross_13],[IsCommission_13],[SCPId_13],[SVKey_13],
	[Gross_14],[IsCommission_14],[SCPId_14],[SVKey_14],
	[Gross_15],[IsCommission_15],[SCPId_15],[SVKey_15]
)
 WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO



/*********************************************************************/
/* end INDEX_ADD_x_TP_PriceComponents_TourDate_TP_PriceComponents.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_TP_Prices_tptokey.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_Prices]') AND name = N'x_TP_Prices_tptokey')
CREATE NONCLUSTERED INDEX [x_TP_Prices_tptokey] ON [dbo].[TP_Prices] 
(
	[TP_TOKey] ASC
)
INCLUDE ([TP_DateBegin],
[TP_DateEnd],
[TP_Gross],
[TP_TIKey],
[TP_CalculatingKey]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_X_TP_Prices_tptokey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ADD_X_TP_ServiceLists_tltokey.sql */
/*********************************************************************/
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[TP_ServiceLists]') AND name = N'x_TP_ServiceLists_tltokey')
CREATE NONCLUSTERED INDEX [x_TP_ServiceLists_tltokey] ON [dbo].[TP_ServiceLists] 
(
	[TL_TOKey] ASC
)
INCLUDE ( [TL_TSKey],
[TL_TIKey],
[TL_CalculatingKey]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO
/*********************************************************************/
/* end INDEX_ADD_X_TP_ServiceLists_tltokey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin INDEX_ALTER_tbl_Turist.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_Turist]') AND name = N'tbl_Turist6')
	DROP INDEX [tbl_Turist6] ON [dbo].[tbl_Turist] WITH ( ONLINE = OFF )
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_Turist]') AND name = N'tbl_Turist6')
CREATE NONCLUSTERED INDEX [tbl_Turist6] ON [dbo].[tbl_Turist] 
(
	[TU_DGCOD] ASC,
	[TU_KEY] ASC,
	[TU_NAMERUS] ASC,
	[TU_SHORTNAME] ASC,
	[TU_FNAMERUS] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO

IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_Turist]') AND name = N'IX_TU_BIRTHDAY_PASPORTTYPE_PASPORTNUM')
	DROP INDEX [IX_TU_BIRTHDAY_PASPORTTYPE_PASPORTNUM] ON [dbo].[tbl_Turist] WITH ( ONLINE = OFF )
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[tbl_Turist]') AND name = N'IX_TU_BIRTHDAY_PASPORTTYPE_PASPORTNUM')
CREATE NONCLUSTERED INDEX [IX_TU_BIRTHDAY_PASPORTTYPE_PASPORTNUM] ON [dbo].[tbl_Turist] 
(
	[TU_BIRTHDAY] ASC,
	[TU_PASPORTTYPE] ASC,
	[TU_PASPORTNUM] ASC
)
INCLUDE ( [TU_DGCOD],
[TU_KEY],
[TU_NAMERUS],
[TU_SEX],
[TU_FNAMERUS]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 70) ON [PRIMARY]
GO



/*********************************************************************/
/* end INDEX_ALTER_tbl_Turist.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CalculatePriceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculatePriceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculatePriceList]
GO

CREATE PROCEDURE [dbo].[CalculatePriceList]
  (
	@nPriceTourKey int,			-- ключ обсчитываемого тура
	@nCalculatingKey int,		-- ключ итерации дозаписи
	@dtSaleDate datetime,		-- дата продажи
	@nNullCostAsZero smallint,	-- считать отсутствующие цены нулевыми (кроме проживания) 0 - нет, 1 - да
	@nNoFlight smallint,		-- при отсутствии перелёта в расписании 0 - ничего не делать, 1 - не обсчитывать тур, 2 - искать подходящий перелёт (если не найдено - не рассчитывать)
	@nUpdate smallint,			-- признак дозаписи 0 - расчет, 1 - дозапись
	@nUseHolidayRule smallint		-- Правило выходного дня: 0 - не использовать, 1 - использовать
  )
AS
--<DATE>2013-01-11</DATE>
---<VERSION>9.2.18.1</VERSION>

--проверяем настройку со страной, если совпала - запускаем новый CalculatePriceList
declare @toCnKey varchar(30), @setting varchar(260),@newpricesetting varchar 

select @toCnKey = rtrim(ltrim(str(to_cnkey))) from tp_tours where to_key = @nPriceTourKey

select @setting = rtrim(ltrim(ss_parmvalue)) from systemsettings where ss_parmname = 'MTDynamicCountries'

select @newpricesetting = SS_ParmValue from systemsettings where ss_parmname = 'NewReCalculatePrice'

if isnull(@newpricesetting,'') = '1'
begin
	if (IsNull(@setting, '') = '' OR exists (select top 1 1 from dbo.ParseKeys(@setting) where xt_key = convert(int, @toCnKey)))
	begin
		exec [dbo].[CalculatePriceListDynamic] @nPriceTourKey,@nCalculatingKey,@dtSaleDate,@nNullCostAsZero,@nNoFlight,@nUpdate,@nUseHolidayRule
		return
	end 
end

declare @variant int
declare @pricetour int
declare @turdate datetime
declare @servicedate datetime
declare @price_brutto money
declare @TrKey int
declare @userKey int
--
declare @nServiceKey int
declare @nSvkey int
declare @nCode int
declare @nSubcode1 int
declare @nSubcode2 int
declare @nPrkey int
declare @nPacketkey int
declare @nDay int
declare @nDays int
declare @sRate varchar(3)
declare @nMen int
declare @nMargin money
declare @nMarginType int
declare @nNetto money
declare @nBrutto money
declare @nDiscount money
declare @nTempGross money
declare @tsCheckMargin smallint
declare @tdCheckMargin smallint
declare @TI_DAYS int
declare @TS_CTKEY int
declare @TS_ATTRIBUTE int
--
declare @SERV_NOTCALCULATE int
--
declare @dtPrevDate datetime
declare @nPrevVariant int
declare @nPrevGross money
declare @nPrevGrossKey int
declare @nPrevGrossDate datetime
declare @nPriceFor smallint
declare @nTP_PriceKeyCurrent int
declare @nTP_PriceKeyMax int
declare @NumPrices int
--
declare @fetchStatus smallint
--declare @nCount int
declare @nDeltaProgress decimal(14, 8)
declare @nTotalProgress decimal(14, 8)
declare @round smallint
--
declare @hdKey int
declare @prevHdKey int
--
declare @nProgressSkipLimit smallint
declare @nProgressSkipCounter smallint
declare @weekday varchar(3)
declare @nDateFirst smallint
declare @nFlightEnabled smallint
declare @nCH_Key int
declare @CS_PRKEY int
declare @dDateBeg1 datetime -- дата начала 1го периода
declare @dDateBeg3 datetime -- дата начала 2,3го периода
declare @dDateEnd1 datetime -- дата окончания 1го периода
declare @dDateEnd3 datetime -- дата окончания 2,3го периода
--
declare @sDetailed varchar(100) -- не используется, необходима только для передачи в качестве параметра в GSC
declare @sBadRate varchar(3)
declare @nettoDetail nvarchar(max)
declare @dtBadDate DateTime
--
declare @nSPId int -- возвращается из GSC, фактически это ключ из ServicePrices
declare @nPDId int 
declare @nBruttoWithCommission money

--переменные для разбиения сгруппированных цен
declare @priceDate datetime
declare @priceListKey int
declare @numDates int
declare @priceListGross int
---------------------------------------------
declare @ROUND_NOTWITHDISC int
declare @ROUND_SERVICE_MATH int
declare @ROUND_SERVICE0_5 int
declare @ROUND_PRICE0_5 int
declare @ROUND_SERVICE int
declare @ROUND_PRICE int
declare @ROUND_NOT int

Set @ROUND_NOTWITHDISC = 64
Set @ROUND_SERVICE_MATH = 32
Set @ROUND_SERVICE0_5 = 16
Set @ROUND_PRICE0_5 = 8
Set @ROUND_SERVICE = 4
Set @ROUND_PRICE = 2
Set @ROUND_NOT = 1
---------------------------------------------
declare @nIsEnabled smallint
select @nIsEnabled = TO_IsEnabled from TP_Tours where TO_Key = @nPriceTourKey
---------------------------------------------
declare @tpPricesCount int
declare @isPriceListPluginRecalculation smallint
select @tpPricesCount = count(1) from tp_prices with(nolock) where tp_tokey = @nPriceTourKey

Set @nTotalProgress = 1
update tp_tours with(rowlock) set to_progress = @nTotalProgress, TO_UPDATETIME = GetDate() where to_key = @nPriceTourKey

--осуществляется пересчет прайса планировщиком
if (@tpPricesCount > 0 and @nUpdate = 0)
begin
	set @isPriceListPluginRecalculation = 1
	set @nCalculatingKey = null
	
	select top 1 @nCalculatingKey = CP_Key from CalculatingPriceLists with(nolock) where CP_PriceTourKey = @nPriceTourKey and CP_Update = 0
	update tp_turdates set td_update = 0 where td_tokey = @nPriceTourKey
	update tp_lists set ti_update = 0 where ti_tokey = @nPriceTourKey
	
	set @nUpdate = 0
end
else
	set @isPriceListPluginRecalculation = 0

--if (@nCalculatingKey is null)
--begin
--	select top 1 @nCalculatingKey = CP_Key from CalculatingPriceLists where CP_PriceTourKey = @nPriceTourKey and CP_Update = 0
--	update tp_turdates set td_update = 0 where td_tokey = @nPriceTourKey
--	update tp_lists set ti_update = 0 where ti_tokey = @nPriceTourKey
--end

declare @nSign tinyint

create table #GetServiceCost(
	tid int identity primary key,
	svkey int,
	code int,
	subcode1 int,
	subcode2 int,
	prkey int,
	pkkey int,
	date datetime,
	days int,
	rate varchar(3),
	nmen int,
	margin money,
	marginType int,
	saleDate datetime,
	netto money,
	brutto money,
	discount money,
	details varchar(100),
	badrate varchar(3),
	baddate datetime,
	details2 varchar(100),
	spid int,
	row_sign tinyint
)

create index x_getservicecost on #GetServiceCost(svkey,code,subcode1,subcode2,prkey,pkkey,date,days,rate,nmen,margin,marginType,saleDate)
include (netto,brutto,discount,details,badRate,badDate,details2,spid,row_sign)

declare @calculatingPriceListsExists smallint -- 0 - CalculatingPriceLists нет, 1 - CalculatingPriceLists есть в базе

BEGIN
	set nocount on

	--koshelev
	--MEG00027550
	if @nUpdate = 0
		update tp_tours with(rowlock) set to_datecreated = GetDate() where to_key = @nPriceTourKey

	select @TrKey = to_trkey, @userKey = to_opkey from tp_tours with(nolock) where to_key = @nPriceTourKey

	if not exists (select 1 from CalculatingPriceLists with(nolock) where CP_PriceTourKey = @nPriceTourKey) and @nPriceTourKey is not null
	begin	
		insert into CalculatingPriceLists (CP_PriceTourKey, CP_SaleDate, CP_NullCostAsZero, CP_NoFlight, CP_Update, CP_TourKey, CP_UserKey, CP_Status, CP_UseHolidayRule)
		values (@nPriceTourKey, @dtSaleDate, @nNullCostAsZero, @nNoFlight, @nUpdate, @TrKey, @userKey, 1, @nUseHolidayRule)
	end
	else if @nPriceTourKey is not null
	begin
		update CalculatingPriceLists with(rowlock) set CP_Status = 1 where CP_Key = @nCalculatingKey
	end

	DECLARE @sHI_Text varchar(254), @nHIID int
	SELECT @sHI_Text=TO_Name FROM tp_tours with(nolock) where to_key = @nPriceTourKey
	EXEC @nHIID = dbo.InsHistory '', null, 11, @nPriceTourKey, 'INS', @sHI_Text, '', 0, ''

	SET @sHI_Text=CONVERT(varchar(30),@dtSaleDate,104)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11001, null, @sHI_Text, null, null, null, @dtSaleDate, 0
	If @nNullCostAsZero=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11002, null, @sHI_Text, null, @nNullCostAsZero, null, null, 0
	If @nNoFlight=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='Flight search'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11003, null, @sHI_Text, null, @nNoFlight, null, null, 0
	If @nUpdate=0
		SET @sHI_Text='First calculate'
	ELSE
		SET @sHI_Text='Add calculate'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11004, null, @sHI_Text, null, @nUpdate, null, null, 0
	If @nUseHolidayRule = 0
		SET @sHI_Text = 'NO'
	ELSE
		SET @sHI_Text = 'YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11008, null, @sHI_Text, null, @nUpdate, null, null, 0

	--Засекаем время начала рассчета begin
	declare @beginPriceCalculate datetime
	set @beginPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@beginPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11009, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время начала рассчета end
	
	-- koshelev 15.02.2011
	-- для подбора перелетов
	if exists(select 1 from tp_lists with(nolock) where TI_TOKey = @nPriceTourKey and TI_TotalDays is null)
	begin
		exec sp_executesql N'
		select TI_Key as xTI_Key, TI_TOKey as xTI_TOKey, TI_CalculatingKey as xTI_CalculatingKey, ti_totaldays as xti_totaldays
		into #tmp
		from tp_lists with(nolock)
		where TI_TOKey = @nPriceTourKey 
		and TI_TotalDays is null
		
		update #tmp with(rowlock)
		set
			xti_totaldays = (select max(case ts_svkey 
							when 3 
							then ts_day + ts_days 
							else (case ts_days 
								when 0 
								then 1 
								else ts_days 
      								  end) + ts_day - 1 
 							   end)
					from dbo.tp_services with (nolock)
						inner join dbo.tp_servicelists with (nolock) on (tl_tskey = ts_key and TS_TOKey = @nPriceTourKey and TL_TOKey = @nPriceTourKey)
					where tl_tikey = xti_key)
		
		update TP_Lists
		set ti_totaldays = xti_totaldays
		from #tmp
		where xTI_Key = TI_Key
		', N'@nPriceTourKey int', @nPriceTourKey
	end

	select @nDateFirst = @@DATEFIRST
	set DATEFIRST 1

	exec sp_executesql N'
	
	set @SERV_NOTCALCULATE = 32768
	
	select distinct TO_Key, TD_Date + TS_Day - 1 as flight_day, TS_Code, TS_OpPartnerKey, TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, ti_totaldays, TD_Date
	into #TP_Flights
	from TP_Tours with(nolock) join TP_Services with(nolock) on TO_Key = TS_TOKey and TS_SVKey = 1
		join TP_ServiceLists with(nolock) on TL_TSKey = TS_Key and TS_TOKey = TO_Key
		join TP_Lists with(nolock) on TL_TIKey = TI_Key and TI_TOKey = TO_Key
		join TP_TurDates with(nolock) on TD_TOKey = TO_Key
	where TO_Key = @nPriceTourKey

	delete from #TP_Flights where exists (Select 1 From TP_Flights with(nolock) Where TF_TOKey=@nPriceTourKey and TF_Date=flight_day
		and TF_CodeOld=TS_Code and TF_PRKeyOld=TS_OpPartnerKey and TF_PKKey=TS_OpPacketKey
		and TF_CTKey=TS_CTKey and TF_SubCode1=TS_SubCode1 and TF_SubCode2=TS_SubCode2 and TF_Days = ti_totaldays)
		
	insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_TourDate, TF_CalculatingKey)
	select *, @nCalculatingKey  from #tp_flights
	', N'@nPriceTourKey int, @nCalculatingKey int, @SERV_NOTCALCULATE int', @nPriceTourKey, @nCalculatingKey, @SERV_NOTCALCULATE

--------------------------------------- ищем подходящий перелет, если стоит настройка подбора перелета --------------------------------------

	------ проверяем, а подходит ли текущий рейс, указанный в туре ----
	--Update	TP_Flights with(rowlock) Set 	TF_CodeNew = TF_CodeOld,
	--			TF_PRKeyNew = TF_PRKeyOld
	--Where	(SELECT count(*) FROM AirSeason  with(nolock) WHERE AS_CHKey = TF_CodeOld AND TF_Date BETWEEN AS_DateFrom AND AS_DateTo AND AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') > 0 
	--	and TF_TOKey = @nPriceTourKey	

	exec sp_executesql 
	N'
	update TP_Flights set TF_CodeNew = null, TF_PRKeyNew = null, TF_SubCode1New = null where TF_TOKey = @nPriceTourKey

	Update	TP_Flights Set 	TF_CodeNew = TF_CodeOld, TF_PRKeyNew = TF_PRKeyOld, TF_SubCode1New = TF_SubCode1, TF_CalculatingKey = @nCalculatingKey
	Where	exists (SELECT 1 FROM AirSeason WHERE AS_CHKey = TF_CodeOld AND TF_Date BETWEEN AS_DateFrom AND AS_DateTo AND AS_Week LIKE ''%''+cast(datepart(weekday, TF_Date)as varchar(1))+''%'')
			and exists (select 1 from Costs where CS_Code = TF_CodeOld and CS_SVKey = 1 and CS_SubCode1 = TF_Subcode1 and CS_PRKey = TF_PRKeyOld and CS_PKKey = TF_PKKey 
			and TF_Date BETWEEN ISNULL(CS_Date, ''1900-01-01'') AND ISNULL(CS_DateEnd, ''2053-01-01'') 
			and TF_TourDate BETWEEN ISNULL(CS_CHECKINDATEBEG, ''1900-01-01'') AND ISNULL(CS_CHECKINDATEEND, ''2053-01-01'')
			and (ISNULL(CS_Week, '''') = '''' or CS_Week LIKE ''%''+cast(datepart(weekday, TF_Date)as varchar(1))+''%'') 
			and (CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long))
			and TF_TOKey = @nPriceTourKey

	If @nNoFlight = 2
	BEGIN
		------ проверяем, а есть ли у данного парнера по рейсу, цены на другие рейсы в этом же пакете ----
		IF exists(SELECT TF_ID FROM TP_Flights with(nolock) WHERE TF_TOKey = @nPriceTourKey and TF_CodeNew is Null)
		begin
			print ''Подбираем перелет''
			
			declare @newFlightsPartnerTable table
			(
				-- идентификатор
				xId int identity(1,1),
				-- ключ услуги перелет
				xTFId int,
				-- ключ исходного партнера
				xPRKey int,
				-- ключ партнера которого подобрали
				xPRKeyNew int,
				-- ключ перелета
				xCHKey int,
				-- ключ тарифа на перелет
				xASKey int
			)
			-- подбираем подходящие нам перелеты
			insert into @newFlightsPartnerTable (xTFId, xCHKey, xASKey, xPRKey, xPRKeyNew)
			SELECT TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			FROM AirSeason with(nolock), Charter with(nolock), Costs with(nolock), TP_Flights with(nolock)
			WHERE CH_CityKeyFrom = TF_Subcode2 and
			CH_CityKeyTo = TF_CTKey and
			CS_Code = CH_Key and
			AS_CHKey = CH_Key and
			CS_SVKey = 1 and
			(	isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = CS_SubCode1), '''')
				= 
				isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = TF_Subcode1), '''')
			) and
			CS_PKKey = TF_PKKey and
			TF_Date BETWEEN AS_DateFrom and AS_DateTo and
			TF_Date BETWEEN CS_Date and CS_DateEnd and
			AS_Week LIKE ''%''+cast(datepart(weekday, TF_Date)as varchar(1))+''%'' and
			(ISNULL(CS_Week, '''') = '''' or CS_Week LIKE ''%''+cast(datepart(weekday, TF_Date)as varchar(1))+''%'') and
			(CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long) and
			TF_CodeNew is Null and 
			TF_TOKey = @nPriceTourKey
			group by TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			
			-- удаляем повторяющиеся (если подобралось несколько перелетов)
			delete @newFlightsPartnerTable
			from @newFlightsPartnerTable as a
			where a.xId != (select top 1 b.xId 
							from @newFlightsPartnerTable as b 
							where b.xTFId = a.xTFId
							-- и приорететнее те перелеты в которых партнеры совпадают с исходным
							order by case when b.xPRKey = b.xPRKeyNew then 0 else 1 end)
			
			-- обновляем информацию о найденом перелете
			update TP_Flights with(rowlock)
			set TF_CodeNew = xCHKey,
			TF_SubCode1New = xASKey,
			TF_PRKeyNew = xPRKeyNew,
			TF_CalculatingKey = @nCalculatingKey
			from TP_Flights with(rowlock) join @newFlightsPartnerTable on TF_Id = xTFId
			
			print ''Закончили подбор перелетов''
		end
	END
	', N'@nPriceTourKey int, @nCalculatingKey int, @nNoFlight smallint', @nPriceTourKey, @nCalculatingKey, @nNoFlight
	
	-----если перелет так и не найден, то в поле TF_CodeNew будет NULL

	--------------------------------------- закончили поиск подходящего перелета --------------------------------------
	--if ISNULL((select to_update from [dbo].tp_tours with(nolock) where to_key = @nPriceTourKey),0) <> 1
	
	declare @calcPricesCount int
	
	exec sp_executesql			
	N'	
	
	if (1 = 1)
	BEGIN

		update [dbo].tp_tours with(rowlock) set to_update = 1 where to_key = @nPriceTourKey
		Set @nTotalProgress = 4
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	
		--------------------------------------- сохраняем цены во временной таблице --------------------------------------
		CREATE TABLE #TP_Prices
		(
			[xTP_Key] [int] PRIMARY KEY NOT NULL ,
			[xTP_TOKey] [int] NOT NULL ,
			[xTP_DateBegin] [datetime] NOT NULL ,
			[xTP_DateEnd] [datetime] NULL ,
			[xTP_Gross] [money] NULL ,
			[xTP_TIKey] [int] NOT NULL,
			[xTP_CalculatingKey] [int] NULL
		)

		CREATE NONCLUSTERED INDEX [x_fields] ON [#TP_Prices] 
		(
			[xTP_TOKey] ASC,
			[xTP_TIKey] ASC,
			[xTP_DateBegin] ASC,
			[xTP_DateEnd] ASC
		)

		DELETE FROM #TP_Prices
		--INSERT INTO #TP_Prices (xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, xTP_Gross, xTP_TIKey) select tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey from tp_prices where tp_tokey = @nPriceTourKey
		---------------------------------------КОНЕЦ  сохраняем цены во временной таблице --------------------------------------
		

		---------------------------------------разбиваем данные в таблицах tp_prices по датам
		if (select COUNT(TP_Key) from TP_Prices with(nolock) where TP_DateBegin != TP_DateEnd and TP_TOKey = @nPriceTourKey) > 0
		begin
			select @numDates = COUNT(1) from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			exec GetNKeys ''TP_PRICES'', @numDates, @nTP_PriceKeyMax output
			set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @numDates + 1
		
			declare datesCursor cursor local fast_forward for
			select TD_Date, TI_Key, TP_Gross from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			
			open datesCursor
			fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			while @@FETCH_STATUS = 0
			begin
				insert into #TP_Prices (xTP_Key, xTP_TOKey, xTP_TIKey, xTP_Gross, xTP_DateBegin, xTP_DateEnd, xTP_CalculatingKey) 
				values (@nTP_PriceKeyCurrent, @nPriceTourKey, @priceListKey, @priceListGross, @priceDate, @priceDate, @nCalculatingKey)
				set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
				fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			end
			
			close datesCursor
			deallocate datesCursor
			
			begin tran tEnd
				delete from TP_Prices with(rowlock) where TP_TOKey = @nPriceTourKey
				
				insert into TP_Prices (TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, TP_CalculatingKey)
				select xTP_Key, xTP_TOKey, xTP_TIKey, xTP_Gross, xTP_DateBegin, xTP_DateEnd, @nCalculatingKey
				from #TP_Prices  
				where xTP_DateBegin = xTP_DateEnd
				
				delete from #TP_Prices
			commit tran tEnd
		end
		--------------------------------------------------------------------------------------
		
		select @TrKey = to_trkey, @nPriceFor = to_pricefor from tp_tours with(nolock) where to_key = @nPriceTourKey
		
		set @nTotalProgress = 5
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey

		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN
		update tp_services with(rowlock) set ts_checkmargin = 1 where
		(ts_svkey in (select tm_svkey FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)
		or
		exists(select 1 FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
			and tm_svkey = 0)
		)and ts_tokey = @nPriceTourKey

		update [dbo].tp_turdates with(rowlock) set td_checkmargin = 1 where
			exists(select 1 from TurMargin with(nolock) WHERE TM_TlKey = @TrKey
			and TD_DATE Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)and td_tokey = @nPriceTourKey
		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN

--		update TP_Services set ts_tempgross = null where ts_tokey = @nPriceTourKey

		SELECT @round = ST_RoundService FROM Setting
		--MEG00036108 увеличил значение
		set @nProgressSkipLimit = 10000

		set @nProgressSkipCounter = 0
		--Set @nTotalProgress = @nTotalProgress + 1
		--update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
		
		--считаем сколько записей надо посчитать
		set @NumPrices = ((select count(1) from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) * (select count(1) from tp_turdates with(nolock) where td_tokey = @nPriceTourKey and td_update = @nUpdate))

		if @NumPrices <> 0
			set @nDeltaProgress = (97.0 - 5) / @NumPrices
		else
			set @nDeltaProgress = 97.0 - 5

		exec GetNKeys ''TP_PRICES'', @NumPrices, @nTP_PriceKeyMax output
		set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
		set @dtPrevDate = ''1899-12-31''
		set @nPrevVariant = -1
		set @nPrevGross = -1
		set @nPrevGrossDate = ''1899-12-31''
		set @prevHdKey = -1

		delete from #TP_Prices

		declare @calcPriceListCount int, @calcTurDates int
		select @calcPriceListCount = COUNT(1) from TP_Lists with(nolock) where TI_TOKey = @nPriceTourKey and TI_UPDATE = @nUpdate
		select @calcTurDates = COUNT(1) from TP_TurDates with(nolock) where TD_TOKey = @nPriceTourKey and TD_UPDATE = @nUpdate
		select @calcPricesCount = @calcPriceListCount * @calcTurDates

		insert into #TP_Prices (xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, xTP_Gross, xTP_TIKey, xTP_CalculatingKey) 
		select tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey, TP_CalculatingKey
		from tp_prices with(nolock)
		where tp_tokey = @nPriceTourKey and 
			tp_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tp_datebegin in (select td_date from tp_turdates with(nolock) where td_tokey = @nPriceTourKey and td_update = @nUpdate)
			
		create table #CursorTable
		(	
			id int identity(1,1) primary key,
			ti_firsthdkey int, 
			ts_key int, 
			ti_key int, 
			td_date datetime, 
			ts_svkey int, 
			ts_code int, 
			ts_subcode1 int, 
			ts_subcode2 int, 
			ts_oppartnerkey int, 
			ts_oppacketkey int, 
			ts_day int, 
			ts_days int, 
			to_rate varchar(3), 
			ts_men int, 
			ts_tempgross float, 
			ts_checkmargin smallint, 
			td_checkmargin smallint, 
			ti_totaldays int, 
			ts_ctkey int, 
			ts_attribute int
		)
		
		insert into #CursorTable (ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, to_rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_totaldays, ts_ctkey, ts_attribute)
		select ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, to_rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_totaldays, ts_ctkey, ts_attribute
		from tp_tours with(nolock), tp_services with(nolock), tp_lists with(nolock), tp_servicelists with(nolock), tp_turdates with(nolock)
		where to_key = @nPriceTourKey and to_key = ts_tokey and to_key = ti_tokey and to_key = tl_tokey and ts_key = tl_tskey and ti_key = tl_tikey and to_key = td_tokey
			and ti_update = @nUpdate and td_update = @nUpdate and (@nUseHolidayRule = 0 or (case cast(datepart(weekday, td_date) as int) when 7 then 0 else cast(datepart(weekday, td_date) as int) end + ti_days) >= 8)
		order by ti_firsthdkey, td_date, ti_key
		
		update #CursorTable
		set ts_code = TF_CodeNew, ts_subcode1 = TF_SubCode1New, ts_oppartnerkey = TF_PRKeyNew
		from TP_Flights 
		where TF_TOKey = @nPriceTourKey 
			AND TF_CodeOld = ts_code 
			AND TF_PRKeyOld = ts_oppartnerkey 
			AND TF_Date = td_date + ts_day - 1 
			AND TF_Days = ti_totaldays 
			AND TF_Subcode1 = ts_subcode1
			AND ts_svkey = 1
			
		declare serviceCursor cursor local fast_forward for
		select ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, to_rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_totaldays, ts_ctkey, ts_attribute
		from #CursorTable

		open serviceCursor

		fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE
		set @fetchStatus = @@fetch_status
		While (@fetchStatus = 0)
		BEGIN
			
			--данных не нашлось, выходим
			if @@fetch_status <> 0 and @nPrevVariant = -1
				break
				
			--очищаем переменные, записываем данные в таблицу #TP_Prices
			if @nPrevVariant <> @variant or @dtPrevDate <> @turdate or @@fetch_status <> 0
			BEGIN
				--записываем данные в таблицу #TP_Prices
				if @nPrevVariant <> -1
				begin
					if @price_brutto is not null
					BEGIN
						exec RoundPriceList @round, @price_brutto output

						if exists(select 1 from #TP_Prices where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant)
						begin
							--select @nCalculatingKey
							if (@isPriceListPluginRecalculation = 0)
								update #TP_Prices set xtp_gross = @price_brutto, xtp_calculatingkey = @nCalculatingKey, xtp_key = @nTP_PriceKeyCurrent where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant
							else
								update #TP_Prices set xtp_gross = @price_brutto, xtp_key = @nTP_PriceKeyCurrent where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant
							set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
						end
						else if (@isPriceListPluginRecalculation = 0)
						begin
							--select @nCalculatingKey
							
							insert into #TP_Prices (xtp_key, xtp_tokey, xtp_datebegin, xtp_dateend, xtp_gross, xtp_tikey, xTP_CalculatingKey) 
							values (@nTP_PriceKeyCurrent, @nPriceTourKey, @dtPrevDate, @dtPrevDate, @price_brutto, @nPrevVariant, @nCalculatingKey)
							
							set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
						end
					END
					ELSE
					BEGIN
						delete from #TP_Prices where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant
					END
				end
			
				--очищаем данные
				if @@fetch_status = 0
				begin
					if @nTP_PriceKeyCurrent > @nTP_PriceKeyMax
					BEGIN
						exec GetNKeys ''TP_PRICES'', @NumPrices, @nTP_PriceKeyMax output
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
					END
					
					set @price_brutto = 0
					set @nPrevVariant = @variant
					set @dtPrevDate = @turdate
				end
				
				set @nTotalProgress = @nTotalProgress + @nDeltaProgress
				if @nProgressSkipCounter = @nProgressSkipLimit
				BEGIN
					update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_updatetime = GetDate() where to_key = @nPriceTourKey
					set @nProgressSkipCounter = 0
				END
				else
					set @nProgressSkipCounter = @nProgressSkipCounter + 1
			END

			--переписываем данные в таблицу tp_prices
			if @hdKey <> @prevHdKey or @@fetch_status <> 0
			begin
				set @prevHdKey = @hdKey
			end
			
			if @@fetch_status <> 0
				break
						
			---------------------------------------------------------------------------------

				if @tsCheckMargin = 1 and @tdCheckMargin = 1
					exec GetTourMargin @TrKey, @turdate, @nMargin output, @nMarginType output, @nSvkey, @TI_DAYS, @dtSaleDate, @nPacketkey
				else
				BEGIN
					set @nMargin = 0
					set @nMarginType = 0
				END
				set @servicedate = @turdate + @nDay - 1
				if @nSvkey = 1
					set @nDays = @TI_DAYS

				-- kurskih 2006/10/11
				-- добавил проверку признака нерассчитываемой услуги
				if @TS_ATTRIBUTE & @SERV_NOTCALCULATE = @SERV_NOTCALCULATE
				BEGIN
					set @nNetto = 0
					set @nBrutto = 0
					set @nDiscount = 0
					set @nPDID = 0
				END
				else
				BEGIN
				
					Set @nSPId = null		
					Set @nBrutto = null	
					if @nCode is not null
					begin
						set @nSign = null

						select
							@nNetto = netto,						
							@nBrutto = brutto,
							@nDiscount = discount,
							@sDetailed = details,
							@sBadRate = badRate,
							@dtBadDate = badDate,
							@sDetailed = details2,
							@nSPId = spid,
							@nSign = row_sign
						from
							#GetServiceCost
						where
							svkey = @nSvkey
							and code = @nCode
							and subcode1 = @nSubcode1
							and subcode2 = @nSubcode2
							and prkey = @nPrkey
							and pkkey = @nPacketkey
							and date = @servicedate
							and days = @nDays
							and rate = @sRate
							and nmen = @nMen
							and margin = @nMargin
							and marginType = @nMarginType
							and saleDate = @dtSaleDate

						if(@nSign is null) -- cost not found
						begin
							exec GetServiceCost @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @servicedate, @nDays,
							@sRate, @nMen, 0, @nMargin, @nMarginType,
							@dtSaleDate, @nNetto output, @nBrutto output, @nDiscount output,
							@nettoDetail output, @sBadRate output, @dtBadDate output,
							@sDetailed output, @nSPId output, 0, @TrKey, @turdate, @TI_DAYS, 1
							
							if @nMen > 1 and @nPriceFor = 0
								set @nBrutto = @nBrutto / @nMen
							if @nBrutto is not null and (@round = @ROUND_SERVICE or @round = @ROUND_SERVICE0_5 or @round = @ROUND_SERVICE_MATH)
								exec RoundPriceList @round, @nBrutto output

							insert into #GetServiceCost(
								svkey,
								code,
								subcode1,
								subcode2,
								prkey,
								pkkey,
								date,
								days,
								rate,
								nmen,
								margin,
								marginType,
								saleDate,
								netto,
								brutto,
								discount,
								details,
								badrate,
								baddate,
								details2,
								spid,
								row_sign)
							values(
								@nSvkey,
								@nCode,
								@nSubcode1,
								@nSubcode2,
								@nPrkey,
								@nPacketkey,
								@servicedate,
								@nDays,
								@sRate,
								@nMen,
								@nMargin,
								@nMarginType,
								@dtSaleDate,
								@nNetto,
								@nBrutto,
								@nDiscount,
								@sDetailed,
								@sBadRate,
								@dtBadDate,
								@sDetailed,
								@nSPId,
								1)
						end
					end
					else
						set @nBrutto = null

					if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey not in (1,3)
						set @nBrutto = 0
					if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey = 1 and @nNoFlight = 0
						set @nBrutto = 0	
		
				END

			set @price_brutto = @price_brutto + @nBrutto
			---------------------------------------------------------------------------------

			fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE
		END
		close serviceCursor
		deallocate serviceCursor

		----------------------------------------------------- возвращаем обратно цены ------------------------------------------------------

		Set @nTotalProgress = 97
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
		
		--удаление из веба
		if (@nIsEnabled = 1)
		begin
			if (@isPriceListPluginRecalculation = 0)
				EXEC ClearMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
			else	
				EXEC ClearMasterWebSearchFields @nPriceTourKey, null
		end

		delete from tp_prices with(rowlock)
		where tp_tokey = @nPriceTourKey and 
			tp_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tp_DateBegin in (select td_date from TP_TurDates with(nolock) where td_tokey = @nPriceTourKey and TD_Update = @nUpdate)
			
		INSERT INTO TP_Prices with(rowlock) (tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey, TP_CalculatingKey) 
			select xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, xTP_Gross, xTP_TIKey, xTP_CalculatingKey 
			from #TP_Prices 

		-----------------------------------------------------КОНЕЦ возвращаем обратно цены ------------------------------------------------------

		update tp_lists with(rowlock) set ti_update = 0 where ti_tokey = @nPriceTourKey
		update tp_turdates with(rowlock) set td_update = 0, td_checkmargin = 0 where td_tokey = @nPriceTourKey
		Set @nTotalProgress = 99
		update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_update = 0, to_updatetime = GetDate(),
							TO_CalculateDateEnd = GetDate(), TO_PriceCount = (Select Count(*) 
			From TP_Prices with(nolock) Where TP_ToKey = to_key) where to_key = @nPriceTourKey
		update tp_services with(rowlock) set ts_checkmargin = 0 where ts_tokey = @nPriceTourKey

	END

	update CalculatingPriceLists with(rowlock) set CP_Status = 0, CP_CreateDate = GetDate(), CP_StartTime = null where CP_PriceTourKey = @nPriceTourKey
	------------------------------------		

	--Заполнение полей в таблице tp_lists
	declare @toKey int, @add int
	set @toKey = @nPriceTourKey
	set @add = @nUpdate

		update tp_lists with(rowlock)
			set ti_hotelkeys = dbo.mwGetTiHotelKeys(ti_key),
				ti_hotelroomkeys = dbo.mwGetTiHotelRoomKeys(ti_key),
				ti_hoteldays = dbo.mwGetTiHotelNights(ti_key),
				ti_hotelstars = dbo.mwGetTiHotelStars(ti_key),
				ti_pansionkeys = dbo.mwGetTiPansionKeys(ti_key),
				ti_nights = dbo.mwGetTiNights(ti_key)
		where
			ti_tokey = @toKey and ti_CalculatingKey = @nCalculatingKey
		
		update tp_lists with(rowlock)
		set
			ti_hdpartnerkey = ts_oppartnerkey,
			ti_firsthotelpartnerkey = ts_oppartnerkey,
			ti_hdday = ts_day,
			ti_hdnights = ts_days
		from tp_servicelists with (nolock)
			inner join tp_services with (nolock) on (tl_tskey = ts_key and ts_svkey = 3)
		where tl_tikey = ti_key and ts_code = ti_firsthdkey and ti_tokey = @toKey and tl_tokey = @toKey
			and ts_tokey = @toKey and ti_CalculatingKey = @nCalculatingKey
		------------------------------------------------------------------------------

	Set @nTotalProgress = 100
	update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	
	', 
	N' @fetchStatus smallint
	, @hdKey int 
	, @isPriceListPluginRecalculation smallint
	, @nBrutto money
	, @nCode int
	, @nDiscount money
	, @nMargin money
	, @nMarginType int
	, @nMen int
	, @nNetto money
	, @nNullCostAsZero smallint
	, @nPDID int
	, @nPrevVariant int 
	, @nPriceTourKey int 
	, @nProgressSkipCounter smallint
	, @nSign tinyint
	, @nSPId int
	, @nSvkey int
	, @nTotalProgress decimal(14, 8)
	, @nTP_PriceKeyCurrent int
	, @nTP_PriceKeyMax int
	, @NumPrices int
	, @price_brutto money
	, @round smallint
	, @TI_DAYS int
	, @TrKey int
	, @TS_ATTRIBUTE int
	, @tsCheckMargin smallint
	, @turdate datetime
	, @variant int
	, @nServiceKey int
	, @nCalculatingKey int
	, @dtPrevDate datetime
	, @nDeltaProgress decimal(14, 8)
	, @nProgressSkipLimit smallint
	, @prevHdKey int
	, @tdCheckMargin smallint
	, @dtSaleDate datetime
	, @nDay int
	, @nDays int 
	, @SERV_NOTCALCULATE int
	, @sDetailed varchar(100)
	, @nSubcode1 int
	, @nPriceFor smallint
	, @ROUND_SERVICE int
	, @nNoFlight smallint
	, @nSubcode2 int
	, @nPacketkey int
	, @servicedate datetime 
	, @sBadRate varchar(3)
	, @ROUND_SERVICE0_5 int
	, @nPrkey int 
	, @dtBadDate datetime
	, @ROUND_SERVICE_MATH int
	, @sRate varchar(3)
	, @nTempGross money
	, @nettoDetail nvarchar(max)
	, @TS_CTKEY int
	, @calcPricesCount int
	, @numDates int
	, @priceDate datetime
	, @priceListKey int
	, @nUpdate smallint
	, @nPrevGross money
	, @nPrevGrossDate datetime
	, @nIsEnabled smallint
	, @priceListGross int 
	, @nUseHolidayRule smallint'
	, @fetchStatus
	, @hdKey
	, @isPriceListPluginRecalculation
	, @nBrutto
	, @nCode
	, @nDiscount
	, @nMargin
	, @nMarginType
	, @nMen
	, @nNetto
	, @nNullCostAsZero
	, @nPDID
	, @nPrevVariant
	, @nPriceTourKey
	, @nProgressSkipCounter
	, @nSign
	, @nSPId
	, @nSvkey
	, @nTotalProgress
	, @nTP_PriceKeyCurrent
	, @nTP_PriceKeyMax
	, @NumPrices
	, @price_brutto
	, @round
	, @TI_DAYS
	, @TrKey
	, @TS_ATTRIBUTE
	, @tsCheckMargin
	, @turdate
	, @variant
	, @nServiceKey
	, @nCalculatingKey
	, @dtPrevDate
	, @nDeltaProgress
	, @nProgressSkipLimit
	, @prevHdKey
	, @tdCheckMargin
	, @dtSaleDate
	, @nDay
	, @nDays
	, @SERV_NOTCALCULATE
	, @sDetailed
	, @nSubcode1
	, @nPriceFor
	, @ROUND_SERVICE
	, @nNoFlight			
	, @nSubcode2
	, @nPacketkey
	, @servicedate
	, @sBadRate
	, @ROUND_SERVICE0_5
	, @nPrkey
	, @dtBadDate
	, @ROUND_SERVICE_MATH		
	, @sRate	
	, @nTempGross
	, @nettoDetail
	, @TS_CTKEY
	, @calcPricesCount
	, @numDates
	, @priceDate
	, @priceListKey
	, @nUpdate
	, @nPrevGross
	, @nPrevGrossDate
	, @nIsEnabled	
	, @priceListGross
	, @nUseHolidayRule
	
	set DATEFIRST @nDateFirst

	set nocount off

	--Засекаем время окончания рассчета begin
	declare @endPriceCalculate datetime
	set @endPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@endPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11010, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время окончания рассчета end

	--Записываем кол-во рассчитанных цен begin
	SET @sHI_Text = CONVERT(varchar(10),@calcPricesCount)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11011, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем кол-во рассчитанных цен end

	--Записываем скорость расчета цен begin
	declare @calculatingSpeed decimal(10,2), @seconds int
	set @seconds = datediff(ss,@beginPriceCalculate,@endPriceCalculate)
	if @seconds = 0
		set @seconds = 1
	set @calculatingSpeed = @calcPricesCount / @seconds
	SET @sHI_Text = CONVERT(varchar(10),@calculatingSpeed)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11012, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем скорость расчета цен end
	
	if (@nIsEnabled = 1)
	begin
		if (@isPriceListPluginRecalculation = 0)
			EXEC FillMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
		else
			EXEC FillMasterWebSearchFields @nPriceTourKey, null
	end

	Return 0
END
GO

grant execute on [dbo].[CalculatePriceList] to public
GO
/*********************************************************************/
/* end sp_CalculatePriceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CalculatePriceListDynamic.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculatePriceListDynamic]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculatePriceListDynamic]
GO

CREATE PROCEDURE [dbo].[CalculatePriceListDynamic]
(
	--<data>2013-07-27</data>
	--<version>9.20</version>
	@nPriceTourKey int,				-- ключ обсчитываемого тура
	@nCalculatingKey int,			-- ключ итерации дозаписи
	@dtSaleDate datetime,			-- дата продажи
	@nNullCostAsZero smallint,		-- считать отсутствующие цены нулевыми (кроме проживания) 0 - нет, 1 - да
	@nNoFlight smallint,			-- при отсутствии перелёта в расписании 0 - ничего не делать, 1 - не обсчитывать тур, 2 - искать подходящий перелёт (если не найдено - не рассчитывать)
	@nUpdate smallint,				-- признак дозаписи 0 - расчет, 1 - дозапись
	@nUseHolidayRule smallint		-- Правило выходного дня: 0 - не использовать, 1 - использовать
)
AS

SET ARITHABORT off;
set nocount on;
declare @beginTime datetime
set @beginTime = getDate()

declare @variant int
declare @pricetour int
declare @turdate datetime
declare @servicedate datetime
declare @price_brutto money
declare @TrKey int
declare @userKey int
--
declare @nServiceKey int
declare @nSvkey int
declare @nCode int
declare @nSubcode1 int
declare @nSubcode2 int
declare @nPrkey int
declare @nPacketkey int
declare @nDay int
declare @nDays int
declare @sRate varchar(3)
declare @nMen int
declare @nMargin money
declare @nMarginType int
declare @nNetto money
declare @nBrutto money
declare @nDiscount money
declare @nTempGross money
declare @tsCheckMargin smallint
declare @tdCheckMargin smallint
declare @TI_DAYS int
declare @TS_CTKEY int
declare @TS_ATTRIBUTE int
--
declare @SERV_NOTCALCULATE int
--
declare @dtPrevDate datetime
declare @nPrevVariant int
declare @nPrevGross money
declare @nPrevGrossKey int
declare @nPrevGrossDate datetime
declare @nPriceFor smallint
declare @nTP_PriceKeyCurrent int
declare @nTP_PriceKeyMax int
declare @NumPrices int, @NumCalculated int
--
declare @fetchStatus smallint
--declare @nCount int
declare @nDeltaProgress decimal(14, 8)
declare @nTotalProgress decimal(14, 8)
declare @round smallint
--
declare @hdKey int
declare @prevHdKey int
--
declare @nProgressSkipLimit smallint
declare @nProgressSkipCounter smallint
declare @weekday varchar(3)
declare @nDateFirst smallint
declare @nFlightEnabled smallint
declare @nCH_Key int
declare @CS_PRKEY int
declare @dDateBeg1 datetime -- дата начала 1го периода
declare @dDateBeg3 datetime -- дата начала 2,3го периода
declare @dDateEnd1 datetime -- дата окончания 1го периода
declare @dDateEnd3 datetime -- дата окончания 2,3го периода
--
declare @sDetailed varchar(100) -- не используется, необходима только для передачи в качестве параметра в GSC
declare @sBadRate varchar(3)
declare @dtBadDate DateTime
--
declare @nSPId int -- возвращается из GSC, фактически это ключ из ServicePrices
declare @nPDId int 
declare @nBruttoWithCommission money

--переменные для разбиения сгруппированных цен
declare @priceDate datetime
declare @priceListKey int
declare @numDates int
declare @priceListGross int
---------------------------------------------
declare @ROUND_NOTWITHDISC int
declare @ROUND_SERVICE_MATH int
declare @ROUND_SERVICE0_5 int
declare @ROUND_PRICE0_5 int
declare @ROUND_SERVICE int
declare @ROUND_PRICE int
declare @ROUND_NOT int

Set @ROUND_NOTWITHDISC = 64
Set @ROUND_SERVICE_MATH = 32
Set @ROUND_SERVICE0_5 = 16
Set @ROUND_PRICE0_5 = 8
Set @ROUND_SERVICE = 4
Set @ROUND_PRICE = 2
Set @ROUND_NOT = 1
---------------------------------------------
declare @nIsEnabled smallint
--select @nIsEnabled = TO_IsEnabled from TP_Tours where TO_Key = @nPriceTourKey
--set @nIsEnabled = 0
---------------------------------------------
declare @tpPricesCount int
declare @isPriceListPluginRecalculation smallint
select @tpPricesCount = count(1) from tp_prices with(nolock) where tp_tokey = @nPriceTourKey

if exists(select top 1 1 from tp_lists with(nolock) where TI_TOKey = @nPriceTourKey and TI_TotalDays is null)
begin
	select TI_Key as xTI_Key, TI_TOKey as xTI_TOKey, TI_CalculatingKey as xTI_CalculatingKey, ti_totaldays as xti_totaldays
	into #tmp
	from tp_lists with(nolock)
	where TI_TOKey = @nPriceTourKey 
	and TI_TotalDays is null
		
	update #tmp with(rowlock)
	set
		xti_totaldays = (select max(case ts_svkey 
						when 3 
						then ts_day + ts_days 
						else (case ts_days 
							when 0 
							then 1 
							else ts_days 
      								end) + ts_day - 1 
 							end)
				from dbo.tp_services with (nolock)
					inner join dbo.tp_servicelists with (nolock) on (tl_tskey = ts_key and TS_TOKey = @nPriceTourKey and TL_TOKey = @nPriceTourKey)
				where tl_tikey = xti_key)
		
	update TP_Lists
	set ti_totaldays = xti_totaldays
	from #tmp
	where xTI_Key = TI_Key
end

if (@nCalculatingKey is null)
begin
	select top 1 @nCalculatingKey = CP_Key from CalculatingPriceLists with(nolock) where CP_PriceTourKey = @nPriceTourKey and CP_Update = 0
	update tp_turdates set td_update = 0 where td_tokey = @nPriceTourKey
	update tp_lists set ti_update = 0 where ti_tokey = @nPriceTourKey
	if (@tpPricesCount <> 0)
		set @isPriceListPluginRecalculation = 1
	else
		set @isPriceListPluginRecalculation = 0
end
else
	set @isPriceListPluginRecalculation = 0

declare @calculatingPriceListsExists smallint -- 0 - CalculatingPriceLists нет, 1 - CalculatingPriceLists есть в базе

print 'Инициализация: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
set @beginTime = getDate()

BEGIN		
	--koshelev
	--MEG00027550
	if @nUpdate = 0
	begin
		update tp_tours with(rowlock) set to_datecreated = GetDate() where to_key = @nPriceTourKey
	end

	select @TrKey = to_trkey, @userKey = to_opkey from tp_tours with(nolock) where to_key = @nPriceTourKey

	if not exists (select 1 from CalculatingPriceLists with(nolock) where CP_PriceTourKey = @nPriceTourKey) and @nPriceTourKey is not null
	begin	
		insert into CalculatingPriceLists (CP_PriceTourKey, CP_SaleDate, CP_NullCostAsZero, CP_NoFlight, CP_Update, CP_TourKey, CP_UserKey, CP_Status, CP_UseHolidayRule)
		values (@nPriceTourKey, @dtSaleDate, @nNullCostAsZero, @nNoFlight, @nUpdate, @TrKey, @userKey, 1, @nUseHolidayRule)
	end
	else if @nPriceTourKey is not null
	begin
		update CalculatingPriceLists with(rowlock) set CP_Status = 1 where CP_Key = @nCalculatingKey
	end

	DECLARE @sHI_Text varchar(254), @nHIID int
	SELECT @sHI_Text=TO_Name FROM tp_tours with(nolock) where to_key = @nPriceTourKey
	EXEC @nHIID = dbo.InsHistory '', null, 11, @nPriceTourKey, 'INS', @sHI_Text, '', 0, ''

	SET @sHI_Text=CONVERT(varchar(30),@dtSaleDate,104)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11001, null, @sHI_Text, null, null, null, @dtSaleDate, 0
	If @nNullCostAsZero=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11002, null, @sHI_Text, null, @nNullCostAsZero, null, null, 0
	If @nNoFlight=0
		SET @sHI_Text='NO'
	ELSE
		SET @sHI_Text='Flight search'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11003, null, @sHI_Text, null, @nNoFlight, null, null, 0
	If @nUpdate=0
		SET @sHI_Text='First calculate'
	ELSE
		SET @sHI_Text='Add calculate'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11004, null, @sHI_Text, null, @nUpdate, null, null, 0
	If @nUseHolidayRule = 0
		SET @sHI_Text = 'NO'
	ELSE
		SET @sHI_Text = 'YES'
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11008, null, @sHI_Text, null, @nUpdate, null, null, 0
	
	--Засекаем время начала рассчета begin
	declare @beginPriceCalculate datetime
	set @beginPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@beginPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11009, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время начала рассчета end
	
	print 'Запись в историю: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	Set @nTotalProgress=1
	update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	select @nDateFirst = @@DATEFIRST
	set DATEFIRST 1
	set @SERV_NOTCALCULATE = 32768

	If @nUpdate=0
		insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_TourDate, TF_CalculatingKey)
		select distinct TO_Key, TD_Date + TS_Day - 1, TS_Code, TS_OpPartnerKey,
			TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, TI_Days, TD_Date, @nCalculatingKey
			From TP_Services with(nolock), TP_TurDates with(nolock), TP_Tours with(nolock), TP_Lists with(nolock), TP_ServiceLists with(nolock)
			where TS_TOKey = TO_Key and TS_SVKey = 1 and TD_TOKey = TO_Key and TI_TOKey = TO_Key and TL_TOKey = TO_Key and TL_TSKey = TS_Key and TL_TIKey = TI_Key and TO_Key = @nPriceTourKey
	Else
	BEGIN
		insert into dbo.TP_Flights (TF_TOKey, TF_Date, TF_CodeOld, TF_PRKeyOld, TF_PKKey, TF_CTKey, TF_SubCode1, TF_SubCode2, TF_Days, TF_TourDate, TF_CalculatingKey)
		select distinct TO_Key, TD_Date + TS_Day - 1, TS_Code, TS_OpPartnerKey,
			TS_OpPacketKey, TS_CTKey, TS_SubCode1, TS_SubCode2, TI_Days, TD_Date, @nCalculatingKey
			From TP_Services with(nolock), TP_TurDates with(nolock), TP_Tours with(nolock), TP_Lists with(nolock), TP_ServiceLists with(nolock)
			where TS_TOKey = TO_Key and TS_SVKey = 1 and TD_TOKey = TO_Key and TI_TOKey = TO_Key and TL_TOKey = TO_Key and TL_TSKey = TS_Key and TL_TIKey = TI_Key and TO_Key = @nPriceTourKey
			and not exists (Select TF_ID From TP_Flights with(nolock) Where TF_TOKey=TO_Key and TF_Date=(TD_Date + TS_Day - 1) 
						and TF_CodeOld=TS_Code and TF_PRKeyOld=TS_OpPartnerKey and TF_PKKey=TS_OpPacketKey
						and TF_CTKey=TS_CTKey and TF_SubCode1=TS_SubCode1 and TF_SubCode2=TS_SubCode2 and TF_Days = TI_Days and TF_CodeNew is not null)	
	END
	
	print 'Подбор перелетов 1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
--------------------------------------- ищем подходящий перелет, если стоит настройка подбора перелета --------------------------------------

	------ проверяем, а подходит ли текущий рейс, указанный в туре ----
	Update	TP_Flights Set 	TF_CodeNew = TF_CodeOld, TF_PRKeyNew = TF_PRKeyOld, TF_SubCode1New = TF_SubCode1
	Where	exists (SELECT 1 FROM AirSeason WHERE AS_CHKey = TF_CodeOld AND TF_Date BETWEEN AS_DateFrom AND AS_DateTo AND AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%')
			and exists (select 1 from Costs where CS_Code = TF_CodeOld and CS_SVKey = 1 and CS_SubCode1 = TF_Subcode1 and CS_PRKey = TF_PRKeyOld and CS_PKKey = TF_PKKey and TF_Date BETWEEN CS_Date AND  CS_DateEnd and (ISNULL(CS_Week, '') = '' or CS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') and (CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long))
			and TF_TOKey = @nPriceTourKey
	
	print 'Подбор перелетов 2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	If @nNoFlight = 2
	BEGIN
		------ проверяем, а есть ли у данного парнера по рейсу, цены на другие рейсы в этом же пакете ----		
		
		IF exists(SELECT TF_ID FROM TP_Flights with(nolock) WHERE TF_TOKey = @nPriceTourKey and TF_CodeNew is Null) 
		begin
			print 'Подбираем перелет'
			
			declare @newFlightsPartnerTable table
			(
				-- идентификатор
				xId int identity(1,1),
				-- ключ услуги перелет
				xTFId int,
				-- ключ исходного партнера
				xPRKey int,
				-- ключ партнера которого подобрали
				xPRKeyNew int,
				-- ключ перелета
				xCHKey int,
				-- ключ тарифа на перелет
				xASKey int
			)
			-- подбираем подходящие нам перелеты
			insert into @newFlightsPartnerTable (xTFId, xCHKey, xASKey, xPRKey, xPRKeyNew)
			SELECT TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			FROM AirSeason with(nolock), Charter with(nolock), Costs with(nolock), TP_Flights with(nolock)
			WHERE CH_CityKeyFrom = TF_Subcode2 and
			CH_CityKeyTo = TF_CTKey and
			CS_Code = CH_Key and
			AS_CHKey = CH_Key and
			CS_SVKey = 1 and
			(	isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = CS_SubCode1), '')
				= 
				isnull((select top 1 AS_GROUP from AirService with(nolock) where AS_KEY = TF_Subcode1), '')
			) and
			CS_PKKey = TF_PKKey and
			TF_Date BETWEEN AS_DateFrom and AS_DateTo and
			TF_Date BETWEEN CS_Date and CS_DateEnd and
			AS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%' and
			(ISNULL(CS_Week, '') = '' or CS_Week LIKE '%'+cast(datepart(weekday, TF_Date)as varchar(1))+'%') and
			(CS_Long is null or CS_LongMin is null or TF_Days between CS_LongMin and CS_Long) and
			TF_CodeNew is Null and 
			TF_TOKey = @nPriceTourKey
			group by TF_Id, CH_Key, CS_SubCode1, TF_PRKeyOld, CS_PRKey
			
			-- удаляем повторяющиеся (если подобралось несколько перелетов)
			delete @newFlightsPartnerTable
			from @newFlightsPartnerTable as a
			where a.xId != (select top 1 b.xId 
							from @newFlightsPartnerTable as b 
							where b.xTFId = a.xTFId
							-- и приорететнее те перелеты в которых партнеры совпадают с исходным
							order by case when b.xPRKey = b.xPRKeyNew then 0 else 1 end)
			
			-- обновляем информацию о найденом перелете
			update TP_Flights with(rowlock)
			set TF_CodeNew = xCHKey,
			TF_SubCode1New = xASKey,
			TF_PRKeyNew = xPRKeyNew,
			TF_CalculatingKey = @nCalculatingKey
			from TP_Flights with(rowlock) join @newFlightsPartnerTable on TF_Id = xTFId
			
			print 'Закончили подбор перелетов'		
		end
		
		print 'Подбор перелетов 3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()	
	END

	--------------------------------------- закончили поиск подходящего перелета --------------------------------------
	if (1 = 1)
	BEGIN
		update [dbo].tp_tours with(rowlock) set to_update = 1 where to_key = @nPriceTourKey
		Set @nTotalProgress=4
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	
		--------------------------------------- сохраняем цены во временной таблице --------------------------------------
		CREATE TABLE #TP_Prices
		(
			[xTP_Key] [int] PRIMARY KEY NOT NULL ,
			[xTP_TOKey] [int] NOT NULL ,
			[xTP_DateBegin] [datetime] NOT NULL ,
			[xTP_DateEnd] [datetime] NULL ,
			-- формула расчета общей цены тура
			[xTP_Gross] as (((case when  [xSCPId_1] is not null then  [xGross_1] else 0 end) * (1 + (isnull( [xMarginPercent_1], 0)/100) * (1 + (isnull( [xIsCommission_1], 0) - 1) * isnull( [xCommissionOnly_1], 0))) + isnull( [xAddCostIsCommission_1], 0) * (1 + (isnull( [xMarginPercent_1], 0)/100)) + isnull( [xAddCostNoCommission_1], 0) * (1 + (isnull( [xMarginPercent_1], 0)/100) * (1 - isnull( [xCommissionOnly_1], 0)))) +
							((case when  [xSCPId_2] is not null then  [xGross_2] else 0 end) * (1 + (isnull( [xMarginPercent_2], 0)/100) * (1 + (isnull( [xIsCommission_2], 0) - 1) * isnull( [xCommissionOnly_2], 0))) + isnull( [xAddCostIsCommission_2], 0) * (1 + (isnull( [xMarginPercent_2], 0)/100)) + isnull( [xAddCostNoCommission_2], 0) * (1 + (isnull( [xMarginPercent_2], 0)/100) * (1 - isnull( [xCommissionOnly_2], 0)))) +
							((case when  [xSCPId_3] is not null then  [xGross_3] else 0 end) * (1 + (isnull( [xMarginPercent_3], 0)/100) * (1 + (isnull( [xIsCommission_3], 0) - 1) * isnull( [xCommissionOnly_3], 0))) + isnull( [xAddCostIsCommission_3], 0) * (1 + (isnull( [xMarginPercent_3], 0)/100)) + isnull( [xAddCostNoCommission_3], 0) * (1 + (isnull( [xMarginPercent_3], 0)/100) * (1 - isnull( [xCommissionOnly_3], 0)))) +
							((case when  [xSCPId_4] is not null then  [xGross_4] else 0 end) * (1 + (isnull( [xMarginPercent_4], 0)/100) * (1 + (isnull( [xIsCommission_4], 0) - 1) * isnull( [xCommissionOnly_4], 0))) + isnull( [xAddCostIsCommission_4], 0) * (1 + (isnull( [xMarginPercent_4], 0)/100)) + isnull( [xAddCostNoCommission_4], 0) * (1 + (isnull( [xMarginPercent_4], 0)/100) * (1 - isnull( [xCommissionOnly_4], 0)))) +
							((case when  [xSCPId_5] is not null then  [xGross_5] else 0 end) * (1 + (isnull( [xMarginPercent_5], 0)/100) * (1 + (isnull( [xIsCommission_5], 0) - 1) * isnull( [xCommissionOnly_5], 0))) + isnull( [xAddCostIsCommission_5], 0) * (1 + (isnull( [xMarginPercent_5], 0)/100)) + isnull( [xAddCostNoCommission_5], 0) * (1 + (isnull( [xMarginPercent_5], 0)/100) * (1 - isnull( [xCommissionOnly_5], 0)))) +
							((case when  [xSCPId_6] is not null then  [xGross_6] else 0 end) * (1 + (isnull( [xMarginPercent_6], 0)/100) * (1 + (isnull( [xIsCommission_6], 0) - 1) * isnull( [xCommissionOnly_6], 0))) + isnull( [xAddCostIsCommission_6], 0) * (1 + (isnull( [xMarginPercent_6], 0)/100)) + isnull( [xAddCostNoCommission_6], 0) * (1 + (isnull( [xMarginPercent_6], 0)/100) * (1 - isnull( [xCommissionOnly_6], 0)))) +
							((case when  [xSCPId_7] is not null then  [xGross_7] else 0 end) * (1 + (isnull( [xMarginPercent_7], 0)/100) * (1 + (isnull( [xIsCommission_7], 0) - 1) * isnull( [xCommissionOnly_7], 0))) + isnull( [xAddCostIsCommission_7], 0) * (1 + (isnull( [xMarginPercent_7], 0)/100)) + isnull( [xAddCostNoCommission_7], 0) * (1 + (isnull( [xMarginPercent_7], 0)/100) * (1 - isnull( [xCommissionOnly_7], 0)))) +
							((case when  [xSCPId_8] is not null then  [xGross_8] else 0 end) * (1 + (isnull( [xMarginPercent_8], 0)/100) * (1 + (isnull( [xIsCommission_8], 0) - 1) * isnull( [xCommissionOnly_8], 0))) + isnull( [xAddCostIsCommission_8], 0) * (1 + (isnull( [xMarginPercent_8], 0)/100)) + isnull( [xAddCostNoCommission_8], 0) * (1 + (isnull( [xMarginPercent_8], 0)/100) * (1 - isnull( [xCommissionOnly_8], 0)))) +
							((case when  [xSCPId_9] is not null then  [xGross_9] else 0 end) * (1 + (isnull( [xMarginPercent_9], 0)/100) * (1 + (isnull( [xIsCommission_9], 0) - 1) * isnull( [xCommissionOnly_9], 0))) + isnull( [xAddCostIsCommission_9], 0) * (1 + (isnull( [xMarginPercent_9], 0)/100)) + isnull( [xAddCostNoCommission_9], 0) * (1 + (isnull( [xMarginPercent_9], 0)/100) * (1 - isnull( [xCommissionOnly_9], 0)))) +
							((case when [xSCPId_10] is not null then [xGross_10] else 0 end) * (1 + (isnull([xMarginPercent_10], 0)/100) * (1 + (isnull([xIsCommission_10], 0) - 1) * isnull([xCommissionOnly_10], 0))) + isnull([xAddCostIsCommission_10], 0) * (1 + (isnull([xMarginPercent_10], 0)/100)) + isnull([xAddCostNoCommission_10], 0) * (1 + (isnull([xMarginPercent_10], 0)/100) * (1 - isnull([xCommissionOnly_10], 0)))) +
							((case when [xSCPId_11] is not null then [xGross_11] else 0 end) * (1 + (isnull([xMarginPercent_11], 0)/100) * (1 + (isnull([xIsCommission_11], 0) - 1) * isnull([xCommissionOnly_11], 0))) + isnull([xAddCostIsCommission_11], 0) * (1 + (isnull([xMarginPercent_11], 0)/100)) + isnull([xAddCostNoCommission_11], 0) * (1 + (isnull([xMarginPercent_11], 0)/100) * (1 - isnull([xCommissionOnly_11], 0)))) +
							((case when [xSCPId_12] is not null then [xGross_12] else 0 end) * (1 + (isnull([xMarginPercent_12], 0)/100) * (1 + (isnull([xIsCommission_12], 0) - 1) * isnull([xCommissionOnly_12], 0))) + isnull([xAddCostIsCommission_12], 0) * (1 + (isnull([xMarginPercent_12], 0)/100)) + isnull([xAddCostNoCommission_12], 0) * (1 + (isnull([xMarginPercent_12], 0)/100) * (1 - isnull([xCommissionOnly_12], 0)))) +
							((case when [xSCPId_13] is not null then [xGross_13] else 0 end) * (1 + (isnull([xMarginPercent_13], 0)/100) * (1 + (isnull([xIsCommission_13], 0) - 1) * isnull([xCommissionOnly_13], 0))) + isnull([xAddCostIsCommission_13], 0) * (1 + (isnull([xMarginPercent_13], 0)/100)) + isnull([xAddCostNoCommission_13], 0) * (1 + (isnull([xMarginPercent_13], 0)/100) * (1 - isnull([xCommissionOnly_13], 0)))) +
							((case when [xSCPId_14] is not null then [xGross_14] else 0 end) * (1 + (isnull([xMarginPercent_14], 0)/100) * (1 + (isnull([xIsCommission_14], 0) - 1) * isnull([xCommissionOnly_14], 0))) + isnull([xAddCostIsCommission_14], 0) * (1 + (isnull([xMarginPercent_14], 0)/100)) + isnull([xAddCostNoCommission_14], 0) * (1 + (isnull([xMarginPercent_14], 0)/100) * (1 - isnull([xCommissionOnly_14], 0)))) +
							((case when [xSCPId_15] is not null then [xGross_15] else 0 end) * (1 + (isnull([xMarginPercent_15], 0)/100) * (1 + (isnull([xIsCommission_15], 0) - 1) * isnull([xCommissionOnly_15], 0))) + isnull([xAddCostIsCommission_15], 0) * (1 + (isnull([xMarginPercent_15], 0)/100)) + isnull([xAddCostNoCommission_15], 0) * (1 + (isnull([xMarginPercent_15], 0)/100) * (1 - isnull([xCommissionOnly_15], 0))))),
			[xTP_TIKey] [int] NOT NULL,
			[xTP_HotelKey] [int] NOT NULL,
			[xTP_DepartureKey] [int] NOT NULL,
			[xTP_CalculatingKey] [int] NULL,
			[xTP_Days] [int] null,
			[xTP_Rate] [nvarchar](2) null,
			[xSCPId_1] [int] null,
			[xSCPId_2] [int] null,
			[xSCPId_3] [int] null,
			[xSCPId_4] [int] null,
			[xSCPId_5] [int] null,
			[xSCPId_6] [int] null,
			[xSCPId_7] [int] null,
			[xSCPId_8] [int] null,
			[xSCPId_9] [int] null,
			[xSCPId_10] [int] null,
			[xSCPId_11] [int] null,
			[xSCPId_12] [int] null,
			[xSCPId_13] [int] null,
			[xSCPId_14] [int] null,
			[xSCPId_15] [int] null,
			
			[xSvKey_1] [int] null,
			[xSvKey_2] [int] null,
			[xSvKey_3] [int] null,
			[xSvKey_4] [int] null,
			[xSvKey_5] [int] null,
			[xSvKey_6] [int] null,
			[xSvKey_7] [int] null,
			[xSvKey_8] [int] null,
			[xSvKey_9] [int] null,
			[xSvKey_10] [int] null,
			[xSvKey_11] [int] null,
			[xSvKey_12] [int] null,
			[xSvKey_13] [int] null,
			[xSvKey_14] [int] null,
			[xSvKey_15] [int] null,
			
			[xGross_1] [money] null,
			[xGross_2] [money] null,
			[xGross_3] [money] null,
			[xGross_4] [money] null,
			[xGross_5] [money] null,
			[xGross_6] [money] null,
			[xGross_7] [money] null,
			[xGross_8] [money] null,
			[xGross_9] [money] null,
			[xGross_10] [money] null,
			[xGross_11] [money] null,
			[xGross_12] [money] null,
			[xGross_13] [money] null,
			[xGross_14] [money] null,
			[xGross_15] [money] null,
			
			[xAddCostIsCommission_1] [money] null,
			[xAddCostIsCommission_2] [money] null,
			[xAddCostIsCommission_3] [money] null,
			[xAddCostIsCommission_4] [money] null,
			[xAddCostIsCommission_5] [money] null,
			[xAddCostIsCommission_6] [money] null,
			[xAddCostIsCommission_7] [money] null,
			[xAddCostIsCommission_8] [money] null,
			[xAddCostIsCommission_9] [money] null,
			[xAddCostIsCommission_10] [money] null,
			[xAddCostIsCommission_11] [money] null,
			[xAddCostIsCommission_12] [money] null,
			[xAddCostIsCommission_13] [money] null,
			[xAddCostIsCommission_14] [money] null,
			[xAddCostIsCommission_15] [money] null,
			
			[xAddCostNoCommission_1] [money] null,
			[xAddCostNoCommission_2] [money] null,
			[xAddCostNoCommission_3] [money] null,
			[xAddCostNoCommission_4] [money] null,
			[xAddCostNoCommission_5] [money] null,
			[xAddCostNoCommission_6] [money] null,
			[xAddCostNoCommission_7] [money] null,
			[xAddCostNoCommission_8] [money] null,
			[xAddCostNoCommission_9] [money] null,
			[xAddCostNoCommission_10] [money] null,
			[xAddCostNoCommission_11] [money] null,
			[xAddCostNoCommission_12] [money] null,
			[xAddCostNoCommission_13] [money] null,
			[xAddCostNoCommission_14] [money] null,
			[xAddCostNoCommission_15] [money] null,
			
			[xMarginPercent_1] [money] null,
			[xMarginPercent_2] [money] null,
			[xMarginPercent_3] [money] null,
			[xMarginPercent_4] [money] null,
			[xMarginPercent_5] [money] null,
			[xMarginPercent_6] [money] null,
			[xMarginPercent_7] [money] null,
			[xMarginPercent_8] [money] null,
			[xMarginPercent_9] [money] null,
			[xMarginPercent_10] [money] null,
			[xMarginPercent_11] [money] null,
			[xMarginPercent_12] [money] null,
			[xMarginPercent_13] [money] null,
			[xMarginPercent_14] [money] null,
			[xMarginPercent_15] [money] null,
			
			[xCommissionOnly_1] [bit] null,
			[xCommissionOnly_2] [bit] null,
			[xCommissionOnly_3] [bit] null,
			[xCommissionOnly_4] [bit] null,
			[xCommissionOnly_5] [bit] null,
			[xCommissionOnly_6] [bit] null,
			[xCommissionOnly_7] [bit] null,
			[xCommissionOnly_8] [bit] null,
			[xCommissionOnly_9] [bit] null,
			[xCommissionOnly_10] [bit] null,
			[xCommissionOnly_11] [bit] null,
			[xCommissionOnly_12] [bit] null,
			[xCommissionOnly_13] [bit] null,
			[xCommissionOnly_14] [bit] null,
			[xCommissionOnly_15] [bit] null,
			
			[xIsCommission_1] [bit] null,
			[xIsCommission_2] [bit] null,
			[xIsCommission_3] [bit] null,
			[xIsCommission_4] [bit] null,
			[xIsCommission_5] [bit] null,
			[xIsCommission_6] [bit] null,
			[xIsCommission_7] [bit] null,
			[xIsCommission_8] [bit] null,
			[xIsCommission_9] [bit] null,
			[xIsCommission_10] [bit] null,
			[xIsCommission_11] [bit] null,
			[xIsCommission_12] [bit] null,
			[xIsCommission_13] [bit] null,
			[xIsCommission_14] [bit] null,
			[xIsCommission_15] [bit] null
		)

		CREATE NONCLUSTERED INDEX [x_fields] ON [#TP_Prices] 
		(
			[xTP_TOKey] ASC,
			[xTP_TIKey] ASC,
			[xTP_DateBegin] ASC,
			[xTP_DateEnd] ASC
		)

		DELETE FROM #TP_Prices
		---------------------------------------КОНЕЦ  сохраняем цены во временной таблице --------------------------------------
		

		---------------------------------------разбиваем данные в таблицах tp_prices по датам
		if (select COUNT(TP_Key) from TP_Prices with(nolock) where TP_DateBegin != TP_DateEnd and TP_TOKey = @nPriceTourKey) > 0
		begin
			
			select @numDates = COUNT(1) from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			exec GetNKeys 'TP_PRICES', @numDates, @nTP_PriceKeyMax output
			set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @numDates + 1
		
			declare datesCursor cursor local fast_forward for
			select TD_Date, TI_Key, TP_Gross from TP_TurDates with(nolock), TP_Lists with(nolock), TP_Prices with(nolock) where TP_TIKey = TI_Key and TD_Date between TP_DateBegin and TP_DateEnd and TP_TOKey = @nPriceTourKey and TD_TOKey = @nPriceTourKey and TI_TOKey = @nPriceTourKey
			
			open datesCursor
			fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			while @@FETCH_STATUS = 0
			begin
				insert into #TP_Prices (xTP_Key, xTP_TOKey, xTP_TIKey, xTP_DateBegin, xTP_DateEnd, xTP_CalculatingKey) 
				values (@nTP_PriceKeyCurrent, @nPriceTourKey, @priceListKey, @priceDate, @priceDate, @nCalculatingKey)
				set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
				fetch next from datesCursor into @priceDate, @priceListKey, @priceListGross
			end
			
			close datesCursor
			deallocate datesCursor
			
			begin tran tEnd
				delete from TP_Prices with(rowlock) where TP_TOKey = @nPriceTourKey
				
				insert into TP_Prices (TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, TP_CalculatingKey)
				select xTP_Key, xTP_TOKey, xTP_TIKey, xTP_Gross, xTP_DateBegin, xTP_DateEnd, @nCalculatingKey
				from #TP_Prices  
				where xTP_DateBegin = xTP_DateEnd
				
				delete from #TP_Prices
			commit tran tEnd
		end
		--------------------------------------------------------------------------------------
		
		select @TrKey = to_trkey, @nPriceFor = to_pricefor from tp_tours with(nolock) where to_key = @nPriceTourKey
		set @nTotalProgress = 5
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey

		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN
		update tp_services with(rowlock) set ts_checkmargin = 1 where
		(ts_svkey in (select tm_svkey FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)
		or
		exists(select 1 FROM TurMargin with(nolock), tp_turdates with(nolock)
		WHERE	TM_TlKey = @TrKey and td_tokey = @nPriceTourKey
			and td_date Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
			and tm_svkey = 0)
		)and ts_tokey = @nPriceTourKey

		update [dbo].tp_turdates with(rowlock) set td_checkmargin = 1 where
			exists(select 1 from TurMargin with(nolock) WHERE TM_TlKey = @TrKey
			and TD_DATE Between TM_DateBeg and TM_DateEnd
			and (@dtSaleDate >= TM_DateSellBeg  or TM_DateSellBeg is null)
			and (@dtSaleDate <= TM_DateSellEnd or TM_DateSellEnd is null)
		)and td_tokey = @nPriceTourKey
		----------------------------------------------------------- Здесь апдейтим TS_CHECKMARGIN и TD_CHECKMARGIN
		
		print 'Инициализация расчета цен: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
		
		declare @tempTO_Rate nvarchar(3), @tempTO_TRKey int
		
		select @tempTO_Rate = TO_Rate, @tempTO_TRKey = TO_TRKey from tp_tours with(nolock) where TO_Key = @nPriceTourKey
		
		create table #CursorTable
		( 
			id int identity(1,1) primary key,
			ti_firsthdkey int, 
			ts_key int, 
			ti_key int, 
			td_date datetime, 
			ts_svkey int, 
			ts_code int, 
			ts_subcode1 int, 
			ts_subcode2 int, 
			ts_oppartnerkey int, 
			ts_oppacketkey int, 
			ts_day int, 
			ts_days int,
			tempTO_Rate varchar(3), 
			to_rate varchar(3), 
			ts_men int, 
			ts_tempgross float, 
			ts_checkmargin smallint, 
			td_checkmargin smallint, 
			ti_days int, 
			ts_ctkey int, 
			ts_attribute int,
			tiCtKeyFrom int,
			sv_IsDuration smallint,
			ti_totaldays int
		)
		
	  insert into #CursorTable (ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, tempTO_Rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_days, ts_ctkey, ts_attribute, tiCtKeyFrom, sv_IsDuration, ti_totaldays)
	  select ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, @tempTO_Rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_days, ts_ctkey, ts_attribute, (select TL_CTDepartureKey from tbl_TurList with(nolock) where @tempTO_TRKey = TL_KEY), SV_IsDuration, ti_totaldays
	  from tp_services with(nolock), tp_lists with(nolock), tp_servicelists with(nolock), tp_turdates with(nolock), [Service] with(nolock)
			where @nPriceTourKey = ts_tokey and @nPriceTourKey = ti_tokey and @nPriceTourKey = tl_tokey and ts_key = tl_tskey and ti_key = tl_tikey and @nPriceTourKey = td_tokey
				and ti_update = @nUpdate and td_update = @nUpdate and (@nUseHolidayRule = 0 or (case cast(datepart(weekday, td_date) as int) when 7 then 0 else cast(datepart(weekday, td_date) as int) end + ti_days) >= 8)
				and ts_svkey = SV_KEY
			order by ti_firsthdkey, td_date, ti_key, case when ti_firsthdkey = ts_code and TS_SVKey = 3 then 0 else 1 end
			
		update #CursorTable
		set ts_code = TF_CodeNew, ts_subcode1 = TF_SubCode1New, ts_oppartnerkey = TF_PRKeyNew
		from TP_Flights 
		where TF_TOKey = @nPriceTourKey
			and TF_CodeOld = ts_code 
			and TF_CalculatingKey = @nCalculatingKey
			and TF_PRKeyOld = ts_oppartnerkey 
			and TF_Date = td_date + ts_day - 1
			and TF_Days = ti_days
			and TF_Subcode1 = ts_subcode1
			and TF_SubCode2 = ts_subcode2
			and ts_svkey = 1
			
		-- формирование темповых таблиц на основе данных по туру
		create table #ServiceComponents
		(
			xSC_ID int identity(-10,-1) primary key,
			xSC_ID_InDB int,
			xSC_SVKEY int,
			xSC_CODE int,
			xSC_SUBCODE1 int,
			xSC_SUBCODE2 int,
			xSC_PRKEY int
		)
		SET IDENTITY_INSERT #ServiceComponents ON;
		
		insert into #ServiceComponents (xsc_id, xsc_svkey, xsc_code, xsc_subcode1, xsc_subcode2, xsc_prkey)
		select sc_id, sc_svkey, sc_code, sc_subcode1, sc_subcode2, sc_prkey 
		from TP_ServiceComponents with(nolock)
		where exists(select top 1 1 
					 from #CursorTable
					 where SC_SVKey = ts_svkey 
					 and SC_Code = ts_code 
					 and SC_SubCode1 = ts_subcode1 
					 and SC_SubCode2 = ts_subcode2 
					 and SC_PRKey = ts_oppartnerkey)
						 
		SET IDENTITY_INSERT #ServiceComponents OFF;

		CREATE INDEX IX_addServiceComponents ON #ServiceComponents
		(
			xSC_SVKEY, 
			xSC_CODE, 
			xSC_SUBCODE1, 
			xSC_SUBCODE2, 
			xSC_PRKEY
		)
		INCLUDE (xSC_ID);
			
		create table #ServiceCalculateParametrs
		(
			xSCP_Id int identity(-10,-1) primary key,
			xSCP_Id_InDB int,
			xSCP_SCId int,
			xscp_SVKEY int,
			xSCP_Date datetime,
			xSCP_DateCheckIn datetime,
			xSCP_Men int,
			xSCP_Days int,
			xSCP_PKKey int,
			xSCP_TourDays int,
			xSCP_DeleteDate datetime
		)
		SET IDENTITY_INSERT #ServiceCalculateParametrs ON;
		
		insert into #ServiceCalculateParametrs (xscp_id, xscp_scid, xscp_svkey, xscp_date, xscp_datecheckin, xscp_men, xscp_days, xscp_pkkey, xscp_tourdays)
		select SCP_Id, SCP_SCId, SCP_SvKey, SCP_Date, SCP_DateCheckIn, SCP_Men, SCP_Days, SCP_PKKey, SCP_TourDays 
		from TP_ServiceCalculateParametrs with(nolock)
		where exists(select 1
					 from #CursorTable
					 where SCP_SvKey = ts_svkey
					 and SCP_Date = dateAdd(dd, ts_day-1, td_date)
					 and SCP_DateCheckIn = td_date
					 and SCP_Men = ts_men
					 and SCP_Days = ts_days
					 and SCP_PKKey = ts_oppacketkey
					 and SCP_TourDays = ti_totaldays)
		and SCP_SCId in (select xsc_id from #ServiceComponents)
		
		SET IDENTITY_INSERT #ServiceCalculateParametrs OFF;

		CREATE INDEX IX_addServiceCalculateParametrs ON #ServiceCalculateParametrs
		(
			[xSCP_SCId] ASC,
			[xSCP_Date] ASC,
			[xSCP_DateCheckIn] ASC,
			[xSCP_Men] ASC,
			[xSCP_Days] ASC,
			[xSCP_TourDays] ASC,
			[xSCP_PKKey] ASC,
			[xSCP_DeleteDate] ASC,
			[xSCP_Id] ASC
		);
		
		create table #ServiceTours
		(
			xST_ID int identity(-10,-1)  primary key,
			xST_SCID int,
			xST_TOKEY int,
			xST_TRKEY int,
			xST_SVKEY int
		)
		
		SET IDENTITY_INSERT #ServiceTours ON;
		
		insert into #ServiceTours (xst_id, xst_scid, xst_tokey, xst_trkey, xst_svkey)
		select st_id, st_scid, st_tokey, st_trkey, st_svkey 
		from TP_ServiceTours with(nolock)
		where st_tokey = @nPriceTourKey
			and st_scid in (select xsc_id from #ServiceComponents)
			
		SET IDENTITY_INSERT #ServiceTours OFF;

		CREATE INDEX IX_addServiceTours ON #ServiceTours
		(
			xST_SVKEY, 
			xST_SCID, 
			xST_TOKEY, 
			xST_TRKEY
		)
		
		create table #TourParametrs
		(
			xTP_ID int identity(-10,-1) primary key,
			xTP_TOKey int,
			xTP_TourDays int,
			xTP_DateCheckIn datetime
		)
		
		SET IDENTITY_INSERT #TourParametrs ON;
				
		insert into #TourParametrs (xtp_id, xtp_tokey, xtp_tourdays, xtp_datecheckin)
		select tp_id, tp_tokey, tp_tourdays, tp_datecheckin  
		from TP_TourParametrs with(nolock)
		where tp_datecheckin in (select td_date 
								 from TP_TurDates with(nolock)
								 where td_calculatingkey = @nCalculatingKey)
				and tp_tokey = @nPriceTourKey
		
		SET IDENTITY_INSERT #TourParametrs OFF;

		CREATE INDEX IX_addServiceTours ON #TourParametrs
		(
			xTP_TOKey, 
			xTP_TourDays, 
			xTP_DateCheckIn
		)
		
		create table #ServicePriceActualDate
		(
			xSPAD_Id int identity (-10,-1) primary key,
			xSPAD_SCPId int,
			xSPAD_IsCommission bit,
			xSPAD_Rate varchar(3),
			xSPAD_SaleDate datetime,
			xSPAD_Gross money,
			xspad_Netto money,
			xspad_DateLastChange datetime,
			xspad_DateLastCalculate datetime,
			xSPAD_NeedApply int,
			xspad_AutoOnline int default 0
		)
		
		SET IDENTITY_INSERT #ServicePriceActualDate ON;
		
		insert into #ServicePriceActualDate (xSPAD_Id, xSPAD_SCPId, xSPAD_IsCommission, xSPAD_Rate, xSPAD_SaleDate, xSPAD_Gross, xspad_Netto, xspad_DateLastChange, xspad_DateLastCalculate, xSPAD_NeedApply, xspad_AutoOnline)
		select SPAD_Id, SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross,spad_Netto, spad_DateLastChange, spad_DateLastCalculate, SPAD_NeedApply, spad_AutoOnline
		from TP_ServicePriceActualDate with(nolock)
		where 
		SPAD_SaleDate is null 
		and SPAD_SCPId in (select xSCP_ID 
							 from #ServiceCalculateParametrs)
					  
		SET IDENTITY_INSERT #ServicePriceActualDate OFF;

		CREATE INDEX IX_INDEX2 ON #ServicePriceActualDate(xSPAD_SCPId, xSPAD_SaleDate, xSPAD_Rate, xSPAD_NeedApply)
		include (xSPAD_Gross, xSPAD_IsCommission)
		
		create table #GetServiceCost
		(
			id int not null identity(1,1) primary key,
			svKey int,
			code int,
			code1 int,
			code2 int,
			prKey int,
			packetKey int,
			tempdate datetime,
			tempdays int,
			resRate varchar(2),
			men int,
			discountPercent decimal(14,2),
			margin int,
			marginType decimal(14,2),
			sellDate datetime,
			tourKey int,
			tourDate datetime,
			tourDays int,
			netto decimal(14,2),
			brutto money, 
			nSPId int,
			discount decimal(14,2)
		)
		
		CREATE INDEX IX_INDEX1 ON #GetServiceCost(svKey, code, code1, code2, prKey, packetKey, tempdate, tempdays, resRate, men, discountPercent, margin, marginType, sellDate, tourDate, tourDays)
		include (netto, brutto, nSPId, discount)
		
		declare serviceCursor cursor local fast_forward for
		select ti_firsthdkey, ts_key, ti_key, td_date, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_oppartnerkey, ts_oppacketkey, ts_day, ts_days, @tempTO_Rate, ts_men, ts_tempgross, ts_checkmargin, td_checkmargin, ti_days, ts_ctkey, ts_attribute,tiCtKeyFrom, sv_IsDuration, ti_totaldays
		from #CursorTable

		open serviceCursor
		
			
		SELECT @round = ST_RoundService FROM Setting
		--MEG00036108 увеличил значение
		set @nProgressSkipLimit = 10000
		set @nProgressSkipCounter = 0

		declare @calcPricesCount int, @calcPriceListCount int, @calcTurDates int, @oldPriceKeyCurrent int
		select @calcPriceListCount = COUNT(1) from TP_Lists with(nolock) where TI_TOKey = @nPriceTourKey and TI_UPDATE = @nUpdate
		select @calcTurDates = COUNT(1) from TP_TurDates with(nolock) where TD_TOKey = @nPriceTourKey and TD_UPDATE = @nUpdate
		select @calcPricesCount = @calcPriceListCount * @calcTurDates
		set @NumPrices = @calcPricesCount
		
		if @NumPrices <> 0
			set @nDeltaProgress = (97.0 - 5) / @NumPrices
		else
			set @nDeltaProgress = 97.0 - 5

		exec GetNKeys 'TP_PRICES', @NumPrices, @nTP_PriceKeyMax output
		set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
		set @dtPrevDate = '1899-12-31'
		set @nPrevVariant = -1
		set @nPrevGross = -1
		set @nPrevGrossDate = '1899-12-31'
		set @prevHdKey = -1

		delete from #TP_Prices
		
		declare @IsDuration smallint
		declare @tiCtKeyFrom int, @tiDays int, @titotaldays int
		declare @tsKey_1 int, @tsKey_2 int, @tsKey_3 int, @tsKey_4 int, @tsKey_5 int, @tsKey_6 int, @tsKey_7 int, @tsKey_8 int, @tsKey_9 int, @tsKey_10 int, @tsKey_11 int, @tsKey_12 int, @tsKey_13 int, @tsKey_14 int, @tsKey_15 int
		declare @tsSVKey_1 int, @tsSVKey_2 int, @tsSVKey_3 int, @tsSVKey_4 int, @tsSVKey_5 int, @tsSVKey_6 int, @tsSVKey_7 int, @tsSVKey_8 int, @tsSVKey_9 int, @tsSVKey_10 int, @tsSVKey_11 int, @tsSVKey_12 int, @tsSVKey_13 int, @tsSVKey_14 int, @tsSVKey_15 int
		declare @tsGross_1 money, @tsGross_2 money, @tsGross_3 money, @tsGross_4 money, @tsGross_5 money, @tsGross_6 money, @tsGross_7 money, @tsGross_8 money, @tsGross_9 money, @tsGross_10 money, @tsGross_11 money, @tsGross_12 money, @tsGross_13 money, @tsGross_14 money, @tsGross_15 money
		declare @tsAddIsCommission_1 money, @tsAddIsCommission_2 money, @tsAddIsCommission_3 money, @tsAddIsCommission_4 money, @tsAddIsCommission_5 money, @tsAddIsCommission_6 money, @tsAddIsCommission_7 money, @tsAddIsCommission_8 money, @tsAddIsCommission_9 money, @tsAddIsCommission_10 money, @tsAddIsCommission_11 money, @tsAddIsCommission_12 money, @tsAddIsCommission_13 money, @tsAddIsCommission_14 money, @tsAddIsCommission_15 money
		declare @tsAddNoCommission_1 money, @tsAddNoCommission_2 money, @tsAddNoCommission_3 money, @tsAddNoCommission_4 money, @tsAddNoCommission_5 money, @tsAddNoCommission_6 money, @tsAddNoCommission_7 money, @tsAddNoCommission_8 money, @tsAddNoCommission_9 money, @tsAddNoCommission_10 money, @tsAddNoCommission_11 money, @tsAddNoCommission_12 money, @tsAddNoCommission_13 money, @tsAddNoCommission_14 money, @tsAddNoCommission_15 money
		declare @tsMarginPercent_1 money, @tsMarginPercent_2 money, @tsMarginPercent_3 money, @tsMarginPercent_4 money, @tsMarginPercent_5 money, @tsMarginPercent_6 money, @tsMarginPercent_7 money, @tsMarginPercent_8 money, @tsMarginPercent_9 money, @tsMarginPercent_10 money, @tsMarginPercent_11 money, @tsMarginPercent_12 money, @tsMarginPercent_13 money, @tsMarginPercent_14 money, @tsMarginPercent_15 money
		declare @tsCommissionOnly_1 money, @tsCommissionOnly_2 money, @tsCommissionOnly_3 money, @tsCommissionOnly_4 money, @tsCommissionOnly_5 money, @tsCommissionOnly_6 money, @tsCommissionOnly_7 money, @tsCommissionOnly_8 money, @tsCommissionOnly_9 money, @tsCommissionOnly_10 money, @tsCommissionOnly_11 money, @tsCommissionOnly_12 money, @tsCommissionOnly_13 money, @tsCommissionOnly_14 money, @tsCommissionOnly_15 money
		declare @tsIsCommission_1 bit, @tsIsCommission_2 bit, @tsIsCommission_3 bit, @tsIsCommission_4 bit, @tsIsCommission_5 bit, @tsIsCommission_6 bit, @tsIsCommission_7 bit, @tsIsCommission_8 bit, @tsIsCommission_9 bit, @tsIsCommission_10 bit, @tsIsCommission_11 bit, @tsIsCommission_12 bit, @tsIsCommission_13 bit, @tsIsCommission_14 bit, @tsIsCommission_15 bit

		fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE, @tiCtKeyFrom, @IsDuration, @titotaldays
		
		set @fetchStatus = @@fetch_status	
			
		print 'Расчет цен 0: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
		While (@fetchStatus = 0)
		BEGIN
			--данных не нашлось, выходим
			if @@fetch_status <> 0 and @nPrevVariant = -1
				break
				
		--очищаем переменные, записываем данные в таблицу #TP_Prices
			if @nPrevVariant <> @variant or @dtPrevDate <> @turdate or @@fetch_status <> 0
			BEGIN				
				--записываем данные в таблицу #TP_Prices
				if @nPrevVariant <> -1
				begin
					if exists(select 1 from #TP_Prices where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant)
					begin
						--select @nCalculatingKey
						update #TP_Prices set xtp_calculatingkey = @nCalculatingKey, xtp_key = @nTP_PriceKeyCurrent where xtp_tokey = @nPriceTourKey and xtp_datebegin = @dtPrevDate and xtp_dateend = @dtPrevDate and xtp_tikey = @nPrevVariant and xtp_gross <> @price_brutto
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
						
					end
					else if (@isPriceListPluginRecalculation = 0)
					begin
						--select @nCalculatingKey
						insert into #TP_Prices (xtp_key, xtp_tokey, xtp_datebegin, xtp_dateend, xtp_tikey, xTP_CalculatingKey, xTP_Days, xTP_Rate, xTP_HotelKey, xTP_DepartureKey
						, xSCPId_1, xSCPId_2, xSCPId_3, xSCPId_4, xSCPId_5, xSCPId_6, xSCPId_7, xSCPId_8, xSCPId_9, xSCPId_10, xSCPId_11, xSCPId_12, xSCPId_13, xSCPId_14, xSCPId_15
						, xSvKey_1, xSvKey_2, xSvKey_3, xSvKey_4, xSvKey_5, xSvKey_6, xSvKey_7, xSvKey_8, xSvKey_9, xSvKey_10, xSvKey_11, xSvKey_12, xSvKey_13, xSvKey_14, xSvKey_15
						, xGross_1, xGross_2, xGross_3, xGross_4, xGross_5, xGross_6, xGross_7, xGross_8, xGross_9, xGross_10, xGross_11, xGross_12, xGross_13, xGross_14, xGross_15
						, xAddCostIsCommission_1, xAddCostIsCommission_2, xAddCostIsCommission_3, xAddCostIsCommission_4, xAddCostIsCommission_5, xAddCostIsCommission_6, xAddCostIsCommission_7, xAddCostIsCommission_8, xAddCostIsCommission_9, xAddCostIsCommission_10, xAddCostIsCommission_11, xAddCostIsCommission_12, xAddCostIsCommission_13, xAddCostIsCommission_14, xAddCostIsCommission_15
						, xAddCostNoCommission_1, xAddCostNoCommission_2, xAddCostNoCommission_3, xAddCostNoCommission_4, xAddCostNoCommission_5, xAddCostNoCommission_6, xAddCostNoCommission_7, xAddCostNoCommission_8, xAddCostNoCommission_9, xAddCostNoCommission_10, xAddCostNoCommission_11, xAddCostNoCommission_12, xAddCostNoCommission_13, xAddCostNoCommission_14, xAddCostNoCommission_15
						, xMarginPercent_1, xMarginPercent_2, xMarginPercent_3, xMarginPercent_4, xMarginPercent_5, xMarginPercent_6, xMarginPercent_7, xMarginPercent_8, xMarginPercent_9, xMarginPercent_10, xMarginPercent_11, xMarginPercent_12, xMarginPercent_13, xMarginPercent_14, xMarginPercent_15
						, xCommissionOnly_1, xCommissionOnly_2, xCommissionOnly_3, xCommissionOnly_4, xCommissionOnly_5, xCommissionOnly_6, xCommissionOnly_7, xCommissionOnly_8, xCommissionOnly_9, xCommissionOnly_10, xCommissionOnly_11, xCommissionOnly_12, xCommissionOnly_13, xCommissionOnly_14, xCommissionOnly_15
						, xIsCommission_1, xIsCommission_2, xIsCommission_3, xIsCommission_4, xIsCommission_5, xIsCommission_6, xIsCommission_7, xIsCommission_8, xIsCommission_9, xIsCommission_10, xIsCommission_11, xIsCommission_12, xIsCommission_13, xIsCommission_14, xIsCommission_15)
						values (@nTP_PriceKeyCurrent, @nPriceTourKey, @dtPrevDate, @dtPrevDate, @nPrevVariant, @nCalculatingKey, @tiDays, @sRate, @hdKey, @tiCtKeyFrom
						, @tsKey_1, @tsKey_2, @tsKey_3, @tsKey_4, @tsKey_5, @tsKey_6, @tsKey_7, @tsKey_8, @tsKey_9, @tsKey_10, @tsKey_11, @tsKey_12, @tsKey_13, @tsKey_14, @tsKey_15
						, @tsSVKey_1, @tsSVKey_2, @tsSVKey_3, @tsSVKey_4, @tsSVKey_5, @tsSVKey_6, @tsSVKey_7, @tsSVKey_8, @tsSVKey_9, @tsSVKey_10, @tsSVKey_11, @tsSVKey_12, @tsSVKey_13, @tsSVKey_14, @tsSVKey_15
						, @tsGross_1, @tsGross_2, @tsGross_3, @tsGross_4, @tsGross_5, @tsGross_6, @tsGross_7, @tsGross_8, @tsGross_9, @tsGross_10, @tsGross_11, @tsGross_12, @tsGross_13, @tsGross_14, @tsGross_15
						, @tsAddIsCommission_1, @tsAddIsCommission_2, @tsAddIsCommission_3, @tsAddIsCommission_4, @tsAddIsCommission_5, @tsAddIsCommission_6, @tsAddIsCommission_7, @tsAddIsCommission_8, @tsAddIsCommission_9, @tsAddIsCommission_10, @tsAddIsCommission_11, @tsAddIsCommission_12, @tsAddIsCommission_13, @tsAddIsCommission_14, @tsAddIsCommission_15
						, @tsAddNoCommission_1, @tsAddNoCommission_2, @tsAddNoCommission_3, @tsAddNoCommission_4, @tsAddNoCommission_5, @tsAddNoCommission_6, @tsAddNoCommission_7, @tsAddNoCommission_8, @tsAddNoCommission_9, @tsAddNoCommission_10, @tsAddNoCommission_11, @tsAddNoCommission_12, @tsAddNoCommission_13, @tsAddNoCommission_14, @tsAddNoCommission_15
						, @tsMarginPercent_1, @tsMarginPercent_2, @tsMarginPercent_3, @tsMarginPercent_4, @tsMarginPercent_5, @tsMarginPercent_6, @tsMarginPercent_7, @tsMarginPercent_8, @tsMarginPercent_9, @tsMarginPercent_10, @tsMarginPercent_11, @tsMarginPercent_12, @tsMarginPercent_13, @tsMarginPercent_14, @tsMarginPercent_15
						, @tsCommissionOnly_1, @tsCommissionOnly_2, @tsCommissionOnly_3, @tsCommissionOnly_4, @tsCommissionOnly_5, @tsCommissionOnly_6, @tsCommissionOnly_7, @tsCommissionOnly_8, @tsCommissionOnly_9, @tsCommissionOnly_10, @tsCommissionOnly_11, @tsCommissionOnly_12, @tsCommissionOnly_13, @tsCommissionOnly_14, @tsCommissionOnly_15
						, @tsIsCommission_1, @tsIsCommission_2, @tsIsCommission_3, @tsIsCommission_4, @tsIsCommission_5, @tsIsCommission_6, @tsIsCommission_7, @tsIsCommission_8, @tsIsCommission_9, @tsIsCommission_10, @tsIsCommission_11, @tsIsCommission_12, @tsIsCommission_13, @tsIsCommission_14, @tsIsCommission_15)
												
						set @tiDays = null
						
						set @tsKey_1 = null
						set @tsKey_2 = null
						set @tsKey_3 = null
						set @tsKey_4 = null
						set @tsKey_5 = null
						set @tsKey_6 = null
						set @tsKey_7 = null
						set @tsKey_8 = null
						set @tsKey_9 = null
						set @tsKey_10 = null
						set @tsKey_11 = null
						set @tsKey_12 = null
						set @tsKey_13 = null
						set @tsKey_14 = null
						set @tsKey_15 = null
						
						set @tsSVKey_1 = null
						set @tsSVKey_2 = null
						set @tsSVKey_3 = null
						set @tsSVKey_4 = null
						set @tsSVKey_5 = null
						set @tsSVKey_6 = null
						set @tsSVKey_7 = null
						set @tsSVKey_8 = null
						set @tsSVKey_9 = null
						set @tsSVKey_10 = null
						set @tsSVKey_11 = null
						set @tsSVKey_12 = null
						set @tsSVKey_13 = null
						set @tsSVKey_14 = null
						set @tsSVKey_15 = null
						
						set @tsGross_1 = null
						set @tsGross_2 = null
						set @tsGross_3 = null
						set @tsGross_4 = null
						set @tsGross_5 = null
						set @tsGross_6 = null
						set @tsGross_7 = null
						set @tsGross_8 = null
						set @tsGross_9 = null
						set @tsGross_10 = null
						set @tsGross_11 = null
						set @tsGross_12 = null
						set @tsGross_13 = null
						set @tsGross_14 = null
						set @tsGross_15 = null
						
						set @tsAddIsCommission_1 = null
						set @tsAddIsCommission_2 = null
						set @tsAddIsCommission_3 = null
						set @tsAddIsCommission_4 = null
						set @tsAddIsCommission_5 = null
						set @tsAddIsCommission_6 = null
						set @tsAddIsCommission_7 = null
						set @tsAddIsCommission_8 = null
						set @tsAddIsCommission_9 = null
						set @tsAddIsCommission_10 = null
						set @tsAddIsCommission_11 = null
						set @tsAddIsCommission_12 = null
						set @tsAddIsCommission_13 = null
						set @tsAddIsCommission_14 = null
						set @tsAddIsCommission_15 = null
						
						set @tsAddNoCommission_1 = null
						set @tsAddNoCommission_2 = null
						set @tsAddNoCommission_3 = null
						set @tsAddNoCommission_4 = null
						set @tsAddNoCommission_5 = null
						set @tsAddNoCommission_6 = null
						set @tsAddNoCommission_7 = null
						set @tsAddNoCommission_8 = null
						set @tsAddNoCommission_9 = null
						set @tsAddNoCommission_10 = null
						set @tsAddNoCommission_11 = null
						set @tsAddNoCommission_12 = null
						set @tsAddNoCommission_13 = null
						set @tsAddNoCommission_14 = null
						set @tsAddNoCommission_15 = null
						
						set @tsMarginPercent_1 = null
						set @tsMarginPercent_2 = null
						set @tsMarginPercent_3 = null
						set @tsMarginPercent_4 = null
						set @tsMarginPercent_5 = null
						set @tsMarginPercent_6 = null
						set @tsMarginPercent_7 = null
						set @tsMarginPercent_8 = null
						set @tsMarginPercent_9 = null
						set @tsMarginPercent_10 = null
						set @tsMarginPercent_11 = null
						set @tsMarginPercent_12 = null
						set @tsMarginPercent_13 = null
						set @tsMarginPercent_14 = null
						set @tsMarginPercent_15 = null
						
						set @tsCommissionOnly_1 = null
						set @tsCommissionOnly_2 = null
						set @tsCommissionOnly_3 = null
						set @tsCommissionOnly_4 = null
						set @tsCommissionOnly_5 = null
						set @tsCommissionOnly_6 = null
						set @tsCommissionOnly_7 = null
						set @tsCommissionOnly_8 = null
						set @tsCommissionOnly_9 = null
						set @tsCommissionOnly_10 = null
						set @tsCommissionOnly_11 = null
						set @tsCommissionOnly_12 = null
						set @tsCommissionOnly_13 = null
						set @tsCommissionOnly_14 = null
						set @tsCommissionOnly_15 = null
						
						set @tsIsCommission_1 = null
						set @tsIsCommission_2 = null
						set @tsIsCommission_3 = null
						set @tsIsCommission_4 = null
						set @tsIsCommission_5 = null
						set @tsIsCommission_6 = null
						set @tsIsCommission_7 = null
						set @tsIsCommission_8 = null
						set @tsIsCommission_9 = null
						set @tsIsCommission_10 = null
						set @tsIsCommission_11 = null
						set @tsIsCommission_12 = null
						set @tsIsCommission_13 = null
						set @tsIsCommission_14 = null
						set @tsIsCommission_15 = null
						
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyCurrent + 1
					end
				end
				
				--очищаем данные
				if @@fetch_status = 0
				begin
					if @nTP_PriceKeyCurrent > @nTP_PriceKeyMax
					BEGIN
						exec GetNKeys 'TP_PRICES', @NumPrices, @nTP_PriceKeyMax output
						set @nTP_PriceKeyCurrent = @nTP_PriceKeyMax - @NumPrices + 1
					END
					
					set @price_brutto = 0
					set @nPrevVariant = @variant
					set @dtPrevDate = @turdate
				end
				
				set @nTotalProgress = @nTotalProgress + @nDeltaProgress
				if @nProgressSkipCounter = @nProgressSkipLimit
				BEGIN
					update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_updatetime = GetDate() where to_key = @nPriceTourKey
					set @nProgressSkipCounter = 0
				END
				else
					set @nProgressSkipCounter = @nProgressSkipCounter + 1
			END

			--переписываем данные в таблицу tp_prices
			if @hdKey <> @prevHdKey or @@fetch_status <> 0
			begin
				set @prevHdKey = @hdKey
			end
			
				if @@fetch_status <> 0
					break	
										
				declare @margin float, @marginType int, @addCostValueIsCommission money, @addCostValueNoCommission money
				declare @scId int -- ключ найденой записи в таблице TP_ServiceComponents
				declare @scpId int -- ключ найденой записи в таблице TP_ServiceCalculateParametrs
				declare @spadId  int -- ключ найденой записи в тиблице TP_ServiePriceActualDate
				
				---- gorshkov поднял дату сюда т.к. она нужна при замене дефолтного перелета на подобранный
				set @servicedate = dateAdd(dd, @nDay-1, @turdate)
				
				---- gorshkov проверка на то что данную услугу вообще нужно расчитывать
				if @TS_ATTRIBUTE & @SERV_NOTCALCULATE = @SERV_NOTCALCULATE
				begin
					set @nNetto = 0
					set @nBrutto = 0
					set @nDiscount = 0
					set @nPDID = 0
					
				end
				else
				begin
					 --если есть ключ услуги то расчитываем, иначе проставляем null
					if (@nCode is not null)
					begin					
						set @tiDays = @TI_DAYS
						
						/*создадим структуру таблиц если ее нету*/
						exec ReCalculate_CreateServiceCalculateParametrs @TrKey, @nPriceTourKey, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nDay, @turdate, @nMen, @nDays, @nPacketkey, @titotaldays, @scId output, @scpId output
						declare @gross money, @addCostIsCommission money, @addCostNoCommission money, @addCostFromAdult money, @addCostFromChild money, @marginPercent money, @CommissionOnly bit, @isCommission bit, @tourRate varchar(2)
						
						/*Производим расчет стоимости услуги*/
						exec ReCalculateCosts_CalculatePriceList @scpId, @nBrutto output, @isCommission output, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @servicedate, @nDays, @sRate, @nMen, 0, @nMargin, @nMarginType, null, @nNetto, @nDiscount, @sDetailed, @sBadRate, @dtBadDate, @sDetailed, @nSPId, @TrKey, @turdate, @TI_DAYS, @IsDuration
						
						 --проверям считать ли null цены = 0					
						if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey not in (1,3)
							set @nBrutto = 0
						if @nNullCostAsZero = 1 and @nBrutto is null and @nSvkey = 1 and @nNoFlight = 0
							set @nBrutto = 0
						set @gross = @nBrutto
		
						/*Производим расчет наценки*/
						--промежуточная хранимка для работы с кэшем (TP_TourMarginActualDate)
						exec ReCalculateMargins_CalculatePriceList @TrKey, @nPriceTourKey, @turdate, @margin output, @marginType output, @nSvkey, @TI_DAYS, @dtSaleDate, @nPacketkey
						set @marginPercent = @margin
						set @CommissionOnly = @marginType
						
						/*Производим расчет доплаты*/
						exec GetServiceAddCosts @TrKey, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @turdate, @TI_DAYS, @nDays, @nMen, null, null, @addCostValueIsCommission output, @addCostValueNoCommission output, @addCostFromAdult output, @addCostFromChild output, @tourRate output
						set @addCostIsCommission = @addCostValueIsCommission
						set @addCostNoCommission = @addCostValueNoCommission
					end
					else
					begin
						set @gross = null
						set @addCostIsCommission = null
						set @addCostNoCommission = null
						set @marginPercent = null
						set @CommissionOnly = null
						set @isCommission = null
					end
					
					-- запишем ключи TS_Key в таблицу (получим список услуг из которых состоит TP_Prices)
					if (@tsKey_1 is null)
					begin
						set @tsKey_1 = @scpId
						set @tsSVKey_1 = @nSvkey
						set @tsGross_1 = @gross
						set @tsAddIsCommission_1 = @addCostIsCommission
						set @tsAddNoCommission_1 = @addCostNoCommission
						set @tsMarginPercent_1 = @marginPercent
						set @tsCommissionOnly_1 = @CommissionOnly
						set @tsIsCommission_1 = @isCommission
					end
					else if (@tsKey_2 is null)
					begin
						set @tsKey_2 = @scpId
						set @tsSVKey_2 = @nSvkey
						set @tsGross_2 = @gross
						set @tsAddIsCommission_2 = @addCostIsCommission
						set @tsAddNoCommission_2 = @addCostNoCommission
						set @tsMarginPercent_2 = @marginPercent
						set @tsCommissionOnly_2 = @CommissionOnly
						set @tsIsCommission_2 = @isCommission
					end
					else if (@tsKey_3 is null)
					begin
						set @tsKey_3 = @scpId
						set @tsSVKey_3 = @nSvkey
						set @tsGross_3 = @gross
						set @tsAddIsCommission_3 = @addCostIsCommission
						set @tsAddNoCommission_3 = @addCostNoCommission
						set @tsMarginPercent_3 = @marginPercent
						set @tsCommissionOnly_3 = @CommissionOnly
						set @tsIsCommission_3 = @isCommission
					end
					else if (@tsKey_4 is null)
					begin
						set @tsKey_4 = @scpId
						set @tsSVKey_4 = @nSvkey
						set @tsGross_4 = @gross
						set @tsAddIsCommission_4 = @addCostIsCommission
						set @tsAddNoCommission_4 = @addCostNoCommission
						set @tsMarginPercent_4 = @marginPercent
						set @tsCommissionOnly_4 = @CommissionOnly
						set @tsIsCommission_4 = @isCommission
					end
					else if (@tsKey_5 is null)
					begin
						set @tsKey_5 = @scpId
						set @tsSVKey_5 = @nSvkey
						set @tsGross_5 = @gross
						set @tsAddIsCommission_5 = @addCostIsCommission
						set @tsAddNoCommission_5 = @addCostNoCommission
						set @tsMarginPercent_5 = @marginPercent
						set @tsCommissionOnly_5 = @CommissionOnly
						set @tsIsCommission_5 = @isCommission
					end
					else if (@tsKey_6 is null)
					begin
						set @tsKey_6 = @scpId
						set @tsSVKey_6 = @nSvkey
						set @tsGross_6 = @gross
						set @tsAddIsCommission_6 = @addCostIsCommission
						set @tsAddNoCommission_6 = @addCostNoCommission
						set @tsMarginPercent_6 = @marginPercent
						set @tsCommissionOnly_6 = @CommissionOnly
						set @tsIsCommission_6 = @isCommission
					end
					else if (@tsKey_7 is null)
					begin
						set @tsKey_7 = @scpId
						set @tsSVKey_7 = @nSvkey
						set @tsGross_7 = @gross
						set @tsAddIsCommission_7 = @addCostIsCommission
						set @tsAddNoCommission_7 = @addCostNoCommission
						set @tsMarginPercent_7 = @marginPercent
						set @tsCommissionOnly_7 = @CommissionOnly
						set @tsIsCommission_7 = @isCommission
					end
					else if (@tsKey_8 is null)
					begin
						set @tsKey_8 = @scpId
						set @tsSVKey_8 = @nSvkey
						set @tsGross_8 = @gross
						set @tsAddIsCommission_8 = @addCostIsCommission
						set @tsAddNoCommission_8 = @addCostNoCommission
						set @tsMarginPercent_8 = @marginPercent
						set @tsCommissionOnly_8 = @CommissionOnly
						set @tsIsCommission_8 = @isCommission
					end
					else if (@tsKey_9 is null)
					begin
						set @tsKey_9 = @scpId
						set @tsSVKey_9 = @nSvkey
						set @tsGross_9 = @gross
						set @tsAddIsCommission_9 = @addCostIsCommission
						set @tsAddNoCommission_9 = @addCostNoCommission
						set @tsMarginPercent_9 = @marginPercent
						set @tsCommissionOnly_9 = @CommissionOnly
						set @tsIsCommission_9 = @isCommission
					end
					else if (@tsKey_10 is null)
					begin
						set @tsKey_10 = @scpId
						set @tsSVKey_10 = @nSvkey
						set @tsGross_10 = @gross
						set @tsAddIsCommission_10 = @addCostIsCommission
						set @tsAddNoCommission_10 = @addCostNoCommission
						set @tsMarginPercent_10 = @marginPercent
						set @tsCommissionOnly_10 = @CommissionOnly
						set @tsIsCommission_10 = @isCommission
					end
					else if (@tsKey_11 is null)
					begin
						set @tsKey_11 = @scpId
						set @tsSVKey_11 = @nSvkey
						set @tsGross_11 = @gross
						set @tsAddIsCommission_11 = @addCostIsCommission
						set @tsAddNoCommission_11 = @addCostNoCommission
						set @tsMarginPercent_11 = @marginPercent
						set @tsCommissionOnly_11 = @CommissionOnly
						set @tsIsCommission_11 = @isCommission
					end
					else if (@tsKey_12 is null)
					begin
						set @tsKey_12 = @scpId
						set @tsSVKey_12 = @nSvkey
						set @tsGross_12 = @gross
						set @tsAddIsCommission_12 = @addCostIsCommission
						set @tsAddNoCommission_12 = @addCostNoCommission
						set @tsMarginPercent_12 = @marginPercent
						set @tsCommissionOnly_12 = @CommissionOnly
						set @tsIsCommission_12 = @isCommission
					end
					else if (@tsKey_13 is null)
					begin
						set @tsKey_13 = @scpId
						set @tsSVKey_13 = @nSvkey
						set @tsGross_13 = @gross
						set @tsAddIsCommission_13 = @addCostIsCommission
						set @tsAddNoCommission_13 = @addCostNoCommission
						set @tsMarginPercent_13 = @marginPercent
						set @tsCommissionOnly_13 = @CommissionOnly
						set @tsIsCommission_13 = @isCommission
					end
					else if (@tsKey_14 is null)
					begin
						set @tsKey_14 = @scpId
						set @tsSVKey_14 = @nSvkey
						set @tsGross_14 = @gross
						set @tsAddIsCommission_14 = @addCostIsCommission
						set @tsAddNoCommission_14 = @addCostNoCommission
						set @tsMarginPercent_14 = @marginPercent
						set @tsCommissionOnly_14 = @CommissionOnly
						set @tsIsCommission_14 = @isCommission
					end
					else if (@tsKey_15 is null)
					begin
						set @tsKey_15 = @scpId
						set @tsSVKey_15 = @nSvkey
						set @tsGross_15 = @gross
						set @tsAddIsCommission_15 = @addCostIsCommission
						set @tsAddNoCommission_15 = @addCostNoCommission
						set @tsMarginPercent_15 = @marginPercent
						set @tsCommissionOnly_15 = @CommissionOnly
						set @tsIsCommission_15 = @isCommission
					end

				end
		fetch next from serviceCursor into @hdKey, @nServiceKey, @variant, @turdate, @nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey, @nPacketkey, @nDay, @nDays, @sRate, @nMen, @nTempGross, @tsCheckMargin, @tdCheckMargin, @TI_DAYS, @TS_CTKEY, @TS_ATTRIBUTE, @tiCtKeyFrom, @IsDuration, @titotaldays
		END
		
		close serviceCursor
		deallocate serviceCursor

		Set @nTotalProgress = 97
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
		
		/* Заполнения основных таблиц, на основе темповых данных */

		declare @step int
		-- таблица сопоставления ключей ServiceComponents
		--если есть данные с отрицательными ключами - это новые данные, их надо добавить в основную таблицу
		if exists (select top 1 1 from #ServiceComponents where xsc_id < 0)
		begin
			insert into TP_ServiceComponents (sc_svkey, sc_code, sc_subcode1, sc_subcode2, sc_prkey)
			select xsc_svkey, xsc_code, xsc_subcode1, xsc_subcode2, xsc_prkey 
			from #ServiceComponents 
			where xsc_id < 0

			update #ServiceComponents
			set xSC_ID_InDB = sc_id
			from TP_ServiceComponents with(nolock)
			where 
			sc_svkey = xSC_SVKEY
			and sc_code = xSC_CODE
			and isnull(sc_subcode1,0) = isnull(xSC_SUBCODE1,0)
			and isnull(sc_subcode2,0) = isnull(xSC_SUBCODE2,0)
			and isnull(sc_prkey,0) = isnull(xSC_PRKEY,0) 			
			and xsc_id < 0
		end

		-- тут ничего не меняется колонка xSC_ID_InDB = xSC_ID
		update #ServiceComponents
		set xSC_ID_InDB = xSC_ID
		where xSC_ID > 0
		-------------------------------

		-- если есть данные с отрицательными ключами - это новые данные, их надо добавить в основную таблицу
		insert into TP_TourParametrs (tp_tokey, tp_tourdays, tp_datecheckin)
		select xtp_tokey, xtp_tourdays, xtp_datecheckin
		from #TourParametrs
		where xTP_ID < 0
		
		-- TP_ServiceTours
		insert into TP_ServiceTours (ST_SCId, ST_SVKey, ST_TOKey, ST_TRKey)
		select xSC_ID_InDB, xST_SVKey, xST_TOKey, xST_TRKey
		from #ServiceTours
		join #ServiceComponents on xSC_ID = xST_SCId
		where xST_ID < 0
		------------------

		-- TP_ServiceCalculateParametrs
		if exists (select top 1 1 from #ServiceCalculateParametrs where xSCP_Id < 0)
		begin
			insert into TP_ServiceCalculateParametrs (SCP_SCId, SCP_SvKey, SCP_Date, SCP_DateCheckIn, SCP_Men, SCP_Days, SCP_PKKey, SCP_TourDays)
			select xSC_ID_InDB, xSCP_SvKey, xSCP_Date, xSCP_DateCheckIn, xSCP_Men, xSCP_Days, xSCP_PKKey, xSCP_TourDays
			from #ServiceCalculateParametrs
			join #ServiceComponents on xSC_ID = xSCP_SCId
			where xSCP_Id < 0

			update #ServiceCalculateParametrs
			set xSCP_Id_InDB = scp_id
			from TP_ServiceCalculateParametrs with(nolock)
			join #ServiceComponents on scp_scid = xSC_ID_InDB
			where
			xSC_ID = xSCP_SCId
			and scp_date = xscp_date
			and scp_datecheckin = xscp_datecheckin
			and scp_men = xscp_men
			and scp_days = xscp_days
			and isnull(scp_tourdays,0) = isnull(xscp_tourdays,0)
			and scp_pkkey = xscp_pkkey
			and isnull(scp_deletedate, '19000101') = isnull(xscp_deletedate, '19000101')			
			and xSCP_Id < 0
		end

		update #ServiceCalculateParametrs
		set xSCP_Id_InDB = xSCP_Id
		where xSCP_Id > 0
		-------------------------------
		
		-- в таблице #TP_Prices для  новых (отрицательных) ST_SCPId происходит замена согласно таблице сопоставления ключей
		update #TP_Prices set xSCPId_1 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_1) where xSCPId_1 < 0
		update #TP_Prices set xSCPId_2 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_2) where xSCPId_2 < 0
		update #TP_Prices set xSCPId_3 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_3) where xSCPId_3 < 0
		update #TP_Prices set xSCPId_4 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_4) where xSCPId_4 < 0
		update #TP_Prices set xSCPId_5 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_5) where xSCPId_5 < 0
		update #TP_Prices set xSCPId_6 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_6) where xSCPId_6 < 0
		update #TP_Prices set xSCPId_7 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_7) where xSCPId_7 < 0
		update #TP_Prices set xSCPId_8 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_8) where xSCPId_8 < 0
		update #TP_Prices set xSCPId_9 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_9) where xSCPId_9 < 0
		update #TP_Prices set xSCPId_10 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_10) where xSCPId_10 < 0
		update #TP_Prices set xSCPId_11 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_11) where xSCPId_11 < 0
		update #TP_Prices set xSCPId_12 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_12) where xSCPId_12 < 0
		update #TP_Prices set xSCPId_13 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_13) where xSCPId_13 < 0
		update #TP_Prices set xSCPId_14 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_14) where xSCPId_14 < 0
		update #TP_Prices set xSCPId_15 = (select xSCP_Id_InDB from #ServiceCalculateParametrs where xSCP_Id = xSCPId_15) where xSCPId_15 < 0

		-- записи цен которые перерасчитались, обновляем из темповой таблицы 
		update TP_ServicePriceActualDate
		set SPAD_IsCommission = xSPAD_IsCommission,
			SPAD_Gross = xSPAD_Gross,			
			SPAD_Netto = xSPAD_Netto,
			SPAD_DateLastCalculate = xSPAD_DateLastCalculate,
			SPAD_NeedApply = ISNULL(xSPAD_NeedApply, 0)
		from #ServicePriceActualDate
		where xSPAD_Id = SPAD_Id 
		and xSPAD_Id > 0
		
		-- записи цен которых не было
		insert into TP_ServicePriceActualDate (SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross, spad_Netto, spad_DateLastChange, spad_DateLastCalculate, SPAD_NeedApply, spad_AutoOnline)
		select xSCP_Id_InDB, xSPAD_IsCommission, xSPAD_Rate, xSPAD_SaleDate, xSPAD_Gross, xspad_Netto, xspad_DateLastChange, xspad_DateLastCalculate, xSPAD_NeedApply, xspad_AutoOnline
		from #ServicePriceActualDate 
		join #ServiceCalculateParametrs on xSPAD_SCPId = xSCP_Id 
		where xSPAD_Id < 0 
		and xSPAD_NeedApply is not null
		
		print 'Расчет цен END: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()

		----------------------------------------------------- возвращаем обратно цены ------------------------------------------------------

		Set @nTotalProgress = 98
		update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
		
		--удаление из веба
		if (@nIsEnabled = 1)
		begin
			if (@isPriceListPluginRecalculation = 0)
				EXEC ClearMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
			else
				EXEC ClearMasterWebSearchFields @nPriceTourKey, null
		end
		
		-- запомним ключи цен которые потом нужно будет удалить из TP_PriceComponents
		declare @tpKeysForDelete table
		(
			xtp_key int
		)
		
		insert into @tpKeysForDelete
		select tp_key from tp_prices with(nolock)
		where tp_tokey = @nPriceTourKey and 
			tp_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tp_DateBegin in (select td_date from TP_TurDates with(nolock) where td_tokey = @nPriceTourKey and TD_Update = @nUpdate)
		union
		select tpd_tpkey from dbo.TP_PricesDeleted with(nolock)
		where tpd_tokey = @nPriceTourKey and 
			tpd_tikey in (select ti_key from tp_lists with(nolock) where ti_tokey = @nPriceTourKey and ti_update = @nUpdate) and
			tpd_DateBegin in (select td_date from TP_TurDates with(nolock) where td_tokey = @nPriceTourKey and TD_Update = @nUpdate)
		
		insert into TP_PricesCleaner(PC_TRKEY, PC_TOKEY, PC_TPKEY, PC_CalculatingKey)
		select @trKey, TP_TOKEY, TP_KEY, @nCalculatingKey from dbo.TP_Prices with(nolock)
		where TP_Key in (select xtp_key from @tpKeysForDelete)	

		delete from dbo.TP_Prices with(rowlock)
		where TP_Key in (select xtp_key from @tpKeysForDelete)	
		
		delete from dbo.TP_PricesDeleted with(rowlock)
		where TPD_TPKey in (select xtp_key from @tpKeysForDelete)	
		
		delete from dbo.TP_PriceComponents with(rowlock)
		where PC_TPKey in (select xtp_key from @tpKeysForDelete)	
		
		-- удалим цены которые не посчитались
		delete #TP_Prices
		where xTP_Gross is null
			
		-- заносим детализацию по посчитанному туру
		declare @insertedTpKeys table(
			tpkey int not null
		)

		while (exists(select top 1 1 from #TP_Prices with(nolock)))
		begin
			insert into @insertedTpKeys
			select top 50000 xtp_key
			from #TP_Prices with(nolock)
		
			INSERT INTO TP_Prices (tp_key, tp_tokey, tp_dateBegin, tp_DateEnd, TP_Gross, TP_TIKey, TP_CalculatingKey)
			select xtp_key, xtp_tokey, xtp_dateBegin, xtp_DateEnd, CEILING(xTP_Gross), xTP_TIKey, xTP_CalculatingKey 
			from #TP_Prices with(nolock) where xtp_key in (select tpkey from  @insertedTpKeys)

			insert into TP_PriceComponents (PC_TIKey, PC_TOKey, PC_TRKey, PC_TourDate, PC_TPKey, PC_Days, PC_Rate, PC_HotelKey, PC_DepartureKey
			, SCPId_1, SCPId_2, SCPId_3, SCPId_4, SCPId_5, SCPId_6, SCPId_7, SCPId_8, SCPId_9, SCPId_10, SCPId_11, SCPId_12, SCPId_13, SCPId_14, SCPId_15
			, SVKey_1, SVKey_2, SVKey_3, SVKey_4, SVKey_5, SVKey_6, SVKey_7, SVKey_8, SVKey_9, SVKey_10, SVKey_11, SVKey_12, SVKey_13, SVKey_14, SVKey_15
			, Gross_1, Gross_2, Gross_3, Gross_4, Gross_5, Gross_6, Gross_7, Gross_8, Gross_9, Gross_10, Gross_11, Gross_12, Gross_13, Gross_14, Gross_15
			, AddCostIsCommission_1, AddCostIsCommission_2, AddCostIsCommission_3, AddCostIsCommission_4, AddCostIsCommission_5, AddCostIsCommission_6, AddCostIsCommission_7, AddCostIsCommission_8, AddCostIsCommission_9, AddCostIsCommission_10, AddCostIsCommission_11, AddCostIsCommission_12, AddCostIsCommission_13, AddCostIsCommission_14, AddCostIsCommission_15
			, AddCostNoCommission_1, AddCostNoCommission_2, AddCostNoCommission_3, AddCostNoCommission_4, AddCostNoCommission_5, AddCostNoCommission_6, AddCostNoCommission_7, AddCostNoCommission_8, AddCostNoCommission_9, AddCostNoCommission_10, AddCostNoCommission_11, AddCostNoCommission_12, AddCostNoCommission_13, AddCostNoCommission_14, AddCostNoCommission_15
			, MarginPercent_1, MarginPercent_2, MarginPercent_3, MarginPercent_4, MarginPercent_5, MarginPercent_6, MarginPercent_7, MarginPercent_8, MarginPercent_9, MarginPercent_10, MarginPercent_11, MarginPercent_12, MarginPercent_13, MarginPercent_14, MarginPercent_15
			, CommissionOnly_1, CommissionOnly_2, CommissionOnly_3, CommissionOnly_4, CommissionOnly_5, CommissionOnly_6, CommissionOnly_7, CommissionOnly_8, CommissionOnly_9, CommissionOnly_10, CommissionOnly_11, CommissionOnly_12, CommissionOnly_13, CommissionOnly_14, CommissionOnly_15
			, IsCommission_1, IsCommission_2, IsCommission_3, IsCommission_4, IsCommission_5, IsCommission_6, IsCommission_7, IsCommission_8, IsCommission_9, IsCommission_10, IsCommission_11, IsCommission_12, IsCommission_13, IsCommission_14, IsCommission_15)
			select xTP_TIKey, xtp_tokey, @TrKey, xtp_dateBegin, xtp_key, xTP_Days, xTP_Rate, xTP_HotelKey, xTP_DepartureKey
			, xSCPId_1, xSCPId_2, xSCPId_3, xSCPId_4, xSCPId_5, xSCPId_6, xSCPId_7, xSCPId_8, xSCPId_9, xSCPId_10, xSCPId_11, xSCPId_12, xSCPId_13, xSCPId_14, xSCPId_15
			, xSvKey_1, xSvKey_2, xSvKey_3, xSvKey_4, xSvKey_5, xSvKey_6, xSvKey_7, xSvKey_8, xSvKey_9, xSvKey_10, xSvKey_11, xSvKey_12, xSvKey_13, xSvKey_14, xSvKey_15
			, xGross_1, xGross_2, xGross_3, xGross_4, xGross_5, xGross_6, xGross_7, xGross_8, xGross_9, xGross_10, xGross_11, xGross_12, xGross_13, xGross_14, xGross_15
			, xAddCostIsCommission_1, xAddCostIsCommission_2, xAddCostIsCommission_3, xAddCostIsCommission_4, xAddCostIsCommission_5, xAddCostIsCommission_6, xAddCostIsCommission_7, xAddCostIsCommission_8, xAddCostIsCommission_9, xAddCostIsCommission_10, xAddCostIsCommission_11, xAddCostIsCommission_12, xAddCostIsCommission_13, xAddCostIsCommission_14, xAddCostIsCommission_15
			, xAddCostNoCommission_1, xAddCostNoCommission_2, xAddCostNoCommission_3, xAddCostNoCommission_4, xAddCostNoCommission_5, xAddCostNoCommission_6, xAddCostNoCommission_7, xAddCostNoCommission_8, xAddCostNoCommission_9, xAddCostNoCommission_10, xAddCostNoCommission_11, xAddCostNoCommission_12, xAddCostNoCommission_13, xAddCostNoCommission_14, xAddCostNoCommission_15
			, xMarginPercent_1, xMarginPercent_2, xMarginPercent_3, xMarginPercent_4, xMarginPercent_5, xMarginPercent_6, xMarginPercent_7, xMarginPercent_8, xMarginPercent_9, xMarginPercent_10, xMarginPercent_11, xMarginPercent_12, xMarginPercent_13, xMarginPercent_14, xMarginPercent_15
			, xCommissionOnly_1, xCommissionOnly_2, xCommissionOnly_3, xCommissionOnly_4, xCommissionOnly_5, xCommissionOnly_6, xCommissionOnly_7, xCommissionOnly_8, xCommissionOnly_9, xCommissionOnly_10, xCommissionOnly_11, xCommissionOnly_12, xCommissionOnly_13, xCommissionOnly_14, xCommissionOnly_15
			, xIsCommission_1, xIsCommission_2, xIsCommission_3, xIsCommission_4, xIsCommission_5, xIsCommission_6, xIsCommission_7, xIsCommission_8, xIsCommission_9, xIsCommission_10, xIsCommission_11, xIsCommission_12, xIsCommission_13, xIsCommission_14, xIsCommission_15
			from #TP_Prices with(nolock) where xtp_key in (select tpkey from  @insertedTpKeys)

			delete #TP_Prices where xtp_key in (select tpkey from  @insertedTpKeys)
			delete from @insertedTpKeys
		end
				
		-----------------------------------------------------КОНЕЦ возвращаем обратно цены ------------------------------------------------------
		Set @nTotalProgress = 99
		update tp_lists with(rowlock) set ti_update = 0 where ti_tokey = @nPriceTourKey
		update tp_turdates with(rowlock) set td_update = 0, td_checkmargin = 0 where td_tokey = @nPriceTourKey
		update tp_tours with(rowlock) set to_progress = @nTotalProgress, to_update = 0, to_updatetime = GetDate(),
							TO_CalculateDateEnd = GetDate(), TO_PriceCount = (Select Count(*) 
			From TP_Prices with(nolock) Where TP_ToKey = to_key) where to_key = @nPriceTourKey
		update tp_services with(rowlock) set ts_checkmargin = 0 where ts_tokey = @nPriceTourKey	
		
		print 'Запись результатов: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()
	END

	update CalculatingPriceLists with(rowlock) set CP_Status = 0, CP_CreateDate = GetDate(), CP_StartTime = null where CP_PriceTourKey = @nPriceTourKey

	--Заполнение полей в таблице tp_lists
	declare @toKey int, @add int
	set @toKey = @nPriceTourKey
	set @add = @nUpdate

	update tp_lists with(rowlock)
		set ti_hotelkeys = dbo.mwGetTiHotelKeys(ti_key),
			ti_hotelroomkeys = dbo.mwGetTiHotelRoomKeys(ti_key),
			ti_hoteldays = dbo.mwGetTiHotelNights(ti_key),
			ti_hotelstars = dbo.mwGetTiHotelStars(ti_key),
			ti_pansionkeys = dbo.mwGetTiPansionKeys(ti_key),
			ti_nights = dbo.mwGetTiNights(ti_key)
	where
		ti_tokey = @toKey and ti_CalculatingKey = @nCalculatingKey
	
	update tp_lists with(rowlock)
	set
		ti_hdpartnerkey = ts_oppartnerkey,
		ti_firsthotelpartnerkey = ts_oppartnerkey,
		ti_hdday = ts_day,
		ti_hdnights = ts_days
	from tp_servicelists with (nolock)
		inner join tp_services with (nolock) on (tl_tskey = ts_key and ts_svkey = 3)
	where tl_tikey = ti_key and ts_code = ti_firsthdkey and ti_tokey = @toKey and tl_tokey = @toKey
		and ts_tokey = @toKey and ti_CalculatingKey = @nCalculatingKey	
	------------------------------------------------------------------------------

	Set @nTotalProgress = 100
	update tp_tours with(rowlock) set to_progress = @nTotalProgress where to_key = @nPriceTourKey
	set DATEFIRST @nDateFirst
	
	select @nIsEnabled = TO_IsEnabled from TP_Tours where TO_Key = @nPriceTourKey
	
	
	--Засекаем время окончания рассчета begin
	declare @endPriceCalculate datetime
	set @endPriceCalculate = GETDATE()
	SET @sHI_Text = CONVERT(varchar(30),@endPriceCalculate,121)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11010, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Засекаем время окончания рассчета end

	--Записываем кол-во рассчитанных цен begin
	SET @sHI_Text = CONVERT(varchar(10),@calcPricesCount)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11011, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем кол-во рассчитанных цен end

	--Записываем скорость расчета цен begin
	declare @calculatingSpeed decimal(10,2), @seconds int
	set @seconds = datediff(ss,@beginPriceCalculate,@endPriceCalculate)
	if @seconds = 0
		set @seconds = 1
	set @calculatingSpeed = @calcPricesCount / @seconds
	SET @sHI_Text = CONVERT(varchar(10),@calculatingSpeed)
	EXECUTE dbo.InsertHistoryDetail @nHIID , 11012, null, @sHI_Text, null, @nUpdate, null, null, 0
	--Записываем скорость расчета цен end

	if (@nIsEnabled = 1)
	begin
		if (@isPriceListPluginRecalculation = 0)
			EXEC FillMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
		else
			EXEC FillMasterWebSearchFields @nPriceTourKey, @nCalculatingKey
	end
	
	print 'Выставление в инет: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	Return 0
END
go 

grant exec on CalculatePriceListDynamic to public

go
/*********************************************************************/
/* end sp_CalculatePriceListDynamic.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CalculatePriceListInit.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CalculatePriceListInit]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[CalculatePriceListInit]
GO

CREATE PROCEDURE [dbo].[CalculatePriceListInit]
  (
	@nPriceTourKey int,			-- ключ обсчитываемого тура
	@dtSaleDate datetime,		-- дата продажи
	@nNullCostAsZero smallint,	-- считать отсутствующие цены нулевыми (кроме проживания) 0 - нет, 1 - да
	@nNoFlight smallint,		-- при отсутствии перелёта в расписании 0 - ничего не делать, 1 - не обсчитывать тур, 2 - искать подходящий перелёт (если не найдено - не рассчитывать)
	@nUpdate smallint,			-- признак дозаписи 0 - расчет, 1 - дозапись
	@nUseHolidayRule smallint		-- Правило выходного дня: 0 - не использовать, 1 - использовать
  )
AS
--<DATE>2013-08-09</DATE>
---<VERSION>9.2.0</VERSION>
BEGIN
	declare @tourKey int
	declare @userKey int
	declare @nCPKey int
	select @tourKey = TO_TRKey from TP_Tours where TO_Key = @nPriceTourKey
	exec GetUserKey @userKey output
	
	--если не отложенный расчет
	if exists (select top 1 1 from SystemSettings where SS_ParmName like'SYSUseRecalculationByTime' and SS_ParmValue=0 )
		update TP_Tours set TO_UPDATE = 1, TO_PROGRESS = 0 where TO_Key = @nPriceTourKey
	else
		update TP_Tours set TO_UPDATE = 1 where TO_Key = @nPriceTourKey
	
	--если у нас висит прайс на отложенном расчете
	if exists (select top 1 1 from SystemSettings where SS_ParmName like'SYSUseRecalculationByTime' and SS_ParmValue=1 )
		if exists (select top 1 1 from CalculatingPriceLists where CP_TourKey=@tourKey and @nUpdate = 1)
			delete from CalculatingPriceLists where CP_TourKey=@tourKey

	insert into CalculatingPriceLists (CP_PriceTourKey, CP_SaleDate, CP_NullCostAsZero, CP_NoFlight, CP_Update, CP_TourKey, CP_UserKey, CP_Status, CP_UseHolidayRule, CP_CreateDate)
	values(@nPriceTourKey, @dtSaleDate, @nNullCostAsZero, @nNoFlight, @nUpdate, @tourKey, @userKey, 1, @nUseHolidayRule, GETDATE())
	
	Set @nCPKey = SCOPE_IDENTITY()

	Return @nCPKey
END
GO

GRANT EXEC ON [dbo].[CalculatePriceListInit] TO PUBLIC
GO
/*********************************************************************/
/* end sp_CalculatePriceListInit.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CheckQuotaExist.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckQuotaExist]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckQuotaExist]
GO

CREATE PROCEDURE [dbo].[CheckQuotaExist]
(
--<DATE>2013-08-12</VERSION>
--<VERSION>2009.2.21</VERSION>
	@SVKey int,
	@Code int,
	@SubCode1 int,
	@DateBeg datetime, 
	@DateEnd datetime,
	@DateFirst datetime,
	@PRKey int,
	@AgentKey int,
	@TourDuration smallint,
	@FilialKey int,				--пока не обрабатывается 
	@CityDepartment int,		--пока не обрабатывается 
	--возвращаемые параметры
	--при наличии Stop-Sale возвращаем

--	Убрал, не нужны более
--	@StopExist int output, --ключ стопа
--	@StopDate smalldatetime output, --дата стопа 

	--переехали из [CheckQuotaInfo]
	@TypeOfResult smallint =null,			
	/*	тип результата 
			0-возвращение полной таблицы данных (без фильтров) используется в экране проверки мест, 
			1-информация о первой подходящей квоте, 
			2-максимальное доступное число мест по всем квотам */	
	@Pax smallint =null,					--кол-во туристов по услуге
	--возвращаемые параметры, в случае @TypeOfResult=2 (попытка проверить возможность постановки услуги на квоту)
	@Wait smallint =null, --в случае не надо снимать квоту,
	@Quota_CheckState smallint =null output,
	/*	0 - RQ (можно бронировать только под запрос)
		1 - OK (можно посадить на квоту)
		2 - STOP (стоп, мест на сущ.квотах недостаточно)
		3 - RELEASE (стопа нет, есть релиз, мест на сущ.квотах недостаточно)	*/
	@Quota_CheckDate smalldatetime =null output,
	/*  если @Quota_Check=2, то в этом поле дата на которую стоит стоп */
	@Quota_CheckInfo smallint =null output,
	/*  если @Quota_Check in (0,3), то в этом поле сколько мест не хватает */

	--возвращаемые параметры, в случае @TypeOfResult=1 (возвращаем характеристики оптимальной квоты)
	@Quota_Count int =null output,
	@Quota_AgentKey int =null output,
	@Quota_Type smallint =null output,
	@Quota_ByRoom bit =null output,
	@Quota_PRKey int =null output, 
	@Quota_FilialKey int =null output,
	@Quota_CityDepartments int =null output,
	@Quota_Duration smallint =null output,
	@Quota_SubCode1 int =null output,
	@Quota_SubCode2 int =null output
	
) AS

if (@Wait=1 AND @TypeOfResult=2)
BEGIN
	set @Quota_CheckState=0
	return 0
end
declare @quoted smallint
select @quoted = isnull(SV_Quoted, 0) from Service where SV_Key = @SVKEY
if (@quoted = 0)
BEGIN
	set @Quota_CheckState=1
	return 0
end
Set @DateFirst=ISNULL(@DateFirst,@DateBeg)

declare @LimitAgentQuote bit, @LimitQuoteLong bit
set @LimitAgentQuote = 0
set @LimitQuoteLong = 0

IF EXISTS(SELECT top 1 1 FROM dbo.SystemSettings WHERE SS_ParmName='SYSLimitAgentQuote' and SS_ParmValue = 1)
	set @LimitAgentQuote = 1
IF EXISTS(SELECT top 1 1 FROM dbo.SystemSettings WHERE SS_ParmName='SYSLimitQuoteLong' and SS_ParmValue = 1)
	set @LimitQuoteLong = 1

--Проверка отсутствия Стопа
declare @StopExist int, @StopDate smalldatetime

exec CheckStopInfo 1,null,@SVKey,@Code,@SubCode1,@PRKey,@DateBeg,@DateEnd,@StopExist output,@StopDate output

declare @Q_QTID int, @Q_Partner int, @Q_ByRoom int, @Q_Type int, @Q_Release int, 
		@Q_FilialKey int, @Q_CityDepartments int, @Q_AgentKey int, @Q_Duration smallint,
		@Q_Places smallint, @ServiceWithDuration bit, @SubQuery varchar(5000), @Query varchar(5000),
		@Q_SubCode1 int, @Q_SubCode2 int, @Q_QTID_Prev int, @DaysCount int, @Q_IsByCheckIn smallint

SET @DaysCount=DATEDIFF(DAY,@DateBeg,@DateEnd)+1
SET @Q_QTID_Prev=0

SELECT @ServiceWithDuration=ISNULL(SV_IsDuration,0) FROM [Service] WHERE SV_Key=@SVKey
IF @ServiceWithDuration=1
	SET @TourDuration=DATEDIFF(DAY,@DateBeg,@DateEnd)+1

-- karimbaeva 28-04-2012 чтобы не выводилось сообщение о недостатке квоты на дополнительное место, если квота последняя и размещение на номер 
IF @SVKey = 3
begin
	if exists(SELECT TOP 1 1 FROM QuotaObjects, Quotas, QuotaDetails, QuotaParts, HotelRooms WHERE QD_QTID=QT_ID and QD_ID=QP_QDID and QO_QTID=QT_ID
	and HR_Key=@SubCode1 and HR_MAIN=0 and QT_ByRoom = 1 and (QP_AgentKey=@AgentKey or QP_AgentKey is null)
	and (QT_PRKey=@PRKey or QT_PRKey=0) and QO_Code=@Code and QD_Date between @DateBeg and @DateEnd and QP_Date = QD_Date
	and QP_ID in (select SD_QPID
					from ServiceByDate as SBD2 join RoomPlaces as RP2 on SBD2.SD_RPID = RP2.RP_ID
					where RP2.RP_Type = 0))
	begin
		set @Quota_CheckInfo = 0
		Set @Quota_CheckState = 1
		If @StopExist > 0
		BEGIN
			Set @Quota_CheckState = 2						
			Set @Quota_CheckDate = @StopDate
		END
		return 0
	end
end
	
-- создаем таблицу со стопами
CREATE TABLE #StopSaleTemp
(SST_Code int, SST_SubCode1 int, SST_SubCode2 int, SST_QOID int, SST_PRKey int, SST_Date smalldatetime,
SST_QDID int, SST_Type smallint, SST_State smallint, SST_Comment varchar(255)
)

-- Task 9148 31.10.2012 ошибка при преобразовании datetime в smalldatetime
if @DateBeg<'1900-01-01'
	set @DateBeg='1900-01-01'
--
INSERT INTO #StopSaleTemp exec dbo.GetTableQuotaDetails NULL, @Q_QTID, @DateBeg, @DaysCount, null, null, @SVKey, @Code, @SubCode1, @PRKey

IF @SVKey=3
BEGIN
	declare CheckQuotaExistСursor cursor for 
		select	DISTINCT QT_ID, QT_PRKey, QT_ByRoom, 
				QD_Type, 
				QP_FilialKey, QP_CityDepartments, QP_AgentKey, CASE WHEN QP_Durations='' THEN 0 ELSE @TourDuration END, QP_FilialKey, QP_CityDepartments, 
				QO_SubCode1, QO_SubCode2, QT_IsByCheckIn
		from	QuotaObjects, Quotas, QuotaDetails, QuotaParts, HotelRooms
		where	QO_SVKey=@SVKey and QO_Code=@Code and HR_Key=@SubCode1 and (QO_SubCode1=HR_RMKey or QO_SubCode1=0) and (QO_SubCode2=HR_RCKey or QO_SubCode2=0) and QO_QTID=QT_ID
			and QD_QTID=QT_ID and QD_Date between @DateBeg and @DateEnd
			and QP_Date = QD_Date
			and QP_QDID = QD_ID
			and (QP_AgentKey=@AgentKey or QP_AgentKey is null) 
			and (QT_PRKey=@PRKey or QT_PRKey=0)
			and QP_IsDeleted is null and QD_IsDeleted is null	
			and (QP_Durations = '' or @TourDuration in (Select QL_Duration From QuotaLimitations Where QL_QPID=QP_ID))
			and not exists(select top 1 1
							from #StopSaleTemp 
							where SST_PRKey = QT_PRKey
							and SST_QOID = QO_ID
							and SST_QDID = QD_ID
							and SST_Date = QD_Date
							and SST_State is not null)
		group by QT_ID, QT_PRKey, QT_ByRoom, QD_Type, QP_FilialKey, QP_CityDepartments, QP_AgentKey, QP_Durations, QO_SubCode1, QO_SubCode2, QT_IsByCheckIn
		--having Count(*) = (@Days+1)
		order by QP_AgentKey DESC, QT_PRKey DESC
END
ELSE
BEGIN
	declare CheckQuotaExistСursor cursor for 
		select	DISTINCT QT_ID, QT_PRKey, QT_ByRoom, 
				QD_Type, 
				QP_FilialKey, QP_CityDepartments, QP_AgentKey, CASE WHEN QP_Durations='' THEN 0 ELSE @TourDuration END, QP_FilialKey, QP_CityDepartments, 
				QO_SubCode1, QO_SubCode2, QT_IsByCheckIn
		from	QuotaObjects, Quotas, QuotaDetails, QuotaParts
		where	
			QO_SVKey = @SVKey and QO_Code = @Code and (QO_SubCode1=@SubCode1 or QO_SubCode1=0) and QO_QTID=QT_ID
			and QD_QTID = QT_ID and QD_Date between @DateBeg and @DateEnd
			and QP_QDID = QD_ID
			and QP_Date = QD_Date
			and (QP_AgentKey=@AgentKey or QP_AgentKey is null) 
			and (QT_PRKey=@PRKey or QT_PRKey=0)
			and QP_IsDeleted is null and QD_IsDeleted is null	
			and (QP_Durations = '' or @TourDuration in (Select QL_Duration From QuotaLimitations Where QL_QPID=QP_ID))
			and not exists(select top 1 1
							from #StopSaleTemp 
							where SST_PRKey = QT_PRKey
							and SST_QOID = QO_ID
							and SST_QDID = QD_ID
							and SST_Date = QD_Date
							and SST_State is not null)
		group by QT_ID, QT_PRKey, QT_ByRoom, QD_Type, QP_FilialKey, QP_CityDepartments, QP_AgentKey, QP_Durations, QO_SubCode1, QO_SubCode2, QT_IsByCheckIn
		order by QP_AgentKey DESC, QT_PRKey DESC
END
open CheckQuotaExistСursor
fetch CheckQuotaExistСursor into	@Q_QTID, @Q_Partner, @Q_ByRoom, 
									@Q_Type, 
									@Q_FilialKey, @Q_CityDepartments, @Q_AgentKey, @Q_Duration, @Q_FilialKey, @Q_CityDepartments, 
									@Q_SubCode1, @Q_SubCode2, @Q_IsByCheckIn

CREATE TABLE #Tbl (	TMP_Count int, TMP_QTID int, TMP_AgentKey int, TMP_Type smallint, TMP_Date datetime, 
					TMP_ByRoom bit, TMP_Release smallint, TMP_Partner int, TMP_Durations nvarchar(25) COLLATE Cyrillic_General_CI_AS, TMP_FilialKey int, 
					TMP_CityDepartments int, TMP_SubCode1 int, TMP_SubCode2 int, TMP_IsByCheckIn smallint, TMP_DurationsCheckIn nvarchar(25))

While (@@fetch_status = 0)
BEGIN
	SET @SubQuery = 'QD_QTID = QT_ID and QP_QDID = QD_ID 
		and QT_ID=' + CAST(@Q_QTID as varchar(10)) + '
		and QT_ByRoom=' + CAST(@Q_ByRoom as varchar(1)) + ' 
		and QD_Type=' + CAST(@Q_Type as varchar(1)) + ' 
		and QO_SVKey=' + CAST(@SVKey as varchar(10)) + '
		and QO_Code=' + CAST(@Code as varchar(10)) + ' 
		and QO_SubCode1=' + CAST(@Q_SubCode1 as varchar(10)) + ' 
		and QO_SubCode2=' + CAST(@Q_SubCode2 as varchar(10)) + '	
		and (QD_Date between ''' + CAST((@DateBeg) as varchar(20)) + ''' and ''' + CAST(@DateEnd as varchar(20)) + ''') and QD_IsDeleted is null'

	IF @Q_FilialKey is null
		SET @SubQuery = @SubQuery + ' and QP_FilialKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_FilialKey=' + CAST(@Q_FilialKey as varchar(10))
	IF @Q_CityDepartments is null
		SET @SubQuery = @SubQuery + ' and QP_CityDepartments is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_CityDepartments=' + CAST(@Q_CityDepartments as varchar(10))
	IF @Q_AgentKey is null
		SET @SubQuery = @SubQuery + ' and QP_AgentKey is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_AgentKey=' + CAST(@Q_AgentKey as varchar(10))		
	IF @Q_Duration=0
		SET @SubQuery = @SubQuery + ' and QP_Durations = '''' '
	ELSE
		SET @SubQuery = @SubQuery + ' and QP_ID in (Select QL_QPID From QuotaLimitations Where QL_Duration=' + CAST(@Q_Duration as varchar(5)) + ') '
	IF @Q_Partner =''
		SET @SubQuery = @SubQuery + ' and QT_PRKey = '''' '
	ELSE
		SET @SubQuery = @SubQuery + ' and QT_PRKey=' + CAST(@Q_Partner as varchar(10))
	IF @Q_IsByCheckIn is null
		SET @SubQuery = @SubQuery + ' and QT_IsByCheckIn is null'
	ELSE
		SET @SubQuery = @SubQuery + ' and QT_IsByCheckIn=' + CAST(@Q_IsByCheckIn as varchar(10))

	declare @SubCode2 int
	
	IF (@Q_IsByCheckIn = 0 or @Q_IsByCheckIn is null)
		SET @Query = 
		'
		INSERT INTO #Tbl (	TMP_Count, TMP_QTID, TMP_AgentKey, TMP_Type, TMP_Date, 
							TMP_ByRoom, TMP_Release, TMP_Partner, TMP_Durations, TMP_FilialKey, 
							TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn)
			SELECT	DISTINCT QP_Places-QP_Busy as d1, QT_ID, QP_AgentKey, QD_Type, QD_Date, 
					QT_ByRoom, QD_Release, QT_PRKey, QP_Durations, QP_FilialKey,
					QP_CityDepartments, QO_SubCode1, QO_SubCode2, QT_IsByCheckIn, '''' 
			FROM	Quotas QT1, QuotaDetails QD1, QuotaParts QP1, QuotaObjects QO1, #StopSaleTemp
			WHERE	QO_ID = SST_QOID and QD_ID = SST_QDID and SST_State is null and ' + @SubQuery
	
	IF @Q_IsByCheckIn = 1
		SET @Query = 
		'
		INSERT INTO #Tbl (	TMP_Count, TMP_QTID, TMP_AgentKey, TMP_Type, TMP_Date, 
							TMP_ByRoom, TMP_Release, TMP_Partner, TMP_Durations, TMP_FilialKey, 
							TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn)
			SELECT	DISTINCT QP_Places-QP_Busy as d1, QT_ID, QP_AgentKey, QD_Type, QD_Date, 
					QT_ByRoom, QD_Release, QT_PRKey, QP_Durations, QP_FilialKey,
					QP_CityDepartments, QO_SubCode1, QO_SubCode2, QT_IsByCheckIn, convert(nvarchar(max) ,QD_LongMin) + ''-'' + convert(nvarchar(max) ,QD_LongMax)
			FROM	Quotas QT1, QuotaDetails QD1, QuotaParts QP1, QuotaObjects QO1, #StopSaleTemp
			WHERE	QO_ID = SST_QOID and QD_ID = SST_QDID and SST_State is null and ' + @SubQuery
			
	print @Query

	exec (@Query)
	
	SET @Q_QTID_Prev=@Q_QTID
	fetch CheckQuotaExistСursor into	@Q_QTID, @Q_Partner, @Q_ByRoom, 
										@Q_Type, 
										@Q_FilialKey, @Q_CityDepartments, @Q_AgentKey, @Q_Duration, @Q_FilialKey, @Q_CityDepartments, 
										@Q_SubCode1, @Q_SubCode2, @Q_IsByCheckIn	
END

--select * from #tbl

/*
Обработаем настройки
						При наличии квоты на агенство, запретить бронирование из общей квоты
						При наличии квоты на продолжительность, запретить бронировать из квоты без продолжительности
*/

-- если стоят 2 настройки и параметры пришли и на продолжительность и на агенство и есть такая квота сразу на агенство и на продолжительность,
-- то удалим остальные
if ((@LimitAgentQuote = 1) and (@LimitQuoteLong = 1))
begin
	if ((isnull(@AgentKey, 0) != 0) and (isnull(@TourDuration, 0) != 0) and (exists (select top 1 1 from #Tbl where isnull(TMP_AgentKey, 0) = @AgentKey and isnull(TMP_Durations, 0) = @TourDuration)))
	begin
		delete #Tbl where isnull(TMP_AgentKey, 0) != @AgentKey or isnull(TMP_Durations, 0) != @TourDuration
	end
	
	--бывают случаии когда обе настройки включены, но найти нужно только по одному из параметров
	if (exists (select top 1 1 from #Tbl where isnull(TMP_AgentKey, 0) = @AgentKey))
	begin
		delete #Tbl where isnull(TMP_AgentKey, 0) != @AgentKey
	end
	if (exists (select top 1 1 from #Tbl where isnull(TMP_Durations, 0) = @TourDuration))
	begin
		delete #Tbl where isnull(TMP_Durations, 0) != @TourDuration
	end
end
-- если стоит настройка только на агенство и нам пришол параметром агенство и квота на агенство есть,
-- то удалим остальные
else if ((@LimitAgentQuote = 1) and (@LimitQuoteLong = 0) and (isnull(@AgentKey, 0) != 0) and (exists (select top 1 1 from #Tbl where isnull(TMP_AgentKey, 0) = @AgentKey)))
begin
	delete #Tbl where isnull(TMP_AgentKey, 0) != @AgentKey
end
-- если есть настройка на продолжительность, и нам пришол параметр продолжительность и есть квота на продолжительность,
-- то удалим остальные
else if ((@LimitAgentQuote = 0) and (@LimitQuoteLong = 1) and (isnull(@TourDuration, 0) != 0) and (exists (select top 1 1 from #Tbl where isnull(TMP_Durations, 0) = @TourDuration)))
begin
	delete #Tbl where isnull(TMP_Durations, 0) != @TourDuration	
end

DELETE FROM #Tbl WHERE exists 
		(SELECT top 1 1  FROM QuotaParts QP2, QuotaDetails QD2, Quotas QT2 
		WHERE	QT_ID=QD_QTID and QP_QDID=QD_ID
				and QD_Type=TMP_Type and QT_ByRoom=TMP_ByRoom
				and QD_IsDeleted is null and QP_IsDeleted is null
				and QT_ID=TMP_QTID
				and ISNULL(QP_FilialKey,-1)=ISNULL(TMP_FilialKey,-1) and ISNULL(QP_CityDepartments,-1)=ISNULL(TMP_CityDepartments,-1)
				and ISNULL(QP_AgentKey,-1)=ISNULL(TMP_AgentKey,-1) and ISNULL(QT_PRKey,-1)=ISNULL(TMP_Partner,-1)
				and QP_Durations=TMP_Durations and ISNULL(QD_Release,-1)=ISNULL(TMP_Release,-1)
				and QD_Date=@DateFirst and (QP_IsNotCheckIn=1 or QP_CheckInPlaces-QP_CheckInPlacesBusy <= 0))

close CheckQuotaExistСursor
deallocate CheckQuotaExistСursor

DECLARE @Tbl_DQ Table 
 		(TMP_Count smallint, TMP_AgentKey int, TMP_Type smallint, TMP_ByRoom bit, 
				TMP_Partner int, TMP_Duration smallint, TMP_FilialKey int, TMP_CityDepartments int,
				TMP_SubCode1 int, TMP_SubCode2 int, TMP_ReleaseIgnore bit, TMP_IsByCheckIn smallint, TMP_DurationsCheckIn nvarchar(25))

DECLARE @DATETEMP datetime
SET @DATETEMP = GetDate()
-- Разрешим посадить в квоту с релиз периодом 0 текущим числом
set @DATETEMP = DATEADD(day, -1, @DATETEMP)
if exists (select top 1 1 from systemsettings where SS_ParmName='SYSAddQuotaPastPermit' and SS_ParmValue=1 and @DateBeg < @DATETEMP)
	SET @DATETEMP='01-JAN-1900'
INSERT INTO @Tbl_DQ
	SELECT	MIN(d1) as TMP_Count, TMP_AgentKey, TMP_Type, TMP_ByRoom, TMP_Partner, 
			d2 as TMP_Duration, TMP_FilialKey, TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2, 0 as TMP_ReleaseIgnore, TMP_IsByCheckIn, TMP_DurationsCheckIn FROM
		(SELECT	SUM(TMP_Count) as d1, TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner, 
				TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END as d2, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn
		FROM	#Tbl
		WHERE	(TMP_Date >= @DATETEMP + ISNULL(TMP_Release,0) OR (TMP_Date < GETDATE() - 1))
		GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
					TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn) D
	GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
				TMP_FilialKey, TMP_CityDepartments, d2, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn
	HAVING count(*)=DATEDIFF(day,@DateBeg,@DateEnd)+1
	UNION
	SELECT	MIN(d1) as TMP_Count, TMP_AgentKey, TMP_Type, TMP_ByRoom, TMP_Partner, 
			d2 as TMP_Duration, TMP_FilialKey, TMP_CityDepartments, TMP_SubCode1, TMP_SubCode2, 1 as TMP_ReleaseIgnore, TMP_IsByCheckIn, TMP_DurationsCheckIn FROM
		(SELECT	SUM(TMP_Count) as d1, TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner, 
				TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END as d2, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn
		FROM	#Tbl
		GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
					TMP_FilialKey, TMP_CityDepartments, TMP_Date, CASE WHEN TMP_Durations='' THEN 0 ELSE @TourDuration END, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn) D
	GROUP BY	TMP_Type, TMP_ByRoom, TMP_AgentKey, TMP_Partner,
				TMP_FilialKey, TMP_CityDepartments, d2, TMP_SubCode1, TMP_SubCode2, TMP_IsByCheckIn, TMP_DurationsCheckIn
	HAVING count(*)=DATEDIFF(day,@DateBeg,@DateEnd)+1


/*
Комментарии к запросу выше!!!
Заполняем таблицу квот, которые могут нам подойти (группируя квоты по всем разделяемым параметрам, кроме релиз-периода
Все строки в таблице дублируются (важно! 11-ый параметр): 
	квоты с учетом релиз-периода (0) --TMP_ReleaseIgnore
	квоты без учета релиз-периода (1)--TMP_ReleaseIgnore
При выводе всех доступных квот требуется отсекать строки без учета релиз-периода и с количеством мест <=0 
*/

DECLARE @IsCommitmentFirst bit
IF Exists (SELECT SS_ID FROM dbo.SystemSettings WHERE SS_ParmName='SYS_Commitment_First' and SS_ParmValue='1')
	SET @IsCommitmentFirst=1

If @TypeOfResult is null or @TypeOfResult=0
BEGIN
	IF @IsCommitmentFirst=1
		select * from @Tbl_DQ order by TMP_IsByCheckIn DESC
	ELSE
		select * from @Tbl_DQ order by TMP_IsByCheckIn DESC
END

DECLARE @Priority int;
SELECT @Priority=QPR_Type FROM   QuotaPriorities 
WHERE  QPR_Date=@DateFirst and QPR_SVKey = @SVKey and QPR_Code=@Code and QPR_PRKey=@PRKey

IF @Priority is not null
	SET @IsCommitmentFirst=@Priority-1

If @TypeOfResult=1 --(возвращаем характеристики оптимальной квоты)
BEGIN
	If exists (SELECT top 1 1 FROM @Tbl_DQ)
	BEGIN
		IF @Quota_Type=1 or @IsCommitmentFirst=1
			select	TOP 1 @Quota_Count=TMP_Count, 
					@Quota_AgentKey=TMP_AgentKey, @Quota_Type=TMP_Type, @Quota_ByRoom=TMP_ByRoom,
					@Quota_PRKey=TMP_Partner, @Quota_FilialKey=TMP_FilialKey, @Quota_CityDepartments=TMP_CityDepartments, 
					@Quota_Duration=TMP_Duration, @Quota_SubCode1=TMP_SubCode1, @Quota_SubCode2=TMP_SubCode2
			from	@Tbl_DQ 
			where	TMP_Count>0 and TMP_ReleaseIgnore=0
			order by TMP_ReleaseIgnore, TMP_Type DESC, TMP_Partner DESC, TMP_AgentKey DESC, TMP_SubCode1 DESC, TMP_SubCode2 DESC, TMP_Duration DESC
		ELSE
			select	TOP 1 @Quota_Count=TMP_Count, 
					@Quota_AgentKey=TMP_AgentKey, @Quota_Type=TMP_Type, @Quota_ByRoom=TMP_ByRoom,
					@Quota_PRKey=TMP_Partner, @Quota_FilialKey=TMP_FilialKey, @Quota_CityDepartments=TMP_CityDepartments, 
					@Quota_Duration=TMP_Duration, @Quota_SubCode1=TMP_SubCode1, @Quota_SubCode2=TMP_SubCode2
			from	@Tbl_DQ 
			where	TMP_Count>0 and TMP_ReleaseIgnore=0
			order by TMP_ReleaseIgnore, TMP_Type, TMP_Partner DESC, TMP_AgentKey DESC, TMP_SubCode1 DESC, TMP_SubCode2 DESC, TMP_Duration DESC
	END
END

	--Проверим на стоп	
	--если есть два стопа, то это либо общий стоп, либо два отдельных стопа
	if @StopExist > 1
		and exists(select 1 from #StopSaleTemp where SST_State is not null and SST_Date between @DateBeg and @DateEnd and SST_Type=1)
		and exists(select 1 from #StopSaleTemp where SST_State is not null and SST_Date between @DateBeg and @DateEnd and SST_Type=2)
	BEGIN
		Set @Quota_CheckState = 2
		Set @Quota_CheckDate = @StopDate
		return
	END
	
	--если существуют стоп на один тип квот, а другой тип квот заведен неполностью или не заведен вовсе
	if (@StopExist > 0
			and
			(
				exists(select 1 from #StopSaleTemp where SST_Date between @DateBeg and @DateEnd and SST_Type=1 and SST_State is not null)
				and (select count (distinct TMP_Date) from #Tbl where TMP_QTID not in (select TMP_QTID from #Tbl,#StopSaleTemp where TMP_Date=SST_Date and SST_State=2 and SST_Type=1) and TMP_Type=1) > 0
				and (select count (distinct TMP_Date) from #Tbl where TMP_QTID not in (select TMP_QTID from #Tbl,#StopSaleTemp where TMP_Date=SST_Date and SST_State=2 and SST_Type=2) and TMP_Type=2) < @DaysCount
				or
				exists(select 1 from #StopSaleTemp where SST_Date between @DateBeg and @DateEnd and SST_Type=2 and SST_State is not null)
				and (select count (distinct TMP_Date) from #Tbl where TMP_QTID not in (select TMP_QTID from #Tbl,#StopSaleTemp where TMP_Date=SST_Date and SST_State=2 and SST_Type=2) and TMP_Type=2) > 0
				and (select count (distinct TMP_Date) from #Tbl where TMP_QTID not in (select TMP_QTID from #Tbl,#StopSaleTemp where TMP_Date=SST_Date and SST_State=2 and SST_Type=1) and TMP_Type=1) < @DaysCount
			)
		)
	BEGIN
		Set @Quota_CheckState = 2
		Set @Quota_CheckDate = @StopDate
		return
	END

	--если существуют два стопа и нет дней с незаведенными квотами
	if (@StopExist > 0 and
		exists(select 1 from #StopSaleTemp where SST_Date between @DateBeg and @DateEnd and SST_Type=1 and SST_State is not null) and
		exists(select 1 from #StopSaleTemp where SST_Date between @DateBeg and @DateEnd and SST_Type=2 and SST_State is not null) and
		((select COUNT(distinct SST_Date) from #StopSaleTemp where SST_Type=1) = @DaysCount) and
			((select COUNT(distinct SST_Date) from #StopSaleTemp where SST_Type=2) = @DaysCount))
	BEGIN
		Set @Quota_CheckState = 2
		Set @Quota_CheckDate = @StopDate
		return
	END

	--если есть стоп на commitment и закончился релиз-период на alotment, или наоборот...
	if (not exists(select 1 from #Tbl where TMP_Type=2 and TMP_Date = @DateBeg and dateadd(day, -1, GETDATE()) < (@DateBeg - ISNULL(TMP_Release, 0)))
		and
		(select count (distinct TMP_Date) from #Tbl where TMP_QTID not in (select TMP_QTID from #Tbl,#StopSaleTemp where TMP_Date=SST_Date and SST_State=2 and SST_Type=TMP_Type) and TMP_Type=1) < @DaysCount
		or
		not exists(select 1 from #Tbl where TMP_Type=1 and TMP_Date = @DateBeg and dateadd(day, -1, GETDATE()) < (@DateBeg - ISNULL(TMP_Release, 0)))
		and
		(select count (distinct TMP_Date) from #Tbl where TMP_QTID not in (select TMP_QTID from #Tbl,#StopSaleTemp where TMP_Date=SST_Date and SST_State=2 and SST_Type=TMP_Type) and TMP_Type=2) < @DaysCount)
	begin
		if exists(select 1 from #Tbl where TMP_Release is not null and TMP_Release!=0 and TMP_Date = @DateBeg AND dateadd(day, -1, GETDATE()) >= (@DateBeg - ISNULL(TMP_Release, 0)))
		begin
			set @Quota_CheckState = 3	-- наступил РЕЛИЗ-Период
			return
		end
	end
	
	--если существует стоп и на первый день нет квот
	If @StopExist > 0 and not exists (select 1 from #Tbl where TMP_Count > 0 and TMP_Date = @DateBeg)
	BEGIN
		Set @Quota_CheckState = 2						--Возвращаем "Внимание STOP"
		Set @Quota_CheckDate = @StopDate
		return
	END

	--Проверим на наличие квот
	if not exists (select 1 from #Tbl where TMP_Count > 0)
	begin
		Set @Quota_CheckState = 0
		return
	end

If @TypeOfResult=2 --(попытка проверить возможность постановки услуги на квоту)
BEGIN
	DECLARE @Places_Count int, @Rooms_Count int,		 --доступное количество мест/номеров в квотах
			@Places_Count_ReleaseIgnore int, @Rooms_Count_ReleaseIgnore int,		 --доступное количество мест/номеров в квотах
			@PlacesNeed_Count smallint,					-- количество мест, которых недостаточно для оформления услуги
			@PlacesNeed_Count_ReleaseIgnore smallint					-- количество мест, которых недостаточно для оформления услуги

	If exists (SELECT top 1 1 FROM @Tbl_DQ)
	BEGIN
		set @PlacesNeed_Count = 0
		set @PlacesNeed_Count_ReleaseIgnore = 0
		
		select @Places_Count = SUM(TMP_Count) from @Tbl_DQ where TMP_Count > 0 and TMP_ByRoom = 0 and TMP_ReleaseIgnore = 0
		select @Places_Count_ReleaseIgnore = SUM(TMP_Count) from @Tbl_DQ where TMP_Count > 0 and TMP_ByRoom = 0 and TMP_ReleaseIgnore = 1

		If @SVKey=3
		begin
			select @Rooms_Count = SUM(TMP_Count) from @Tbl_DQ where TMP_Count > 0 and TMP_ByRoom = 1 and TMP_ReleaseIgnore = 0
			select @Rooms_Count_ReleaseIgnore = SUM(TMP_Count) from @Tbl_DQ where TMP_Count > 0 and TMP_ByRoom = 1 and TMP_ReleaseIgnore = 1
		end
		
		Set @Places_Count = ISNULL(@Places_Count,0)
		Set @Rooms_Count = ISNULL(@Rooms_Count,0)
		Set @Places_Count_ReleaseIgnore = ISNULL(@Places_Count_ReleaseIgnore,0)
		Set @Rooms_Count_ReleaseIgnore = ISNULL(@Rooms_Count_ReleaseIgnore,0)
		
		SET @StopExist = ISNULL(@StopExist, 0)
		
		--проверяем достаточно ли будет текущего кол-ва мест для бронирования, если нет устанавливаем статус бронирования под запрос
		declare @nPlaces smallint, @nRoomsService smallint
		If @SVKey = 3 and @Rooms_Count > 0
		BEGIN
			exec GetServiceRoomsCount @Code, @SubCode1, @Pax, @nRoomsService output
			
			If @nRoomsService > @Rooms_Count
			begin
				Set @PlacesNeed_Count = @nRoomsService - @Rooms_Count
				Set @Quota_CheckState = 0
			end
				
			If @nRoomsService > @Rooms_Count_ReleaseIgnore
			begin
				Set @PlacesNeed_Count_ReleaseIgnore = @nRoomsService - @Rooms_Count_ReleaseIgnore
				Set @Quota_CheckState = 0
			end
		END
		ELSE
		begin
			If @Pax > @Places_Count
			begin
				Set @PlacesNeed_Count = @Pax - @Places_Count
				Set @Quota_CheckState = 0
			end 
			
			If @Pax > @Places_Count_ReleaseIgnore
			begin
				Set @PlacesNeed_Count_ReleaseIgnore = @Pax - @Places_Count_ReleaseIgnore
				Set @Quota_CheckState = 0
			end
		end
		
		-- проверим на релиз
		If @PlacesNeed_Count_ReleaseIgnore <= 0 --мест в квоте хватило
			Set @Quota_CheckState = 3						--Возвращаем "Release" (мест не достаточно, но наступил РЕЛИЗ-Период)"
		
		If @PlacesNeed_Count <= 0 --мест в квоте хватило
			Set @Quota_CheckState = 1						--Возвращаем "Ok (квоты есть)"
		else
			set @Quota_CheckInfo = @PlacesNeed_Count
	END
	else
	begin
		-- если выборка пустая
		Set @Quota_CheckState = 0
	end
END
GO
grant exec on [dbo].[CheckQuotaExist] to public
go

/*********************************************************************/
/* end sp_CheckQuotaExist.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CorrectionCalculatedPrice_GetServiceTypeKey.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CorrectionCalculatedPrice_GetServiceTypeKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CorrectionCalculatedPrice_GetServiceTypeKey]
GO

CREATE PROCEDURE [dbo].[CorrectionCalculatedPrice_GetServiceTypeKey]
	(
		-- version 2009.9.20
		-- date 2013-08-28
		@dateList xml
	)
AS
BEGIN
	SET NOCOUNT ON;
	SET ARITHABORT ON;

	select distinct TS_SVKey
	from TP_Services
	where TS_TOKey in 
		(select TD_TOKey 
		 from  TP_TurDates 
		 where exists (
			select top 1 1 from @dateList.nodes('/ArrayOfDateTime/dateTime') as tbl(res) where res.value('.', 'datetime') = TD_Date))
	and TS_SVKey is not null
	and TS_Code is not null
	and TS_CNKey is not null
	and TS_CTKey is not null
	
END
GO

grant execute on [dbo].[CorrectionCalculatedPrice_GetServiceTypeKey] to public
GO


/*********************************************************************/
/* end sp_CorrectionCalculatedPrice_GetServiceTypeKey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CorrectionCalculatedPrice_GetServiceVariant.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CorrectionCalculatedPrice_GetServiceVariant]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CorrectionCalculatedPrice_GetServiceVariant]
GO

CREATE PROCEDURE [dbo].[CorrectionCalculatedPrice_GetServiceVariant]
	(
		-- version 2009.9.20
		-- date 2013-08-28
		@serviceTypeKey int,
		@dateList xml
	)
AS
BEGIN
	SET NOCOUNT ON;
	SET ARITHABORT ON;
	
	select distinct TS_Code, TS_CNKey, TS_CTKey
	from TP_Services with (nolock)
	where TS_TOKey in 
			(select TD_TOKey 
			 from TP_TurDates 
			 where TD_TOKey = TS_TOKey
				and exists (select top 1 1 from @dateList.nodes('/ArrayOfDateTime/dateTime') as tbl(res) where res.value('.', 'datetime') = TD_Date))
	and TS_SVKey = @serviceTypeKey
	and TS_Code is not null
	and TS_CNKey is not null
	and TS_CTKey is not null
END
GO

grant execute on [dbo].[CorrectionCalculatedPrice_GetServiceVariant] to public
GO

/*********************************************************************/
/* end sp_CorrectionCalculatedPrice_GetServiceVariant.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CorrectionCalculatedPrice_GetTurDurationList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CorrectionCalculatedPrice_GetTurDurationList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CorrectionCalculatedPrice_GetTurDurationList]
GO

CREATE PROCEDURE [dbo].[CorrectionCalculatedPrice_GetTurDurationList]
	(
		-- version 2009.9.20
		-- date 2013-08-28
		@serviceTypeKey int,
		@serviceCodeList xml,
		@turList xml,
		@dateList xml
	)
AS
BEGIN
	SET NOCOUNT ON;
	SET ARITHABORT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	create table #tmp_services (TL_TIKey int primary key)
	
	
	insert into #tmp_services
	select distinct TL_TIKey
	from TP_ServiceLists 
	where TL_TSKey in 
			(select TS_Key 
			 from TP_Services 
			 where TS_SVKey = @serviceTypeKey
				and TS_Code in (select tbl.res.value('.', 'int') from @serviceCodeList.nodes('/ArrayOfInt/int') as tbl(res))
				and TS_TOKey in (select tbl.res.value('.', 'int') from @turList.nodes('/ArrayOfInt/int') as tbl(res)))

	create table #tmp_Prices (TP_TIKey int primary key)
	
	insert into #tmp_Prices
	select distinct TP_TIKey
	from TP_Prices 
	where TP_TIKey in 
			(select TL_TIKey
			 from #tmp_services
			 where TP_DateBegin in (select res.value('.', 'datetime') from @dateList.nodes('/ArrayOfDateTime/dateTime') as tbl(res)))

	select distinct ti_totaldays as TurDuration
    from TP_Lists 
    where TI_Key in (select TP_TIKey from #tmp_Prices)
    and ti_totaldays is not null
END
GO

grant execute on [dbo].[CorrectionCalculatedPrice_GetTurDurationList] to public
GO

/*********************************************************************/
/* end sp_CorrectionCalculatedPrice_GetTurDurationList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CorrectionCalculatedPrice_GetTurList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CorrectionCalculatedPrice_GetTurList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CorrectionCalculatedPrice_GetTurList]
GO

CREATE PROCEDURE [dbo].[CorrectionCalculatedPrice_GetTurList]
	(
		-- version 2009.9.20
		-- date 2013-08-28
		@serviceTypeKey int,
		@serviceCodeList xml,
		@dateList xml,
		@filterString nvarchar(max)
	)
AS
begin
	SET NOCOUNT ON;
	SET ARITHABORT ON;
	
	create table #tmpTours (TS_TOKey int primary key)
	
	insert into #tmpTours 
	select distinct TS_TOKey
	from dbo.TP_Services with (nolock) 
	where TS_SVKey = @serviceTypeKey
	and TS_Code in (select tbl.res.value('.', 'int') from @serviceCodeList.nodes('/ArrayOfInt/int') as tbl(res))
		
	if (isnull(@filterString, '') = '')
	begin
		select distinct TO_Key as TurKey, TO_Name + ' (' + TL_Name + ')' as TurName
		from TP_Tours with (nolock) join tbl_TurList with (nolock) on TO_TRKey = TL_Key
		where TO_Key in (select TS_TOKey from #tmpTours)
		and exists (select top 1 1 from dbo.TP_TurDates with (nolock) where TD_TOKey = TO_Key
					and exists (select top 1 1 from @dateList.nodes('/ArrayOfDateTime/dateTime') as tbl(res) where res.value('.', 'datetime') = TD_Date))
		and TO_UPDATE != 1
	end
	else
	begin
		select distinct TO_Key as TurKey, TO_Name + ' (' + TL_Name + ')' as TurName
		from TP_Tours with (nolock) join tbl_TurList with (nolock) on TO_TRKey = TL_Key 
		where TO_Key in (select TS_TOKey from #tmpTours)
		and TO_Key in (select TD_TOKey from dbo.TP_TurDates with (nolock) 
					where exists (select top 1 1 from @dateList.nodes('/ArrayOfDateTime/dateTime') as tbl(res) where res.value('.', 'datetime') = TD_Date))
		and TO_Name + ' (' + TL_Name + ')' like '%' + @filterString + '%'
		and TO_UPDATE != 1
	end
END

GO

grant execute on [dbo].[CorrectionCalculatedPrice_GetTurList] to public
GO



/*********************************************************************/
/* end sp_CorrectionCalculatedPrice_GetTurList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_CostOfferChangeState.sql */
/*********************************************************************/
--<VERSION>2009.2.19.1</VERSION>
--<DATE>2013-05-21</DATE>
--хранимка активирует, деактивирует или публикует ЦБ

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CostOfferChangeState]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CostOfferChangeState]
GO

CREATE PROCEDURE [dbo].[CostOfferChangeState]
	(
		-- ключ ЦБ
		-- null - если вызов ХП осуществляется без передачи параметров, и тогда берем первый попавшийся ЦБ
		@coId int=null,
		-- ключ операции 1 - активировать, 2 - деактивировать, 3 - публиковать
		@operationId smallint=null
	)
AS

declare @datefirst int
set @datefirst = @@datefirst
set datefirst 1

BEGIN TRY

	Set NOCOUNT OFF
	-- проверяем, что было перадано процедуре во входных параметрах
	-- если входные параметры отсут-т, то выбираем 1ый ЦБ из очереди, который ожидает обработки 
	-- или в противном случае берем тот, который в прошлый раз завершился с ошибкой
	-- 0(ожидает), 1 (в обработке), -1(завершилось с ошибкой)
	BEGIN TRANSACTION
	DECLARE @rowcount INT
	DECLARE @COQueuesCount INT
	if(@coId is null Or @operationId is null)
	BEGIN 		
		-- кол-во костофферов в таблице очереди [QueuesCostOffers]
		declare @costOffersCount int
		select @costOffersCount = COUNT(*) from [dbo].[QueuesCostOffers] where [QCO_State] = 0 or [QCO_State] = -1
		if(@costOffersCount > 0)
		begin
			select top 1 @coId = [QCO_COId], @operationId = [QCO_OperationId] from [QueuesCostOffers]
			where [QCO_State] = 0 or [QCO_State] = -1
			order by [QCO_State] desc, QCO_QueuedDate
		end
		ELSE
		begin
			PRINT 'В таблице отсутствуют ценовые блоки для обработки'
			ROLLBACK TRANSACTION
            RETURN
		end
	END

	-- обновляем состояние очереди для текущего ЦБ в 1, чтобы проинформировать о процессе обработки ЦБ
	update [QueuesCostOffers]
	set [QCO_State] = 1
	where [QCO_COId] = @coId and [QCO_OperationId] = @operationId
	SET @rowcount = @@ROWCOUNT
	COMMIT TRANSACTION
	
	IF @rowcount = 1
	begin
		-- временная таблица для цен
		declare @spadIdTable table
		(
			spadId bigint		
		)
		
		-- временная таблица для цен на будущие даты
		declare @spndIdTable table
		(
			spndId bigint
		)

		-- активация ценового блока или деактивация
		if (@operationId = 1 or @operationId = 2)
		begin	
			insert into @spadIdTable (spadId)
			select spad.SPAD_Id
			from (dbo.TP_ServicePriceActualDate as spad with (nolock)
					join dbo.TP_ServiceCalculateParametrs as scp with (nolock) on spad.SPAD_SCPId = scp.SCP_Id
					join dbo.TP_ServiceComponents as sc with (nolock) on scp.SCP_SCId = sc.SC_Id)
					cross join
				(CostOffers as [co] with (nolock)
					join dbo.CostOfferServices as [cos] with (nolock) on co.CO_Id = [cos].COS_COID
					join dbo.Seasons as seas with (nolock) on co.CO_SeasonId = seas.SN_Id)
			where
				[co].CO_Id = @coId
				-- должны публиковаться только последние актуальные цены
				and spad.SPAD_SaleDate is null
				and seas.SN_IsActive = 1			
				and SC_SVKey = co.CO_SVKey
				and sc.SC_Code = [cos].COS_CODE
				and scp.SCP_PKKey = co.CO_PKKey
				and SC_PRKey = co.CO_PartnerKey
				--mv 13102012 для индекса	
				and scp.SCP_SvKey = co.CO_SVKey
				--mv 13102012 дата заезда при отборе должна быть ограничена датами заезда в ценах
				and scp.SCP_DateCheckIn between  
							(SELECT MIN(ISNULL(CS_CHECKINDATEBEG,DATEADD(DAY,-1,GetDate()))) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey) 
						and (SELECT MAX(ISNULL(CS_CHECKINDATEEND,'01-01-2100')) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey)
				--mv 13102012 дата заезда должна быть больше текущей даты
				and scp.SCP_DateCheckIn >= DATEADD(DAY,-1,GetDate())
				--mv 13102012 дата заезда не можеть быть больше максимальной даты в ценах
				and scp.SCP_DateCheckIn <= (SELECT MAX(ISNULL(CS_DATEEND,'01-01-2100')) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey)
				--mv 13102012 дата заезда + продолжительность тура не можеть быть меньше, чем минимальная дата в ценах
				and DATEADD(DAY, scp.SCP_TourDays, scp.SCP_DateCheckIn) >= (SELECT MIN(ISNULL(CS_DATE,DATEADD(DAY,-1,GetDate()))) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey)
				--kadraliev 20120625 день недели должен покрываться аттрибутом cs_week цены, если он задан
				and exists(select top 1 1 from dbo.tbl_costs with(nolock) where CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey and (cs_week is null or len(cs_week) = 0 or cs_week like ('%' + ltrim(rtrim(str(DATEPART(dw, scp.SCP_Date)))) + '%')))  
			
			-- в ценах которые расчитали на будущее, тоже нужно пересчитать	
			insert into @spndIdTable (spndId)
			select spnd.SPND_Id
			from (dbo.TP_ServicePriceNextDate as spnd with (nolock)
					join dbo.TP_ServiceCalculateParametrs as scp with (nolock) on spnd.SPND_SCPId = scp.SCP_Id
					join dbo.TP_ServiceComponents as sc with (nolock) on scp.SCP_SCId = sc.SC_Id)
					cross join
				(CostOffers as [co] with (nolock)
					join dbo.CostOfferServices as [cos] with (nolock) on [co].CO_Id = [cos].COS_COID
					join dbo.Seasons as seas with (nolock) on [co].CO_SeasonId = seas.SN_Id)
			where			
				[co].CO_Id = @coId
				and seas.SN_IsActive = 1
				and SC_SVKey = [co].CO_SVKey
				and sc.SC_Code = [cos].COS_CODE
				and scp.SCP_PKKey = [co].CO_PKKey
				and SC_PRKey = [co].CO_PartnerKey
				--mv 13102012 для индекса	
				and scp.SCP_SvKey = [co].CO_SVKey
				--mv 13102012 дата заезда при отборе должна быть ограничена датами заезда в ценах
				and scp.SCP_DateCheckIn between  
							(SELECT MIN(ISNULL(CS_CHECKINDATEBEG,DATEADD(DAY,-1,GetDate()))) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey) 
						and (SELECT MAX(ISNULL(CS_CHECKINDATEEND,'01-01-2100')) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey)
				--mv 13102012 дата заезда должна быть больше текущей даты
				and scp.SCP_DateCheckIn >= DATEADD(DAY,-1,GetDate())
				--mv 13102012 дата заезда не можеть быть больше максимальной даты в ценах
				and scp.SCP_DateCheckIn <= (SELECT MAX(ISNULL(CS_DATEEND,'01-01-2100')) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey)
				--mv 13102012 дата заезда + продолжительность тура не можеть быть меньше, чем минимальная дата в ценах
				and DATEADD(DAY, scp.SCP_TourDays, scp.SCP_DateCheckIn) >= (SELECT MIN(ISNULL(CS_DATE,DATEADD(DAY,-1,GetDate()))) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey)
				--kadraliev 20120625 день недели должен покрываться аттрибутом cs_week цены, если он задан
				and exists(select top 1 1 from dbo.tbl_costs with(nolock) where CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey and (cs_week is null or len(cs_week) = 0 or cs_week like ('%' + ltrim(rtrim(str(DATEPART(dw, scp.SCP_Date)))) + '%')))  
				
			while(exists (select top 1 1 from @spadIdTable))
			begin			
				update top (10000) spad
				set 
				spad.SPAD_NeedApply = 1,
				spad.SPAD_DateLastChange = getdate()
				from dbo.TP_ServicePriceActualDate as spad join @spadIdTable on spad.SPAD_Id = spadId
				
				delete @spadIdTable 
				where exists (	select top 1 1 
								from dbo.TP_ServicePriceActualDate as spad with(nolock) 
								where spad.SPAD_Id = spadId 
								and (spad.SPAD_NeedApply = 1))
			end
				
			while(exists (select top 1 1 from @spndIdTable))
			begin			
				update top (10000) spnd
				set spnd.SPND_NeedApply = 1,
				spnd.SPND_DateLastChange = getdate()
				from dbo.TP_ServicePriceNextDate as spnd join @spndIdTable on spnd.SPND_Id = spndId
				
				delete @spndIdTable 
				where exists (	select top 1 1 
								from dbo.TP_ServicePriceNextDate as spnd with(nolock) 
								where spnd.SPND_Id = spndId
								and spnd.SPND_NeedApply = 1)
			end

			if (@operationId = 1)
			begin
				-- переводим ЦБ в активное состояние и состояние очереди ЦБ в FALSE
				-- надо только проверить нет ли других очередей для данного ЦБ, тогда в этом случае проверяем на > 1
				select @COQueuesCount=Count(*) from [dbo].[QueuesCostOffers]
				where [QCO_COId] = @coId
				if (@COQueuesCount > 1)
				begin
					update CostOffers
					set CO_State = 1, CO_DateActive = ISNULL(CO_DateActive, getdate())
					where CO_Id = @coId
				end
				else
				begin
					update CostOffers
					set CO_State = 1, CO_DateActive = ISNULL(CO_DateActive, getdate()),[CO_InQueue] = 0
					where CO_Id = @coId
				end
			end
			else if (@operationId = 2)
			begin
				-- переводим ЦБ в закрытое состояние и состояние очереди ЦБ в FALSE			
				-- надо только проверить нет ли других очередей для данного ЦБ, тогда в этом случае проверяем на > 1
				select @COQueuesCount=Count(*) from [dbo].[QueuesCostOffers]
				where [QCO_COId] = @coId
				if (@COQueuesCount > 1)
				begin	
					update CostOffers
					set CO_State = 2, CO_DateClose = getdate()
					where CO_Id = @coId
				end
				else
				begin
					update CostOffers
					set CO_State = 2, CO_DateClose = getdate(), [CO_InQueue] = 0
					where CO_Id = @coId
				end
			end

		end	
		-- публикация ценового блока
		else if (@operationId = 3)
		begin
			insert into @spadIdTable (spadId)
			select spad.SPAD_Id
			from (dbo.TP_ServicePriceActualDate as spad with (nolock)
					join dbo.TP_ServiceCalculateParametrs as scp with (nolock) on spad.SPAD_SCPId = scp.SCP_Id
					join dbo.TP_ServiceComponents as sc with (nolock) on scp.SCP_SCId = sc.SC_Id)
					cross join
				(CostOffers as [co] with (nolock)
					join dbo.CostOfferServices as [cos] with (nolock) on [co].CO_Id = [cos].COS_COID
					join dbo.Seasons as seas with (nolock) on [co].CO_SeasonId = seas.SN_Id)
			where
				[co].CO_Id = @coId
				-- должны публиковаться только последние актуальные цены
				and spad.SPAD_SaleDate is null
				and seas.SN_IsActive = 1			
				and SC_SVKey = [co].CO_SVKey
				and sc.SC_Code = [cos].COS_CODE
				and scp.SCP_PKKey = [co].CO_PKKey
				and SC_PRKey = [co].CO_PartnerKey
				-- и дата продажи ценового блока должна быть вокруг текущей даты
				and getdate() between isnull([co].CO_SaleDateBeg, '1900-01-01') and isnull([co].CO_SaleDateEnd, '2072-01-01')
				--mv 13102012 для индекса	
				and scp.SCP_SvKey = [co].CO_SVKey
				--mv 13102012 дата заезда при отборе должна быть ограничена датами заезда в ценах
				and scp.SCP_DateCheckIn between  
							(SELECT MIN(ISNULL(CS_CHECKINDATEBEG,DATEADD(DAY,-1,GetDate()))) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey) 
						and (SELECT MAX(ISNULL(CS_CHECKINDATEEND,'01-01-2100')) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey)
				--mv 13102012 дата заезда должна быть больше текущей даты
				and scp.SCP_DateCheckIn >= DATEADD(DAY,-1,GetDate())
				--mv 13102012 дата заезда не можеть быть больше максимальной даты в ценах
				and scp.SCP_DateCheckIn <= (SELECT MAX(ISNULL(CS_DATEEND,'01-01-2100')) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey)
				--mv 13102012 дата заезда + продолжительность тура не можеть быть меньше, чем минимальная дата в ценах
				and DATEADD(DAY, scp.SCP_TourDays, scp.SCP_DateCheckIn) >= (SELECT MIN(ISNULL(CS_DATE,DATEADD(DAY,-1,GetDate()))) FROM dbo.tbl_costs with (nolock) WHERE CS_COID = [co].CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = [co].CO_SVKey)
				--kadraliev 20120625 день недели должен покрываться аттрибутом cs_week цены, если он задан
				and exists(select top 1 1 from dbo.tbl_costs with(nolock) where CS_COID = co.CO_Id and CS_CODE = sc.SC_Code and CS_SVKEY = co.CO_SVKey and (cs_week is null or len(cs_week) = 0 or cs_week like ('%' + ltrim(rtrim(str(DATEPART(dw, scp.SCP_Date)))) + '%')))  
				
			while(exists (select top 1 1 from @spadIdTable))
			begin			
				update top (10000) spad
				set 		
				spad.SPAD_NeedApply = 1,	
				spad.SPAD_AutoOnline = 1,
				spad.SPAD_DateLastChange = getdate()
				from dbo.TP_ServicePriceActualDate as spad join @spadIdTable on spad.SPAD_Id = spadId
				
				delete @spadIdTable 
				where exists (	select top 1 1 
								from dbo.TP_ServicePriceActualDate as spad with(nolock) 
								where spad.SPAD_Id = spadId 
								and (spad.SPAD_AutoOnline = 1))
			end
			
			-- обновим дату публикации и состояние очереди ЦБ в FALSE
			-- надо только проверить нет ли других очередей для данного ЦБ, тогда в этом случае проверяем на > 1
			select @COQueuesCount=Count(*) from [dbo].[QueuesCostOffers]
			where [QCO_COId] = @coId
			if (@COQueuesCount > 1)
			begin	
				update CostOffers
				set CO_DateLastPublish = getdate()
				where CO_Id = @coId
			end
			else
			begin
				update CostOffers
				set CO_DateLastPublish = getdate(), [CO_InQueue] = 0
				where CO_Id = @coId
			end
		end
		-- удаляем очередь для текущего ЦБ
		delete from [dbo].[QueuesCostOffers]
		where [QCO_COId] = @coId and [QCO_OperationId] = @operationId
	end

END TRY

BEGIN CATCH
	ROLLBACK TRANSACTION
	-- ставим состояние очереди ЦБ в -1, если произошла ошибка
	update [QueuesCostOffers]
	set [QCO_State] = -1
	where [QCO_COId] = @coId
END CATCH;

set datefirst @datefirst
GO

grant exec on [dbo].[CostOfferChangeState] to public
go
/*********************************************************************/
/* end sp_CostOfferChangeState.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_DeleteLogin.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteLogin]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteLogin]
GO
CREATE PROCEDURE [dbo].[DeleteLogin]
(
	@login nvarchar(50)
)
AS
BEGIN
	--<VERSION>9.2.18.0</VERSION>
	--<DATE>2012-12-03</DATE>	
	SET NOCOUNT ON;
	SET XACT_ABORT ON
	
	if (exists (select top 1 1 from master.dbo.syslogins where loginname like @login))
	begin
		IF (CHARINDEX('\', @login) > 0)
		BEGIN
			EXEC sp_revokelogin @login
		END
		ELSE
		BEGIN
			EXEC sp_droplogin @login
		END	
	end
END
GO

grant exec on [dbo].[DeleteLogin] to public
go
/*********************************************************************/
/* end sp_DeleteLogin.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_Delete_MisQuotas.sql */
/*********************************************************************/
set ansi_nulls on
go
set quoted_identifier on
go

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Delete_MisQuotas]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[Delete_MisQuotas]
GO

create procedure [dbo].[Delete_MisQuotas] 
(
	@ImportIdentificator nvarchar(100)
)
as begin

select 	[MQ_Id],
		[ImportIdentificator],
		[UpdateDate],
		[Allotment_MT_Key],
		[Commitment_MT_Key],
		[External_Id],
		[MQ_PartnerKey],
		[MQ_HotelKey],
		[MQ_RoomCategoryKey],
		[MQ_Date],
		[MQ_CommitmentFree],
		[MQ_CommitmentSold],
		[MQ_CommitmenTotal],
		[MQ_AllotmentFree],
		[MQ_AllotmentSold],
		[MQ_AllotmentTotal],
		[MQ_Release],
		[MQ_Stopsale],
		[MQ_CancelStopsale],
		[MQ_RecordDate],
		[MQ_IsByCheckin],
		[MQ_DurationMin],
		[MQ_DurationMax],
		[MQ_ErrorState]
from 	[MIS_Quotas]
where 	[ImportIdentificator] = @ImportIdentificator and ([Allotment_MT_Key] is not null or [Commitment_MT_Key] is not null)

delete from [MIS_Quotas] where [ImportIdentificator] = @ImportIdentificator and ([Allotment_MT_Key] is not null or [Commitment_MT_Key] is not null)

end
go

/*********************************************************************/
/* end sp_Delete_MisQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ExportToDCTables.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ExportToDCTables]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[ExportToDCTables]
GO

--<VERSION>2009.2.19.1</VERSION>
--<DATE>2013-05-16</DATE>
CREATE PROCEDURE [dbo].[ExportToDCTables]
	(
		@exportList [dbo].[StructToExportAllDCTables] readonly
	)
AS
BEGIN	
	CREATE TABLE #TP_Prices
		(
			[xTP_TIKey] [int] NOT NULL,
			[xTP_TOKey] [int] NOT NULL,
			[xTP_TRKey] [int] NOT NULL,
			[xTP_TourDate] [datetime] NOT NULL,
			[xTP_Key] [int] PRIMARY KEY NOT NULL,			
			[xTP_HotelKey] [int] NOT NULL,
			[xTP_DepartureKey] [int] NOT NULL,
			[xTP_Rate] [nvarchar](2) null,
			[xTP_Days] [int] null,			

			[xSCPId_1] [int] null,
			[xSCPId_2] [int] null,
			[xSCPId_3] [int] null,
			[xSCPId_4] [int] null,
			[xSCPId_5] [int] null,
			[xSCPId_6] [int] null,
			[xSCPId_7] [int] null,
			[xSCPId_8] [int] null,
			[xSCPId_9] [int] null,
			[xSCPId_10] [int] null,
			[xSCPId_11] [int] null,
			[xSCPId_12] [int] null,
			[xSCPId_13] [int] null,
			[xSCPId_14] [int] null,
			[xSCPId_15] [int] null,
			
			[xSvKey_1] [int] null,
			[xSvKey_2] [int] null,
			[xSvKey_3] [int] null,
			[xSvKey_4] [int] null,
			[xSvKey_5] [int] null,
			[xSvKey_6] [int] null,
			[xSvKey_7] [int] null,
			[xSvKey_8] [int] null,
			[xSvKey_9] [int] null,
			[xSvKey_10] [int] null,
			[xSvKey_11] [int] null,
			[xSvKey_12] [int] null,
			[xSvKey_13] [int] null,
			[xSvKey_14] [int] null,
			[xSvKey_15] [int] null,
			
			[xGross_1] [money] null,
			[xGross_2] [money] null,
			[xGross_3] [money] null,
			[xGross_4] [money] null,
			[xGross_5] [money] null,
			[xGross_6] [money] null,
			[xGross_7] [money] null,
			[xGross_8] [money] null,
			[xGross_9] [money] null,
			[xGross_10] [money] null,
			[xGross_11] [money] null,
			[xGross_12] [money] null,
			[xGross_13] [money] null,
			[xGross_14] [money] null,
			[xGross_15] [money] null,
			
			[xAddCostIsCommission_1] [money] null,
			[xAddCostIsCommission_2] [money] null,
			[xAddCostIsCommission_3] [money] null,
			[xAddCostIsCommission_4] [money] null,
			[xAddCostIsCommission_5] [money] null,
			[xAddCostIsCommission_6] [money] null,
			[xAddCostIsCommission_7] [money] null,
			[xAddCostIsCommission_8] [money] null,
			[xAddCostIsCommission_9] [money] null,
			[xAddCostIsCommission_10] [money] null,
			[xAddCostIsCommission_11] [money] null,
			[xAddCostIsCommission_12] [money] null,
			[xAddCostIsCommission_13] [money] null,
			[xAddCostIsCommission_14] [money] null,
			[xAddCostIsCommission_15] [money] null,
			
			[xAddCostNoCommission_1] [money] null,
			[xAddCostNoCommission_2] [money] null,
			[xAddCostNoCommission_3] [money] null,
			[xAddCostNoCommission_4] [money] null,
			[xAddCostNoCommission_5] [money] null,
			[xAddCostNoCommission_6] [money] null,
			[xAddCostNoCommission_7] [money] null,
			[xAddCostNoCommission_8] [money] null,
			[xAddCostNoCommission_9] [money] null,
			[xAddCostNoCommission_10] [money] null,
			[xAddCostNoCommission_11] [money] null,
			[xAddCostNoCommission_12] [money] null,
			[xAddCostNoCommission_13] [money] null,
			[xAddCostNoCommission_14] [money] null,
			[xAddCostNoCommission_15] [money] null,
			
			[xMarginPercent_1] [money] null,
			[xMarginPercent_2] [money] null,
			[xMarginPercent_3] [money] null,
			[xMarginPercent_4] [money] null,
			[xMarginPercent_5] [money] null,
			[xMarginPercent_6] [money] null,
			[xMarginPercent_7] [money] null,
			[xMarginPercent_8] [money] null,
			[xMarginPercent_9] [money] null,
			[xMarginPercent_10] [money] null,
			[xMarginPercent_11] [money] null,
			[xMarginPercent_12] [money] null,
			[xMarginPercent_13] [money] null,
			[xMarginPercent_14] [money] null,
			[xMarginPercent_15] [money] null,
			
			[xCommissionOnly_1] [bit] null,
			[xCommissionOnly_2] [bit] null,
			[xCommissionOnly_3] [bit] null,
			[xCommissionOnly_4] [bit] null,
			[xCommissionOnly_5] [bit] null,
			[xCommissionOnly_6] [bit] null,
			[xCommissionOnly_7] [bit] null,
			[xCommissionOnly_8] [bit] null,
			[xCommissionOnly_9] [bit] null,
			[xCommissionOnly_10] [bit] null,
			[xCommissionOnly_11] [bit] null,
			[xCommissionOnly_12] [bit] null,
			[xCommissionOnly_13] [bit] null,
			[xCommissionOnly_14] [bit] null,
			[xCommissionOnly_15] [bit] null,
			
			[xIsCommission_1] [bit] null,
			[xIsCommission_2] [bit] null,
			[xIsCommission_3] [bit] null,
			[xIsCommission_4] [bit] null,
			[xIsCommission_5] [bit] null,
			[xIsCommission_6] [bit] null,
			[xIsCommission_7] [bit] null,
			[xIsCommission_8] [bit] null,
			[xIsCommission_9] [bit] null,
			[xIsCommission_10] [bit] null,
			[xIsCommission_11] [bit] null,
			[xIsCommission_12] [bit] null,
			[xIsCommission_13] [bit] null,
			[xIsCommission_14] [bit] null,
			[xIsCommission_15] [bit] null
		)
		
		declare @tsKey_1 int, @tsKey_2 int, @tsKey_3 int, @tsKey_4 int, @tsKey_5 int, @tsKey_6 int, @tsKey_7 int, @tsKey_8 int, @tsKey_9 int, @tsKey_10 int, @tsKey_11 int, @tsKey_12 int, @tsKey_13 int, @tsKey_14 int, @tsKey_15 int
		declare @tsSVKey_1 int, @tsSVKey_2 int, @tsSVKey_3 int, @tsSVKey_4 int, @tsSVKey_5 int, @tsSVKey_6 int, @tsSVKey_7 int, @tsSVKey_8 int, @tsSVKey_9 int, @tsSVKey_10 int, @tsSVKey_11 int, @tsSVKey_12 int, @tsSVKey_13 int, @tsSVKey_14 int, @tsSVKey_15 int
		declare @tsGross_1 money, @tsGross_2 money, @tsGross_3 money, @tsGross_4 money, @tsGross_5 money, @tsGross_6 money, @tsGross_7 money, @tsGross_8 money, @tsGross_9 money, @tsGross_10 money, @tsGross_11 money, @tsGross_12 money, @tsGross_13 money, @tsGross_14 money, @tsGross_15 money
		declare @tsAddIsCommission_1 money, @tsAddIsCommission_2 money, @tsAddIsCommission_3 money, @tsAddIsCommission_4 money, @tsAddIsCommission_5 money, @tsAddIsCommission_6 money, @tsAddIsCommission_7 money, @tsAddIsCommission_8 money, @tsAddIsCommission_9 money, @tsAddIsCommission_10 money, @tsAddIsCommission_11 money, @tsAddIsCommission_12 money, @tsAddIsCommission_13 money, @tsAddIsCommission_14 money, @tsAddIsCommission_15 money
		declare @tsAddNoCommission_1 money, @tsAddNoCommission_2 money, @tsAddNoCommission_3 money, @tsAddNoCommission_4 money, @tsAddNoCommission_5 money, @tsAddNoCommission_6 money, @tsAddNoCommission_7 money, @tsAddNoCommission_8 money, @tsAddNoCommission_9 money, @tsAddNoCommission_10 money, @tsAddNoCommission_11 money, @tsAddNoCommission_12 money, @tsAddNoCommission_13 money, @tsAddNoCommission_14 money, @tsAddNoCommission_15 money
		declare @tsMarginPercent_1 money, @tsMarginPercent_2 money, @tsMarginPercent_3 money, @tsMarginPercent_4 money, @tsMarginPercent_5 money, @tsMarginPercent_6 money, @tsMarginPercent_7 money, @tsMarginPercent_8 money, @tsMarginPercent_9 money, @tsMarginPercent_10 money, @tsMarginPercent_11 money, @tsMarginPercent_12 money, @tsMarginPercent_13 money, @tsMarginPercent_14 money, @tsMarginPercent_15 money
		declare @tsCommissionOnly_1 money, @tsCommissionOnly_2 money, @tsCommissionOnly_3 money, @tsCommissionOnly_4 money, @tsCommissionOnly_5 money, @tsCommissionOnly_6 money, @tsCommissionOnly_7 money, @tsCommissionOnly_8 money, @tsCommissionOnly_9 money, @tsCommissionOnly_10 money, @tsCommissionOnly_11 money, @tsCommissionOnly_12 money, @tsCommissionOnly_13 money, @tsCommissionOnly_14 money, @tsCommissionOnly_15 money
		declare @tsIsCommission_1 bit, @tsIsCommission_2 bit, @tsIsCommission_3 bit, @tsIsCommission_4 bit, @tsIsCommission_5 bit, @tsIsCommission_6 bit, @tsIsCommission_7 bit, @tsIsCommission_8 bit, @tsIsCommission_9 bit, @tsIsCommission_10 bit, @tsIsCommission_11 bit, @tsIsCommission_12 bit, @tsIsCommission_13 bit, @tsIsCommission_14 bit, @tsIsCommission_15 bit

		-- переменные предыдущего шага
		declare @prevTPKey int, @prevToKey int, @prevTiKey int, @prevTRKey int, @prevDays int, @prevRate nvarchar(10), @prevHotelKey int, @prevDepartureKey int, @prevTourDate datetime
		set @prevTPKey = -100500

		declare @xTPKey int, @xToKey int, @xTiKey int, @xTRKey int, @xTourDate datetime, @xDays int, @xRate nvarchar(10),
		@xHotelKey int, @xDepartureKey int, @xSVKey int, @xCode int, @xSubCode1 int, @xSubCode2 int, @xPRKey int, @xDate datetime,
		@xMen int, @xServiceDays int, @xPkKey int, @xNetto money, @xBrutto money, @xIsCommission bit, @xMargin money, @xCommissionOnly bit,
		@xAddCostIsCommission money, @xAddCostNoCommission money, @xServiceOrder bit

		declare exportServiceCursor cursor local fast_forward for
		select [TPKey], [ToKey], [TiKey], [TRKey], [TourDate], [Days], [Rate], [HotelKey], [DepartureKey], [SVKey], [Code], [SubCode1], [SubCode2], [PRKey],
		[Date], [Men], [ServiceDays], [PkKey], [Netto], [Brutto], [IsCommission], [Margin], [CommissionOnly], [AddCostIsCommission], [AddCostNoCommission],
		case when [SVKey] = 3 and [HotelKey] = [Code] then 0 else 1 end as [ServiceOrder]
		from @exportList
		union
		--добавим 1 запись в конец, что бы в курсоре понять что последовательность кончилась
		select 2147483647, null, null, null, null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null, null,
		0 as [ServiceOrder]
		order by [TPKey], [ServiceOrder]

		print 'Инициализация'
		print CONVERT(TIME, GETDATE())

		open exportServiceCursor
		fetch exportServiceCursor into @xTPKey, @xToKey, @xTiKey, @xTRKey, @xTourDate, @xDays, @xRate,
		@xHotelKey, @xDepartureKey, @xSVKey, @xCode, @xSubCode1, @xSubCode2, @xPRKey, @xDate,
		@xMen, @xServiceDays, @xPkKey, @xNetto, @xBrutto, @xIsCommission, @xMargin, @xCommissionOnly,
		@xAddCostIsCommission, @xAddCostNoCommission, @xServiceOrder

		print 'Открытие курсора'
		print CONVERT(TIME, GETDATE())

		while (@@FETCH_STATUS = 0)
		begin
			-- если ключ сменился то нужно записать предыдущие записи во временную таблицу
			if (@prevTPKey != @xTPKey and @prevTPKey != -100500)
			begin
				insert into #TP_Prices (xtp_key, xtp_tokey, xtp_tikey, xtp_trkey, xTP_Days, xTP_TourDate, xTP_Rate, xTP_HotelKey, xTP_DepartureKey
				, xSCPId_1, xSCPId_2, xSCPId_3, xSCPId_4, xSCPId_5, xSCPId_6, xSCPId_7, xSCPId_8, xSCPId_9, xSCPId_10, xSCPId_11, xSCPId_12, xSCPId_13, xSCPId_14, xSCPId_15
				, xSvKey_1, xSvKey_2, xSvKey_3, xSvKey_4, xSvKey_5, xSvKey_6, xSvKey_7, xSvKey_8, xSvKey_9, xSvKey_10, xSvKey_11, xSvKey_12, xSvKey_13, xSvKey_14, xSvKey_15
				, xGross_1, xGross_2, xGross_3, xGross_4, xGross_5, xGross_6, xGross_7, xGross_8, xGross_9, xGross_10, xGross_11, xGross_12, xGross_13, xGross_14, xGross_15
				, xAddCostIsCommission_1, xAddCostIsCommission_2, xAddCostIsCommission_3, xAddCostIsCommission_4, xAddCostIsCommission_5, xAddCostIsCommission_6, xAddCostIsCommission_7, xAddCostIsCommission_8, xAddCostIsCommission_9, xAddCostIsCommission_10, xAddCostIsCommission_11, xAddCostIsCommission_12, xAddCostIsCommission_13, xAddCostIsCommission_14, xAddCostIsCommission_15
				, xAddCostNoCommission_1, xAddCostNoCommission_2, xAddCostNoCommission_3, xAddCostNoCommission_4, xAddCostNoCommission_5, xAddCostNoCommission_6, xAddCostNoCommission_7, xAddCostNoCommission_8, xAddCostNoCommission_9, xAddCostNoCommission_10, xAddCostNoCommission_11, xAddCostNoCommission_12, xAddCostNoCommission_13, xAddCostNoCommission_14, xAddCostNoCommission_15
				, xMarginPercent_1, xMarginPercent_2, xMarginPercent_3, xMarginPercent_4, xMarginPercent_5, xMarginPercent_6, xMarginPercent_7, xMarginPercent_8, xMarginPercent_9, xMarginPercent_10, xMarginPercent_11, xMarginPercent_12, xMarginPercent_13, xMarginPercent_14, xMarginPercent_15
				, xCommissionOnly_1, xCommissionOnly_2, xCommissionOnly_3, xCommissionOnly_4, xCommissionOnly_5, xCommissionOnly_6, xCommissionOnly_7, xCommissionOnly_8, xCommissionOnly_9, xCommissionOnly_10, xCommissionOnly_11, xCommissionOnly_12, xCommissionOnly_13, xCommissionOnly_14, xCommissionOnly_15
				, xIsCommission_1, xIsCommission_2, xIsCommission_3, xIsCommission_4, xIsCommission_5, xIsCommission_6, xIsCommission_7, xIsCommission_8, xIsCommission_9, xIsCommission_10, xIsCommission_11, xIsCommission_12, xIsCommission_13, xIsCommission_14, xIsCommission_15)
				values (@prevTPKey, @prevToKey, @prevTiKey, @prevTRKey, @prevDays, @prevTourDate, @prevRate, @prevHotelKey, @prevDepartureKey
				, @tsKey_1, @tsKey_2, @tsKey_3, @tsKey_4, @tsKey_5, @tsKey_6, @tsKey_7, @tsKey_8, @tsKey_9, @tsKey_10, @tsKey_11, @tsKey_12, @tsKey_13, @tsKey_14, @tsKey_15
				, @tsSVKey_1, @tsSVKey_2, @tsSVKey_3, @tsSVKey_4, @tsSVKey_5, @tsSVKey_6, @tsSVKey_7, @tsSVKey_8, @tsSVKey_9, @tsSVKey_10, @tsSVKey_11, @tsSVKey_12, @tsSVKey_13, @tsSVKey_14, @tsSVKey_15
				, @tsGross_1, @tsGross_2, @tsGross_3, @tsGross_4, @tsGross_5, @tsGross_6, @tsGross_7, @tsGross_8, @tsGross_9, @tsGross_10, @tsGross_11, @tsGross_12, @tsGross_13, @tsGross_14, @tsGross_15
				, @tsAddIsCommission_1, @tsAddIsCommission_2, @tsAddIsCommission_3, @tsAddIsCommission_4, @tsAddIsCommission_5, @tsAddIsCommission_6, @tsAddIsCommission_7, @tsAddIsCommission_8, @tsAddIsCommission_9, @tsAddIsCommission_10, @tsAddIsCommission_11, @tsAddIsCommission_12, @tsAddIsCommission_13, @tsAddIsCommission_14, @tsAddIsCommission_15
				, @tsAddNoCommission_1, @tsAddNoCommission_2, @tsAddNoCommission_3, @tsAddNoCommission_4, @tsAddNoCommission_5, @tsAddNoCommission_6, @tsAddNoCommission_7, @tsAddNoCommission_8, @tsAddNoCommission_9, @tsAddNoCommission_10, @tsAddNoCommission_11, @tsAddNoCommission_12, @tsAddNoCommission_13, @tsAddNoCommission_14, @tsAddNoCommission_15
				, @tsMarginPercent_1, @tsMarginPercent_2, @tsMarginPercent_3, @tsMarginPercent_4, @tsMarginPercent_5, @tsMarginPercent_6, @tsMarginPercent_7, @tsMarginPercent_8, @tsMarginPercent_9, @tsMarginPercent_10, @tsMarginPercent_11, @tsMarginPercent_12, @tsMarginPercent_13, @tsMarginPercent_14, @tsMarginPercent_15
				, @tsCommissionOnly_1, @tsCommissionOnly_2, @tsCommissionOnly_3, @tsCommissionOnly_4, @tsCommissionOnly_5, @tsCommissionOnly_6, @tsCommissionOnly_7, @tsCommissionOnly_8, @tsCommissionOnly_9, @tsCommissionOnly_10, @tsCommissionOnly_11, @tsCommissionOnly_12, @tsCommissionOnly_13, @tsCommissionOnly_14, @tsCommissionOnly_15
				, @tsIsCommission_1, @tsIsCommission_2, @tsIsCommission_3, @tsIsCommission_4, @tsIsCommission_5, @tsIsCommission_6, @tsIsCommission_7, @tsIsCommission_8, @tsIsCommission_9, @tsIsCommission_10, @tsIsCommission_11, @tsIsCommission_12, @tsIsCommission_13, @tsIsCommission_14, @tsIsCommission_15)
										
				set @tsKey_1 = null
				set @tsKey_2 = null
				set @tsKey_3 = null
				set @tsKey_4 = null
				set @tsKey_5 = null
				set @tsKey_6 = null
				set @tsKey_7 = null
				set @tsKey_8 = null
				set @tsKey_9 = null
				set @tsKey_10 = null
				set @tsKey_11 = null
				set @tsKey_12 = null
				set @tsKey_13 = null
				set @tsKey_14 = null
				set @tsKey_15 = null
						
				set @tsSVKey_1 = null
				set @tsSVKey_2 = null
				set @tsSVKey_3 = null
				set @tsSVKey_4 = null
				set @tsSVKey_5 = null
				set @tsSVKey_6 = null
				set @tsSVKey_7 = null
				set @tsSVKey_8 = null
				set @tsSVKey_9 = null
				set @tsSVKey_10 = null
				set @tsSVKey_11 = null
				set @tsSVKey_12 = null
				set @tsSVKey_13 = null
				set @tsSVKey_14 = null
				set @tsSVKey_15 = null
						
				set @tsGross_1 = null
				set @tsGross_2 = null
				set @tsGross_3 = null
				set @tsGross_4 = null
				set @tsGross_5 = null
				set @tsGross_6 = null
				set @tsGross_7 = null
				set @tsGross_8 = null
				set @tsGross_9 = null
				set @tsGross_10 = null
				set @tsGross_11 = null
				set @tsGross_12 = null
				set @tsGross_13 = null
				set @tsGross_14 = null
				set @tsGross_15 = null
						
				set @tsAddIsCommission_1 = null
				set @tsAddIsCommission_2 = null
				set @tsAddIsCommission_3 = null
				set @tsAddIsCommission_4 = null
				set @tsAddIsCommission_5 = null
				set @tsAddIsCommission_6 = null
				set @tsAddIsCommission_7 = null
				set @tsAddIsCommission_8 = null
				set @tsAddIsCommission_9 = null
				set @tsAddIsCommission_10 = null
				set @tsAddIsCommission_11 = null
				set @tsAddIsCommission_12 = null
				set @tsAddIsCommission_13 = null
				set @tsAddIsCommission_14 = null
				set @tsAddIsCommission_15 = null
						
				set @tsAddNoCommission_1 = null
				set @tsAddNoCommission_2 = null
				set @tsAddNoCommission_3 = null
				set @tsAddNoCommission_4 = null
				set @tsAddNoCommission_5 = null
				set @tsAddNoCommission_6 = null
				set @tsAddNoCommission_7 = null
				set @tsAddNoCommission_8 = null
				set @tsAddNoCommission_9 = null
				set @tsAddNoCommission_10 = null
				set @tsAddNoCommission_11 = null
				set @tsAddNoCommission_12 = null
				set @tsAddNoCommission_13 = null
				set @tsAddNoCommission_14 = null
				set @tsAddNoCommission_15 = null
						
				set @tsMarginPercent_1 = null
				set @tsMarginPercent_2 = null
				set @tsMarginPercent_3 = null
				set @tsMarginPercent_4 = null
				set @tsMarginPercent_5 = null
				set @tsMarginPercent_6 = null
				set @tsMarginPercent_7 = null
				set @tsMarginPercent_8 = null
				set @tsMarginPercent_9 = null
				set @tsMarginPercent_10 = null
				set @tsMarginPercent_11 = null
				set @tsMarginPercent_12 = null
				set @tsMarginPercent_13 = null
				set @tsMarginPercent_14 = null
				set @tsMarginPercent_15 = null
						
				set @tsCommissionOnly_1 = null
				set @tsCommissionOnly_2 = null
				set @tsCommissionOnly_3 = null
				set @tsCommissionOnly_4 = null
				set @tsCommissionOnly_5 = null
				set @tsCommissionOnly_6 = null
				set @tsCommissionOnly_7 = null
				set @tsCommissionOnly_8 = null
				set @tsCommissionOnly_9 = null
				set @tsCommissionOnly_10 = null
				set @tsCommissionOnly_11 = null
				set @tsCommissionOnly_12 = null
				set @tsCommissionOnly_13 = null
				set @tsCommissionOnly_14 = null
				set @tsCommissionOnly_15 = null
						
				set @tsIsCommission_1 = null
				set @tsIsCommission_2 = null
				set @tsIsCommission_3 = null
				set @tsIsCommission_4 = null
				set @tsIsCommission_5 = null
				set @tsIsCommission_6 = null
				set @tsIsCommission_7 = null
				set @tsIsCommission_8 = null
				set @tsIsCommission_9 = null
				set @tsIsCommission_10 = null
				set @tsIsCommission_11 = null
				set @tsIsCommission_12 = null
				set @tsIsCommission_13 = null
				set @tsIsCommission_14 = null
				set @tsIsCommission_15 = null
			end
			
			-- если это не последняя запись
			if (@xTPKey != 2147483647)
			begin
				declare @scId int, @scpId bigint, @spadId bigint, @stId bigint, @tmadId int
				-- то заполняем вспомогательные таблицы и получаем ключи нужных нам записей
				declare @modificationDate datetime
				set @modificationDate = getdate()
								
				-- пробуем найти запись под нашу услугу
				set @scId = isnull((select top 1 SC_Id
									from TP_ServiceComponents with (nolock)
									where SC_SVKey = @xSVKey
									and SC_Code = @xCode
									and SC_SubCode1 = @xSubCode1
									and SC_SubCode2 = @xSubCode2
									and SC_PRKey = @xPRKey), null)
				-- если не нашли то добавим новую
				if (@scId is null)
				begin
					insert into TP_ServiceComponents (SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SC_PRKey)
					values (@xSVKey, @xCode, @xSubCode1, @xSubCode2, @xPRKey)
		
					set @scId = SCOPE_IDENTITY()
				end

				-- заполняем TP_ServiceTours
				-- проверим есть ли запись в таблице TP_ServiceTours
				set @stId = isnull((select top 1 ST_Id
									from TP_ServiceTours with (nolock)
									where ST_SVKey = @xSVKey
									and ST_SCId = @scId
									and ST_TRKey = @xTRKey
									and ST_TOKey = @xToKey), null)
				if (@stId is null)
				begin
					insert into TP_ServiceTours (ST_SVKey, ST_SCId, ST_TRKey, ST_TOKey)
					values (@xSVKey, @scId, @xTRKey, @xToKey)
		
					set @stId = SCOPE_IDENTITY()
				end

				-- заполняем TP_ServiceCalculateParametrs
				set @scpId = isnull((	select top 1 SCP_Id
										from TP_ServiceCalculateParametrs with (nolock)
										where SCP_SCId = @scId
										and SCP_Date = @xDate
										and SCP_DateCheckIn = @xTourDate
										and SCP_Men = @xMen
										and SCP_Days = @xServiceDays
										and SCP_TourDays = @xDays
										and SCP_PKKey = @xPkKey
										and SCP_DeleteDate is null), null)

				-- если не нашли, то добавим новую
				if (@scpId is null)
				begin
					insert into TP_ServiceCalculateParametrs(SCP_SCId, SCP_Date, SCP_DateCheckIn, SCP_Men, SCP_Days, SCP_PKKey, SCP_TourDays, SCP_SvKey)
					values (@scId, @xDate, @xTourDate, @xMen, @xServiceDays, @xPkKey, @xDays, @xSVKey)
		
					set @scpId = SCOPE_IDENTITY()
				end

				-- заполняем TP_ServicePriceActualDays
				set @spadId = isnull((	select top 1 SPAD_Id
										from TP_ServicePriceActualDate with (nolock)
										where SPAD_SCPId = @scpId
										and SPAD_SaleDate is null
										and SPAD_Rate = @xRate), null)
				-- если не нашли, то добавим новую
				if (@spadId is null)
				begin					
					insert into TP_ServicePriceActualDate (SPAD_SCPId, SPAD_IsCommission, SPAD_Rate, SPAD_SaleDate, SPAD_Gross, SPAD_Netto, SPAD_DateLastChange, SPAD_DateLastCalculate, SPAD_NeedApply)
					values (@scpId, @xIsCommission, @xRate, null, @xBrutto, @xNetto, @modificationDate, @modificationDate , 0)
				end
				else	-- если нашли то и стоимость отличается то обновим значение
				begin
					if not exists (	select top 1 1 
									from TP_ServicePriceActualDate with (nolock)
									where SPAD_Id = @spadId
									and SPAD_IsCommission = @xIsCommission
									and SPAD_Gross = @xBrutto
									and SPAD_Netto = @xNetto)
					begin
						-- обновим
						update TP_ServicePriceActualDate
						set SPAD_Gross = @xBrutto,
						SPAD_Netto = @xNetto,
						SPAD_IsCommission = @xIsCommission,
						SPAD_DateLastCalculate = getdate(),
						SPAD_NeedApply = 0,
						SPAD_AutoOnline = 1 -- и скажем чтобы обновились цены в других турах
						where SPAD_SCPId = @scpId
					end
				end

				-- заполняем TP_TourMarginActualDays
				set @tmadId = isnull((	select top 1 1
										from TP_TourMarginActualDate with(nolock)
										where TMAD_TRKey = @xTRKey
										and TMAD_SvKey = @xSVKey
										and TMAD_DateCheckIn = @xTourDate
										and TMAD_Long = @xDays), null)
				-- если не нашли, то добавим новую
				if (@tmadId is null)
				begin					
					insert into TP_TourMarginActualDate (TMAD_TRKey, TMAD_SvKey, TMAD_DateCheckIn, TMAD_Percent, TMAD_IsCommission, TMAD_Long, TMAD_DateLastChange, TMAD_DateLastCalculate, TMAD_NeedApply)
					values (@xTRKey, @xSVKey, @xTourDate, @xMargin, @xCommissionOnly, @xDays, @modificationDate, @modificationDate, 2)
				end

				-- Готово, все ключи известны
				-- Теперь по очереди кладем их в нашу заготовку для TP_PriceComponents
				if (@tsKey_1 is null)
				begin
					set @tsKey_1 = @scpId
					set @tsSVKey_1 = @xSVKey
					set @tsGross_1 = @xBrutto
					set @tsAddIsCommission_1 = @xAddCostIsCommission
					set @tsAddNoCommission_1 = @xAddCostNoCommission
					set @tsMarginPercent_1 = @xMargin
					set @tsCommissionOnly_1 = @xCommissionOnly
					set @tsIsCommission_1 = @xIsCommission
				end
				else if (@tsKey_2 is null)
				begin
					set @tsKey_2 = @scpId
					set @tsSVKey_2 = @xSVKey
					set @tsGross_2 = @xBrutto
					set @tsAddIsCommission_2 = @xAddCostIsCommission
					set @tsAddNoCommission_2 = @xAddCostNoCommission
					set @tsMarginPercent_2 = @xMargin
					set @tsCommissionOnly_2 = @xCommissionOnly
					set @tsIsCommission_2 = @xIsCommission
				end
				else if (@tsKey_3 is null)
				begin
					set @tsKey_3 = @scpId
					set @tsSVKey_3 = @xSVKey
					set @tsGross_3 = @xBrutto
					set @tsAddIsCommission_3 = @xAddCostIsCommission
					set @tsAddNoCommission_3 = @xAddCostNoCommission
					set @tsMarginPercent_3 = @xMargin
					set @tsCommissionOnly_3 = @xCommissionOnly
					set @tsIsCommission_3 = @xIsCommission
				end
				else if (@tsKey_4 is null)
				begin
					set @tsKey_4 = @scpId
					set @tsSVKey_4 = @xSVKey
					set @tsGross_4 = @xBrutto
					set @tsAddIsCommission_4 = @xAddCostIsCommission
					set @tsAddNoCommission_4 = @xAddCostNoCommission
					set @tsMarginPercent_4 = @xMargin
					set @tsCommissionOnly_4 = @xCommissionOnly
					set @tsIsCommission_4 = @xIsCommission
				end
				else if (@tsKey_5 is null)
				begin
					set @tsKey_5 = @scpId
					set @tsSVKey_5 = @xSVKey
					set @tsGross_5 = @xBrutto
					set @tsAddIsCommission_5 = @xAddCostIsCommission
					set @tsAddNoCommission_5 = @xAddCostNoCommission
					set @tsMarginPercent_5 = @xMargin
					set @tsCommissionOnly_5 = @xCommissionOnly
					set @tsIsCommission_5 = @xIsCommission
				end
				else if (@tsKey_6 is null)
				begin
					set @tsKey_6 = @scpId
					set @tsSVKey_6 = @xSVKey
					set @tsGross_6 = @xBrutto
					set @tsAddIsCommission_6 = @xAddCostIsCommission
					set @tsAddNoCommission_6 = @xAddCostNoCommission
					set @tsMarginPercent_6 = @xMargin
					set @tsCommissionOnly_6 = @xCommissionOnly
					set @tsIsCommission_6 = @xIsCommission
				end
				else if (@tsKey_7 is null)
				begin
					set @tsKey_7 = @scpId
					set @tsSVKey_7 = @xSVKey
					set @tsGross_7 = @xBrutto
					set @tsAddIsCommission_7 = @xAddCostIsCommission
					set @tsAddNoCommission_7 = @xAddCostNoCommission
					set @tsMarginPercent_7 = @xMargin
					set @tsCommissionOnly_7 = @xCommissionOnly
					set @tsIsCommission_7 = @xIsCommission
				end
				else if (@tsKey_8 is null)
				begin
					set @tsKey_8 = @scpId
					set @tsSVKey_8 = @xSVKey
					set @tsGross_8 = @xBrutto
					set @tsAddIsCommission_8 = @xAddCostIsCommission
					set @tsAddNoCommission_8 = @xAddCostNoCommission
					set @tsMarginPercent_8 = @xMargin
					set @tsCommissionOnly_8 = @xCommissionOnly
					set @tsIsCommission_8 = @xIsCommission
				end
				else if (@tsKey_9 is null)
				begin
					set @tsKey_9 = @scpId
					set @tsSVKey_9 = @xSVKey
					set @tsGross_9 = @xBrutto
					set @tsAddIsCommission_9 = @xAddCostIsCommission
					set @tsAddNoCommission_9 = @xAddCostNoCommission
					set @tsMarginPercent_9 = @xMargin
					set @tsCommissionOnly_9 = @xCommissionOnly
					set @tsIsCommission_9 = @xIsCommission
				end
				else if (@tsKey_10 is null)
				begin
					set @tsKey_10 = @scpId
					set @tsSVKey_10 = @xSVKey
					set @tsGross_10 = @xBrutto
					set @tsAddIsCommission_10 = @xAddCostIsCommission
					set @tsAddNoCommission_10 = @xAddCostNoCommission
					set @tsMarginPercent_10 = @xMargin
					set @tsCommissionOnly_10 = @xCommissionOnly
					set @tsIsCommission_10 = @xIsCommission
				end
				else if (@tsKey_11 is null)
				begin
					set @tsKey_11 = @scpId
					set @tsSVKey_11 = @xSVKey
					set @tsGross_11 = @xBrutto
					set @tsAddIsCommission_11 = @xAddCostIsCommission
					set @tsAddNoCommission_11 = @xAddCostNoCommission
					set @tsMarginPercent_11 = @xMargin
					set @tsCommissionOnly_11 = @xCommissionOnly
					set @tsIsCommission_11 = @xIsCommission
				end
				else if (@tsKey_12 is null)
				begin
					set @tsKey_12 = @scpId
					set @tsSVKey_12 = @xSVKey
					set @tsGross_12 = @xBrutto
					set @tsAddIsCommission_12 = @xAddCostIsCommission
					set @tsAddNoCommission_12 = @xAddCostNoCommission
					set @tsMarginPercent_12 = @xMargin
					set @tsCommissionOnly_12 = @xCommissionOnly
					set @tsIsCommission_12 = @xIsCommission
				end
				else if (@tsKey_13 is null)
				begin
					set @tsKey_13 = @scpId
					set @tsSVKey_13 = @xSVKey
					set @tsGross_13 = @xBrutto
					set @tsAddIsCommission_13 = @xAddCostIsCommission
					set @tsAddNoCommission_13 = @xAddCostNoCommission
					set @tsMarginPercent_13 = @xMargin
					set @tsCommissionOnly_13 = @xCommissionOnly
					set @tsIsCommission_13 = @xIsCommission
				end
				else if (@tsKey_14 is null)
				begin
					set @tsKey_14 = @scpId
					set @tsSVKey_14 = @xSVKey
					set @tsGross_14 = @xBrutto
					set @tsAddIsCommission_14 = @xAddCostIsCommission
					set @tsAddNoCommission_14 = @xAddCostNoCommission
					set @tsMarginPercent_14 = @xMargin
					set @tsCommissionOnly_14 = @xCommissionOnly
					set @tsIsCommission_14 = @xIsCommission
				end
				else if (@tsKey_15 is null)
				begin
					set @tsKey_15 = @scpId
					set @tsSVKey_15 = @xSVKey
					set @tsGross_15 = @xBrutto
					set @tsAddIsCommission_15 = @xAddCostIsCommission
					set @tsAddNoCommission_15 = @xAddCostNoCommission
					set @tsMarginPercent_15 = @xMargin
					set @tsCommissionOnly_15 = @xCommissionOnly
					set @tsIsCommission_15 = @xIsCommission
				end
			end

			-- записываем значения текущего шага, для анализа на следующем шаге
			set @prevTPKey = @xTPKey
			set @prevToKey = @xToKey
			set @prevTiKey = @xTiKey
			set @prevTRKey = @xTRKey
			set @prevDays = @xDays
			set @prevTourDate = @xTourDate
			set @prevRate = @xRate
			set @prevHotelKey = @xHotelKey
			set @prevDepartureKey = @xDepartureKey

			fetch exportServiceCursor into @xTPKey, @xToKey, @xTiKey, @xTRKey, @xTourDate, @xDays, @xRate,
			@xHotelKey, @xDepartureKey, @xSVKey, @xCode, @xSubCode1, @xSubCode2, @xPRKey, @xDate,
			@xMen, @xServiceDays, @xPkKey, @xNetto, @xBrutto, @xIsCommission, @xMargin, @xCommissionOnly,
			@xAddCostIsCommission, @xAddCostNoCommission, @xServiceOrder
		end
		close exportServiceCursor
		deallocate exportServiceCursor

		print 'Работа курсора'
		print CONVERT(TIME, GETDATE())

		-- закончили формирование таблицы TP_PriceComponents
		--select * from #TP_Prices

		-- заливаем результат
		insert into TP_PriceComponents (PC_TIKey, PC_TOKey, PC_TRKey, PC_TourDate, PC_TPKey, PC_Days, PC_Rate, PC_HotelKey, PC_DepartureKey
		, SCPId_1, SCPId_2, SCPId_3, SCPId_4, SCPId_5, SCPId_6, SCPId_7, SCPId_8, SCPId_9, SCPId_10, SCPId_11, SCPId_12, SCPId_13, SCPId_14, SCPId_15
		, SVKey_1, SVKey_2, SVKey_3, SVKey_4, SVKey_5, SVKey_6, SVKey_7, SVKey_8, SVKey_9, SVKey_10, SVKey_11, SVKey_12, SVKey_13, SVKey_14, SVKey_15
		, Gross_1, Gross_2, Gross_3, Gross_4, Gross_5, Gross_6, Gross_7, Gross_8, Gross_9, Gross_10, Gross_11, Gross_12, Gross_13, Gross_14, Gross_15
		, AddCostIsCommission_1, AddCostIsCommission_2, AddCostIsCommission_3, AddCostIsCommission_4, AddCostIsCommission_5, AddCostIsCommission_6, AddCostIsCommission_7, AddCostIsCommission_8, AddCostIsCommission_9, AddCostIsCommission_10, AddCostIsCommission_11, AddCostIsCommission_12, AddCostIsCommission_13, AddCostIsCommission_14, AddCostIsCommission_15
		, AddCostNoCommission_1, AddCostNoCommission_2, AddCostNoCommission_3, AddCostNoCommission_4, AddCostNoCommission_5, AddCostNoCommission_6, AddCostNoCommission_7, AddCostNoCommission_8, AddCostNoCommission_9, AddCostNoCommission_10, AddCostNoCommission_11, AddCostNoCommission_12, AddCostNoCommission_13, AddCostNoCommission_14, AddCostNoCommission_15
		, MarginPercent_1, MarginPercent_2, MarginPercent_3, MarginPercent_4, MarginPercent_5, MarginPercent_6, MarginPercent_7, MarginPercent_8, MarginPercent_9, MarginPercent_10, MarginPercent_11, MarginPercent_12, MarginPercent_13, MarginPercent_14, MarginPercent_15
		, CommissionOnly_1, CommissionOnly_2, CommissionOnly_3, CommissionOnly_4, CommissionOnly_5, CommissionOnly_6, CommissionOnly_7, CommissionOnly_8, CommissionOnly_9, CommissionOnly_10, CommissionOnly_11, CommissionOnly_12, CommissionOnly_13, CommissionOnly_14, CommissionOnly_15
		, IsCommission_1, IsCommission_2, IsCommission_3, IsCommission_4, IsCommission_5, IsCommission_6, IsCommission_7, IsCommission_8, IsCommission_9, IsCommission_10, IsCommission_11, IsCommission_12, IsCommission_13, IsCommission_14, IsCommission_15)
		select xTP_TIKey, xtp_tokey, xtp_trkey, xTP_TourDate, xtp_key, xTP_Days, xTP_Rate, xTP_HotelKey, xTP_DepartureKey
		, xSCPId_1, xSCPId_2, xSCPId_3, xSCPId_4, xSCPId_5, xSCPId_6, xSCPId_7, xSCPId_8, xSCPId_9, xSCPId_10, xSCPId_11, xSCPId_12, xSCPId_13, xSCPId_14, xSCPId_15
		, xSvKey_1, xSvKey_2, xSvKey_3, xSvKey_4, xSvKey_5, xSvKey_6, xSvKey_7, xSvKey_8, xSvKey_9, xSvKey_10, xSvKey_11, xSvKey_12, xSvKey_13, xSvKey_14, xSvKey_15
		, xGross_1, xGross_2, xGross_3, xGross_4, xGross_5, xGross_6, xGross_7, xGross_8, xGross_9, xGross_10, xGross_11, xGross_12, xGross_13, xGross_14, xGross_15
		, xAddCostIsCommission_1, xAddCostIsCommission_2, xAddCostIsCommission_3, xAddCostIsCommission_4, xAddCostIsCommission_5, xAddCostIsCommission_6, xAddCostIsCommission_7, xAddCostIsCommission_8, xAddCostIsCommission_9, xAddCostIsCommission_10, xAddCostIsCommission_11, xAddCostIsCommission_12, xAddCostIsCommission_13, xAddCostIsCommission_14, xAddCostIsCommission_15
		, xAddCostNoCommission_1, xAddCostNoCommission_2, xAddCostNoCommission_3, xAddCostNoCommission_4, xAddCostNoCommission_5, xAddCostNoCommission_6, xAddCostNoCommission_7, xAddCostNoCommission_8, xAddCostNoCommission_9, xAddCostNoCommission_10, xAddCostNoCommission_11, xAddCostNoCommission_12, xAddCostNoCommission_13, xAddCostNoCommission_14, xAddCostNoCommission_15
		, xMarginPercent_1, xMarginPercent_2, xMarginPercent_3, xMarginPercent_4, xMarginPercent_5, xMarginPercent_6, xMarginPercent_7, xMarginPercent_8, xMarginPercent_9, xMarginPercent_10, xMarginPercent_11, xMarginPercent_12, xMarginPercent_13, xMarginPercent_14, xMarginPercent_15
		, xCommissionOnly_1, xCommissionOnly_2, xCommissionOnly_3, xCommissionOnly_4, xCommissionOnly_5, xCommissionOnly_6, xCommissionOnly_7, xCommissionOnly_8, xCommissionOnly_9, xCommissionOnly_10, xCommissionOnly_11, xCommissionOnly_12, xCommissionOnly_13, xCommissionOnly_14, xCommissionOnly_15
		, xIsCommission_1, xIsCommission_2, xIsCommission_3, xIsCommission_4, xIsCommission_5, xIsCommission_6, xIsCommission_7, xIsCommission_8, xIsCommission_9, xIsCommission_10, xIsCommission_11, xIsCommission_12, xIsCommission_13, xIsCommission_14, xIsCommission_15
		from #TP_Prices

		print 'Заливка результата'
		print CONVERT(TIME, GETDATE())
END
GO

GRANT EXECUTE ON [dbo].[ExportToDCTables]	TO PUBLIC
GO
/*********************************************************************/
/* end sp_ExportToDCTables.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_FillMasterWebSearchFields.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[FillMasterWebSearchFields]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[FillMasterWebSearchFields]
GO

create procedure [dbo].[FillMasterWebSearchFields](@tokey int, @calcKey int = null, @forceEnable smallint = null, @overwritePrices bit = null)
-- if @forceEnable > 0 (by default) then make call mwEnablePriceTour @calcKey, 1 at the end of the procedure
as
begin
	--<VERSION>2009.2.20</VERSION>
	--<DATE>2013-09-18</DATE>
	set @forceEnable = isnull(@forceEnable, 1)

	declare @findByAdultChild int, @newRecalcPrice int
	
	declare @counter int, @deleteCount int, @params nvarchar(500)
	
	set @findByAdultChild = isnull((select top 1 convert(int, SS_ParmValue) from SystemSettings where SS_ParmName = 'OnlineFindByAdultChild'), 0)
	set @newRecalcPrice = isnull((select top 1 convert(int, SS_ParmValue) from SystemSettings where SS_ParmName = 'NewReCalculatePrice'), 0)

	if (@tokey is null)
	begin
		print 'Procedure does not support NULL param. You must specify @tokey parameter.'
		return
	end

	DECLARE @departFromKey INT
	SELECT top 1 @departFromKey = TL_CTDepartureKey FROM tbl_TurList 
	INNER JOIN tp_Tours 
	ON TL_KEY = TO_TRKey
	WHERE TO_Key = @tokey
	
	IF EXISTS(SELECT 1 FROM mwSpoDataTable WHERE sd_tourkey = @tokey AND sd_ctkeyfrom <> @departFromKey)
	BEGIN
		SET @calcKey = null
		EXEC mwReplDisablePriceTour @tokey
	END

	update dbo.TP_Tours set TO_Progress = 0 where TO_Key = @tokey

	if dbo.mwReplIsSubscriber() > 0
	begin
		exec dbo.mwFillTP @tokey, @calcKey
	end

	create table #tmpHotelData (
		thd_tourkey int, 
		thd_firsthdkey int,
		thd_firstpnkey int, 
		thd_cnkey int, 
		thd_tlkey int, 
		thd_isenabled smallint, 
		thd_tourcreated datetime, 
		thd_hdstars nvarchar(15), 
		thd_ctkey int, 
		thd_rskey int, 
		thd_hdkey int, 
		thd_hdpartnerkey int, 
		thd_hrkey int, 
		thd_rmkey int, 
		thd_rckey int, 
		thd_ackey int, 
		thd_pnkey int, 
		thd_hdmain smallint,
		thd_firsthotelday int,
		thd_ctkeyfrom int, 
		thd_ctkeyto int, 
		thd_apkeyfrom int, 
		thd_apkeyto int,
		thd_tourtype int,
		thd_cnname nvarchar(200) collate database_default,
		thd_tourname nvarchar(200) collate database_default,
		thd_hdname nvarchar(200) collate database_default,
		thd_ctname nvarchar(200) collate database_default,
		thd_rsname nvarchar(200) collate database_default,
		thd_ctfromname nvarchar(200) collate database_default,
		thd_cttoname nvarchar(200) collate database_default,
		thd_tourtypename nvarchar(200) collate database_default,
		thd_pncode nvarchar(50) collate database_default,
		thd_hdorder int,
		thd_hotelkeys nvarchar(256) collate database_default,
		thd_pansionkeys nvarchar(256) collate database_default,
		thd_hotelnights nvarchar(256) collate database_default,
		thd_tourvalid datetime,
		thd_hotelurl varchar(254) collate database_default
	)

	-- создадим темповую ценовую таблицу
	select top 1 * into #tempPriceTable from mwPriceDataTable with(nolock)
	truncate table #tempPriceTable
	
	
	CREATE NONCLUSTERED INDEX [x_main] ON [dbo].[#tempPriceTable] 
	(
		pt_tourdate asc,
		pt_hdkey asc,
		pt_rmkey asc,
		pt_rckey asc,
		pt_ackey asc,
		pt_pnkey asc,
		pt_days asc,
		pt_nights asc,
		pt_tourtype asc,
		pt_ctkeyfrom asc
	)

	select top 1
		ti_key,
		ti_tokey,
		ti_firsthdkey,
		ti_firstpnkey,
		ti_firsthrkey,
		ti_firsthotelday,
		ti_lasthotelday,
		ti_totaldays,
		ti_nights,
		ti_hotelkeys,
		ti_hotelroomkeys,
		ti_hoteldays,
		ti_hotelstars,
		ti_pansionkeys,
		ti_hdpartnerkey,
		ti_firsthotelpartnerkey,
		ti_hdday,
		ti_hdnights,
		ti_chkey,
		ti_chday,
		ti_chpkkey,
		ti_chprkey,
		ti_ctkeyfrom,
		ti_chbackkey,
		ti_chbackday,
		ti_chbackpkkey,
		ti_chbackprkey,
		ti_ctkeyto,
		ti_apkeyfrom,
		ti_apkeyto,
		ti_firstctkey,
		ti_firstrskey,
		ti_firsthdstars
	into #tp_lists
	from tp_lists with(nolock)

	truncate table #tp_lists
	alter table #tp_lists add primary key(ti_key)

	-- Город отправления из свойств тура
	declare @ctdeparturekey int
	select	@ctdeparturekey = tl_ctdeparturekey
	from	tp_tours with(nolock)
		inner join tbl_turList with(nolock) on tbl_turList.tl_key = to_trkey
	where to_key = @tokey

	if (@ctdeparturekey is null or @ctdeparturekey = 0)
	begin
		-- Подбираем город вылета первого рейса
		exec GetCityDepartureKey @tokey, @ctdeparturekey output
	end

	declare @firsthdday int
	select @firsthdday = (select min(ts_day) 
				from tp_services with (nolock)
 				where ts_svkey = 3 and ts_tokey = @tokey)

	declare @count_ts_code int

	select @count_ts_code = count(distinct ts_code)
	from tp_services with(nolock)
	where ts_svkey = 1 and ts_tokey = @tokey 
	and (ts_day <= @firsthdday or (ts_day = 1 and @firsthdday = 0)) 
	and ts_subcode2 = @ctdeparturekey

	if (@count_ts_code > 1)
	begin
		if(@calcKey is not null)
		begin
			insert into #tp_lists
			select
				ti_key,
				ti_tokey,
				ti_firsthdkey,
				ti_firstpnkey,
				ti_firsthrkey,
				@firsthdday as ti_firsthotelday,
				ti_lasthotelday,
				ti_totaldays,
				ti_nights,
				ti_hotelkeys,
				ti_hotelroomkeys,
				ti_hoteldays,
				ti_hotelstars,
				ti_pansionkeys,
				ti_hdpartnerkey,
				ti_firsthotelpartnerkey,
				ti_hdday,
				ti_hdnights,
				(
					select top 1 ts_code
					from tp_servicelists with(nolock) 
					inner join tp_services with(nolock) on tl_tskey = ts_key and ts_svkey = 1
					where tl_tikey = ti_key and ts_tokey = @tokey and tl_tokey = @tokey 
					and (ts_day <= @firsthdday or (ts_day = 1 and @firsthdday = 0)) and ts_subcode2 = @ctdeparturekey
				) as ti_chkey,
				ti_chday,
				ti_chpkkey,
				ti_chprkey,
				ti_ctkeyfrom,
				ti_chbackkey,
				ti_chbackday,
				ti_chbackpkkey,
				ti_chbackprkey,
				ti_ctkeyto,
				ti_apkeyfrom,
				ti_apkeyto,
				ti_firstctkey,
				ti_firstrskey,
				ti_firsthdstars
			from tp_lists with(nolock)
			where TI_Key in (select TP_TIKey from TP_Prices where TP_TOKey = TI_TOKey and TP_CalculatingKey = @calcKey) 
			and TI_TOKey = @tokey
		end
		else
		begin
			insert into #tp_lists
			select
				ti_key,
				ti_tokey,
				ti_firsthdkey,
				ti_firstpnkey,
				ti_firsthrkey,
				@firsthdday as ti_firsthotelday,
				ti_lasthotelday,
				ti_totaldays,
				ti_nights,
				ti_hotelkeys,
				ti_hotelroomkeys,
				ti_hoteldays,
				ti_hotelstars,
				ti_pansionkeys,
				ti_hdpartnerkey,
				ti_firsthotelpartnerkey,
				ti_hdday,
				ti_hdnights,
				(
					select top 1 ts_code
					from tp_servicelists with(nolock) 
					inner join tp_services with(nolock) on tl_tskey = ts_key and ts_svkey = 1
					where tl_tikey = ti_key and ts_tokey = @tokey and tl_tokey = @tokey 
					and (ts_day <= @firsthdday or (ts_day = 1 and @firsthdday = 0)) and ts_subcode2 = @ctdeparturekey
				) as ti_chkey,	
				ti_chday,
				ti_chpkkey,
				ti_chprkey,
				ti_ctkeyfrom,
				ti_chbackkey,
				ti_chbackday,
				ti_chbackpkkey,
				ti_chbackprkey,
				ti_ctkeyto,
				ti_apkeyfrom,
				ti_apkeyto,
				ti_firstctkey,
				ti_firstrskey,
				ti_firsthdstars
			from tp_lists with(nolock)
			where TI_TOKey = @tokey		
		end
	end
	else
	begin

		declare @ts_code int
		declare @ti_key int
		select top 1 @ti_key = ti_key
		from tp_lists with(nolock)
		where TI_TOKey = @tokey	

		select top 1 @ts_code = ts_code
		from tp_services with(nolock)
		where ts_svkey = 1 and ts_tokey = @tokey
		and (ts_day <= @firsthdday or (ts_day = 1 and @firsthdday = 0)) 
		and ts_subcode2 = @ctdeparturekey

		if(@calcKey is not null)
		begin
			insert into #tp_lists
			select
				ti_key,
				ti_tokey,
				ti_firsthdkey,
				ti_firstpnkey,
				ti_firsthrkey,
				@firsthdday as ti_firsthotelday,
				ti_lasthotelday,
				ti_totaldays,
				ti_nights,
				ti_hotelkeys,
				ti_hotelroomkeys,
				ti_hoteldays,
				ti_hotelstars,
				ti_pansionkeys,
				ti_hdpartnerkey,
				ti_firsthotelpartnerkey,
				ti_hdday,
				ti_hdnights,
				@ts_code as ti_chkey,			
				ti_chday,
				ti_chpkkey,
				ti_chprkey,
				ti_ctkeyfrom,
				ti_chbackkey,
				ti_chbackday,
				ti_chbackpkkey,
				ti_chbackprkey,
				ti_ctkeyto,
				ti_apkeyfrom,
				ti_apkeyto,
				ti_firstctkey,
				ti_firstrskey,
				ti_firsthdstars
			from tp_lists with(nolock)
			where TI_Key in (select TP_TIKey from TP_Prices where TP_TOKey = TI_TOKey and TP_CalculatingKey = @calcKey) 
			and TI_TOKey = @tokey
		end
		else
		begin
			insert into #tp_lists
			select
				ti_key,
				ti_tokey,
				ti_firsthdkey,
				ti_firstpnkey,
				ti_firsthrkey,
				@firsthdday as ti_firsthotelday,
				ti_lasthotelday,
				ti_totaldays,
				ti_nights,
				ti_hotelkeys,
				ti_hotelroomkeys,
				ti_hoteldays,
				ti_hotelstars,
				ti_pansionkeys,
				ti_hdpartnerkey,
				ti_firsthotelpartnerkey,
				ti_hdday,
				ti_hdnights,
				@ts_code as ti_chkey,			
				ti_chday,
				ti_chpkkey,
				ti_chprkey,
				ti_ctkeyfrom,
				ti_chbackkey,
				ti_chbackday,
				ti_chbackpkkey,
				ti_chbackprkey,
				ti_ctkeyto,
				ti_apkeyfrom,
				ti_apkeyto,
				ti_firstctkey,
				ti_firstrskey,
				ti_firsthdstars
			from tp_lists with(nolock)
			where TI_TOKey = @tokey		
		end
	end

	declare @mwAccomodationPlaces nvarchar(254)
	declare @mwRoomsExtraPlaces nvarchar(254)
	declare @mwSearchType int
	declare @sql nvarchar(4000)
	declare @countryKey int
	declare @cityFromKey int

	update dbo.TP_Tours with(rowlock) set TO_Progress = 7 where TO_Key = @tokey

	update TP_Tours with(rowlock) set TO_MinPrice = (
			select min(TP_Gross) 
			from TP_Prices with(nolock) 
				left join TP_Lists with(nolock) on ti_key = tp_tikey
				left join HotelRooms with(nolock) on hr_key = ti_firsthrkey				
			where TP_TOKey = TO_Key 
					and hr_main > 0 
					and (isnull(HR_AGEFROM, 0) <= 0 or isnull(HR_AGEFROM, 0) > 16)
		)
		where TO_Key = @tokey

	update dbo.TP_Tours with(rowlock) set TO_Progress = 13 where TO_Key = @tokey

	update #tp_lists with(rowlock)
	set
		ti_lasthotelday = (select max(ts_day)
				from tp_servicelists  with (nolock)
					inner join tp_services with (nolock) on tl_tskey = ts_key
				where tl_tikey = ti_key and ts_svkey = 3 and TS_TOKey = @tokey and TL_TOKey = @tokey)

	update dbo.TP_Tours with(rowlock) set TO_Progress = 20 where TO_Key = @tokey	

	update dbo.TP_Tours with(rowlock) set TO_Progress = 30 where TO_Key = @tokey

	-- MEG00024548 Paul G 11.01.2009
	-- изменил логику подсчёта кол-ва ночей в туре
	-- раньше было сумма ночей проживания по всем отелям в туре
	-- теперь если проживания пересекаются, лишние ночи не суммируются
	update #tp_lists with(rowlock)
	set
		ti_nights = dbo.mwGetTiNights(ti_key)

	--koshelev
	--02.04.2012 MEG00040744
    declare @result nvarchar(256)
    set @result = N''
    select @result = @result + rtrim(ltrim(str(tbl.ti_nights))) + N', ' from (select distinct ti_nights from (select ti_nights from #tp_lists union select ti_nights from tp_lists where ti_tokey = @tokey ) as tbl2) tbl order by tbl.ti_nights
    declare @len int
    set @len = len(@result)
    if(@len > 0)
          set @result = substring(@result, 1, @len - 1)

    update TP_Tours with(rowlock) set TO_HotelNights = @result where TO_Key = @tokey

	update dbo.TP_Tours with(rowlock) set TO_Progress = 40 where TO_Key = @tokey

	update #tp_lists with(rowlock)
		set ti_hotelkeys = dbo.mwGetTiHotelKeys(ti_key),
			ti_hotelroomkeys = dbo.mwGetTiHotelRoomKeys(ti_key),
			ti_hoteldays = dbo.mwGetTiHotelNights(ti_key),
			ti_hotelstars = dbo.mwGetTiHotelStars(ti_key),
			ti_pansionkeys = dbo.mwGetTiPansionKeys(ti_key)

	update #tp_lists with(rowlock)
	set
		ti_hdpartnerkey = ts_oppartnerkey,
		ti_firsthotelpartnerkey = ts_oppartnerkey,
		ti_hdday = ts_day,
		ti_hdnights = ts_days
	from tp_servicelists with (nolock)
		inner join tp_services with (nolock) on (tl_tskey = ts_key and ts_svkey = 3)
	where tl_tikey = ti_key and ts_code = ti_firsthdkey and TS_TOKey = @tokey and TL_TOKey = @tokey

	update dbo.TP_Tours with(rowlock) set TO_Progress = 50 where TO_Key = @tokey

	-- город вылета + прямой перелет
	update #tp_lists with(rowlock)
	set 
		ti_chday = ts_day,
		ti_chpkkey = ts_oppacketkey,
		ti_chprkey = ts_oppartnerkey
	from tp_servicelists with(nolock) inner join tp_services with(nolock) on tl_tskey = ts_key and ts_svkey = 1
	where	tl_tikey = ti_key 
		and (ts_day <= ti_firsthotelday or (ts_day = 1 and ti_firsthotelday = 0))
		and ts_code = ti_chkey 
		and ts_subcode2 = @ctdeparturekey
		and TS_TOKey = @tokey and TL_TOKey = @tokey

	update #tp_lists with(rowlock)
	set 
		ti_ctkeyfrom = @ctdeparturekey

	-- Проверка наличия перелетов в город вылета
	declare @existBackCharter smallint
	select	@existBackCharter = count(ts_key)
	from	tp_services
	where	ts_tokey = @tokey
		and	ts_svkey = 1
		and ts_ctkey = @ctdeparturekey

	-- город прилета + обратный перелет
	update #tp_lists with(rowlock) 
	set 
		ti_chbackkey = ts_code,
		ti_chbackday = ts_day,
		ti_chbackpkkey = ts_oppacketkey,
		ti_chbackprkey = ts_oppartnerkey,
		ti_ctkeyto = ts_subcode2
	from tp_servicelists with(nolock)
		inner join tp_services with(nolock) on (tl_tskey = ts_key and ts_svkey = 1)
		inner join tp_tours with(nolock) on ts_tokey = to_key 
	where 
		tl_tikey = ti_key 
		and ts_day > ti_lasthotelday
		and (ts_ctkey = @ctdeparturekey or @existBackCharter = 0)
		and TI_TOKey = @tokey
		and TS_TOKey = @tokey and TL_TOKey = @tokey

	-- _ключ_ аэропорта вылета
	update #tp_lists with(rowlock)
	set 
		ti_apkeyfrom = (select top 1 ap_key from airport with(nolock), charter with(nolock) 
				where ch_portcodefrom = ap_code 
					and ch_key = ti_chkey)

	-- _ключ_ аэропорта прилета
	update #tp_lists with(rowlock)
	set 
		ti_apkeyto = (select top 1 ap_key from airport with(nolock), charter with(nolock) 
				where ch_portcodefrom = ap_code 
					and ch_key = ti_chbackkey)

	-- ключ города и ключ курорта + звезды
	update #tp_lists with(rowlock)
	set
		ti_firstctkey = hd_ctkey,
		ti_firstrskey = hd_rskey,
		ti_firsthdstars = hd_stars
	from hoteldictionary with(nolock)
	where 
		ti_firsthdkey = hd_key

	update dbo.TP_Tours with(rowlock) set TO_Progress = 60 where TO_Key = @tokey

	if dbo.mwReplIsPublisher() > 0
	begin
		declare @trkey int
		select @trkey = to_trkey from dbo.tp_tours with(nolock) where to_key = @tokey
		
		insert into dbo.mwReplTours with(rowlock) (rt_trkey, rt_tokey, rt_date, rt_CalcKey)
		values (@trkey, @tokey, getdate(), @calcKey)
		
		update CalculatingPriceLists with(rowlock) set CP_Status = 0 where CP_PriceTourKey = @tokey
		update dbo.TP_Tours with(rowlock) 
		set TO_Update = 0, 
			TO_Progress = 100,
			TO_IsEnabled = 1
		where TO_Key = @tokey
		
		--return
	end

	-- временная таблица с информацией об отелях
	insert into #tmpHotelData (
		thd_tourkey, 
		thd_firsthdkey, 
		thd_firstpnkey, 
		thd_cnkey, 
		thd_tlkey, 
		thd_isenabled, 
		thd_tourcreated, 
		thd_hdstars, 
		thd_ctkey, 
		thd_rskey, 
		thd_hdkey, 
		thd_hdpartnerkey, 
		thd_hrkey, 
		thd_rmkey, 
		thd_rckey, 
		thd_ackey, 
		thd_pnkey, 
		thd_hdmain,
		thd_firsthotelday,
		thd_ctkeyfrom, 
		thd_ctkeyto, 
		thd_apkeyfrom, 
		thd_apkeyto,
		thd_tourtype,
		thd_cnname,
		thd_tourname,
		thd_hdname,
		thd_ctname,
		thd_rsname,
		thd_ctfromname,
		thd_cttoname,
		thd_tourtypename,
		thd_pncode,
		thd_hotelkeys,
		thd_pansionkeys,
		thd_hotelnights,
		thd_tourvalid,
		thd_hotelurl
	)
	select distinct 
		to_key, 
		ti_firsthdkey, 
		ti_firstpnkey,
		to_cnkey, 
		to_trkey, 
		@forceEnable, 
		to_datecreated, 
		hd_stars, 
		hd_ctkey, 
		hd_rskey, 
		ts_code, 
		ts_oppartnerkey, 
		ts_subcode1, 
		hr_rmkey, 
		hr_rckey, 
		hr_ackey, 
		ts_subcode2, 
		(case ts_code when ti_firsthdkey then 1 else 0 end),
		ti_firsthotelday,
		isnull(ti_ctkeyfrom, 0), 
		ti_ctkeyto, 
		ti_apkeyfrom, 
		ti_apkeyto,
		tl_tip,
		cn_name,
		isnull(tl_nameweb, isnull(to_name, tl_name)),
		hd_name,
		ct_name,
		null,
		null,
		null,
		tp_name,
		pn_code,
		ti_hotelkeys,
		ti_pansionkeys,
		ti_hoteldays,
		to_datevalid,
		hd_http
	from #tp_lists with(nolock)
		inner join tp_tours with(nolock) on ti_tokey = to_key
		inner join tp_servicelists with(nolock) on tl_tikey = ti_key 
		inner join tp_services with(nolock) on (tl_tskey = ts_key and ts_svkey = 3) 
		inner join hoteldictionary with(nolock) on ts_code = hd_key
		inner join hotelrooms with(nolock) on hr_key = ts_subcode1
		inner join turList with(nolock) on turList.tl_key = to_trkey
		inner join country with(nolock) on cn_key = to_cnkey
		inner join citydictionary with(nolock) on ct_key = hd_ctkey
		inner join tiptur with(nolock) on tp_key = tl_tip
		inner join pansion with(nolock) on pn_key = ts_subcode2
	where to_key = @tokey and to_datevalid >= getdate() 
		and TS_TOKey = @tokey and TL_TOKey = @tokey

	update #tmpHotelData set thd_hdorder = (select min(ts_day) from tp_services with(nolock) where ts_tokey = thd_tourkey and ts_svkey = 3 and ts_code = thd_hdkey)
	update #tmpHotelData set thd_rsname = rs_name from resorts with(nolock) where rs_key = thd_rskey
	update #tmpHotelData set thd_ctfromname = ct_name from citydictionary with(nolock) where ct_key = thd_ctkeyfrom
	update #tmpHotelData set thd_ctfromname = '-Без перелета-' where thd_ctkeyfrom = 0
	update #tmpHotelData set thd_cttoname = ct_name from citydictionary with(nolock) where ct_key = thd_ctkeyto
	update #tmpHotelData set thd_cttoname = '-Без перелета-' where thd_ctkeyto = 0
	--

	update dbo.TP_Tours set TO_Progress = 70 where TO_Key = @tokey

	select @mwAccomodationPlaces = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings with(nolock)
	where SS_ParmName = 'MWAccomodationPlaces'

	select @mwRoomsExtraPlaces = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWRoomsExtraPlaces'

	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'

	if (@calcKey is null)
	begin
		delete from dbo.mwSpoDataTable with(rowlock) where sd_tourkey = @tokey
		delete from dbo.mwPriceHotels with(rowlock) where sd_tourkey = @tokey
		delete from dbo.mwPriceDurations with(rowlock) where sd_tourkey = @tokey
	end
	else
	begin
		--saifullina 16.01.2013 если мы изменили название и дозаписываем тур, то должны дозаписать с новым названием
		update dbo.mwSpoDataTable set sd_tourname=(select to_name from TP_Tours where TO_Key=@tokey) where sd_tourkey = @tokey
	end

	--MEG00026692 Paul G 25.03.2010
	--функции от ti_key должны вызываться на каждую запись из tp_lists
	--поэтому результаты их выполнения записываю в темповую таблицу
	--которую джоиню в последующем селекте
	create table #tempTourInfo (
		tt_tikey int,
		tt_charterto varchar(256) collate database_default,
		tt_charterback varchar(256) collate database_default,
		tt_tourhotels varchar(256) collate database_default,
		tt_directFlightAttribute int,
		tt_backFlightAttribute int
	)

	insert into #tempTourInfo
	(
		tt_tikey, 
		tt_charterto, 
		tt_charterback, 
		tt_tourhotels,
		tt_directFlightAttribute,
		tt_backFlightAttribute
	)
	select 
		ti_key, 
		dbo.mwGetTourCharters(ti_key, 1), 
		dbo.mwGetTourCharters(ti_key, 0), 
		dbo.mwGetTourHotels(ti_key),
		dbo.mwGetTourCharterAttribute(ti_key, 1),
		dbo.mwGetTourCharterAttribute(ti_key, 0)
	from #tp_lists with(nolock)
	--End MEG00026692	

	if(@calcKey is not null)
	begin
		insert into #tempPriceTable (
			[pt_mainplaces],
			[pt_addplaces],
			[pt_main],
			[pt_tourvalid],
			[pt_tourcreated],
			[pt_tourdate],
			[pt_days],
			[pt_nights],
			[pt_cnkey],
			[pt_ctkeyfrom],
			[pt_apkeyfrom],
			[pt_ctkeyto],
			[pt_apkeyto],
			[pt_ctkeybackfrom],
			[pt_ctkeybackto],
			[pt_tourkey],
			[pt_tourtype],
			[pt_tlkey],
			[pt_pricelistkey],
			[pt_pricekey],
			[pt_price],
			[pt_hdkey],
			[pt_hdpartnerkey],
			[pt_rskey],
			[pt_ctkey],
			[pt_hdstars],
			[pt_pnkey],
			[pt_hrkey],
			[pt_rmkey],
			[pt_rckey],
			[pt_ackey],
			[pt_childagefrom],
			[pt_childageto],
			[pt_childagefrom2],
			[pt_childageto2],
			[pt_hdname],
			[pt_tourname],
			[pt_pnname],
			[pt_pncode],
			[pt_rmname],
			[pt_rmcode],
			[pt_rcname],
			[pt_rccode],
			[pt_acname],
			[pt_accode],
			[pt_rsname],
			[pt_ctname],
			[pt_rmorder],
			[pt_rcorder],
			[pt_acorder],
			[pt_rate],
			[pt_toururl],
			[pt_hotelurl],
			[pt_isenabled],
			[pt_chkey],
			[pt_chbackkey],
			[pt_hdday],
			[pt_hdnights],
			[pt_chday],
			[pt_chpkkey],
			[pt_chprkey],
			[pt_chbackday],
			[pt_chbackpkkey],
			[pt_chbackprkey],
			pt_hotelkeys,
			pt_hotelroomkeys,
			pt_hotelstars,
			pt_pansionkeys,
			pt_hotelnights,
			pt_chdirectkeys,
			pt_chbackkeys,
			[pt_topricefor],
			pt_tlattribute,
			pt_hddetails,
			pt_directFlightAttribute,
			pt_backFlightAttribute
		)
		select 
				(	case when @mwAccomodationPlaces = '0'
					then isnull(rm_nplaces, 0)
					else (	case when @findByAdultChild = 1 -- искать по взрослым
							then isnull(AC_NADMAIN, 0) + isnull(AC_NADEXTRA,0)
							-- искать по основным
							else isnull(AC_NADMAIN, 0) + isnull(AC_NCHMAIN, 0)
							end)
					end),
				(	case when isnull(ac_nmenexbed, -1) = -1
					then (	case when @mwRoomsExtraPlaces <> '0' 
							then isnull(rm_nplacesex, 0)
							else isnull(ac_nmenexbed, 0)
							end)
					else (	case when @findByAdultChild = 1 -- искать по детям
							then isnull(AC_NCHMAIN, 0) + isnull(AC_NCHEXTRA, 0)
							-- искать по дополнительным местам
							else isnull(AC_NADEXTRA, 0) + isnull(AC_NCHEXTRA, 0)
							end)
					end),
			hr_main, 
			to_datevalid, 
			to_datecreated, 
			td_date,
			ti_totaldays,
			ti_nights,
			to_cnkey, 
			isnull(ti_ctkeyfrom, 0), 
			ti_apkeyfrom,
			ti_ctkeyto, 
			ti_apkeyto, 
			null,
			null,
			to_key, 
			tl_tip,
			tl_key, 
			ti_key, 
			tp_key,
			tp_gross, 
			ti_firsthdkey, 
			ti_hdpartnerkey,
			hd_rskey, 
			hd_ctkey, 
			hd_stars, 
			ti_firstpnkey,
			ti_firsthrkey, 
			hr_rmkey, 
			hr_rckey, 
			hr_ackey,
			ac_agefrom, 
			ac_ageto, 
			ac_agefrom2,
			ac_ageto2, 
			hd_name, 
			substring(tl_nameweb,1,128), 
			pn_name, 
			pn_code, 
			rm_name, 
			rm_code,
			rc_name, 
			rc_code, 
			ac_name, 
			ac_code, 
			rs_name,
			ct_name, 
			rm_order, 
			rc_order, 
			ac_order,
			to_rate,
			tl_webhttp,
			hd_http, 
			@forceEnable,
			ti_chkey,
			ti_chbackkey,
			ti_hdday,
			ti_hdnights,
			ti_chday,
			ti_chpkkey,
			ti_chprkey,
			ti_chbackday,
			ti_chbackpkkey,
			ti_chbackprkey,
			ti_hotelkeys,
			ti_hotelroomkeys,
			ti_hotelstars,
			ti_pansionkeys,
			ti_hoteldays,
			tt_charterto,
			tt_charterback,
			to_pricefor,
			tl_attribute,
			tt_tourhotels,
			tt_directFlightAttribute,
			tt_backFlightAttribute
		from tp_tours with(nolock)
			inner join turList with(nolock) on to_trkey = tl_key
			inner join #tp_lists with(nolock) on ti_tokey = to_key
			inner join tp_prices with(nolock) on tp_tikey = ti_key
			inner join tp_turdates with(nolock) on (td_tokey = to_key and td_date between tp_datebegin and tp_dateend)
			inner join hoteldictionary with(nolock) on ti_firsthdkey = hd_key
			inner join hotelrooms with(nolock) on ti_firsthrkey = hr_key
			inner join pansion with(nolock) on ti_firstpnkey = pn_key
			inner join rooms with(nolock) on hr_rmkey = rm_key
			inner join roomscategory with(nolock) on hr_rckey = rc_key
			inner join accmdmentype with(nolock) on hr_ackey = ac_key
			inner join citydictionary with(nolock) on hd_ctkey = ct_key
			left outer join resorts with(nolock) on hd_rskey = rs_key
			inner join #tempTourInfo on tt_tikey = ti_key
		where
			to_key = @tokey and TP_CalculatingKey = @calcKey
	end
	else
	begin
		insert into #tempPriceTable (
			[pt_mainplaces],
			[pt_addplaces],
			[pt_main],
			[pt_tourvalid],
			[pt_tourcreated],
			[pt_tourdate],
			[pt_days],
			[pt_nights],
			[pt_cnkey],
			[pt_ctkeyfrom],
			[pt_apkeyfrom],
			[pt_ctkeyto],
			[pt_apkeyto],
			[pt_ctkeybackfrom],
			[pt_ctkeybackto],
			[pt_tourkey],
			[pt_tourtype],
			[pt_tlkey],
			[pt_pricelistkey],
			[pt_pricekey],
			[pt_price],
			[pt_hdkey],
			[pt_hdpartnerkey],
			[pt_rskey],
			[pt_ctkey],
			[pt_hdstars],
			[pt_pnkey],
			[pt_hrkey],
			[pt_rmkey],
			[pt_rckey],
			[pt_ackey],
			[pt_childagefrom],
			[pt_childageto],
			[pt_childagefrom2],
			[pt_childageto2],
			[pt_hdname],
			[pt_tourname],
			[pt_pnname],
			[pt_pncode],
			[pt_rmname],
			[pt_rmcode],
			[pt_rcname],
			[pt_rccode],
			[pt_acname],
			[pt_accode],
			[pt_rsname],
			[pt_ctname],
			[pt_rmorder],
			[pt_rcorder],
			[pt_acorder],
			[pt_rate],
			[pt_toururl],
			[pt_hotelurl],
			[pt_isenabled],
			[pt_chkey],
			[pt_chbackkey],
			[pt_hdday],
			[pt_hdnights],
			[pt_chday],
			[pt_chpkkey],
			[pt_chprkey],
			[pt_chbackday],
			[pt_chbackpkkey],
			[pt_chbackprkey],
			pt_hotelkeys,
			pt_hotelroomkeys,
			pt_hotelstars,
			pt_pansionkeys,
			pt_hotelnights,
			pt_chdirectkeys,
			pt_chbackkeys,
			[pt_topricefor],
			pt_tlattribute,
			pt_hddetails,
			pt_directFlightAttribute,
			pt_backFlightAttribute
		)
		select
				(	case when @mwAccomodationPlaces = '0'
					then isnull(rm_nplaces, 0)
					else (	case when @findByAdultChild = 1 -- искать по взрослым
							then isnull(AC_NADMAIN, 0) + isnull(AC_NADEXTRA,0)
							-- искать по основным
							else isnull(AC_NADMAIN, 0) + isnull(AC_NCHMAIN, 0)
							end)
					end),
				(	case when isnull(ac_nmenexbed, -1) = -1
					then (	case when @mwRoomsExtraPlaces <> '0' 
							then isnull(rm_nplacesex, 0)
							else isnull(ac_nmenexbed, 0)
							end)
					else (	case when @findByAdultChild = 1 -- искать по детям
							then isnull(AC_NCHMAIN, 0) + isnull(AC_NCHEXTRA, 0)
							-- искать по дополнительным местам
							else isnull(AC_NADEXTRA, 0) + isnull(AC_NCHEXTRA, 0)
							end)
					end),
			hr_main, 
			to_datevalid, 
			to_datecreated, 
			td_date,
			ti_totaldays,
			ti_nights,
			to_cnkey, 
			isnull(ti_ctkeyfrom, 0), 
			ti_apkeyfrom,
			ti_ctkeyto, 
			ti_apkeyto, 
			null,
			null,
			to_key, 
			tl_tip,
			tl_key, 
			ti_key, 
			tp_key,
			tp_gross, 
			ti_firsthdkey, 
			ti_hdpartnerkey,
			hd_rskey, 
			hd_ctkey, 
			hd_stars, 
			ti_firstpnkey,
			ti_firsthrkey, 
			hr_rmkey, 
			hr_rckey, 
			hr_ackey,
			ac_agefrom, 
			ac_ageto, 
			ac_agefrom2,
			ac_ageto2, 
			hd_name, 
			substring(tl_nameweb,1,128), 
			pn_name, 
			pn_code, 
			rm_name, 
			rm_code,
			rc_name, 
			rc_code, 
			ac_name, 
			ac_code, 
			rs_name,
			ct_name, 
			rm_order, 
			rc_order, 
			ac_order,
			to_rate,
			tl_webhttp,
			hd_http, 
			@forceEnable,
			ti_chkey,
			ti_chbackkey,
			ti_hdday,
			ti_hdnights,
			ti_chday,
			ti_chpkkey,
			ti_chprkey,
			ti_chbackday,
			ti_chbackpkkey,
			ti_chbackprkey,
			ti_hotelkeys,
			ti_hotelroomkeys,
			ti_hotelstars,
			ti_pansionkeys,
			ti_hoteldays,
			tt_charterto,
			tt_charterback,
			to_pricefor,
			tl_attribute,
			tt_tourhotels,
			tt_directFlightAttribute,
			tt_backFlightAttribute
		from tp_tours with(nolock)
			inner join turList with(nolock) on to_trkey = tl_key
			inner join #tp_lists with(nolock) on ti_tokey = to_key
			inner join tp_prices with(nolock) on tp_tikey = ti_key
			inner join tp_turdates with(nolock) on (td_tokey = to_key and td_date between tp_datebegin and tp_dateend)
			inner join hoteldictionary with(nolock) on ti_firsthdkey = hd_key
			inner join hotelrooms with(nolock) on ti_firsthrkey = hr_key
			inner join pansion with(nolock) on ti_firstpnkey = pn_key
			inner join rooms with(nolock) on hr_rmkey = rm_key
			inner join roomscategory with(nolock) on hr_rckey = rc_key
			inner join accmdmentype with(nolock) on hr_ackey = ac_key
			inner join citydictionary with(nolock) on hd_ctkey = ct_key
			left outer join resorts with(nolock) on hd_rskey = rs_key
			inner join #tempTourInfo on tt_tikey = ti_key
		where
			to_key = @tokey and TP_TOKey = @tokey
	end	

	--чтобы не перевыставлялись удаленные цены при выставлении тура в он-лайн
	update #tempPriceTable set pt_isenabled = 0 where exists (select 1 from mwdeleted with (nolock) where del_key = pt_pricekey)

	update dbo.TP_Tours set TO_Progress = 80 where TO_Key = @tokey

	if dbo.mwReplIsPublisher() <= 0
	begin
		insert into dbo.mwPriceDurations with(rowlock) (
			sd_tourkey,
			sd_tlkey,
			sd_days,
			sd_nights,
			sd_hdnights
		)
		select distinct
			ti_tokey,
			to_trkey,
			ti_totaldays,
			ti_nights,
			ti_hoteldays
		from #tp_lists with(nolock) inner join tp_tours with(nolock) on ti_tokey = to_key

		-- Даты в поисковой таблице ставим как в таблице туров - чтобы не было двоений MEG00021274
		update mwspodatatable with(rowlock) 
		set sd_tourcreated = to_datecreated 
		from tp_tours with(nolock)
		where sd_tourkey = to_key 		
			and to_key = @tokey
			and sd_tourcreated != to_datecreated 

		set @counter = -1
		set @deleteCount = 50000
		set @params = '@counterOut int output'

		-- Переписываем данные из временной таблицы и уничтожаем ее
		if @mwSearchType = 0
		begin
			while(@counter <> 0)
			begin
				if (@calcKey is not null)
					set @sql = 'delete top (' + ltrim(STR(@deleteCount)) +  ') from mwPriceDataTable with(rowlock) where pt_pricekey in (select tp_key from tp_prices with(nolock) where TP_CalculatingKey = ' + cast(@calcKey as nvarchar(20)) + '); set @counterOut = @@ROWCOUNT'
				else
					set @sql = 'delete top(' + ltrim(STR(@deleteCount)) + ') from mwPriceDataTable with(rowlock) where pt_tourkey = ' + cast(@tokey as nvarchar(20)) + ';set @counterOut = @@ROWCOUNT'
				EXECUTE sp_executesql @sql, @params, @counterOut = @counter output
			end
		
			exec dbo.mwFillPriceTable '#tempPriceTable', 0, 0
		end
		else
		begin			
			declare cur cursor fast_forward for select distinct thd_cnkey, isnull(thd_ctkeyfrom, 0) from #tmpHotelData
			open cur
			fetch next from cur into @countryKey, @cityFromKey
			while @@fetch_status = 0
			begin
				exec dbo.mwCreateNewPriceTable @countryKey, @cityFromKey

				set @counter = -1
				set @params = '@counterOut int output'
				while(@counter <> 0)
				begin
					if (@calcKey is not null)
						set @sql = 'delete top (' + ltrim(rtrim(str(@deleteCount)))  + ') from ' + dbo.mwGetPriceTableName(@countryKey, @cityFromKey) + ' with(rowlock) where pt_pricekey in (select tp_key from tp_prices with(nolock) where TP_CalculatingKey = ' + cast(@calcKey as nvarchar(20)) + '); set @counterOut = @@ROWCOUNT'
					else
						set @sql = 'delete top (' + ltrim(rtrim(str(@deleteCount))) + ') from ' + dbo.mwGetPriceTableName(@countryKey, @cityFromKey) + ' with(rowlock) where pt_tourkey = ' + cast(@tokey as nvarchar(20)) + '; set @counterOut = @@ROWCOUNT'
					EXECUTE sp_executesql @sql, @params, @counterOut = @counter output
				end

				exec dbo.mwFillPriceTable '#tempPriceTable', @countryKey, @cityFromKey

				exec dbo.mwCreatePriceTableIndexes @countryKey, @cityFromKey
				fetch next from cur into @countryKey, @cityFromKey
			end		
			close cur
			deallocate cur
		end
	end
	
	if dbo.mwReplIsPublisher() <= 0
	begin

		update dbo.TP_Tours set TO_Progress = 90 where TO_Key = @tokey

		insert into dbo.mwPriceHotels with(rowlock) (
			sd_tourkey,
			sd_mainhdkey,
			sd_mainpnkey,
			sd_hdkey,
			sd_hdstars,
			sd_hdctkey,
			sd_hdrskey,
			sd_hrkey,
			sd_rmkey,
			sd_rckey,
			sd_ackey,
			sd_pnkey,
			sd_hdorder)
		select distinct 
			thd_tourkey, 
			thd_firsthdkey, 
			thd_firstpnkey,
			thd_hdkey, 
			thd_hdstars, 
			thd_ctkey, 
			thd_rskey, 
			thd_hrkey, 
			thd_rmkey, 
			thd_rckey, 
			thd_ackey, 
			thd_pnkey,
			thd_hdorder
		from #tmpHotelData

		-- информация об отелях
		insert into mwSpoDataTable with(rowlock)(
			sd_tourkey, 
			sd_cnkey, 
			sd_hdkey, 
			sd_hdstars, 
			sd_ctkey, 
			sd_rskey, 
			sd_ctkeyfrom, 
			sd_ctkeyto, 
			sd_tlkey, 
			sd_isenabled, 
			sd_tourcreated,
			sd_main,
			sd_pnkey,
			sd_tourtype,
			sd_cnname,
			sd_tourname,
			sd_hdname,
			sd_ctname,
			sd_rsname,
			sd_ctfromname,
			sd_cttoname,
			sd_tourtypename,
			sd_pncode,
			sd_hotelkeys,
			sd_pansionkeys,
			sd_tourvalid,

			sd_hotelurl,
			sd_hdprkey
		) 
		select distinct 
			thd_tourkey, 
			thd_cnkey, 
			thd_hdkey, 
			thd_hdstars, 
			thd_ctkey, 
			thd_rskey, 
			thd_ctkeyfrom, 
			thd_ctkeyto, 
			thd_tlkey, 
			thd_isenabled, 
			thd_tourcreated,
			thd_hdmain,
			thd_pnkey,
			thd_tourtype,
			thd_cnname,
			thd_tourname,
			thd_hdname,
			thd_ctname,
			thd_rsname,
			thd_ctfromname,
			thd_cttoname,
			thd_tourtypename,
			thd_pncode,
			thd_hotelkeys,
			thd_pansionkeys,
			thd_tourvalid,
			thd_hotelurl,
			thd_hdpartnerkey
		from #tmpHotelData 
		where thd_hdmain > 0

		update mwPriceHotels with(rowlock) set ph_sdkey = mwsdt.sd_key
			from mwSpoDataTable mwsdt with(nolock)
			where mwsdt.sd_tourkey = mwPriceHotels.sd_tourkey and mwsdt.sd_hdkey = mwPriceHotels.sd_mainhdkey
				and mwsdt.sd_tourkey = @tokey
				and mwPriceHotels.sd_tourkey = @tokey

		-- Указываем на необходимость обновления в таблице минимальных цен отеля
		update mwHotelDetails with(rowlock)
			set htd_needupdate = 1
			where htd_hdkey in (select thd_hdkey from #tmpHotelData)
			
	end
	
	if dbo.mwReplIsSubscriber() > 0
	begin
		while 1=1
		begin
			delete top (10000) from TP_Prices with(rowlock) where tp_tokey = @tokey
			if @@rowcount = 0
				break
		end
	
		while 1=1
		begin
			delete top (10000) from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
			if @@rowcount = 0
				break
		end
		
		while 1=1
		begin
			delete top (10000) from TP_Services with(rowlock) where ts_tokey = @tokey
			if @@rowcount = 0
				break
		end
		
		while 1=1
		begin
			delete top (10000) from TP_Lists with(rowlock) where ti_tokey = @tokey
			if @@rowcount = 0
				break
		end
		-- don't delete from TP_Tours	
	end
	else
	begin
		update tp_lists with(rowlock)
		set
			ti_firsthdkey = ti.ti_firsthdkey,
			ti_lasthotelday = ti.ti_lasthotelday,			
			ti_nights = ti.ti_nights,
			ti_hotelkeys = ti.ti_hotelkeys,
			ti_hotelroomkeys = ti.ti_hotelroomkeys,
			ti_hoteldays = ti.ti_hoteldays,
			ti_hotelstars = ti.ti_hotelstars,
			ti_pansionkeys = ti.ti_pansionkeys,
			ti_hdpartnerkey = ti.ti_hdpartnerkey,
			ti_firsthotelpartnerkey = ti.ti_firsthotelpartnerkey,
			ti_hdday = ti.ti_hdday,
			ti_hdnights = ti.ti_hdnights,
			ti_chkey = ti.ti_chkey,
			ti_chday = ti.ti_chday,
			ti_chpkkey = ti.ti_chpkkey,
			ti_chprkey = ti.ti_chprkey,
			ti_ctkeyfrom = ti.ti_ctkeyfrom,
			ti_chbackkey = ti.ti_chbackkey,
			ti_chbackday = ti.ti_chbackday,
			ti_chbackpkkey = ti.ti_chbackpkkey,
			ti_chbackprkey = ti.ti_chbackprkey,
			ti_ctkeyto = ti.ti_ctkeyto,
			ti_apkeyfrom = ti.ti_apkeyfrom,
			ti_apkeyto = ti.ti_apkeyto,
			ti_firstctkey = ti.ti_firstctkey,
			ti_firstrskey = ti.ti_firstrskey,
			ti_firsthdstars = ti.ti_firsthdstars
		from #tp_lists ti
		where
			(tp_lists.TI_CalculatingKey = @calcKey or @calcKey is null)
			and tp_lists.TI_Key = ti.TI_Key
			and
			(
				isnull(tp_lists.ti_firsthdkey, 0) <> isnull(ti.ti_firsthdkey , 0)
				or isnull(tp_lists.ti_lasthotelday, 0) <> isnull(ti.ti_lasthotelday, 0)
				or isnull(tp_lists.ti_nights, 0) <> isnull(ti.ti_nights, 0)
				or isnull(tp_lists.ti_hotelkeys, 0) <> isnull(ti.ti_hotelkeys, 0)
				or isnull(tp_lists.ti_hotelroomkeys, 0) <> isnull(ti.ti_hotelroomkeys, 0)
				or isnull(tp_lists.ti_hoteldays, 0) <> isnull(ti.ti_hoteldays, 0)
				or isnull(tp_lists.ti_hotelstars, 0) <> isnull(ti.ti_hotelstars, 0)
				or isnull(tp_lists.ti_pansionkeys, 0) <> isnull(ti.ti_pansionkeys, 0)
				or isnull(tp_lists.ti_hdpartnerkey, 0) <> isnull(ti.ti_hdpartnerkey, 0)
				or isnull(tp_lists.ti_firsthotelpartnerkey, 0) <> isnull(ti.ti_firsthotelpartnerkey, 0)
				or isnull(tp_lists.ti_hdday, 0) <> isnull(ti.ti_hdday, 0)
				or isnull(tp_lists.ti_hdnights, 0) <> isnull(ti.ti_hdnights, 0)
				or isnull(tp_lists.ti_chkey, 0) <> isnull(ti.ti_chkey, 0)
				or isnull(tp_lists.ti_chday, 0) <> isnull(ti.ti_chday, 0)
				or isnull(tp_lists.ti_chpkkey, 0) <> isnull(ti.ti_chpkkey, 0)
				or isnull(tp_lists.ti_chprkey, 0) <> isnull(ti.ti_chprkey, 0)
				or isnull(tp_lists.ti_ctkeyfrom, 0) <> isnull(ti.ti_ctkeyfrom, 0)
				or isnull(tp_lists.ti_chbackkey, 0) <> isnull(ti.ti_chbackkey, 0)
				or isnull(tp_lists.ti_chbackday, 0) <> isnull(ti.ti_chbackday, 0)
				or isnull(tp_lists.ti_chbackpkkey, 0) <> isnull(ti.ti_chbackpkkey, 0)
				or isnull(tp_lists.ti_chbackprkey, 0) <> isnull(ti.ti_chbackprkey, 0)
				or isnull(tp_lists.ti_ctkeyto, 0) <> isnull(ti.ti_ctkeyto, 0)
				or isnull(tp_lists.ti_apkeyfrom, 0) <> isnull(ti.ti_apkeyfrom, 0)
				or isnull(tp_lists.ti_apkeyto, 0) <> isnull(ti.ti_apkeyto, 0)
				or isnull(tp_lists.ti_firstctkey, 0) <> isnull(ti.ti_firstctkey, 0)
				or isnull(tp_lists.ti_firstrskey, 0) <> isnull(ti.ti_firstrskey, 0)
				or isnull(tp_lists.ti_firsthdstars, 0) <> isnull(ti.ti_firsthdstars, 0)
			)
	end

	if(@forceEnable > 0 and @calcKey is null)
	begin
		exec mwEnablePriceTourNewSinglePrice @tokey, '#tempPriceTable'

		update tp_tours with(rowlock)
		set to_isenabled = 1
		where to_key = @tokey
	end

	drop table #tempPriceTable

	update dbo.TP_Tours with(rowlock)
	set TO_Update = 0,
		TO_Progress = 100,
		TO_DateCreated = GetDate()
	where
		TO_Key = @tokey

	if dbo.mwReplIsSubscriber() <= 0
	begin
		update dbo.TP_Tours with(rowlock)
		set TO_UpdateTime = GetDate()
		where
			TO_Key = @tokey
	end

	EXECUTE mwFillPriceListDetails @tokey

end
GO

GRANT EXEC ON [dbo].[FillMasterWebSearchFields] TO PUBLIC
GO
/*********************************************************************/
/* end sp_FillMasterWebSearchFields.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetAddCostsForReCalculate.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetAddCostsForReCalculate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetAddCostsForReCalculate]
GO
CREATE PROCEDURE [dbo].[GetAddCostsForReCalculate]
(
	-- хранимка возвращает данные для расчета доплат
	@tlKey int,
	@queueKeys dbo.ListIntValue readonly
)
AS
BEGIN
	--<VERSION>9.2.17.1</VERSION>
	--<DATE>2012-12-07</DATE>
	SET ARITHABORT ON;
	set nocount on;
	
	-- только проживание
	select QAC_Id, SCP_Id, ADC_TLKey, SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SCP_DateCheckIn, SCP_Days, SC_PRKey, SCP_Men, SCP_TourDays
	from TP_ServiceTours with(nolock)
	join TP_ServiceComponents with(nolock) on SC_ID = ST_SCId
	join TP_ServiceCalculateParametrs with(nolock) on SCP_SCID = SC_ID
	join AddCosts with(nolock) on ADC_TLKey = ST_TRKey
	join TP_QueueAddCosts with(nolock) on QAC_ADCId = ADC_Id and ST_SVKey = ADC_SVKey
	where
	QAC_Id in (select value from @queueKeys)
	and ADC_SVKey = 3
	and ST_TRKey = @tlKey
	and ADC_SVKey = SC_SVKey
	and (ADC_Code = 0 OR ADC_Code = SC_Code)
	and (ADC_SubCode1 = 0 OR SC_SubCode1 in (SELECT HR_Key FROM HotelRooms with(nolock) WHERE HR_RMKey=ADC_SubCode1))
	and (ADC_SubCode2 = 0 OR SC_SubCode1 in (SELECT HR_Key FROM HotelRooms with(nolock) WHERE HR_RCKey=ADC_SubCode2))
	and (ADC_PansionKey = 0 OR SC_SubCode2 = ADC_PansionKey)
	and (ADC_PartnerKey = 0 OR ADC_PartnerKey = SC_PRKey)
	-- нам нужны только доплаты на будующие даты
	and SCP_DateCheckIn > getdate()
	and SCP_DateCheckIn between ADC_CheckInDateBeg and ADC_CheckInDateEnd
	and (SCP_TourDays between case when isnull(ADC_LongMin, 0) = 0 then -100500 else ADC_LongMin end
		and case when isnull(ADC_LongMax, 0) = 0 then 100500 else ADC_LongMax end)
	union
	-- остальные услуги
	select QAC_Id, SCP_Id, ADC_TLKey, SC_SVKey, SC_Code, SC_SubCode1, SC_SubCode2, SCP_DateCheckIn, SCP_Days, SC_PRKey, SCP_Men, SCP_TourDays
	from TP_ServiceTours with(nolock)
	join TP_ServiceComponents with(nolock) on SC_ID = ST_SCId
	join TP_ServiceCalculateParametrs with(nolock) on SCP_SCID = SC_ID
	join AddCosts with(nolock) on ADC_TLKey = ST_TRKey
	join TP_QueueAddCosts with(nolock) on QAC_ADCId = ADC_Id and ST_SVKey = ADC_SVKey
	where 
	QAC_Id in (select value from @queueKeys)
	and ADC_SVKey != 3
	and ST_TRKey = @tlKey
	and ADC_SVKey = SC_SVKey
	and (ADC_Code = 0 OR ADC_Code = SC_Code)
	and (ADC_SubCode1 = 0 OR ADC_SubCode1 = SC_SubCode1)
	and (ADC_SubCode2 = 0 OR ADC_SubCode2 = SC_SubCode2)
	and (ADC_PartnerKey = 0 OR ADC_PartnerKey = SC_PRKey)
	-- нам нужны только доплаты на будующие даты
	and SCP_DateCheckIn > getdate()
	and SCP_DateCheckIn between ADC_CheckInDateBeg and ADC_CheckInDateEnd
	and (SCP_TourDays between case when isnull(ADC_LongMin, 0) = 0 then -100500 else ADC_LongMin end
		and case when isnull(ADC_LongMax, 0) = 0 then 100500 else ADC_LongMax end)
	option(maxdop 1);
END
GO

grant exec on [dbo].[GetAddCostsForReCalculate] to public
go
/*********************************************************************/
/* end sp_GetAddCostsForReCalculate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetCalendarTourDates.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetCalendarTourDates]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetCalendarTourDates]
GO

CREATE PROCEDURE [dbo].[GetCalendarTourDates]
	@departFromKey INT,
	@countryKey INT,
	@tourKey INT = null,
	@resortKey INT = null,
	@tourTypeKey INT = null,
	@cityKey INT = null
AS
BEGIN
	--<VERSION>9.2</VERSION>
	--<DATE>2013-05-29</DATE>
	SET DATEFIRST 1
	
	DECLARE @mwSearchType INT
	SELECT @mwSearchType = ltrim(rtrim(isnull(SS_ParmValue, ''))) FROM dbo.systemsettings 
	WHERE SS_ParmName = 'MWDivideByCountry'
	
	DECLARE @tableName NVARCHAR(100)
	IF (@mwSearchType = 0)
		SET @tableName = 'dbo.mwPriceDataTable'
	ELSE
		SET @tableName = dbo.mwGetPriceTableName(@countryKey, @departFromKey)	
		
	DECLARE @sql NVARCHAR(4000)
	SET @sql = 'SELECT DISTINCT DATEDIFF(ss, ''1970-01-01'', TP_TurDates.TD_Date) AS [key]
					,CONVERT(varchar, TP_TurDates.TD_Date, 4) AS name
					,TP_TurDates.TD_Date FROM TP_TurDates 	
					 inner join mwSpoData with(nolock) on TP_TurDates.TD_TOKey = mwSpoData.sd_tourkey 
					 WHERE TD_Date > DATEADD(day, - 1, GETDATE())
					 AND TD_Date not in 
					 (
						 SELECT distinct TD_Date FROM TP_TurDates
						 inner join QuotaDetails ON QD_Date = TD_Date
						 inner join Quotas on QD_QTID = QT_ID 
						 inner join QuotaObjects on QT_ID=QO_QTID and QO_SVKey = 1
						 inner join Charter on QO_Code = CH_KEY 
						 left join StopSales as s1 on s1.SS_QDID = QD_ID 
						 left join StopSales as s2 on s2.SS_QOID = QO_ID
						 where (((QD_Places - QD_Busy) <= 0 
								and QO_CNKey = @countryKey
								and CH_CITYKEYFROM = @departFromKey
								)
								or (s1.SS_ID is not null and ISNULL(s1.SS_IsDeleted, 0) <> 1)
								or (s2.SS_ID is not null and ISNULL(s2.SS_IsDeleted, 0) <> 1))
								and  TD_Date not in	
								(
									SELECT distinct QD_Date FROM QuotaDetails
									inner join Quotas ON QD_QTID = QT_ID
									inner join QuotaObjects ON QT_ID = QO_QTID and QO_SVKey = 1
									inner join Charter on QO_Code = CH_Key
									left join StopSales as s1 on s1.SS_QDID = QD_ID 
									left join StopSales as s2 on s2.SS_QOID = QO_ID
									where (QD_Places - QD_Busy) > 0
										  and (s1.SS_ID is null or ISNULL(s1.SS_IsDeleted, 0) = 1)
										  and (s2.SS_ID is null or ISNULL(s2.SS_IsDeleted, 0) = 1)  
								)		
					 ) 
                  and mwSpoData.sd_ctkeyfrom = @departFromKey 
                  and mwSpoData.sd_cnkey = @countryKey'
             
	IF @tourKey is not null
	BEGIN
		SET @sql += ' and mwSpoData.sd_tourkey = @tourKey and exists(SELECT TOP 1 1 FROM ' + @tableName + ' WHERE pt_tourkey = @tourKey and pt_tourdate = TD_Date) '
	END
	IF @resortKey is not null
		SET @sql += ' and mwSpoData.sd_rskey = @resortKey '
	if @tourTypeKey is not null
		SET @sql += ' and mwSpoData.sd_tourtype = @tourTypeKey '
	if @cityKey is not null
		SET @sql += ' and mwSpoData.sd_ctkey = @cityKey '        
    
    SET @sql += ' ORDER BY TD_Date '
    
    DECLARE @paramDef NVARCHAR(500)
    SET @paramDef = ' @departFromKey INT, 
				  @countryKey INT, 
				  @tourKey INT = NULL, 
				  @resortKey INT = NULL, 
				  @tourTypeKey INT = NULL, 
				  @cityKey INT = NULL, 
				  @tableName NVARCHAR(100) = NULL'
       
    exec sp_executesql @sql, @paramDef,
							 @departFromKey = @departFromKey, 
							 @countryKey = @countryKey, 
							 @tourKey = @tourKey,
							 @resortKey = @resortKey,
							 @tourTypeKey = @tourTypeKey,
							 @cityKey = @cityKey
 
END

GO

grant exec on [dbo].[GetCalendarTourDates] to public
GO
/*********************************************************************/
/* end sp_GetCalendarTourDates.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetNewKey.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetNewKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetNewKey]
GO
CREATE PROCEDURE [dbo].[GetNewKey]
  (@strKeyTable varchar(100) = null,
  @nLastKey int = null output)
AS
--<VERSION>9.2.20</VERSION>
--<DATE>2013-11-07</DATE>
--<SUMMARY>Возвращает ключ через кросс-запрос к Keys для текущей таблицы</SUMMARY>
declare @KeyTable varchar(100)
set @KeyTable=replace(@strKeyTable,'Key_','')
EXECUTE [GetNKey] @KeyTable, @nLastKey OUTPUT
return 0
GO
GRANT EXECUTE ON [dbo].[GetNewKey] TO Public
GO
/*********************************************************************/
/* end sp_GetNewKey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetNKeys.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetNKeys]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[GetNKeys]
GO

create PROCEDURE [dbo].[GetNKeys]
  (@sTable varchar(50) = null,
  @nKeyCount int,
  @nNewKey int = null output)
AS
--<VERSION>9.2.20</VERSION>
--<DATE>2013-11-09</DATE>
--<SUMMARY>Возвращает опред. количество ключей для таблицы</SUMMARY>
declare @nID int
declare @keyTable varchar(100)
declare @query nvarchar (500)
declare @transactionIsolationLevel int

SELECT @transactionIsolationLevel = transaction_isolation_level 
FROM sys.dm_exec_sessions 
where session_id = @@spid

SET TRANSACTION ISOLATION LEVEL serializable;

set nocount on

if @nKeyCount is null
	set @nKeyCount = 0
	
if @sTable like 'TP_TOURDATES'
	set @sTable = 'TP_TURDATES'

set nocount on

select @keyTable = 
	case 
		when @sTable like 'TP_TURDATES' then 'Key_TPTurDates'
		when @sTable like 'TP_Lists' then 'Key_TPLists'
		when @sTable like 'TP_Services' then 'Key_TPServices'
		when @sTable like 'TP_Tours' then 'Key_TPTours'
		when @sTable like 'TP_ServiceLists' then 'Key_TPServiceLists'
		when @sTable like 'TP_Prices' then 'Key_TPPrices'
		when @sTable like 'TURSERVICE' then 'Key_TURSERVICE'
		when @sTable like 'TURIST' then 'Key_TURIST'
		when @sTable like 'TURLIST' then 'Key_TURLIST'
		when @sTable like 'TurMargin' then 'Key_TurMargin'
		when @sTable like 'PRICELIST' then 'Key_PRICELIST'
		when @sTable like 'PRICESERVICELINK' then 'Key_PRICESERVICELINK'
		when @sTable like 'PARTNERS' then 'Key_PARTNERS'
	end

if @keyTable is not null
begin
	set @query = N'
	declare @maxKeyFromTable int 
	declare @maxKeyFromKeys int
	
	Select @maxKeyFromTable = id from @keyTable (updlock) 
	Select @maxKeyFromKeys = id from Keys WITH (UPDLOCK) where Key_Table = ''@sTable''
	If @maxKeyFromKeys < @maxKeyFromTable
		Set @nNewKeyOut = @maxKeyFromTable
	Else
		Set @nNewKeyOut = @maxKeyFromKeys
	--
	Set @nNewKeyOut = @nNewKeyOut + @nKeyCount
	update @keyTable set Id = @nNewKeyOut
	update Keys set Id = @nNewKeyOut where Key_Table = ''@sTable''
	'
	begin tran
	set @query = REPLACE(@query, '@keyTable', @keyTable)
	set @query = REPLACE(@query, '@sTable', @sTable)
	EXECUTE sp_executesql @query, N'@nNewKeyOut int output, @nKeyCount int', @nNewKeyOut = @nNewKey  output,  @nKeyCount = @nKeyCount
	commit tran
end
else
begin
	begin tran
	if exists (select top 1 1 from Keys where Key_Table = @sTable)
	begin
		Select @nNewKey = id + @nKeyCount from Keys WITH (UPDLOCK) where Key_Table = @sTable
		update Keys set Id = @nNewKey where Key_Table = @sTable
	end
	else
	begin
		insert into Keys (Key_Table, Id) values (@sTable, @nKeyCount)
		set @nNewKey=@nKeyCount
	end
	commit tran
end

if (@transactionIsolationLevel = 1) SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
if (@transactionIsolationLevel = 2) SET TRANSACTION ISOLATION LEVEL READ COMMITTED
if (@transactionIsolationLevel = 3) SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
if (@transactionIsolationLevel = 4) SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
if (@transactionIsolationLevel = 5) SET TRANSACTION ISOLATION LEVEL SNAPSHOT

return 0
GO
grant exec on [dbo].[GetNKeys] to public
GO
/*********************************************************************/
/* end sp_GetNKeys.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetPartnerCommission.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='GetPartnerCommission')
	drop proc dbo.GetPartnerCommission
go

CREATE PROCEDURE [dbo].[GetPartnerCommission] 
     @nTLKey int,
     @nPRKey int,
     @nBTKey int,
     @nDSKey int output,
     @nValue money output,
     @nIsPercent int output, 
	 @dCheckinDate datetime,
	 @nCNKey int=0,
	 @DGCreateDate datetime = null,
	 @nDepartureCity int = 0,
	 @sDiscountCode varchar(5) = null,
	 @sDiscountNumber varchar(10) = null,
	 @price decimal(16,6) = null,
	 @rate varchar(3) = null,
	 @dogovorCode varchar(10) = null
AS
    --<VERSION>2009.2.20</VERSION>
    --<DATE>2013-11-07</DATE>
	declare @discountSettingValue varchar(256)
	select @discountSettingValue = ISNULL(SS_ParmValue, '0') from dbo.SystemSettings where SS_ParmName like 'SYSUseDiscountCards'
	if @discountSettingValue = '1' and ISNULL(@sDiscountCode, '') != '' and ISNULL(@sDiscountNumber, '') != ''
	begin
		
		declare @discountCode varchar(5)
		declare @discountNumber varchar(10)
		declare @reservationsCount int, @cardKey int
		declare @reservationsPrice decimal(16,6)
		declare @nationalRate varchar(3)
		declare @discount money
		declare @discountId int

		if (ISNULL(@dogovorCode, '') = '')
		begin
			set @sDiscountCode = rtrim(ltrim(@sDiscountCode))
			set @sDiscountNumber = rtrim(ltrim(@sDiscountNumber))
				
			select @cardKey = CD_Key from Cards where ISNULL(CD_Code, '') = ISNULL(@sDiscountCode, '') and ISNULL(CD_Number, '') = ISNULL(@sDiscountNumber, '')
			select @reservationsCount = count(RR_ID) from ReservationsRegister where RR_CardKey = @cardKey
			select @reservationsPrice = sum(DG_NationalCurrencyPrice) from Dogovor where DG_CODE in (select RR_DGCODE  COLLATE Cyrillic_General_CI_AS from ReservationsRegister where RR_CardKey = @cardKey)
			select @nationalRate = RA_Code from dbo.Rates where RA_National = 1
			exec ExchangeCost @price output, @rate, @nationalRate, @dCheckinDate

			set @reservationsPrice = ISNULL(@reservationsPrice, 0)
		
			select top 1 @discount = cast(ISNULL(DS_DISCOUNT, 0) as money), @discountId = DS_ID  
				from dbo.DiscountScheme, dbo.TurList, dbo.TurService where 
				TL_Key = @nTLKey and 
				TS_TRKey = TL_Key and
				DS_Series like @sDiscountCode and
				((DS_CityFromKey is not null and DS_CityFromKey = TL_CTDepartureKey) or (DS_CityFromKey is null)) and
				((DS_CountryKey is not null and DS_CountryKey = TL_CNKey) or (DS_CountryKey is null)) and
				((DS_CityKey is not null and DS_CityKey = TS_CTKey) or (DS_CityKey is null)) and
				((DS_TourTypeKey is not null and DS_TourTypeKey = TL_TIP) or (DS_TourTypeKey is null) or DS_TourTypeKey = -1) and
				((DS_ReservationsFrom is not null and DS_ReservationsFrom <= (@reservationsCount + 1)) or (DS_ReservationsFrom is null)) and
				((DS_ReservationsTo is not null and DS_ReservationsTo >= (@reservationsCount + 1)) or (DS_ReservationsTo is null)) and
				((DS_TotalCostFrom is not null and DS_TotalCostFrom <= (@reservationsPrice + @price)) or (DS_TotalCostFrom is null)) and
				((DS_TotalCostTo is not null and DS_TotalCostTo >= (@reservationsPrice + @price)) or (DS_TotalCostTo is null)) and
				((DS_MinPrice is not null and DS_MinPrice <= @price) or (DS_MinPrice is null))
			order by DS_ID DESC

			set @nDSKey = -1
			set @nValue = @discount
			set @nIsPercent = 1
			return 1
		end
		else
		begin
			
			select @discount = DD_DiscountPercent from dbo.DogovorDetails where DD_DGCODE like @dogovorCode
			set @discount = ISNULL(@discount, 0)
			set @nDSKey = -1
			set @nValue = @discount
			set @nIsPercent = 1
			return 1
		end
		
	end

     if @nPRKey = 0
     begin
          set @nDSKey = -1     
          set @nValue = 0     
          set @nIsPercent = 1     
		  return 0
     end

	declare @nPGKey int, @nTpKey int, @nAttr int, @nCTDepartureKey int
	set @nTpKey=0
	if 	@nPRKey>0
		select @nPGKey = PR_PGKey from Partners where PR_Key = @nPRKey
	else
		set @nPGKey=0
	if @nTLKey>0
		select @nCNKey = TL_CNKey, @nTpKey=TL_TIP, @nAttr = isnull(TL_Attribute, 0) 
		from TurList where TL_Key = @nTLKey

	declare @discountAction int
	set @discountAction = 0
	if @nAttr & 16 > 0
		set @discountAction = 1

	if @dCheckinDate is null
		SET @dCheckinDate=ISNULL(@dCheckinDate,GetDate())
     if @nBTKey = 0 or @nBTKey is null
     begin
          select top 1 @nDSKey = DS_Key, @nValue = DS_Value, @nIsPercent = DS_IsPercent from Discounts
          where DS_PRKey IN(0, @nPRKey) AND DS_BTKey IN (0, @nBTKey) AND DS_PGKey IN (0, @nPGKey) 
				AND DS_TLKey IN (0, @nTLKey) AND DS_CNKey IN (0, @nCNKey) AND DS_TPKEY IN (-1,@nTpKey)
				AND @dCheckinDate between ISNULL(DS_CheckInFrom,'30-DEC-1899') and ISNULL(DS_CheckInTo,'30-DEC-2200')
				AND DATEDIFF(d, GetDate(), @dCheckinDate) <= ISNULL(DS_DaysBeforeCheckIn, 99999)
				AND ISNULL(@DGCreateDate, ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899')) between ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899') and dateadd(second,-1,dateadd(day,1,CONVERT(char(10), ISNULL(DS_DogovorCreateDateTo,'30-DEC-2200'),126)))
				AND (CASE WHEN @discountAction = 0 THEN ISNULL(DS_DAKey, 0) ELSE 0 END) = 0
				AND DS_DepartureCityKey IN (0, @nDepartureCity)
          order by DS_Priority, DS_BTKey, DS_TLKey desc, DS_CNKey desc,DS_TPKEY desc, DS_PRKey desc, DS_PGKey desc, DS_DepartureCityKey desc
          , (case when @dCheckinDate = '1899-12-30' then GETDATE() else @dCheckinDate end) - ISNULL(DS_DaysBeforeCheckIn, 77777) asc
          , DS_DogovorCreateDateFrom asc, DS_DogovorCreateDateTo asc, DS_DAKey asc
     end
     else
     begin
          select top 1 @nDSKey = DS_Key, @nValue = DS_Value, @nIsPercent = DS_IsPercent from Discounts
          where DS_PRKey IN(0, @nPRKey) AND DS_BTKey IN (0, @nBTKey) AND DS_PGKey IN (0, @nPGKey) 
				AND DS_TLKey IN (0, @nTLKey) AND DS_CNKey IN (0, @nCNKey) AND DS_TPKEY IN (-1,@nTpKey)
				AND @dCheckinDate between ISNULL(DS_CheckInFrom,'30-DEC-1899') and ISNULL(DS_CheckInTo,'30-DEC-2200')
				AND DATEDIFF(d, GetDate(), @dCheckinDate) <= ISNULL(DS_DaysBeforeCheckIn, 99999)
				AND ISNULL(@DGCreateDate, ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899')) between ISNULL(DS_DogovorCreateDateFrom,'30-DEC-1899') and dateadd(second,-1,dateadd(day,1,CONVERT(char(10), ISNULL(DS_DogovorCreateDateTo,'30-DEC-2200'),126)))
				AND (CASE WHEN @discountAction = 0 THEN ISNULL(DS_DAKey, 0) ELSE 0 END) = 0
				AND DS_DepartureCityKey IN (0, @nDepartureCity)
          order by DS_Priority, DS_BTKey desc, DS_TLKey desc, DS_CNKey desc, DS_TPKEY desc,DS_PRKey desc, DS_PGKey desc, DS_DepartureCityKey desc
          , (case when @dCheckinDate = '1899-12-30' then GETDATE() else @dCheckinDate end) - ISNULL(DS_DaysBeforeCheckIn, 77777) asc
          , DS_DogovorCreateDateFrom asc, DS_DogovorCreateDateTo asc, DS_DAKey asc
     end

     if @nDSKey is null
     begin
          set @nDSKey = -1     
          set @nValue = 0     
          set @nIsPercent = 1     
     end

GO

grant execute on [dbo].[GetPartnerCommission] to public

GO

/*********************************************************************/
/* end sp_GetPartnerCommission.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetQuotaLoadListData_N.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetQuotaLoadListData_N]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[GetQuotaLoadListData_N]
GO

CREATE procedure [dbo].[GetQuotaLoadListData_N]
(
--<VERSION>2009.2.21</VERSION>
--<DATE>2013-10-28</DATE>
@QT_ID int=null,
@Service_SVKey int=null,
@Service_Code int=null,
@DateStart smalldatetime = null,
@DaysCount int=null,			 -- для режима 10-для наличия мест - в этом поле передается продолжительность услуги

@nShowQuotaTypes smallint =null,  -- показывать квоты типа (0 - все, 1 - allotment, 2 - commitment)
@bShowCommonInfo bit =null,  -- показывать (1-общую информацию по квоте, 0-информацию по распределению квоты)
@bShowAgencyInfo bit =null,   -- показывать информацию об агентских квотах
@AgentKey int =null,
@bFreeSale bit =null,
@DLKey int =null,
@ResultType smallint=null,		--варианты отображения (0,null-общее, 10-для наличия мест(из оформления))
@TourDurations  smallint=null,
@DateStart2 smalldatetime = null,
@DateStart3 smalldatetime = null,
@bShowByCheckIn bit =null,
@bCommonRelease bit =null,
@bShowCommonRequest bit = null,   --отображение услуг по запросу одной строкой
@nGridFilter int = 0              -- фильтр в зависимости от экрана / 3-английский вариант экранов
)
as 

set transaction isolation level read uncommitted

DECLARE @DateEnd smalldatetime, @Service_PRKey int, @QT_IDLocal int, @Result_From smallint, @Result_To smallint, @ServiceLong smallint, @DurationLocal smallint, @ByRoom int
--@Result
--11 - общее кол-во мест (строка 8000)
--12 - кол-во свободных мест (строка 8000)
--13 - кол-во занятых мест (строка 8000)
--21 - кол-во свободных мест (smallint)
--22 - % Stop-Sale (smallint)
--23 - возможен ли заезд (smallint)
if @ResultType is null or @ResultType not in (10)
	Set @DateEnd = DATEADD(DAY, @DaysCount-1, @DateStart)
Else --для наличия мест(из оформления)
BEGIN
	Set @ServiceLong=@DaysCount
	Set @DateEnd = DATEADD(DAY,ISNULL(@DaysCount,1)-1,@DateStart3)
	Set @DaysCount=DATEDIFF(DAY,@DateStart,@DateEnd)+1

	if exists (select 1 from dbo.Service(nolock) where SV_Key=@Service_SVKey and SV_IsDuration=1)
		set @DurationLocal=@ServiceLong
	Else
		set @DurationLocal=@TourDurations
END

CREATE TABLE #StopSaleTemp
(
SST_QDID int, SST_QO_Count smallint, SST_QO_CountWithStop smallint, SST_Comment varchar(255)
)

CREATE CLUSTERED INDEX idx_StopSaleTemp
ON #StopSaleTemp(SST_QDID ASC)

INSERT INTO #StopSaleTemp exec dbo.GetTableQuotaDetails	@DLKey, null, @DateStart, @DaysCount, null, null, @Service_SVKey, @Service_Code, null, null, 1

--SELECT * FROM #StopSaleTemp

CREATE TABLE #QuotaLoadList(QL_ID int identity(1,1),
QL_QTID int, QL_QOID int, QL_PRKey int, QL_SubCode1 int, QL_SubCode2 int, QL_PartnerName nvarchar(100) collate Cyrillic_General_CI_AS, QL_Description nvarchar(255) collate Cyrillic_General_CI_AS, 
QL_dataType smallint, QL_Type smallint, QL_TypeQuota smallint, QL_Release nvarchar(max), QL_Durations nvarchar(20) collate Cyrillic_General_CI_AS, QL_FilialKey int, 
QL_CityDepartments int, QL_AgentKey int, QL_CustomerInfo nvarchar(150) collate Cyrillic_General_CI_AS, QL_DateCheckinMin smalldatetime,
QL_ByRoom int)

DECLARE @n int, @str varchar(8000)
if (@ResultType is null) or (@ResultType <> 10)
BEGIN
	set @n=1
	WHILE @n <= @DaysCount
	BEGIN
		set @str = 'ALTER TABLE #QuotaLoadList ADD QL_' + CAST(@n as varchar(3)) + ' varchar(8000)'
		exec (@str)
		set @n = @n + 1
	END
END
ELSE
BEGIN
	--для наличия мест(из оформления)
	set @n=1
	WHILE @n <= @DaysCount
	BEGIN
		set @str = 'ALTER TABLE #QuotaLoadList ADD QL_' + CAST(@n as varchar(3)) + ' varchar(8000)'--' smallint'
		exec (@str)
		set @n = @n + 1
	END
END


if @bShowCommonInfo = 1
BEGIN
	insert into #QuotaLoadList 
	(QL_QTID, QL_Type, QL_Release, QL_dataType, QL_DateCheckinMin, QL_PRKey, QL_ByRoom, QL_TypeQuota)
	select	DISTINCT QT_ID, QD_Type, case when QD_Release = 0 then null else QD_Release end, NU_ID, @DateEnd+1,QT_PRKey, QT_ByRoom, QT_IsByCheckIn
	from	Quotas, QuotaObjects, QuotaDetails, Numbers
	where	QT_ID=QO_QTID and QD_QTID=QT_ID
			and ((QO_Code=@Service_Code and QO_SVKey=@Service_SVKey and QO_QTID is not null and @QT_ID is null) or (@QT_ID is not null and @QT_ID=QT_ID))
			and ISNULL(QD_IsDeleted,0)=0
			and QD_Date between @DateStart and @DateEnd
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0)
			and NU_ID between 1 and 3
END
else
BEGIN
DECLARE @Service_SubCode1 int
	, @Object_SubCode1 int
	, @Object_SubCode2 int
	, @Service_SubCode2 int
	, @Service_NDays int
	, @Service_Day int
	, @Dogovor_NDay int
	, @Service_Duration int
	, @Dogovor_Key int
	SET @Object_SubCode1=0
	SET @Object_SubCode2=0
	IF @DLKey is not null				-- если мы запустили процедуру из конкрентной услуги
	BEGIN
		SELECT	@Service_SVKey=DL_SVKey, @Service_Code=DL_Code, @Service_SubCode1=DL_SubCode1
			  , @AgentKey=ISNULL(DL_Agent,0), @Service_PRKey=DL_PartnerKey, @Service_SubCode2 = DL_SubCode2
			  , @Service_NDays = DL_NDAYS
			  , @Service_Day = DL_DAY
			  , @Dogovor_Key = DL_DGKEY
		FROM	DogovorList (nolock)
		WHERE	DL_Key=@DLKey
		IF @Service_NDays is null
			SELECT @Service_Duration = DG_NDAY FROM Dogovor WHERE DG_Key = @Dogovor_Key
		ELSE
			SET @Service_Duration = @Service_NDays
		If @Service_SVKey=3
			SELECT @Object_SubCode1=HR_RMKey, @Object_SubCode2=HR_RCKey 
			FROM dbo.HotelRooms (nolock) WHERE HR_Key=@Service_SubCode1
		Else
			SET @Object_SubCode1=@Service_SubCode1
		IF @Service_SVKey=1
			SET @Object_SubCode2=@Service_SubCode2
	END

if @ResultType is null or @ResultType not in (10)
BEGIN
	Set @Result_From=11
	Set @Result_To=13
END
ELSE
BEGIN
	--для наличия мест(из оформления)
	Set @Result_From=21
	Set @Result_To=23
END;
	-- сначала заполняем таблицу квотами
	-- чтобы ускорить инсерт добавим временную таблицу
	DECLARE @TempTable2 TABLE
	(
		QL_QTID int,
		QL_Type smallint,
		QL_TypeQuota smallint,
		QL_Release int,
		QL_Durations varchar(20),
		QL_FilialKey int,
		QL_CityDepartments int,
		QL_AgentKey int,
		QL_CustomerInfo varchar(150),
		QL_DateCheckinMin smalldatetime,
		QL_PRKey int,
		QL_ByRoom int		
	)
	
	declare @QT_IsByCheckIn bit
	select @QT_IsByCheckIn = QT_IsByCheckIn from Quotas where QT_ID = @QT_ID
	
	if (@QT_IsByCheckIn = 1 or @QT_IsByCheckIn is null)
		insert into @TempTable2 (QL_QTID, QL_Type, QL_TypeQuota, QL_Release, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom)
		select QT_ID, QD_Type, QT_IsByCheckIn, QD_Release, convert(nvarchar(max) ,QD_LongMin) + '-' + convert(nvarchar(max) ,QD_LongMax), QP_FilialKey, QP_CityDepartments, QP_AgentKey, '', @DateEnd + 1, QT_PRKey,QT_ByRoom
		from	Quotas (nolock), QuotaObjects (nolock), QuotaDetails (nolock), QuotaParts (nolock)
		where	QT_ID=QO_QTID
				and QD_QTID=QT_ID
				and QP_QDID = QD_ID
				and ((QO_Code=@Service_Code and QO_SVKey=@Service_SVKey and QO_QTID is not null and @QT_ID is null) or (@QT_ID is not null and @QT_ID=QT_ID))
				and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) 
				and QD_Date between @DateStart and @DateEnd
				and QP_Date between @DateStart and @DateEnd
				and (QP_AgentKey is null or (@bShowAgencyInfo=1 and ((@AgentKey=QP_AgentKey) or (@AgentKey is null))))
				and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey=QT_PRKey or QT_PRKey=0)))
				and (QP_Durations='' or (@DurationLocal is null or (@DurationLocal is not null and exists (Select QL_QPID From QuotaLimitations (nolock) WHERE QL_Duration=@DurationLocal and QL_QPID=QP_ID))))
				and ISNULL(QP_IsDeleted,0)=0
				and ISNULL(QD_IsDeleted,0)=0			
				and (@DLKey is null or (@DLKey is not null
				and ((QD_LongMin is null and QD_LongMax is null) or (@Service_Duration >= QD_LongMin and @Service_Duration <= QD_LongMax)) and ((QO_SubCode1 = -1) or (QO_SubCode1 in (0,@Object_SubCode1))) 
				and ((QO_SubCode2 = -1) or (QO_SubCode2 in (0,@Object_SubCode2)))))
				and QT_IsByCheckIn = 1 
	if (@QT_IsByCheckIn = 0 or @QT_IsByCheckIn is null)
		insert into @TempTable2 (QL_QTID, QL_Type, QL_TypeQuota, QL_Release, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom)
		select QT_ID, QD_Type, QT_IsByCheckIn, QD_Release, QP_Durations, QP_FilialKey, QP_CityDepartments, QP_AgentKey, '', @DateEnd + 1, QT_PRKey,QT_ByRoom
		from	Quotas (nolock), QuotaObjects (nolock), QuotaDetails (nolock), QuotaParts (nolock)
		where	QT_ID=QO_QTID
				and QD_QTID=QT_ID
				and QP_QDID = QD_ID
				and ((QO_Code=@Service_Code and QO_SVKey=@Service_SVKey and QO_QTID is not null and @QT_ID is null) or (@QT_ID is not null and @QT_ID=QT_ID))
				and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) 
				and QD_Date between @DateStart and @DateEnd
				and QP_Date between @DateStart and @DateEnd
				and (QP_AgentKey is null or (@bShowAgencyInfo=1 and ((@AgentKey=QP_AgentKey) or (@AgentKey is null))))
				and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey=QT_PRKey or QT_PRKey=0)))
				and (QP_Durations='' or (@DurationLocal is null or (@DurationLocal is not null and exists (Select QL_QPID From QuotaLimitations (nolock) WHERE QL_Duration=@DurationLocal and QL_QPID=QP_ID))))
				and ISNULL(QP_IsDeleted,0)=0
				and ISNULL(QD_IsDeleted,0)=0			
				and (@DLKey is null or (@DLKey is not null
				and (QP_Durations='' or PATINDEX('%,' + CAST(@Service_Duration AS VARCHAR) + ',%', ',' + QP_Durations + ',') != 0)
				and ((QO_SubCode1 = -1) or (QO_SubCode1 in (0,@Object_SubCode1))) 
				and ((QO_SubCode2 = -1) or (QO_SubCode2 in (0,@Object_SubCode2)))))
				and QT_IsByCheckIn = 0 

	insert into #QuotaLoadList (QL_QTID, QL_Type, QL_TypeQuota, QL_Release, QL_dataType, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom)
	SELECT DISTINCT QL_QTID, QL_Type, QL_TypeQuota, QL_Release, NU_ID, QL_Durations, QL_FilialKey, QL_CityDepartments, QL_AgentKey, QL_CustomerInfo, QL_DateCheckinMin, QL_PRKey, QL_ByRoom
	FROM @TempTable2 nolock, Numbers (nolock)
	WHERE NU_ID between @Result_From and @Result_To

END

DECLARE @QD_ID int, @Date smalldatetime, @State smallint, @QD_Release int, @QP_Durations varchar(20), @QP_FilialKey int,
		@QP_CityDepartments int, @QP_AgentKey int, @Quota_Places int, @Quota_Busy int, @QP_IsNotCheckIn bit,
		@QD_QTID int, @QP_ID int, @Quota_Comment varchar(8000), @Stop_Comment varchar(255), @QO_ID int, @QT_IsNotCheckIn smallint, @QD_LongMin smallint, @QD_LongMax smallint--,	@QT_ID int
DECLARE @ColumnName varchar(10), @QueryUpdate varchar(8000), @QueryUpdate1 varchar(255), @QueryWhere1 varchar(255), @QueryWhere2 varchar(255), 
		@QD_PrevID int, @StopSale_Percent int, @CheckInPlaces smallint, @CheckInPlacesBusy smallint --@QuotaObjects_Count int, 

if @bShowCommonInfo = 1
	DECLARE curQLoadList CURSOR FOR SELECT 
			QT_ID, QD_ID, QD_Date, QD_Type, case when QD_Release = 0 then null else QD_Release end,
			QD_Places, QD_Busy,
			0,'',0,0,0,0, ISNULL(REPLACE(QD_Comment,'''','"'),''),0,0,0,0,0
	FROM	Quotas, QuotaDetails
	WHERE	QD_QTID=QT_ID
			and 
			(	
				(@QT_ID is null and exists 
					(	
						SELECT 1 FROM QuotaObjects WHERE QT_ID=QO_QTID 
						and QO_Code=@Service_Code and QO_SVKey=@Service_SVKey
					)
				)
				or
				(@QT_ID is not null and @QT_ID=QT_ID)
			)
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) and QD_Date between @DateStart and @DateEnd
			and (QD_IsDeleted = 0 or QD_IsDeleted is null)
	ORDER BY QD_Date DESC, QD_ID
else
	DECLARE curQLoadList CURSOR FOR 
	SELECT QT_ID, QD_ID, QD_Date, QD_Type, QD_Release, 
			QP_Places, QP_Busy, 
			QP_ID, QP_Durations, QP_FilialKey, QP_CityDepartments, QP_AgentKey, ISNULL(QP_IsNotCheckIn,0), ISNULL(REPLACE(QD_Comment,'''','"'),'') + '' + ISNULL(REPLACE(QP_Comment,'''','"'),''), QP_CheckInPlaces, QP_CheckInPlacesBusy, QT_IsByCheckIn, QD_LongMin, QD_LongMax
	FROM	Quotas, QuotaDetails,QuotaParts
	WHERE	QD_QTID=QT_ID and QP_QDID = QD_ID
			and 
			(	
				(@QT_ID is null and exists 
					(	
						SELECT 1 FROM QuotaObjects WHERE QT_ID=QO_QTID 
						and QO_Code=@Service_Code and QO_SVKey=@Service_SVKey
					)
				)
				or
				(@QT_ID is not null and @QT_ID=QT_ID)
			)
			and (QD_Type = @nShowQuotaTypes or @nShowQuotaTypes = 0) 
			and QD_Date between @DateStart and @DateEnd
			and QP_Date between @DateStart and @DateEnd
			and QP_QDID = QD_ID	
			and (QP_AgentKey is null or (@bShowAgencyInfo=1 and ((@AgentKey=QP_AgentKey) or (@AgentKey is null))))
			and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey=QT_PRKey or QT_PRKey=0)))
			and (QP_Durations='' or (@DurationLocal is null or (@DurationLocal is not null and exists (Select QL_QPID From QuotaLimitations WHERE QL_Duration=@DurationLocal and QL_QPID=QP_ID))))
			and (QP_IsDeleted = 0 or QP_IsDeleted is null)
			and (QD_IsDeleted = 0 or QD_IsDeleted is null)
	ORDER BY QD_Date DESC, QD_ID


OPEN curQLoadList
FETCH NEXT FROM curQLoadList INTO	@QT_IDLocal,
									@QD_ID, @Date, @State, @QD_Release, @Quota_Places, @Quota_Busy,
									@QP_ID, @QP_Durations, @QP_FilialKey, @QP_CityDepartments, @QP_AgentKey, 
									@QP_IsNotCheckIn, @Quota_Comment, @CheckInPlaces, @CheckInPlacesBusy, @QT_IsNotCheckIn, @QD_LongMin, @QD_LongMax
SET @QD_PrevID = @QD_ID - 1

SET @StopSale_Percent=0
WHILE @@FETCH_STATUS = 0
BEGIN
	set @QueryUpdate1=''
	if DATEADD(DAY,ISNULL(@QD_Release,0),DATEADD(hh,0,GETDATE()- {fn CURRENT_time()})) < @Date
	begin
		set @QueryUpdate1=', QL_DateCheckInMin=''' + CAST(@Date as varchar(250)) + ''''
		--print @QueryUpdate1
	end
	--если релиз период наступил сегодня
	if DATEADD(DAY,ISNULL(@QD_Release,0),DATEADD(hh,0,GETDATE()- {fn CURRENT_time()})) = @Date
	begin
		set @QueryUpdate1=', QL_DateCheckInMin=''' + CAST(@Date as varchar(250)) + ''''
		--print @QueryUpdate1
	end
	set @ColumnName = CAST(CAST((@Date-@DateStart+1) as int) as varchar(6))

	If @QD_PrevID != @QD_ID
	BEGIN
		SET @StopSale_Percent=0
		
		SET @Stop_Comment = ''
		IF @DLKey is null
		BEGIN
			if Exists (SELECT 1 FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID )
				SELECT @StopSale_Percent = 100*SST_QO_Count/SST_QO_CountWithStop, @Stop_Comment = SST_Comment FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID
		END
		ELSE
		BEGIN
			if Exists (SELECT 1 FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID )
				SELECT @StopSale_Percent = 100, @Stop_Comment = SST_Comment FROM #StopSaleTemp (nolock) WHERE SST_QDID = @QD_ID
		END

		If @Stop_Comment!=''
			SET @Quota_Comment=@Quota_Comment+ 'Stop-Sale info: ' + @Stop_Comment
		SET @QD_PrevID = @QD_ID
	END	
	ELSE
		If @Stop_Comment!=''
			SET @Quota_Comment=@Quota_Comment+ 'Stop-Sale info: ' + @Stop_Comment

	set @QueryWhere1 = ' where QL_Type = ' + CAST(@State as varchar(1))
	if @QD_Release is null
		set @QueryWhere1 = @QueryWhere1 + ' and QL_Release is null' 
	else
		set @QueryWhere1 = @QueryWhere1 + ' and QL_Release = ' + CAST(@QD_Release as varchar(5))
	
	if @bShowCommonInfo = 1
	BEGIN
	--			+ ',QL_B_' + @ColumnName + ' = ''' + CAST((@Quota_Busy) as varchar(10)) + ';' + CAST(@QD_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@Quota_Comment as varchar(7980)) + ''''
		set @QueryUpdate = 'UPDATE #QuotaLoadList SET 
			QL_' + @ColumnName + ' = (CASE QL_dataType WHEN 1 THEN ''' + CAST((@Quota_Places) as varchar(10))  + ''' WHEN 2 THEN ''' + CAST((@Quota_Places-@Quota_Busy) as varchar(10))  + ''' WHEN 3 THEN ''' + CAST((@Quota_Busy) as varchar(10)) + ''' END)+' + ''';' + CAST(@QD_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@Quota_Comment as varchar(7980)) + ''''
				+ @QueryUpdate1
				+ @QueryWhere1 + ' and QL_dataType in (1,2,3) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
		--print @QueryUpdate
		exec (@QueryUpdate)
	END
	else
	BEGIN
		set @QueryWhere2 = ''
		
		if (@QT_IsNotCheckIn = 1 or @QT_IsNotCheckIn is null)
		begin
			if @QD_LongMin is null and @QD_LongMax is null
				set @QueryWhere2 = @QueryWhere2 + ' and QL_Durations is null' 
			else
				set @QueryWhere2 = @QueryWhere2 + ' and QL_Durations = ''' + (convert(nvarchar(max) ,@QD_LongMin) + '-' + convert(nvarchar(max) ,@QD_LongMax)) + ''''
		end
		if (@QT_IsNotCheckIn = 0 or @QT_IsNotCheckIn is null)
		begin
			if @QP_Durations is null
				set @QueryWhere2 = @QueryWhere2 + ' and QL_Durations is null' 
			else
				set @QueryWhere2 = @QueryWhere2 + ' and QL_Durations = ''' + @QP_Durations + ''''
		end
		
		if @QP_FilialKey is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_FilialKey is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_FilialKey = ' + CAST(@QP_FilialKey as varchar(10))
		if @QP_CityDepartments is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_CityDepartments is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_CityDepartments = ' + CAST(@QP_CityDepartments as varchar(10))
 		if @QP_AgentKey is null
			set @QueryWhere2 = @QueryWhere2 + ' and QL_AgentKey is null' 
		else
			set @QueryWhere2 = @QueryWhere2 + ' and QL_AgentKey = ' + CAST(@QP_AgentKey as varchar(10))
	--			+ ',QL_B_' + @ColumnName + ' = ''' + CAST((@Quota_Busy) as varchar(10))  + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7980)) + ''''
		IF @ResultType is null or @ResultType not in (10)
		BEGIN
			IF @bShowByCheckIn = 1 and @QP_Durations <> '' 
			set @QueryUpdate = 'UPDATE #QuotaLoadList SET	
					QL_' + @ColumnName + ' = (CASE QL_dataType WHEN 11 THEN ''' + CAST(ISNULL(@CheckInPlaces,0) as varchar(10)) + ''' WHEN 12 THEN ''' + CAST(ISNULL(@CheckInPlaces-@CheckInPlacesBusy,0) as varchar(10)) + ''' WHEN 13 THEN ''' + CAST(ISNULL(@CheckInPlacesBusy,0) as varchar(10)) + ''' END)+' + ''';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + ''''
				+ @QueryUpdate1
				+ @QueryWhere1 + @QueryWhere2 + ' and QL_dataType in (11,12,13) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
			ELSE
			BEGIN
				-- @StopSaleOrPlaces служит для показывания буквы 'S' для стопов на объекты квотирования вместо 0
				DECLARE @StopSaleOrPlaces varchar(255)
				if @QD_ID < 0
					set @StopSaleOrPlaces = '''S'
				else
					set @StopSaleOrPlaces = '(CASE QL_dataType WHEN 11 THEN ''' + CAST((@Quota_Places) as varchar(10)) + ''' WHEN 12 THEN ''' + CAST((@Quota_Places-@Quota_Busy) as varchar(10)) + ''' WHEN 13 THEN ''' + CAST((@Quota_Busy) as varchar(10)) + ''' END)+'''
					
				set @QueryUpdate = 'UPDATE #QuotaLoadList SET	
						QL_' + @ColumnName + ' = ' + @StopSaleOrPlaces + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + ''''
					+ @QueryUpdate1
					+ @QueryWhere1 + @QueryWhere2 + ' and QL_dataType in (11,12,13) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
			END		
		END
		ELSE
		BEGIN
		--для наличия мест(из оформления)
			--  WHEN 22 THEN ' + @StopSale_Percent + ' WHEN 23 THEN ' + @QP_IsNotCheckIn + ' END
			set @QueryUpdate = 'UPDATE #QuotaLoadList SET	
					QL_' + @ColumnName + ' = (CASE QL_dataType WHEN 21 THEN ' + CAST((@Quota_Places-@Quota_Busy) as varchar(5)) + ' WHEN 22 THEN ' + CAST(@StopSale_Percent as varchar(5)) + ' WHEN 23 THEN ' + CAST(@QP_IsNotCheckIn as varchar(5)) + ' END)' 
				+ @QueryUpdate1
				+ @QueryWhere1 + @QueryWhere2 + ' and QL_dataType in (21,22,23) and QL_QTID=' + CAST(@QT_IDLocal as varchar(10))
		END	
		--print @QueryUpdate
		exec (@QueryUpdate)
	END	
	FETCH NEXT FROM curQLoadList INTO	@QT_IDLocal,
										@QD_ID, @Date, @State, @QD_Release, @Quota_Places, @Quota_Busy,
										@QP_ID, @QP_Durations, @QP_FilialKey, @QP_CityDepartments, @QP_AgentKey, 
										@QP_IsNotCheckIn, @Quota_Comment, @CheckInPlaces, @CheckInPlacesBusy, @QT_IsNotCheckIn, @QD_LongMin, @QD_LongMax
END
CLOSE curQLoadList
DEALLOCATE curQLoadList

--select * from #QuotaLoadList
-- заполняем таблицу стопами, т.е. обозначаем квоты на которых стоит стоп, и если стоп поставлен плагином, добавляем строчку с буквой "S"
DECLARE @TEMP_QL_ID INT, 
	@SS_Code INT, @SS_SubCode1 INT, @SS_SubCode2 INT, @SS_PRKey INT, @SS_AllotmentAndCommitment INT, @SS_Date datetime, @SS_Comment varchar(255),
	@SS_PrevCode INT, @SS_PrevSubCode1 INT, @SS_PrevSubCode2 INT, @SS_PrevPRKey INT, @SS_PrevAllotmentAndCommitment INT, @SS_PrevDate datetime, 
	@SS_PrevComment varchar(255)

SET @StopSaleOrPlaces = 'S'
SET @QP_ID=-1
SET @StopSale_Percent = 100
SET @QP_IsNotCheckIn = 0
SET @TEMP_QL_ID = null

declare StopSaleWithOutQO CURSOR FOR
	SELECT	QO_Code, QO_SubCode1, QO_SubCode2, SS_PRKey, ISNULL(SS_AllotmentAndCommitment,0), SS_Date, SS_Comment
	FROM	QuotaObjects, StopSales 
	WHERE	QO_ID = SS_QOID 
			and QO_Code = @Service_Code and QO_SVKey = @Service_SVKey and QO_QTID is null
			and SS_Date between @DateStart and @DateEnd
			and (@Service_PRKey is null or (@Service_PRKey is not null and (@Service_PRKey = SS_PRKey or SS_PRKey = 0)))
			and ISNULL(SS_IsDeleted,0) = 0
	ORDER BY QO_Code, QO_SubCode1, QO_SubCode2, SS_PRKey, SS_AllotmentAndCommitment, SS_Date, SS_Comment
OPEN StopSaleWithOutQO
FETCH NEXT FROM StopSaleWithOutQO INTO	
			@SS_Code, @SS_SubCode1, @SS_SubCode2, @SS_PRKey, @SS_AllotmentAndCommitment, @SS_Date, @SS_Comment
WHILE @@FETCH_STATUS = 0
BEGIN
	IF @SS_Code != ISNULL(@SS_PrevCode,-100)
		OR @SS_SubCode1 != @SS_PrevSubCode1
		OR @SS_SubCode2 != @SS_PrevSubCode2
		OR @SS_PRKey != @SS_PrevPRKey
		OR @SS_AllotmentAndCommitment != @SS_PrevAllotmentAndCommitment
	BEGIN
		SET @SS_PrevDate = null
		SET @ColumnName = CAST((DATEDIFF(DAY,@DateStart,@SS_Date)+1) as varchar(3))
		SET @Quota_Comment = ISNULL(@SS_Comment,'')
		SET @QueryUpdate='INSERT INTO #QuotaLoadList 
			(QL_QTID, QL_PRKey, QL_SubCode1, QL_SubCode2, QL_dataType, 
			QL_Type, QL_ByRoom, QL_' + @ColumnName + ')
			values 
			(0, ' + CAST(@SS_PRKey as varchar(15)) + ', ' + CAST(@SS_SubCode1 as varchar(15)) + ', ' + CAST(@SS_SubCode2 as varchar(15)) + ', 11, ' +
			CAST((@SS_AllotmentAndCommitment+1) as varchar(2)) + ', 1, 
			''' + @StopSaleOrPlaces + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + '''
			)
		'
		exec (@QueryUpdate)
	END
	ELSE
	BEGIN
		IF @SS_Date != @SS_PrevDate
		BEGIN
			SET @ColumnName = CAST((DATEDIFF(DAY,@DateStart,@SS_Date)+1) as varchar(3))
			SET @Quota_Comment = ISNULL(@SS_Comment,'')
			SET @QueryUpdate='UPDATE #QuotaLoadList SET	
						QL_' + @ColumnName + ' = ''' + @StopSaleOrPlaces + ';' + CAST(@QP_ID as varchar(10)) + ';' + CAST(@StopSale_Percent as varchar(10)) + ';' + CAST(@QP_IsNotCheckIn as varchar(1)) + ';'  + CAST(@Quota_Comment as varchar(7900)) + ''' 
						WHERE 
							QL_PRKey = ' + CAST(@SS_PRKey as varchar(15)) + '
							AND QL_SubCode1 = ' + CAST(@SS_SubCode1 as varchar(15)) + '
							AND QL_SubCode2 = ' + CAST(@SS_SubCode2 as varchar(15)) + '
							AND QL_Type = ' + CAST((@SS_AllotmentAndCommitment+1) as varchar(2)) 
							
			exec (@QueryUpdate)
		END
		ELSE IF @SS_Date = @SS_PrevDate
		BEGIN 
			IF @SS_Comment != @SS_PrevComment
			BEGIN
				SET @Quota_Comment = ISNULL(@SS_Comment,'')
				SET @QueryUpdate='UPDATE #QuotaLoadList SET	
						QL_' + @ColumnName + ' = QL_' + @ColumnName + ' + CAST(' + @Quota_Comment + ' as varchar(7900)) +  
						WHERE 
							QL_PRKey = ' + CAST(@SS_PRKey as varchar(15)) + '
							AND QL_SubCode1 = ' + CAST(@SS_SubCode1 as varchar(15)) + '
							AND QL_SubCode2 = ' + CAST(@SS_SubCode2 as varchar(15)) + '
							AND QL_Type = ' + CAST((@SS_AllotmentAndCommitment+1) as varchar(2)) 
				exec (@QueryUpdate)
			END
		END
	END
	SET @SS_PrevDate = @SS_Date
	SET @SS_PrevComment = @SS_Comment	
	SET @SS_PrevCode = @SS_Code
	SET @SS_PrevSubCode1 = @SS_SubCode1
	SET @SS_PrevSubCode2 = @SS_SubCode2
	SET @SS_PrevPRKey = @SS_PRKey
	SET @SS_PrevAllotmentAndCommitment = @SS_AllotmentAndCommitment
	FETCH NEXT FROM StopSaleWithOutQO INTO	
				@SS_Code, @SS_SubCode1, @SS_SubCode2, @SS_PRKey, @SS_AllotmentAndCommitment, @SS_Date, @SS_Comment
END
CLOSE StopSaleWithOutQO
DEALLOCATE StopSaleWithOutQO


IF @DLKey is null and @QT_ID is null and (@ResultType is null or @ResultType not in (10))
BEGIN
	IF(@Service_SVKey = 3)
		SET @ByRoom = (SELECT AVG(ISNULL(QL_ByRoom,0)) FROM #QuotaLoadList)
	ELSE
		SET @ByRoom = 0

	insert into #QuotaLoadList 
		(QL_SubCode1, QL_Type, QL_dataType, QL_PRKey, QL_ByRoom)
	select DISTINCT DL_SubCode1, SD_State, 21, DL_PartnerKey, @ByRoom
	from	DogovorList (nolock),ServiceByDate (nolock)
	where	SD_DLKey=DL_Key
			and DL_SVKey=@Service_SVKey and DL_Code=@Service_Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd))
			and SD_Date<=@DateEnd and SD_Date>=@DateStart
			and SD_State not in (1,2)
	group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State
END

if (@nGridFilter=3)
begin
	update #QuotaLoadList set QL_CustomerInfo = (Select PR_NameENG from Partners (nolock) where PR_Key = QL_AgentKey and QL_AgentKey > 0)
	update #QuotaLoadList set QL_PartnerName = (Select PR_NameENG from Partners (nolock) where PR_Key = QL_PRKey and QL_PRKey > 0)
end
else
begin
	update #QuotaLoadList set QL_CustomerInfo = (Select PR_Name from Partners (nolock) where PR_Key = QL_AgentKey and QL_AgentKey > 0)
	update #QuotaLoadList set QL_PartnerName = (Select PR_Name from Partners (nolock) where PR_Key = QL_PRKey and QL_PRKey > 0)
end
update #QuotaLoadList set QL_PartnerName = 'All partners' where QL_PRKey=0

IF @DLKey is null and @QT_ID is null and (@ResultType is null or @ResultType not in (10))
BEGIN
	DECLARE @ServiceCount int, @SubCode1 int, @PartnerKey int

	DECLARE curQServiceList CURSOR FOR SELECT
		SD_Date,
		CASE @ByRoom WHEN 1 THEN count(distinct SD_RLID) ELSE count(SD_ID) END,
		DL_SubCode1,
		DL_PartnerKey,
		SD_State
		from	DogovorList (nolock),ServiceByDate (nolock)
		where	SD_DLKey=DL_Key
				and DL_SVKey=@Service_SVKey and DL_Code=@Service_Code 
				and DL_DateBeg<=@DateEnd and DL_DateEnd>=@DateStart
				and SD_Date<=@DateEnd and SD_Date>=@DateStart
				and SD_State not in (1,2)
		group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State
	OPEN curQServiceList
	FETCH NEXT FROM curQServiceList INTO	@Date, @ServiceCount, @SubCode1, @PartnerKey, @State

	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @ColumnName = CAST(CAST((@Date-@DateStart+1) as int) as varchar(6))
		set @QueryWhere1 = ' where QL_Type = ' + CAST(@State as varchar(1))

		set @QueryUpdate = 'UPDATE #QuotaLoadList SET QL_' + @ColumnName + ' = ''' + CAST((@ServiceCount) as varchar(10))  + ''' 
		WHERE QL_Type = ' + CAST(@State as varchar(1)) + ' and QL_SubCode1= ' + CAST(@SubCode1 as varchar(10)) + ' and QL_PRKey= ' + CAST(@PartnerKey as varchar(10))

		exec (@QueryUpdate)
		FETCH NEXT FROM curQServiceList INTO	@Date, @ServiceCount, @SubCode1, @PartnerKey, @State
	END
	CLOSE curQServiceList
	DEALLOCATE curQServiceList
END

DECLARE @QO_SubCode int, @QO_TypeD smallint, @DL_SubCode1 int, @QT_ID_Prev int, @ServiceName1 varchar(100), @ServiceName2 varchar(100), @Temp varchar(100),
	@IDEN_Local int, @IDEN_Prev int, @IDENTYPE_Local int, @IDENTYPE_Prev int
DECLARE curQLoadListQO CURSOR FOR 
	SELECT DISTINCT QO_QTID, QO_SubCode1, 1, null, 1 FROM QuotaObjects (nolock) WHERE QO_QTID in (SELECT QL_QTID FROM #QuotaLoadList (nolock) WHERE QO_QTID is not null)
	UNION
	SELECT DISTINCT QO_QTID, QO_SubCode2, 2, null, 1 FROM QuotaObjects (nolock) WHERE QO_QTID in (SELECT QL_QTID FROM #QuotaLoadList (nolock) WHERE QO_QTID is not null)
	UNION
	SELECT DISTINCT QL_ID, QL_SubCode1, 1, null, 3 FROM #QuotaLoadList (nolock) WHERE QL_SubCode1 is not null
	UNION
	SELECT DISTINCT QL_ID, QL_SubCode2, 2, null, 3 FROM #QuotaLoadList (nolock) WHERE QL_SubCode2 is not null
	UNION
	SELECT DISTINCT null, null, null, QL_SubCode1, 2 FROM #QuotaLoadList (nolock) WHERE QL_SubCode1 is not null
	ORDER BY 5,1,3

OPEN curQLoadListQO
FETCH NEXT FROM curQLoadListQO INTO	@IDEN_Local, @QO_SubCode, @QO_TypeD, @DL_SubCode1, @IDENType_Local
Set @IDEN_Prev=@IDEN_Local
Set @IDENTYPE_Prev=@IDENTYPE_Local

Set @ServiceName1=''
Set @ServiceName2=''

WHILE @@FETCH_STATUS = 0
BEGIN
	if @DL_SubCode1 is not null
	BEGIN
		Set @Temp=''
		if (@nGridFilter=3)
			begin
				--для англ версии
				exec GetSvCode1Name @Service_SVKey, @DL_SubCode1, null, null, null, @Temp output
			end
			else
			begin
				--для русской версии
				exec GetSvCode1Name @Service_SVKey, @DL_SubCode1, null, @Temp output, null, null
			end

		Update #QuotaLoadList set QL_Description=ISNULL(QL_Description,'') + @Temp where QL_SubCode1=@DL_SubCode1
		--print @Temp
	END
	Else
	BEGIN
		If (@IDEN_Prev != @IDEN_Local) OR (@IDENTYPE_Prev != @IDENTYPE_Local)
		BEGIN
			If @Service_SVKey=3
			BEGIN
				Set @ServiceName2='(' + @ServiceName2 + ')'
			END
			IF @IDENTYPE_Prev = 1
				Update #QuotaLoadList set QL_Description=LEFT(ISNULL(QL_Description,'') + @ServiceName1 + @ServiceName2,255) where QL_QTID=@IDEN_Prev
			IF @IDENTYPE_Prev = 3
			--обработка стоп сейла
				Update #QuotaLoadList set QL_Description=LEFT(@ServiceName1 + @ServiceName2,255) where QL_ID=@IDEN_Prev and QL_QTID is not null
			Set @ServiceName1=''
			Set @ServiceName2=''
		END
		
		SET @IDEN_Prev=@IDEN_Local
		SET @IDENTYPE_Prev=@IDENTYPE_Local
		Set @Temp=''
		If @Service_SVKey=3
		BEGIN
			IF @QO_TypeD=1
			BEGIN
				if (@nGridFilter=3)
				begin
					--для англ версии
					EXEC GetRoomName @QO_SubCode, null, @Temp output
				end
				else
				begin
					--для русской версии
					EXEC GetRoomName @QO_SubCode, @Temp output, null
				end
				If @ServiceName1!=''
					Set @ServiceName1=@ServiceName1+','
				Set @ServiceName1=@ServiceName1+@Temp
			END			
			Set @Temp=''
			IF @QO_TypeD=2
			BEGIN
				if (@nGridFilter=3)
				begin
					--для англ версии
					EXEC GetRoomCtgrName @QO_SubCode, null, @Temp output
				end
				else
				begin
					--для русской версии
					EXEC GetRoomCtgrName @QO_SubCode, @Temp output, null
				end
				If @ServiceName2!=''
					Set @ServiceName2=@ServiceName2+','
				Set @ServiceName2=@ServiceName2+@Temp
				--print @Temp
			END
		END
		ELse
		BEGIN
			if (@nGridFilter=3)
			begin
				--для англ версии
				exec GetSvCode1Name @Service_SVKey, @QO_SubCode, null, null, null, @Temp output
			end
			else
			begin
				--для русской версии
				exec GetSvCode1Name @Service_SVKey, @QO_SubCode, null, @Temp output, null, null
			end
			If @ServiceName1!=''
				Set @ServiceName1=@ServiceName1+','
			Set @ServiceName1=@ServiceName1+@Temp
		END
	END
	FETCH NEXT FROM curQLoadListQO INTO	@IDEN_Local, @QO_SubCode, @QO_TypeD, @DL_SubCode1, @IDENType_Local
END


If @Service_SVKey=3
BEGIN
	Set @ServiceName2='(' + @ServiceName2 + ')'
END
	IF @IDENTYPE_Prev = 1
		Update #QuotaLoadList set QL_Description=LEFT(ISNULL(QL_Description,'') + @ServiceName1 + @ServiceName2,255) where QL_QTID=@IDEN_Prev
	IF @IDENTYPE_Prev = 3
		--обработка стоп сейла
		Update #QuotaLoadList set QL_Description=LEFT(@ServiceName1 + @ServiceName2,255) where QL_ID=@IDEN_Prev and QL_QTID is not null
	--print @ServiceName1
	--print @ServiceName2
CLOSE curQLoadListQO
DEALLOCATE curQLoadListQO


/*
-- 29-03-2012 karimbaeva удаляю строки, чтобы не дублировались при выводе в окне, если стоп стоит по нескольким типам номеров
delete from #QuotaLoadList where ql_qoid <> (select top 1  ql_qoid from #QuotaLoadList) and ql_qoid is not null
*/

if (@bShowCommonRequest=1)
begin

--saifullina 11.02.2013
--формируем темповую таблицу для услуг на запросе
CREATE TABLE #tmpQuotaLoadList(QLID int,
	QLQTID int, QLQOID int, QLPRKey int, QLSubCode1 int, QLSubCode2 int, QLPartnerName nvarchar(100) collate Cyrillic_General_CI_AS, QLDescription nvarchar(255) collate Cyrillic_General_CI_AS, 
	QLdataType smallint, QLType smallint, QLTypeQuota smallint, QLRelease int, QLDurations nvarchar(20) collate Cyrillic_General_CI_AS, QLFilialKey int, 
	QLCityDepartments int, QLAgentKey int, QLCustomerInfo nvarchar(150) collate Cyrillic_General_CI_AS, QLDateCheckinMin smalldatetime,
	QLByRoom int)
	
	set @n=1 
	set @str = ''
	 
	WHILE @n <= @DaysCount
	BEGIN
		set @str = 'ALTER TABLE #tmpQuotaLoadList ADD QL' + CAST(@n as varchar(3)) + ' int'
		exec (@str)
		set @n = @n + 1
	END

declare @qlid int,
@qlPrKey int,
@qlAgentKey int,
@qlAgentName varchar(max),
@qlPartnerName varchar(max)
	--добавляем все услуги на запросе в таблицу
	DECLARE qCur CURSOR FAST_FORWARD READ_ONLY FOR
	select QL_ID,QL_PRKey,QL_AgentKey,QL_PartnerName,QL_CustomerInfo from #QuotaLoadList where QL_Type = 4		
	OPEN qCur								
	FETCH NEXT FROM qCur INTO @qlid,@qlPrKey,@qlAgentKey,@qlPartnerName,@qlAgentName		
	WHILE @@FETCH_STATUS = 0
	BEGIN
		insert into #tmpQuotaLoadList (QLID,QLSubCode1, QLType, QLdataType, QLByRoom,QLAgentKey,QLPRKey) select top 1 QL_ID, QL_SubCode1, QL_Type, QL_dataType, QL_ByRoom, QL_AgentKey, QL_PRKey from #QuotaLoadList where QL_ID=@qlid
		set @n = 1
		declare @turist nvarchar(max)
		WHILE @n <= @DaysCount
		begin
			set @QueryUpdate = ''
		set @QueryUpdate = 'UPDATE #tmpQuotaLoadList SET QL' + CAST(@n as varchar(3)) + ' = (select CAST (QL_' + CAST(@n as varchar(3))  +' as int) from #QuotaLoadList
		WHERE QL_ID = ' + CAST(@qlid as varchar(10)) + ' and QL_' + CAST(@n as varchar(3)) + ' is not null) where QLID='+CAST(@qlid as varchar(25))
		exec (@QueryUpdate) 
			set @n = @n + 1
		end
		
		delete #QuotaLoadList where QL_Type=4 and QL_ID=@qlid
		
		if not exists (select * from #QuotaLoadList where (QL_Description like 'Любое' or  QL_Description like 'Any') and QL_Type=4 and QL_dataType=21 and (QL_AgentKey=@qlAgentKey or (QL_AgentKey is null and @qlAgentKey is null))and QL_PRKey = @qlPrKey)
		begin
			if (@ngridfilter=3)
			begin
				insert into #QuotaLoadList (QL_Description, QL_Type,QL_dataType,QL_AgentKey,QL_PRKey, QL_CustomerInfo, QL_PartnerName) values ('Any',4,21,@qlAgentKey,@qlPrKey,@qlAgentName,@qlPartnerName)
			end
			else
			begin
				insert into #QuotaLoadList (QL_Description, QL_Type,QL_dataType,QL_AgentKey,QL_PRKey, QL_CustomerInfo, QL_PartnerName) values ('Любое',4,21,@qlAgentKey,@qlPrKey,@qlAgentName,@qlPartnerName)
			end
		end
		
	FETCH NEXT FROM qCur INTO @qlid,@qlPrKey,@qlAgentKey,@qlPartnerName,@qlAgentName
	END
	CLOSE qCur
	DEALLOCATE qCur

set @n = 1
WHILE @n <= @DaysCount
	begin
		set @QueryUpdate = ''
	set @QueryUpdate = 'UPDATE #QuotaLoadList SET QL_' + CAST(@n as varchar(3)) + ' =' + '(select SUM(QL' + CAST(@n as varchar(3)) + ') from #tmpQuotaLoadList)
	WHERE QL_Type=4'
	exec (@QueryUpdate) 
		set @n = @n + 1
	end
drop table #tmpQuotaLoadList

end

If @Service_SVKey=3
BEGIN
	Update #QuotaLoadList set QL_Description = QL_Description + ' - Per person' where QL_ByRoom = 0
END
--Общий релиз период
if (@bCommonRelease is not null and @bCommonRelease = 1) and (@ResultType is null or @ResultType not in (10))
begin
	update #QuotaLoadList set QL_Release=0 where QL_Release is null
	
	CREATE TABLE #tempQuotaLoadList(QLID int,
	QLQTID int, QLQOID int, QLPRKey int, QLSubCode1 int, QLSubCode2 int, QLPartnerName nvarchar(100) collate Cyrillic_General_CI_AS, QLDescription nvarchar(255) collate Cyrillic_General_CI_AS, 
	QLdataType smallint, QLType smallint, QLTypeQuota smallint, QLRelease nvarchar(max), QLDurations nvarchar(20) collate Cyrillic_General_CI_AS, QLFilialKey int, 
	QLCityDepartments int, QLAgentKey int, QLCustomerInfo nvarchar(150) collate Cyrillic_General_CI_AS, QLDateCheckinMin smalldatetime,
	QLByRoom int)

	set @n=1 
	set @str = ''
	 
	WHILE @n <= @DaysCount
	BEGIN
		set @str = 'ALTER TABLE #tempQuotaLoadList ADD QL' + CAST(@n as varchar(3)) + ' varchar(8000)'
		exec (@str)
		set @n = @n + 1
	END
	
	declare @Qtid int, @Prkey int, @partnerName nvarchar(100), @description nvarchar(100), @dataType smallint, @type smallint, 
	@typeQuota smallint, @durations nvarchar(20), @agent int, @qlid_min int 
	DECLARE qCur CURSOR FAST_FORWARD READ_ONLY FOR
	select QL_QTID, QL_PRKey, QL_PartnerName, QL_Description, QL_DataType, QL_Type, QL_TypeQuota, QL_Durations, QL_AgentKey, MIN(QL_ID) as ql_id
								from #QuotaLoadList
								where QL_Release is not null
								group by QL_QTID, QL_PRKey, QL_PartnerName, QL_Description, QL_DataType, QL_Type, QL_TypeQuota, QL_Durations, QL_AgentKey
								having count(*)>1
								
	OPEN qCur								
	FETCH NEXT FROM qCur INTO @Qtid, @Prkey, @partnerName, @description, @dataType, @type, @typeQuota, @durations, @agent, @qlid_min 						
	WHILE @@FETCH_STATUS = 0
	BEGIN
		insert into #tempQuotaLoadList 
		select *
		from #QuotaLoadList where QL_QTID = @Qtid and QL_PRKey = @Prkey and QL_PartnerName = @partnerName 
		and QL_Description = @description and QL_DataType = @dataType and QL_Type = @type 
		and QL_TypeQuota = @typeQuota and ((QL_Durations is null and @durations is null) or (QL_Durations = @durations))   
		and ((QL_AgentKey is null and @agent is null) or (QL_AgentKey = @agent))
		and QL_ID <> @qlid_min
		
		set @n = 1
		WHILE @n <= @DaysCount
		begin
			set @QueryUpdate = ''
			set @QueryUpdate = 'UPDATE #QuotaLoadList SET QL_' + CAST(@n as varchar(3)) + ' = QL' + CAST(@n as varchar(3)) + '
			from #tempQuotaLoadList
			WHERE QL_ID = ' + CAST(@qlid_min as varchar(10)) + ' and QL' + CAST(@n as varchar(3)) + ' is not null'

			exec (@QueryUpdate) 
			set @n = @n + 1
		end
				
		declare @commonRelease nvarchar(20), @tempRelease nvarchar(max)
		set @tempRelease = ''
		DECLARE qCurs CURSOR FAST_FORWARD READ_ONLY FOR
		select QLRelease from #tempQuotaLoadList
		OPEN qCurs								
		FETCH NEXT FROM qCurs INTO @commonRelease					
		WHILE @@FETCH_STATUS = 0
		BEGIN
			set @tempRelease = @tempRelease + ',' + @commonRelease
			FETCH NEXT FROM qCurs INTO @commonRelease			
		END
		CLOSE qCurs
		DEALLOCATE qCurs
		update #QuotaLoadList set QL_Release = QL_Release + @tempRelease where QL_ID = @qlid_min
				
		delete from #QuotaLoadList where QL_ID in (select QLID from #tempQuotaLoadList)
		truncate table #tempQuotaLoadList
		FETCH NEXT FROM qCur INTO @Qtid, @Prkey, @partnerName, @description, @dataType, @type, @typeQuota, @durations, @agent, @qlid_min 
	END
	CLOSE qCur
	DEALLOCATE qCur
	drop table #tempQuotaLoadList
end

-- удаляем вспомогательный столбец
alter table #QuotaLoadList drop column QL_QOID
alter table #QuotaLoadList drop column QL_SubCode2
alter table #QuotaLoadList drop column QL_ID

-- если запуск из экрана Статус бронирования
-- фильтруем по квотам на зезд, они должны отображаться только на 1-й день
if (@nGridFilter=1)
begin
	set @n = 2
		WHILE @n <= @DaysCount
		begin
			set @QueryUpdate = ''
			--set @QueryUpdate = 'UPDATE #QuotaLoadList SET QL_' + CAST(@n as varchar(3)) + ' = null 
			--WHERE QL_QTID in (select QT_ID from Quotas join QuotaDetails on QT_ID = QD_QTID where QT_IsByCheckIn=1 and QD_Date <> ' + CAST(@DateStart as varchar(20))  +')'
			set @QueryUpdate = 'UPDATE #QuotaLoadList SET QL_' + CAST(@n as varchar(3)) + ' = null 
			WHERE QL_TypeQuota = 1'
			--print @QueryUpdate
			exec (@QueryUpdate) 
			set @n = @n + 1
		end
end

IF @ResultType is null or @ResultType not in (10)
BEGIN
	if (@bCommonRelease is not null and @bCommonRelease = 1)
	begin
		select *
		from #QuotaLoadList (nolock)
		order by
			(case
			when QL_QTID is not null then 1
			else 0
			end) DESC,
			QL_Description /*Сначала квоты, потом неквоты*/,QL_PartnerName,QL_Type DESC, 
			CONVERT(int,SUBSTRING(QL_Release,0,CHARINDEX('-',QL_Release))),
			--сортируем по первому числу продолжительности если продолжительность с "-",","," "
			case 
			when CHARINDEX('-',QL_DURATIONS) <>0 then CONVERT(int, REPLACE(QL_DURATIONS, '-', ''))
			when CHARINDEX(',',QL_DURATIONS) <>0 then CONVERT(int,SUBSTRING(QL_DURATIONS,0,CHARINDEX(',',QL_DURATIONS)))
			when CHARINDEX(' ',QL_DURATIONS) <>0 then CONVERT(int,SUBSTRING(QL_DURATIONS,0,CHARINDEX(' ',QL_DURATIONS)))
			when CHARINDEX('-',QL_DURATIONS) = 0 then CONVERT(int,QL_DURATIONS)
			end,
			QL_CityDepartments,QL_FilialKey,QL_CustomerInfo,QL_QTID,QL_DataType
		RETURN 0
	end
	else
	begin
		select *
		from #QuotaLoadList (nolock)
		order by
			(case
			when QL_QTID is not null then 1
			else 0
			end) DESC,
			QL_Description /*Сначала квоты, потом неквоты*/,QL_PartnerName,QL_Type DESC, CONVERT(int, QL_Release),
			--сортируем по первому числу продолжительности если продолжительность с "-",","," "
			case 
			--when CHARINDEX('-',QL_DURATIONS) <>0 then CONVERT(int,SUBSTRING(QL_DURATIONS,0,CHARINDEX('-',QL_DURATIONS)) + SUBSTRING(QL_DURATIONS,CHARINDEX('-',QL_DURATIONS) + 1, LEN(QL_DURATIONS) - CHARINDEX('-',QL_DURATIONS)))
			when CHARINDEX('-',QL_DURATIONS) <>0 then CONVERT(int, REPLACE(QL_DURATIONS, '-', ''))
			when CHARINDEX(',',QL_DURATIONS) <>0 then CONVERT(int,SUBSTRING(QL_DURATIONS,0,CHARINDEX(',',QL_DURATIONS)))
			when CHARINDEX(' ',QL_DURATIONS) <>0 then CONVERT(int,SUBSTRING(QL_DURATIONS,0,CHARINDEX(' ',QL_DURATIONS)))
			when CHARINDEX('-',QL_DURATIONS) = 0 then CONVERT(int,QL_DURATIONS)
			end,
			QL_CityDepartments,QL_FilialKey,QL_CustomerInfo,QL_QTID,QL_DataType
		RETURN 0
	end
END
ELSE
BEGIN --для наличия мест(из оформления)
	CREATE TABLE #ServicePlacesTr(
		SPT_QTID int, SPT_PRKey int, SPT_SubCode1 int, SPT_PartnerName varchar(100), SPT_Description varchar(255), 
		SPT_Type smallint, SPT_TypeQuota smallint, SPT_FilialKey int, SPT_CityDepartments int, SPT_Release int, SPT_Durations varchar(100),
		SPT_AgentKey int, SPT_Date smalldatetime, SPT_Places smallint, SPT_Stop smallint, SPT_CheckIn smallint)
	
	-- В MSSQL 2000 это не работает
	--ALTER TABLE #ServicePlacesTr ADD SPT_Date smalldatetime
	--ALTER TABLE #ServicePlacesTr ADD SPT_Places smallint
	--ALTER TABLE #ServicePlacesTr ADD SPT_Stop smallint
	--ALTER TABLE #ServicePlacesTr ADD SPT_CheckIn smallint


	set @n=1
	WHILE @n <= @DaysCount
	BEGIN
		DECLARE @curDate smalldatetime
		SET @curDate = DATEADD(DAY,@n-1,@DateStart)

		set @str = '
			INSERT INTO #ServicePlacesTr 
				(SPT_QTID, SPT_PRKey,SPT_SubCode1,SPT_PartnerName,SPT_Description,SPT_Type, SPT_TypeQuota,
				SPT_FilialKey,SPT_CityDepartments,SPT_Release,SPT_Durations,SPT_AgentKey,
				SPT_Date,SPT_Places) 
			SELECT QL_QTID, QL_PRKey,QL_SubCode1,QL_PartnerName, QL_Description, QL_Type, QL_TypeQuota,
				QL_FilialKey, QL_CityDepartments,QL_Release,QL_Durations,QL_AgentKey, 
				''' + CAST(@curDate as varchar(20)) + ''', QL_' + CAST(@n as varchar(3)) + '
				FROM #QuotaLoadList
				WHERE QL_dataType=21'
		exec (@str)

		set @str = 'UPDATE #ServicePlacesTr SET SPT_Stop=
					(SELECT QL_' + CAST(@n as varchar(3)) + '
					FROM #QuotaLoadList
					WHERE  QL_dataType=22 and 
					SPT_QTID=QL_QTID and
					SPT_PRKey=QL_PRKey and 
					ISNULL(SPT_SubCode1,-1)=ISNULL(QL_SubCode1,-1) and 
					SPT_PartnerName=QL_PartnerName and 
					SPT_Description=QL_Description and 
					SPT_Type=QL_Type and 
					SPT_TypeQuota = QL_TypeQuota and
					ISNULL(SPT_FilialKey,-1)=ISNULL(QL_FilialKey,-1) and 
					ISNULL(SPT_CityDepartments,-1)=ISNULL(QL_CityDepartments,-1) and 
					ISNULL(SPT_Release,-1)=ISNULL(QL_Release,-1) and 
					ISNULL(SPT_Durations,-1)=ISNULL(QL_Durations,-1) and 
					ISNULL(SPT_AgentKey,-1)=ISNULL(QL_AgentKey,-1) and 
					SPT_Date=''' + CAST(@curDate as varchar(20)) + ''')
					WHERE SPT_Date=''' + CAST(@curDate as varchar(20))+ ''''

		exec (@str)

		set @str = 'UPDATE #ServicePlacesTr SET SPT_CheckIn=
					(SELECT QL_' + CAST(@n as varchar(3)) + '
					FROM #QuotaLoadList
					WHERE  QL_dataType=23 and
					SPT_QTID=QL_QTID and 
					SPT_PRKey=QL_PRKey and 
					ISNULL(SPT_SubCode1,-1)=ISNULL(QL_SubCode1,-1) and 
					SPT_PartnerName=QL_PartnerName and 
					SPT_Description=QL_Description and 
					SPT_Type=QL_Type and
					SPT_TypeQuota = QL_TypeQuota and 
					ISNULL(SPT_FilialKey,-1)=ISNULL(QL_FilialKey,-1) and 
					ISNULL(SPT_CityDepartments,-1)=ISNULL(QL_CityDepartments,-1) and 
					ISNULL(SPT_Release,-1)=ISNULL(QL_Release,-1) and 
					ISNULL(SPT_Durations,-1)=ISNULL(QL_Durations,-1) and
					ISNULL(SPT_AgentKey,-1)=ISNULL(QL_AgentKey,-1) and 
					SPT_Date= ''' + CAST(@curDate as varchar(20)) + ''')
					WHERE SPT_Date=''' + CAST(@curDate as varchar(20)) + ''''

		exec (@str)
		set @n = @n + 1
	END
END

--Select * from #ServicePlacesTr 	ORDER BY  SPT_PRKey, SPT_Type, SPT_SubCode1, SPT_PartnerName, SPT_Description, SPT_FilialKey, SPT_CityDepartments, SPT_Date, SPT_Release

DECLARE @ServicePlaces TABLE
(
	SP_PRKey int, SP_SubCode1 int, SP_PartnerName nvarchar(100), SP_Description nvarchar(255), 
	SP_Type smallint, SP_TypeQuota smallint, SP_FilialKey int, SP_CityDepartments int, 
	SP_Places1 smallint, SP_Places2 smallint, SP_Places3 smallint, 
	SP_NonReleasePlaces1 smallint,SP_NonReleasePlaces2 smallint,SP_NonReleasePlaces3 smallint, 
	SP_StopPercent1 smallint,SP_StopPercent2 smallint,SP_StopPercent3 smallint
)

DECLARE @SPT_QTID int, @SPT_PRKey int, @SPT_SubCode1 int, @SPT_PartnerName varchar(100), @SPT_Description varchar(255), 
		@SPT_Type smallint, @SPT_TypeQuota smallint, @SPT_FilialKey int, @SPT_CityDepartments int, @SPT_Release smallint, @SPT_Date smalldatetime, 
		@SPT_Places smallint, @SPT_Stop smallint, @SPT_CheckIn smallint, @SPT_PRKey_Old int, @SPT_PartnerName_Old varchar(100), 
		@SPT_SubCode1_Old int, @SPT_Description_Old varchar(255), @SPT_Type_Old smallint, @SPT_TypeQuota_Old smallint, @SPT_FilialKey_Old int,
		@SPT_CityDepartments_Old int, @SPT_Date_Old smalldatetime,
		@currentPlaces1 smallint, @currentPlaces2 smallint, @currentPlaces3 smallint,
		@currentNonReleasePlaces1 smallint, @currentNonReleasePlaces2 smallint, @currentNonReleasePlaces3 smallint,
		@OblectPlacesMin1 smallint, @OblectPlacesMin2 smallint, @OblectPlacesMin3 smallint,
		@OblectNonReleasePlacesMin1 smallint, @OblectNonReleasePlacesMin2 smallint, @OblectNonReleasePlacesMin3 smallint,
		@stopPercentSum1 smallint,@stopPercentSum2 smallint,@stopPercentSum3 smallint,
		@quotaCounter1 smallint,@quotaCounter2 smallint,@quotaCounter3 smallint,
		@Now smalldatetime

SET @Now = GETDATE()
		
DECLARE curQ2 CURSOR FOR SELECT
			 SPT_QTID, SPT_PRKey, SPT_SubCode1, SPT_PartnerName, SPT_Description, SPT_Type, SPT_TypeQuota, SPT_FilialKey, 
			 SPT_CityDepartments, ISNULL(SPT_Release, 0), SPT_Date, ISNULL(SPT_Places, 0), ISNULL(SPT_Stop,0), SPT_CheckIn
	FROM	#ServicePlacesTr
	ORDER BY  SPT_PRKey DESC, SPT_Description DESC, SPT_Type DESC, SPT_TypeQuota DESC, SPT_Date DESC, SPT_SubCode1 DESC, SPT_PartnerName DESC, 
		SPT_FilialKey DESC, SPT_CityDepartments DESC, SPT_Places, SPT_Release DESC

OPEN curQ2
FETCH NEXT FROM curQ2 INTO @SPT_QTID, @SPT_PRKey, @SPT_SubCode1, @SPT_PartnerName, @SPT_Description, 
		@SPT_Type, @SPT_TypeQuota, @SPT_FilialKey, @SPT_CityDepartments, @SPT_Release, @SPT_Date, @SPT_Places, @SPT_Stop, @SPT_CheckIn	

SET @SPT_PRKey_Old=@SPT_PRKey
SET @SPT_Description_Old=@SPT_Description
SET @SPT_PartnerName_Old=@SPT_PartnerName
SET @SPT_Type_Old=@SPT_Type
SET @SPT_TypeQuota_Old=@SPT_TypeQuota
SET @SPT_Date_Old=@SPT_Date
SET @currentPlaces1=0
SET @currentPlaces2=0
SET @currentPlaces3=0
SET @currentNonReleasePlaces1=0
SET @currentNonReleasePlaces2=0
SET @currentNonReleasePlaces3=0
SET @stopPercentSum1=0
SET @stopPercentSum2=0
SET @stopPercentSum3=0
SET @quotaCounter1=0
SET @quotaCounter2=0
SET @quotaCounter3=0


WHILE @@FETCH_STATUS = 0
BEGIN
	IF @SPT_PRKey=@SPT_PRKey_Old and @SPT_Description=@SPT_Description_Old and ISNULL(@SPT_Type,-1)=ISNULL(@SPT_Type_Old,-1) and @SPT_Date!=@SPT_Date_Old
	BEGIN
		If (@OblectPlacesMin1 is null or @OblectPlacesMin1 > @currentPlaces1) AND @SPT_Date_Old BETWEEN @DateStart AND DATEADD(DAY,@ServiceLong-1,@DateStart)
		BEGIN
			--Set @quotaCounter1=0
			Set @OblectPlacesMin1=@currentPlaces1
			--Set @currentPlaces1=0
			Set @OblectNonReleasePlacesMin1=@currentNonReleasePlaces1
			--Set @currentNonReleasePlaces1=0
		END
		If (@OblectPlacesMin2 is null or @OblectPlacesMin2 > @currentPlaces2) AND @SPT_Date_Old BETWEEN @DateStart2 AND DATEADD(DAY,@ServiceLong-1,@DateStart2)
		BEGIN
			--Set @quotaCounter2=0
			Set @OblectPlacesMin2=@currentPlaces2
			--Set @currentPlaces2=0
			Set @OblectNonReleasePlacesMin2=@currentNonReleasePlaces2
			--Set @currentNonReleasePlaces2=0
		END
		If (@OblectPlacesMin3 is null or @OblectPlacesMin3 > @currentPlaces3) AND @SPT_Date_Old BETWEEN @DateStart3 AND DATEADD(DAY,@ServiceLong-1,@DateStart3)
		BEGIN
			--Set @quotaCounter3=0
			Set @OblectPlacesMin3=@currentPlaces3
			--Set @currentPlaces3=0
			Set @OblectNonReleasePlacesMin3=@currentNonReleasePlaces3
			--Set @currentNonReleasePlaces3=0
		END
-- При смене даты обнуляем текущие количества мест
		SET @currentPlaces1=0
		SET @currentPlaces2=0
		SET @currentPlaces3=0
		SET @currentNonReleasePlaces1=0
		SET @currentNonReleasePlaces2=0
		SET @currentNonReleasePlaces3=0
	END

	IF @SPT_PRKey!=@SPT_PRKey_Old or @SPT_Description!=@SPT_Description_Old or ISNULL(@SPT_Type,-1)!=ISNULL(@SPT_Type_Old,-1) or ISNULL(@SPT_TypeQuota,-1)!=ISNULL(@SPT_TypeQuota_Old,-1)
	BEGIN
		IF @quotaCounter1 = 0 SET @quotaCounter1 = 1
		IF @quotaCounter2 = 0 SET @quotaCounter2 = 1
		IF @quotaCounter3 = 0 SET @quotaCounter3 = 1
		INSERT INTO @ServicePlaces (SP_PRKey, SP_SubCode1, SP_PartnerName, SP_Description, SP_Type, SP_TypeQuota,
				SP_FilialKey, SP_CityDepartments, SP_Places1, SP_Places2, SP_Places3, 
				SP_NonReleasePlaces1, SP_NonReleasePlaces2, SP_NonReleasePlaces3,
				SP_StopPercent1,SP_StopPercent2,SP_StopPercent3)
		Values (@SPT_PRKey_Old, @SPT_SubCode1_Old, @SPT_PartnerName_Old, @SPT_Description_Old, @SPT_Type_Old, @SPT_TypeQuota_Old,
				@SPT_FilialKey_Old, @SPT_CityDepartments_Old, 
				@currentPlaces1, @currentPlaces2, @currentPlaces3,
				ISNULL(@OblectNonReleasePlacesMin1,@currentNonReleasePlaces1), ISNULL(@OblectNonReleasePlacesMin2,@currentNonReleasePlaces2), ISNULL(@OblectNonReleasePlacesMin3,@currentNonReleasePlaces3),
				@stopPercentSum1/@quotaCounter1,@stopPercentSum2/@quotaCounter2,@stopPercentSum3/@quotaCounter3)

		set @OblectPlacesMin1 = null
		set @OblectPlacesMin2 = null
		set @OblectPlacesMin3 = null
		set @OblectNonReleasePlacesMin1 = null
		set @OblectNonReleasePlacesMin2 = null
		set @OblectNonReleasePlacesMin3 = null
		Set @currentPlaces1=0
		Set @currentPlaces2=0
		Set @currentPlaces3=0
		Set @currentNonReleasePlaces1=0
		Set @currentNonReleasePlaces2=0
		Set @currentNonReleasePlaces3=0
		Set @stopPercentSum1=0
		Set @stopPercentSum2=0
		Set @stopPercentSum3=0
		Set @quotaCounter1=0
		Set @quotaCounter2=0
		Set @quotaCounter3=0
	END

	If @SPT_Date BETWEEN @DateStart AND DATEADD(DAY,@ServiceLong-1,@DateStart)
	BEGIN
			Set @quotaCounter1=@quotaCounter1+1
		Set @stopPercentSum1 = @stopPercentSum1 + @SPT_Stop
		Set @currentPlaces1=@currentPlaces1+@SPT_Places
		If @DateStart > DATEADD(DAY,@SPT_Release,@Now)
			Set @currentNonReleasePlaces1=@currentNonReleasePlaces1+@SPT_Places
	END
	If @SPT_Date BETWEEN @DateStart2 AND DATEADD(DAY,@ServiceLong-1,@DateStart2)
	BEGIN
			Set @quotaCounter2=@quotaCounter2+1
		Set @stopPercentSum2 = @stopPercentSum2 + @SPT_Stop
		Set @currentPlaces2=@currentPlaces2+@SPT_Places
		If @DateStart2 > DATEADD(DAY,@SPT_Release,@Now)
			Set @currentNonReleasePlaces2=@currentNonReleasePlaces2+@SPT_Places
	END
	If @SPT_Date BETWEEN @DateStart3 AND DATEADD(DAY,@ServiceLong-1,@DateStart3)
	BEGIN
			Set @quotaCounter3=@quotaCounter3+1
		Set @stopPercentSum3 = @stopPercentSum3 + @SPT_Stop
		Set @currentPlaces3=@currentPlaces3+@SPT_Places
		If @DateStart3 > DATEADD(DAY,@SPT_Release,@Now)
			Set @currentNonReleasePlaces3=@currentNonReleasePlaces3+@SPT_Places
	END

	SET @SPT_PRKey_Old=@SPT_PRKey
	SET @SPT_PartnerName_Old=@SPT_PartnerName
	SET @SPT_Description_Old=@SPT_Description
	SET @SPT_Type_Old=@SPT_Type
	SET @SPT_TypeQuota_Old=@SPT_TypeQuota
	SET @SPT_Date_Old=@SPT_Date
	FETCH NEXT FROM curQ2 INTO @SPT_QTID, @SPT_PRKey, @SPT_SubCode1, @SPT_PartnerName, @SPT_Description, 
			@SPT_Type, @SPT_TypeQuota, @SPT_FilialKey, @SPT_CityDepartments, @SPT_Release, @SPT_Date, @SPT_Places, @SPT_Stop, @SPT_CheckIn	

	If @@FETCH_STATUS != 0
	BEGIN
		IF @quotaCounter1 = 0 SET @quotaCounter1 = 1
		IF @quotaCounter2 = 0 SET @quotaCounter2 = 1
		IF @quotaCounter3 = 0 SET @quotaCounter3 = 1
		INSERT INTO @ServicePlaces (SP_PRKey, SP_SubCode1, SP_PartnerName, SP_Description, SP_Type, SP_TypeQuota,
			SP_FilialKey, SP_CityDepartments, SP_Places1, SP_Places2, SP_Places3, 
			SP_NonReleasePlaces1, SP_NonReleasePlaces2, SP_NonReleasePlaces3,
			SP_StopPercent1,SP_StopPercent2,SP_StopPercent3)
		Values (@SPT_PRKey_Old, @SPT_SubCode1_Old, @SPT_PartnerName_Old, @SPT_Description_Old, @SPT_Type_Old, @SPT_TypeQuota_Old,
			@SPT_FilialKey_Old, @SPT_CityDepartments_Old, 
			ISNULL(@OblectPlacesMin1,@currentPlaces1), ISNULL(@OblectPlacesMin2,@currentPlaces2), ISNULL(@OblectPlacesMin3,@currentPlaces3),
			ISNULL(@OblectNonReleasePlacesMin1,@currentNonReleasePlaces1), ISNULL(@OblectNonReleasePlacesMin2,@currentNonReleasePlaces2), ISNULL(@OblectNonReleasePlacesMin3,@currentNonReleasePlaces3),
			@stopPercentSum1/@quotaCounter1,@stopPercentSum2/@quotaCounter2,@stopPercentSum3/@quotaCounter3)
		END
END
CLOSE curQ2
DEALLOCATE curQ2

--select * from #ServicePlacesTr
--ORDER BY  SPT_PRKey, SPT_Type, SPT_SubCode1, SPT_PartnerName, SPT_Description, 
--		SPT_FilialKey, SPT_CityDepartments, SPT_Date, SPT_Release

--select * from #ServicePlaces


	select 
		SP_PRKey,SP_PartnerName,SP_Description,SP_SubCode1,SP_Type,SP_TypeQuota,SP_FilialKey,SP_CityDepartments,
		CAST(SP_Places1 as varchar(4))+';'+CAST(SP_NonReleasePlaces1 as varchar(4))+';'+CAST(SP_StopPercent1 as varchar(4)) as SP_1,
		CAST(SP_Places2 as varchar(4))+';'+CAST(SP_NonReleasePlaces2 as varchar(4))+';'+CAST(SP_StopPercent2 as varchar(4)) as SP_2,
		CAST(SP_Places3 as varchar(4))+';'+CAST(SP_NonReleasePlaces3 as varchar(4))+';'+CAST(SP_StopPercent3 as varchar(4)) as SP_3
	from @ServicePlaces
	order by SP_Description, SP_PartnerName, SP_Type, SP_TypeQuota
GO

GRANT EXECUTE ON [dbo].[GetQuotaLoadListData_N]	TO PUBLIC
GO
/*********************************************************************/
/* end sp_GetQuotaLoadListData_N.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceCost.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetServiceCost]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetServiceCost]
GO

--<DATE>2013-07-10</DATE>
--<VERSION>9.2.20.3</VERSION>
CREATE PROCEDURE [dbo].[GetServiceCost] 
	(
		--.18 gorshkov 12.03.2012 - для динамического ценообразования @CS_Profit заполняется нулями
		--.17 mv 06.02.2012 (MEG00040397) обработка продолжительности а/п
		--.15 mv 27.01.2012: Изменил обвязку рядом вокруг sp "GetServiceAddCosts"
		@svKey int, @code int, @code1 int, @code2 int, @prKey int, @packetKey int, @date datetime, @days int,
		@resRate varchar(2), @men int, @discountPercent decimal(14,2), @margin decimal(14,2) = 0, @marginType int =0,
		@sellDate dateTime, @netto decimal(14,2) output, @brutto decimal(14,2) output, @discount decimal(14,2) output, 
		@nettoDetail varchar(100) = '' output, @sBadRate varchar(2) = '' output, @dtBadDate DateTime = '' output,
		@sDetailed varchar(100) = '' output,  @nSPId int = null output, @useDiscountDays int = 0 output,
		@tourKey int = 0, @tourDate datetime, @tourDays int, @includeAddCost bit = 1
	)
as
SET DATEFIRST 1
DECLARE @tourlong int

DECLARE @LONG_MAX int
SET @LONG_MAX = 99

declare @newReCalculatePrice bit
set @newReCalculatePrice = 0
if exists(select top 1 1 from SystemSettings with(nolock) where SS_ParmName = 'NewReCalculatePrice' and SS_ParmValue = 1)
begin
	set @newReCalculatePrice = 1
end

If @svKey = 1 and @days > 0
BEGIN
	Set @tourlong = @days
	Set @days = 0
END
else
	set @tourlong = 0
If ((((@days <= 0) or (@days is null)) and (@svKey != 3 and @svKey != 8)) or (@svKey = 1 and isnull(@tourDays,0) > 0))
	Set @days = 1

/*
Новый код!!!!!!
НАЧАЛО
*/
declare @rakey int, @marginCalcValue decimal(14,2), @bSPUpdate bit, @sUseServicePrices varchar(1)
Select @rakey = RA_Key from dbo.Rates with(nolock) where RA_Code = @resRate

select @sUseServicePrices = SS_ParmValue from systemsettings with(nolock) where SS_ParmName = 'UseServicePrices'
if @sUseServicePrices = '1'
BEGIN
	SET @bSPUpdate = 0
	set @netto = null

	if @nSPId is not null 
		if exists (select SP_ID from dbo.ServicePrices with(nolock) where SP_ID = @nSPId)
			Set @bSPUpdate = 1

	if @bSPUpdate = 0
	BEGIN
		select	@nSPId = SP_ID, @netto = SP_Cost, @brutto = SP_Price, @discount = SP_PriceWithCommission
		from	dbo.ServicePrices with(nolock)
		where 
				SP_SVKey = @svKey and SP_Code = @code and SP_SubCode1 = @code1 and
				SP_SubCode2 = @code2 and SP_PRKey = @prKey and SP_PKKey = @packetKey and
				SP_Long = @days and SP_Date = @date and SP_Pax = @men and
				SP_RateKey = @rakey
	END
END

if @nSPId is null or @bSPUpdate = 1
BEGIN
/*
Новый код!!!!!!
КОНЕЦ
*/

DECLARE @profitValue decimal(14,2)
Set @marginType = ISNULL(@marginType,0)
Set @packetKey = ISNULL(@packetKey,0)

DECLARE @TMP_Number_Period int, @TMP_DATE_Period datetime, @nCostByDayExists smallint, @WeekDate varchar(1), @IsFetchNormal bit, @csid int
DECLARE @TMP_Number INT, @DayOfWeek char(1), @DayOfWeeks varchar(13), @String varchar(500), @COST_ID INT, @TMP_Date DATETIME, @CS_Date DATETIME, @CS_DateEnd DATETIME, @CS_Week varchar(7), @CS_CostNetto decimal(14,4), @CS_Cost decimal(14,4)
DECLARE @CS_Discount decimal(14,4), @CS_Type INT, @CS_Rate varchar(2), @CS_LongMin int, @CS_Long int
--DECLARE @CS_ByDay INT, @CS_Profit decimal(8,4), @CS_ID INT, @TMP_Rate varchar(2), @course decimal (8,6), @sBadRate varchar(3), @dtBadDate DateTime
DECLARE @CS_ByDay INT, @CS_Profit decimal(14,4), @CS_ID INT, @TMP_Rate varchar(2), @course decimal (18,8), @CS_CheckInDateBEG datetime, @CS_CheckInDateEND datetime, @CS_DateSellBeg datetime, @CS_DateSellEnd datetime, @NotCalculatedCosts smallint, @CS_Pax smallint, @FindCostByPeriod smallint
DECLARE @serviceEndDate datetime

set @NotCalculatedCosts = 1
set @WeekDate = DATEPART (weekday, @date)

--	REGION		MEG00015352 2008-02-22
	DECLARE @RealNetto decimal(14,2)	-- Сюда будем фиксировать НЕТТО, если цены в базе разделены 
	DECLARE @UseTypeDivisionMode int	-- Переменная, которая определяет ведется ли расчет отдельно по брутто и отдельно по нетто ценам
	DECLARE @TypeDivision int	-- Переменная указывает по какому типу цены ведем расчет (1-нетто, 2-брутто)
	SET @TypeDivision = 0

	SELECT @UseTypeDivisionMode = SS_ParmValue from dbo.SystemSettings with(nolock) where SS_ParmName = 'SYSUseCostTypeDivision'
	IF @UseTypeDivisionMode is not null and @UseTypeDivisionMode > 0
	BEGIN
		SELECT @UseTypeDivisionMode = COUNT(*) FROM tbl_costs with(nolock)
			WHERE	CS_TYPEDIVISION > 0 AND
					CS_SVKey = @svKey and CS_Code = @code and CS_SubCode1 = @code1 and CS_SubCode2 = @code2 and 
					CS_PrKey = @prKey and CS_PkKey = @packetKey
					and ((@date between CS_CheckInDateBEG and CS_CheckInDateEnd) or (CS_CheckInDateBEG is null)) 
					and (CS_DateEnd >= @date and CS_DATE < @date+isnull(@days,0) or CS_DATE IS NULL) 
	END
	-- Если есть разделение цен на НЕТТО и БРУТТО
	IF @UseTypeDivisionMode is not null and @UseTypeDivisionMode > 0
	BEGIN
		SET @UseTypeDivisionMode = 2
		SET @TypeDivision = 1
	END
	ELSE
	BEGIN
		SET @UseTypeDivisionMode = 0	-- там и так ноль, но для наглядности
		SET @TypeDivision = 0
	END
	
		
	WHILE @TypeDivision <= @UseTypeDivisionMode
	BEGIN
	--	ENDREGION	MEG00015352 2008-02-22 Разделение цен на НЕТТО и БРУТТО
		
		if @UseTypeDivisionMode > 0
			declare costCursor cursor local fast_forward for
			select 
			CS_DATE, CS_DATEEND, CS_WEEK, CS_COSTNETTO, CAST(CS_COST as decimal(14,2)),
			CS_DISCOUNT, isnull(CS_TYPE,0), CS_RATE, CS_LONGMIN, CS_LONG,
			CS_BYDAY, CS_PROFIT, CS_ID, CS_CheckInDateBEG, CS_CheckInDateEND, 
			ISNULL(CS_DateSellBeg, '19000101'), ISNULL(CS_DateSellEnd, '99980101')
				from tbl_costs with(nolock)           
				WHERE	CS_SVKey = @svKey and CS_Code = @code and CS_SubCode1 = @code1 and CS_SubCode2 = @code2 and 
					    CS_PrKey = @prKey and CS_PkKey = @packetKey
					--	and (CS_CheckInDateEnd >= @date or CS_CheckInDateEnd is null)
						and ((@date between CS_CheckInDateBEG and CS_CheckInDateEnd) or (CS_CheckInDateBEG is null and CS_CheckInDateEnd is null)) 
					    and (CS_DateEnd >= @date and CS_DATE <= @date+isnull(@days,0) or (CS_DATE is null and CS_DateEnd is null))
		            --    and ((GetDate() between CS_DateSellBeg and CS_DateSellEnd) or (CS_DateSellBeg is null))
						and (CS_TYPEDIVISION IN (0,@TypeDivision) OR CS_TYPEDIVISION IS NULL)	-- отбираем цены только определенного типа при использовании режима разделения цен (брутто или нетто)
			    ORDER BY
						CS_CheckInDateBEG Desc, CS_CheckInDateEnd, CS_Date Desc, CS_DATEEND, CS_LONGMIN desc, 
						CS_LONG, CS_DateSellBeg Desc, CS_DateSellEnd, CS_BYDAY,	CS_WEEK ASC
		else if (@newReCalculatePrice = 1)
			declare costCursor cursor local fast_forward for
			select 
			CS_DATE, CS_DATEEND, CS_WEEK, CS_COSTNETTO, CAST(CS_COST as decimal(14,2)),
			CS_DISCOUNT, isnull(CS_TYPE,0), CS_RATE, CS_LONGMIN, CS_LONG,
			CS_BYDAY, 0 /* т.к. профиты конвертнулись в AddCosts */, CS_ID, CS_CheckInDateBEG, CS_CheckInDateEND, 
			ISNULL(CO_SaleDateBeg, '1900-01-01'), ISNULL(CO_SaleDateEnd, '2072-01-01')
				from tbl_costs with(nolock) join CostOffers with(nolock) on CS_COID = CO_Id
				join Seasons with(nolock) on CO_SeasonId = SN_Id
				WHERE	isnull(SN_IsActive, 0) = 1
						-- проверим активность костофера на нужную нам дату продажи
						and ((@sellDate is null and CO_State = 1) 
							or (CO_State in (1,2) and @sellDate is not null and @sellDate between isnull(CO_DateActive, '1900-01-01') and isnull(CO_DateClose, '2072-01-01')))
						-- проверим период продажи ценового блока
						and isnull(@sellDate, getdate()) between isnull(CO_SaleDateBeg, '1900-01-01') and isnull(CO_SaleDateEnd, '2072-01-01')
						and CS_SVKey = @svKey
						and CS_Code = @code
						and CS_SubCode1 = @code1
						and CS_SubCode2 = @code2
						and CS_PrKey = @prKey
						and CS_PkKey = @packetKey
						and @date between isnull(CS_CheckInDateBEG, '1900-01-01') and isnull(CS_CheckInDateEnd, '2072-01-01')
						-- либо дата начала услуги лежит между началом и концом цены,
						-- либо дата начала цены лежит между датой начала и концом услуги
						and (CS_DATE is null 
								or @date between CS_DATE and CS_DATEEND
								or CS_DATE between @date and dateadd(dd, isnull(@days,0), @date))
				ORDER BY
						-- если не задана дата продажи то смотрим по текущему полю последней даты активации
						-- иначе смотрим по истории активации
						isnull(CO_DateActive,'1900-01-01') desc,
						CS_CheckInDateBEG Desc, CS_CheckInDateEnd, CS_Date Desc, CS_DATEEND, CS_LONGMIN desc, 
						CS_LONG, CS_DateSellBeg Desc, CS_DateSellEnd, CS_BYDAY,	CS_WEEK ASC
		else
			declare costCursor cursor local fast_forward for
			select
			CS_DATE, CS_DATEEND, CS_WEEK, CS_COSTNETTO, CAST(CS_COST as decimal(14,2)),
			CS_DISCOUNT, isnull(CS_TYPE,0), CS_RATE, CS_LONGMIN, CS_LONG,
			CS_BYDAY, CS_PROFIT, CS_ID, CS_CheckInDateBEG, CS_CheckInDateEND,
			ISNULL(CS_DateSellBeg, '19000101'), ISNULL(CS_DateSellEnd, '99980101')
				from tbl_costs with(nolock)
				WHERE	CS_SVKey = @svKey and CS_Code = @code and CS_SubCode1 = @code1 and CS_SubCode2 = @code2 and
					    CS_PrKey = @prKey and CS_PkKey = @packetKey
						and ((@date between CS_CheckInDateBEG and CS_CheckInDateEnd) or (CS_CheckInDateBEG is null and CS_CheckInDateEnd is null))
					    and (CS_DateEnd >= @date and CS_DATE <= @date+isnull(@days,0) or (CS_DATE is null and CS_DateEnd is null))
			    ORDER BY
						CS_CheckInDateBEG Desc, CS_CheckInDateEnd, CS_Date Desc, CS_DATEEND, CS_LONGMIN desc,
						CS_LONG, CS_DateSellBeg Desc, CS_DateSellEnd, CS_BYDAY,	CS_WEEK ASC				

	Set @sellDate = ISNULL(@sellDate,GetDate())
	open costCursor
	set @nCostByDayExists = 0

	fetch next from costCursor 
		into	@CS_Date, @CS_DateEnd, @CS_Week, @CS_CostNetto, @CS_Cost, 
				@CS_Discount, @CS_Type, @CS_Rate, @CS_LongMin, @CS_Long, 
				@CS_ByDay, @CS_Profit, @CS_ID, @CS_CheckInDateBEG, @CS_CheckInDateEND, @CS_DateSellBeg, @CS_DateSellEnd

		If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
		BEGIN
			If @@fetch_status = 0
			BEGIN

				declare @TMPTable Table 
 				( CL_Date datetime,
				CL_CostNetto decimal(14,6),
				CL_Cost decimal(14,6),
				CL_Discount smallint,
				CL_Type smallint,
				CL_Rate varchar(2),
				CL_Course decimal(14,6),
				CL_Pax smallint default 1,
				CL_ByDay smallint,
				CL_Part smallint,
				CL_Profit decimal(14,6))

				DECLARE @temp_date DATETIME
				SET @temp_date = @date + @days - 1

				while @temp_date >= @date 
				BEGIN -- begin while @temp_date >= @date 
					insert into @TMPTable (CL_Date, CL_ByDay) values (@temp_date, -1 )
					set @temp_date = @temp_date - 1 
				END  -- end while @temp_date >= @date 
			END
			Else
			BEGIN
				close costCursor
				deallocate costCursor
				return 0
			END

			set @COST_ID = 1 --идетификатор уникальности цены
			If @CS_ByDay = 2
				Set @nCostByDayExists = 1

			If @CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) --or (@CS_ByDay = 0 and @days = 0)
				insert into @TMPTable (CL_Date, CL_ByDay) values (@date + @days, -1 )
		END

		set @NotCalculatedCosts = 1
		set @FindCostByPeriod = 0   --переменная контролирует поиск цены за период, точно совпадающий с периодом предоставления услуги

	While (@@fetch_status = 0) and (@NotCalculatedCosts > 0 or @FindCostByPeriod > 0)  --цены уже могут быть найдены на все даты, но возможно где-то еще есть цена на период...
	BEGIN -- While (@@fetch_status = 0)
		-- подправим продолжительность цены, чтобы было проще искать по периодам и по неделям
		Set @IsFetchNormal = 1
			-- если не указаны даты периодов, то значит указаны даты заедов
			-- в этом случае "дни недели", подразумевают дни заездов, и действуют все дни из периодов]

		If	@CS_CheckInDateBEG is not null and @CS_Date is null and @CS_Week is not null and @CS_Week != ''
			if CHARINDEX ( @WeekDate, @CS_Week ) = 0
				Set @IsFetchNormal = 0
			Else
				Set @CS_Week = ''

		If @tourlong > 0 and @svKey = 1
		Begin		
			If (@CS_LongMin is null or @tourlong >= @CS_LongMin) and (@CS_Long is null or @tourlong <= @CS_Long)
				Set @IsFetchNormal = @IsFetchNormal
			else
				Set @IsFetchNormal = 0
		end     

		If @svKey != 1
		begin
			If @CS_LongMin is not null and @CS_LongMin > @days
				Set @IsFetchNormal = 0
		end

		-- Если время не задано, то увеличиваем период продажи на один день. Иначе, смотрим точный период.
		If DATEPART(hour, @CS_DateSellEnd)+DATEPART(minute, @CS_DateSellEnd) = 0
			Set @CS_DateSellEnd = @CS_DateSellEnd + 1
		-- При переходе с 5.2 возможны цены с периодом продаж оганиченном только с одной стороны.
		If (@sellDate between ISNULL(@CS_DateSellBeg, @sellDate - 1) and ISNULL(@CS_DateSellEnd, @sellDate + 1))
			Set @IsFetchNormal = @IsFetchNormal 
		else
			Set @IsFetchNormal = 0
			
		if (@svKey = 3 or @svKey = 8)
			set @serviceEndDate = @date + @days - 1
		else
			set @serviceEndDate = @date + @days

		If @FindCostByPeriod = 1 and ((@days between @CS_LongMin and @CS_Long) or @CS_Long is null) and @CS_DateEnd = @serviceEndDate -- смотрим может есть цена за период точно совпадает с периодом действия услуги
			Update @TMPTable Set CL_CostNetto = null, CL_Cost = null, CL_Discount = null, CL_Type = null, 
				CL_Rate = null, CL_Course = null, CL_Pax = 1, CL_ByDay =-1, CL_Part = null, CL_Profit = null

	--	If @CS_ByDay = 1 and @CS_Long is not null and @CS_Long < @days
	--		Set @IsFetchNormal = 0
		If @CS_Week != '' and (@days = 0 or (@days = 1 and (@CS_ByDay != 2 or (@svKey!=3 and @svKey!=8) ) ) )
		BEGIN
			If CHARINDEX ( @WeekDate, @CS_Week ) > 0
				Set @IsFetchNormal = @IsFetchNormal 
			Else
				Set @IsFetchNormal = 0
		END

		If @Days = 1 and @CS_Date > @date
			Set @IsFetchNormal = 0

		If @Days = 1 and @CS_ByDay in (3,4)
			Set @IsFetchNormal = 0

	--ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! 
	--ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! ВНИМАНИЕ!!!! 
	/*
		If 	@CS_CheckInDateBEG is not null
		BEGIN
			Set @CS_Date = null
			Set @CS_DateEnd = null
		END
	*/
			If (@days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)) and @IsFetchNormal = 1 	-- fetch нам подходит
			BEGIN			--цены подходят для поиска
				Set @CS_Date = (isnull(@CS_Date,@date))
				Set @CS_DateEnd = isnull(@CS_DateEnd,@date+ISNULL(@CS_Long,@LONG_MAX))

				If @nCostByDayExists = 0 and @CS_ByDay = 2 and (@svKey = 3 or @svKey = 8)
				BEGIN
					update @TMPTable Set CL_CostNetto = null, CL_Cost = null, CL_Discount = null, CL_Type = null, 
							CL_Rate = null, CL_Course = null, CL_Pax = 1, CL_ByDay =-1, CL_Part = null, CL_Profit = null
					if not exists (select * from @TMPTable where CL_Date = @date + @days)
						insert into @TMPTable (CL_Date, CL_ByDay) values (@date + @days, -1 )
					Set @nCostByDayExists = 1	
				END

				if @CS_Date < @date
					Set @CS_Date = @date
				if @CS_DateEnd > @date + @days
					Set @CS_DateEnd = @date + @days
				Set @CS_Discount = ISNULL(@CS_Discount,0)
				Set @TMP_Number_Period = null

				if @CS_ByDay = 3 and (@nCostByDayExists = 0 or (@svKey != 3 and @svKey != 8)) -- если цена за неделю
				BEGIN -- if @CS_ByDay = 3
					if (@CS_DateEnd - @CS_Date + 1) >= 7 and ((@days between @CS_LongMin and @CS_Long) or @CS_Long is null)
					BEGIN
						select @TMP_Number = count(*), @TMP_Date = MIN(CL_Date) from @TMPTable Where CL_Date between @CS_Date and @CS_DateEnd and CL_ByDay in (-1,1,4)
						while @TMP_Number >= 7
						BEGIN
							UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID, 
								CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, 
								CL_Pax = 1, CL_Profit = @CS_Profit
								WHERE CL_DATE between @TMP_Date and @TMP_Date + 6  and CL_ByDay  in (-1,1,4)
		
							UPDATE @TMPTable SET CL_Pax = 0 WHERE CL_DATE != @TMP_Date and CL_Part = @COST_ID
							SET @TMP_Number = @TMP_Number - 7
							SET @TMP_Date = @TMP_Date + 7
							SET @COST_ID = @COST_ID + 1
						END
					END
				END	-- if @CS_ByDay = 3

		--		print 'поиск'
				if @CS_ByDay = 0 and (@nCostByDayExists = 0 or (@svKey != 3 and @svKey != 8)) -- если цена за период
				BEGIN -- if @CS_ByDay = 0
		--			print 'период'
					select @TMP_Number = count(*), @TMP_Date = MIN(CL_Date) from @TMPTable 
						Where	CL_Date between @CS_Date and @CS_DateEnd and CL_ByDay != 3 and CL_ByDay != 0

					if @CS_Date < @TMP_Date and @date < @TMP_Date
					BEGIN
						select @TMP_Number_Period = CL_Part from @TMPTable where CL_Date = @TMP_Date - 1 and CL_ByDay = 0
				--		print @TMP_Number_Period
						if @TMP_Number_Period is not null
						BEGIN					
							select @TMP_Date_Period = MIN(CL_Date) from @TMPTable where CL_Part = @TMP_Number_Period
							if @CS_Date <= @TMP_Date_Period and (@CS_Long is null or @CS_Long > DATEDIFF(DAY,@TMP_Date_Period,@TMP_Date + @TMP_Number)) and (@CS_LongMin is null or @CS_LongMin <= DATEDIFF(DAY,@TMP_Date_Period,@TMP_Date + @TMP_Number))
							BEGIN
								select @TMP_Number = count(*), @TMP_Date = MIN(CL_Date) from @TMPTable 
									Where	CL_Date between @CS_Date and @CS_DateEnd and CL_ByDay != 3 and (CL_ByDay != 0 or CL_Part = @TMP_Number_Period)					
							END
						END
						Set @TMP_Number_Period = null
					END

					if @CS_Long is null or @CS_Long > @TMP_Number
					BEGIN
						--если предыдущий период захватывается полностью, то его надо включить
						--это делается только в случае, если цену указана за период
				--		print @TMP_Date + @TMP_Number
						select @TMP_Number_Period = CL_Part from @TMPTable where CL_Date = @TMP_Date + @TMP_Number and CL_ByDay = 0
			--			print @TMP_Number_Period
						if @TMP_Number_Period is not null
						BEGIN 
							select @TMP_Date_Period = MAX(CL_Date) from @TMPTable where CL_Part = @TMP_Number_Period
		--					print @TMP_Date_Period
							if (@CS_Long is null or @CS_Long > DATEDIFF(DAY,@TMP_Date,@TMP_Date_Period + 1)) and (@CS_LongMin is null or @CS_LongMin <= DATEDIFF(DAY,@TMP_Date,@TMP_Date_Period + 1)) and @TMP_Date_Period <= @CS_DateEnd
								Set @TMP_Number = DATEDIFF(DAY,@TMP_Date,@TMP_Date_Period) + 1
						END
					END

					--mv 06.02.2012 (MEG00040397) Сделал проверку только НЕ для а/п
					If @svKey != 1
					begin
						if @CS_Long is not null and @CS_Long < @TMP_Number
							set @TMP_Number = @CS_Long
					end

					--mv 06.02.2012 (MEG00040397) отдельная проверка на продолжительность а/п
					if @CS_LongMin is null or @CS_LongMin <= @TMP_Number 
						or (@svKey=1 and (@CS_LongMin is null or @tourDays >= @CS_LongMin) and (@CS_Long is null or @tourDays <= @CS_Long))
					BEGIN
						UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID, 
							CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, 
							CL_Pax = 1, CL_Profit = @CS_Profit
							WHERE CL_DATE between @TMP_Date and @TMP_Date + @TMP_Number - 1 and CL_ByDay != 3
						UPDATE @TMPTable SET CL_Pax = 0 WHERE CL_DATE != @TMP_Date and CL_Part = @COST_ID
						SET @COST_ID = @COST_ID + 1
					END
				END	-- if @CS_ByDay = 0
		
				if (@CS_ByDay = 1 and @nCostByDayExists = 0) or (@CS_ByDay = 2 and @nCostByDayExists = 1) or ((@svKey != 3 and @svKey != 8) and @CS_ByDay in (1,2))  -- если цена за ночь / день
				BEGIN -- if @CS_ByDay = 1/2
					if @CS_DateEnd > @date + @CS_Long - 1		-- если дата окончания цены действует в паре с продолжительностью
						Set @CS_DateEnd = @date + @CS_Long - 1
					if 1=1 -- временная заглушка, 
					BEGIN  -- если Цена удовлетворяет условиям
						SET @DayOfWeeks = @CS_Week
						While exists (select TOP 1 CL_Part from @TMPTable where CL_ByDay = 0 group by CL_Part having MIN(CL_Date) >= @CS_Date and MAX(CL_Date) <= @CS_DateEnd)
						BEGIN
							select TOP 1 @TMP_Number = CL_Part from @TMPTable where CL_ByDay = 0 group by CL_Part having MIN(CL_Date) >= @CS_Date and MAX(CL_Date) <= @CS_DateEnd
							update @TMPTable Set CL_CostNetto = null, CL_Cost = null, CL_Discount = null, CL_Type = null, 
								CL_Rate = null, CL_Course = null, CL_Pax = 1, CL_ByDay =-1, CL_Part = null, CL_Profit = null
								Where CL_Part = @TMP_Number
						END				

						IF @DayOfWeeks = ''
							UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
								CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, CL_Profit = @CS_Profit, CL_Course = ISNULL(@CS_Long,@LONG_MAX)
								WHERE CL_DATE between @CS_Date and @CS_DateEnd 
								and (CL_ByDay in (-1,4) or (@CS_CheckInDateBEG is not null and CL_ByDay in (-1,1,2,4) and exists(select 1 from @TMPTable where CL_ByDay in (-1,4) and CL_Date = @date)) or (CL_ByDay in (1,2) and CL_Course < ISNULL(@CS_Long,@LONG_MAX)))
						ELSE
							UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
								CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate, CL_Profit = @CS_Profit, CL_Course = ISNULL(@CS_Long,@LONG_MAX)
								WHERE CL_DATE between @CS_Date and @CS_DateEnd 
								and (CL_ByDay in (-1,4) or (@CS_CheckInDateBEG is not null and CL_ByDay in (-1,1,2,4) and exists(select 1 from @TMPTable where CL_ByDay in (-1,4) and CL_Date = @date)) or (CL_ByDay in (1,2) and CL_Course < ISNULL(@CS_Long,@LONG_MAX))) AND CHARINDEX(CAST(DATEPART (weekday, CL_DATE) as varchar(1)),@DayOfWeeks) > 0

						SET @COST_ID = @COST_ID + 1
					END   -- если Цена удовлетворяет условиям
				END	-- if @CS_ByDay = 1

				if @CS_ByDay = 4 --and @nCostByDayExists = 0 -- если цена за доп.ночь
				BEGIN -- if @CS_ByDay = 4
					if @CS_DateEnd > @date + @CS_Long - 1		-- если дата окончания цены действует в паре с продолжительностью
						Set @CS_DateEnd = @date + @CS_Long - 1

					SET @DayOfWeeks = ''
					Set @CS_Week = REPLACE(@CS_Week,'.','');

					if @CS_Week != ''
					BEGIN			
						Set @TMP_Number = 1
						Set @DayOfWeeks = LEFT(@CS_Week,1)
						while @TMP_Number < LEN(@CS_Week)
						BEGIN
							Set @TMP_Number = @TMP_Number + 1
							Set @DayOfWeeks = @DayOfWeeks + ',' + SUBSTRING(@CS_Week, @TMP_Number, 1)				
						END
					END
					
					-- доп.ночи могут только добивать в конец, первый день точно не к ним
					If @CS_Date = @date
						Set @CS_Date = @CS_Date + 1

					IF @DayOfWeeks = ''
						UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
							CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate
							WHERE	CL_DATE between @CS_Date and @CS_DateEnd /*and (CL_ByDay = -1)*/
					ELSE
						UPDATE @TMPTable SET CL_CostNetto = @CS_CostNetto, CL_ByDay = @CS_ByDay, CL_Part = @COST_ID,
							CL_Cost = @CS_Cost, CL_Discount = (CASE WHEN @CS_Discount=1 THEN 1 ELSE null END), CL_Type = @CS_Type, CL_Rate = @CS_Rate
							WHERE	CL_DATE between @CS_Date and @CS_DateEnd /*and (CL_ByDay = -1)*/ AND CHARINDEX(CAST(DATEPART (weekday, CL_DATE) as varchar(1)),@DayOfWeeks) > 0
					SET @COST_ID = @COST_ID + 1
				END	-- if @CS_ByDay = 4
				select @NotCalculatedCosts = Count(*) from @TMPTable where CL_CostNetto is null
			END -- цены подходят для поиска и есть продолжительность
			ELSE
				If @IsFetchNormal = 1
					Set @NotCalculatedCosts = 0

		-- мы уже нашли цену на период, это 11-я версия
		-- да, может быть у нас остались более приоритетные цены на период, но в 11-ой версии это маловериятно
		-- для более ранних версий поведение не меняется
		If @NotCalculatedCosts = 0 and @CS_ByDay = 0 and @newReCalculatePrice = 1
			Set @FindCostByPeriod = 0
		else If (@days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)) or @IsFetchNormal = 0
		BEGIN
			fetch next from costCursor 
				into	@CS_Date, @CS_DateEnd, @CS_Week, @CS_CostNetto, @CS_Cost, 
						@CS_Discount, @CS_Type, @CS_Rate, @CS_LongMin, @CS_Long, 
						@CS_ByDay, @CS_Profit, @CS_ID, @CS_CheckInDateBEG, @CS_CheckInDateEND, @CS_DateSellBeg, @CS_DateSellEnd

			If @CS_ByDay = 0 and @CS_Date = @date and @CS_DateEnd <= (@date + @days) and @days > 1 and (@sellDate between ISNULL(@CS_DateSellBeg, @sellDate - 1) and ISNULL(@CS_DateSellEnd, @sellDate + 1))
				Set @FindCostByPeriod = 1  -- отметка, что может быть эта цена за период, нам супер подойдет
			Else
				Set @FindCostByPeriod = 0
		END
	END -- While (@@fetch_status = 0)
	close costCursor
	deallocate costCursor


if @NotCalculatedCosts > 0
BEGIN
--	delete from @TMPTable
	if @bSPUpdate = 1
		delete from dbo.ServicePrices where SP_ID = @nSPId	
	return 0
END

If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
BEGIN
	Update @TMPTable set CL_Course = null
	Update @TMPTable set CL_Course = 1 Where CL_Rate = @resRate
	Update @TMPTable set CL_Course = 0 Where CL_CostNetto = 0 and ISNULL(CL_Cost,0) = 0 and ISNULL(CL_Profit,0) = 0

	set @TMP_Rate = null
	SELECT TOP 1 @TMP_Rate = CL_Rate from @TMPTable where CL_Course is null

	while @TMP_Rate is not null
	BEGIN
		Set @course = 1
		exec ExchangeCost @course output, @TMP_Rate, @resRate, @date
		if (@course is null) 
		begin 
			set @sBadRate=@TMP_Rate
			set @dtBadDate =@date
			--print 'нет курса между ' + ISNULL(@TMP_Rate,'NULL') + ' и ' + ISNULL(@resRate,'NULL') + ' на ' + CAST(@dtBadDate as varchar(12))
			if @bSPUpdate = 1
				delete from dbo.ServicePrices where SP_ID = @nSPId	
			return 0 		
		end 
		Update @TMPTable set CL_Course = @course Where CL_Rate = @TMP_Rate

		set @TMP_Rate = null
		SELECT TOP 1 @TMP_Rate = CL_Rate from @TMPTable where CL_Course is null
	END
end
else
BEGIN
	set @course=1
	If @CS_CostNetto = 0 and ISNULL(@CS_Cost,0) = 0 and ISNULL(@CS_Profit,0) = 0
		set @course = 0
	Else IF (@CS_Rate<>@resRate)
		exec ExchangeCost @course output, @CS_Rate, @resRate, @date             

	if (@course is null) 
	begin 
		set @sBadRate = @CS_Rate
		set @dtBadDate = @date
		--print 'нет курса между ' + ISNULL(@TMP_Rate,'NULL') + ' и ' + ISNULL(@resRate,'NULL') + ' на ' + CAST(@dtBadDate as varchar(12))
		--delete from @TMPTable
		if @bSPUpdate = 1
			delete from dbo.ServicePrices where SP_ID = @nSPId	
		return 0 		
	end 			
END

--select * from TMP
If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
	Update @TMPTable set CL_Pax = CL_Pax * @men Where CL_Type = 0
else
	If (isnull(@CS_Type, 0) = 0)
		Set @CS_Pax = @men
	Else
		Set @CS_Pax = 1

--Update @TMP set CL_Course = 0 Where CL_ByDay not in (0,3) and CL_DateFirst != CL_Date
--Update @TMP set CL_Course = CL_Course*(@margin + 100)/100 Where CL_Discount + (1- @marginType) != 0
If @days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)
BEGIN	
	update @TMPTable set CL_Profit = 0 where CL_Date != @date
	if not exists (Select * from @TMPTable where CL_Cost is null)
		select	@brutto = SUM((CL_Cost + ISNULL(CL_Profit,0)) * CL_Course * CL_Pax),
				@discount = SUM((CL_Cost + ISNULL(CL_Profit,0)) * CL_Course * CL_Pax * CL_Discount) 
		from @TMPTable
	select	@netto = SUM(CL_CostNetto * CL_Course * CL_Pax) from @TMPTable
--	select	@profitValue = ISNULL(CL_Profit * CL_Course * CL_Pax * CL_Margin,0) from @TMPTable where CL_Date = @date
--	select	@profitValue = CL_Profit from @TMPTable where CL_Date = @date
	set @useDiscountDays = (select SUM(ISNULL(CL_Discount,0)) from @TMPTable)
	
END
else
BEGIN
	set @brutto = (@CS_Cost + ISNULL(@CS_Profit,0)) * @course * @CS_Pax
	set @discount = (@CS_Cost + ISNULL(@CS_Profit,0)) * @course * @CS_Pax * @CS_Discount
	set @netto = @CS_CostNetto * @course * @CS_Pax 
	set @useDiscountDays = @CS_Discount
--	set @profitValue = @CS_Profit * @course * @CS_Pax * @CS_Margin
END

/*
Новый код!!!!!!
НАЧАЛО
*/
If @sUseServicePrices = '1'
BEGIN
		if @bSPUpdate = 1
			update	dbo.ServicePrices 
					set	SP_Cost = @netto, SP_Price = @brutto, SP_PriceWithCommission = ISNULL(@discount,0)
			where SP_ID = @nSPId	
		else
		begin
			insert into dbo.ServicePrices (SP_SVKey, SP_Code, SP_SubCode1, SP_SubCode2, SP_PRKey,
				SP_PKKey, SP_Long, SP_Date, SP_Pax, SP_Cost, 
				SP_Price, SP_PriceWithCommission, SP_RateKey)
			values (@svKey, @code, @code1, @code2, @prKey,
				@packetKey, @days, @date, @men, @netto,
				@brutto, ISNULL(@discount,0), @rakey )
			Set @nSPId = SCOPE_IDENTITY()
		end
	END

--	REGION		MEG00015352 2008-02-22 Разделение цен на НЕТТО и БРУТТО		
		IF		(@TypeDivision = 1)	-- Если производили расчет по ценам НЕТТО
			BEGIN
				SET @RealNetto = @netto -- Фиксируем НЕТТО
				DELETE FROM @TMPTable	-- Подчищаем за собой для следующей итерации
			END
		ELSE IF	(@TypeDivision = 2)	-- Если производили расчет по ценам БРУТТО
			BEGIN
				SET @netto = @RealNetto	-- Восстанавливаем НЕТТО
			END
		SET @TypeDivision = @TypeDivision + 1
	END -- WHILE @TypeDivision <= @UseTypeDivisionMode
--	ENDREGION	MEG00015352 2008-02-22 Разделение цен на НЕТТО и БРУТТО

END -- Это конец основного блока !!!!!!!!!
/*
Новый код!!!!!!
КОНЕЦ
*/

--@discount на данный момент хранит сумму, с которой надо давать скидку
declare @sum_with_commission decimal(18,2)
set @sum_with_commission = @discount

/*Посчитаем доплату*/
if (@includeAddCost = 1 and @newReCalculatePrice = 1)
begin
	declare @addCostValueIsCommission money, @addCostValueNoCommission money, @addCostFromAdult money, @addCostFromChild money, @addCostRate nvarchar(2)
	--print @tourKey
	exec GetServiceAddCosts @tourKey, @svKey, @code, @code1, @code2, @prKey, @tourDate, @tourDays, @days, @men, @sellDate, null, @addCostValueIsCommission output, @addCostValueNoCommission output, @addCostFromAdult output, @addCostFromChild output, @addCostRate output
	/*
	print @addCostValueIsCommission
	print @addCostValueNoCommission
	*/
	--конвертируем доплаты в валюту расчета из валюты тура (в которой они задавались)
	If @addCostValueIsCommission is not null
		exec ExchangeCost @addCostValueIsCommission output, @addCostRate, @resRate, @date
	If @addCostValueNoCommission is not null
		exec ExchangeCost @addCostValueNoCommission output, @addCostRate, @resRate, @date
	
	if @addCostValueIsCommission is not null
		set @sum_with_commission = isnull(@sum_with_commission,0) + isnull(@addCostValueIsCommission, 0)
	set @brutto = @brutto + isnull(@addCostValueIsCommission, 0) + isnull(@addCostValueNoCommission, 0)
end

If @marginType = 0 -- даем наценку, вне зависмости от наличия комиссии по услуге
	Set @brutto = ISNULL(@brutto,0) * (100 + @margin) / 100 
Else -- даем наценку, только при наличии комиссии
	Set @brutto = ISNULL(@brutto,0) - ISNULL(@sum_with_commission,0) + ISNULL(@sum_with_commission,0) * (100 + @margin) / 100 

--теперь @discount это именно сумма скидки
Set @discount = @sum_with_commission * ((100 + @margin) / 100) * @discountPercent / 100

exec RoundCost @brutto output, 1

Set @brutto = ISNULL(@brutto,0) - ISNULL(@discount,0)

if (@newReCalculatePrice = 0)
begin
	DECLARE @TMP_Number_Course decimal(12,4), @TMP_Number_Part INT, @TMP_Number_Pax int
	DECLARE @TMP_Number_CostNetto decimal(12,2), @TMP_Number_Cost decimal(12,2)

	If (@days > 1 or (@CS_ByDay = 2 and (@svKey = 3 or @svKey = 8) and @days=1)) and @nSPId is null    -- Новый код !!!!!  and @useServicePrices is null
	BEGIN
		set @nettoDetail = '='
		set @sDetailed = '='
		while exists (select * from @TMPTable where CL_Course != 0)
		begin
			SELECT TOP 1	@CS_Date = CL_Date, @TMP_Number_CostNetto = CL_CostNetto, @TMP_Number_Cost = CL_Cost, @TMP_Number_Course = CL_Course, 
							@TMP_Number_Part = CL_Part, @TMP_Number_Pax = CL_Pax
			from			@TMPTable 
			where			CL_Course != 0	 
			Order By		CL_Date

			Set @TMP_Number = 0
			Select @TMP_Number = Count(*) from @TMPTable where CL_Part = @TMP_Number_Part and CL_Pax != 0
			UPDATE @TMPTable SET CL_Course = 0 WHERE ISNULL(CL_Part, 0) = ISNULL(@TMP_Number_Part, 0)
			if @nettoDetail != '='
				Set @nettoDetail = @nettoDetail + ' +'
			if @sDetailed != '='
				Set @sDetailed = @sDetailed + ' +'

			Set @nettoDetail = @nettoDetail + CAST(@TMP_Number_CostNetto as varchar(15)) 
			Set @sDetailed = @sDetailed + CAST(@TMP_Number_Cost as varchar(15)) 

			if @TMP_Number != 1
			begin
				Set @nettoDetail = @nettoDetail + '*' + CAST(@TMP_Number as varchar(15)) 
				Set @sDetailed = @sDetailed + '*' + CAST(@TMP_Number as varchar(15)) 
			end

			if @TMP_Number_Pax != 1
			begin
				Set @nettoDetail = @nettoDetail + '*' + CAST(@TMP_Number_Pax as varchar(15))
				Set @sDetailed = @sDetailed + '*' + CAST(@TMP_Number_Pax as varchar(15))
			end

			if @TMP_Number_Course != 1
			begin
				Set @nettoDetail = @nettoDetail + '*' + CAST(@TMP_Number_Course as varchar(15)) 
				Set @sDetailed = @sDetailed + '*' + CAST(@TMP_Number_Course as varchar(15)) 
			end
		end

		If ISNULL(@profitValue,0) > 0
			Set @sDetailed = @sDetailed + ' +' + CAST(@profitValue as varchar(15)) 

		if @marginCalcValue > 0
			Set @sDetailed = @sDetailed + '+' + CAST(@marginCalcValue as varchar(15)) 

		If ISNULL(@discount,0) > 0
			Set @sDetailed = @sDetailed + ' -' + CAST(@discount as varchar(15)) 
	END
end
GO

grant exec on [dbo].[GetServiceCost] to public
go
/*********************************************************************/
/* end sp_GetServiceCost.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetServiceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetServiceList]
GO

CREATE procedure [dbo].[GetServiceList] 
(
--<VERSION>2009.2.18.2</VERSION>
--<DATE>2013-10-29</DATE>
@TypeOfRelult int, -- 1-список по по услугам, 2-список по туристам на услуге
@SVKey int, 
@Codes varchar(100), 
@SubCode1 int=null,
@Date datetime =null, 
@QDID int =null,
@QPID int =null,
@ShowHotels bit =null,
@ShowFligthDep bit =null,
@ShowDescription bit =null,
@State smallint=null,
@SubCode2 int = null
)
as 

--koshelev
--2012-07-19 TFS 6699 блокировки на базе мешали выполнению хранимки, вынужденная мера
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

declare @Query varchar(8000)
 
CREATE TABLE #Result
(
	DG_Code nvarchar(max), DG_Key int, DG_DiscountSum money, DG_Price money, DG_Payed money,
	DG_PriceToPay money, DG_Rate nvarchar(3), DG_NMen int, PR_Name nvarchar(max), PR_Name_Lat nvarchar(max), CR_Name nvarchar(max), CR_Name_Lat nvarchar(max),
	DL_Key int, DL_NDays int, DL_NMen int, DL_Reserved int, DL_CTKeyTo int, DL_CTKeyFrom int, DL_CNKEYFROM int,
	DL_SubCode1 int, TL_Key int, TL_Name nvarchar(max), TL_Name_Lat nvarchar(max),  TUCount int, TU_NameRus nvarchar(max), TU_NameLat nvarchar(max),
	TU_FNameRus nvarchar(max), TU_FNameLat nvarchar(max), TU_Key int, TU_Sex Smallint, TU_PasportNum nvarchar(max),
	TU_PasportType nvarchar(max), TU_PasportDateEnd datetime, TU_BirthDay datetime, TU_Hotels nvarchar(max), TU_Hotels_Lat nvarchar(max),
	Request smallint, Commitment smallint, Allotment smallint, Ok smallint, TicketNumber nvarchar(max),
	FlightDepDLKey int, FligthDepDate datetime, FlightDepNumber nvarchar(max), ServiceDescription nvarchar(max), ServiceDescription_Lat nvarchar(max),
	ServiceDateBeg datetime, ServiceDateEnd datetime, RM_Name nvarchar(max), RC_Name nvarchar(max), SD_RLID int,
	TU_SNAMERUS nvarchar(max), TU_SNAMELAT nvarchar(max), TU_IDKEY int
)
 
if @TypeOfRelult = 2
begin
	--- создаем таблицу в которой пронумируем незаполненых туристов
	CREATE TABLE #TempServiceByDate
	(
		SD_ID int identity(1,1) not null,
		SD_Date datetime,
		SD_DLKey int,
		SD_RLID int,
		SD_QPID int,
		SD_TUKey int,
		SD_RPID int,
		SD_State int
	)

	-- вносим все записи которые нам могут подойти
	insert into #TempServiceByDate(SD_Date, SD_DLKey, SD_RLID, SD_QPID,	SD_TUKey, SD_RPID, SD_State)
	select SD_Date, SD_DLKey, SD_RLID, SD_QPID,	SD_TUKey, SD_RPID, SD_State
	from ServiceByDate as SSD join Dogovorlist on DL_KEY = SD_DLKey
	where DL_SVKEY = @SVKey
	and DL_CODE = convert(int, @Codes)
	and ((@SubCode1 is null) or (DL_SUBCODE1 = @SubCode1))
	and ((@QPID is null) or (SD_QPID = @QPID))
	and ((@State is null) or (SD_State = @State))
	--mv 24.10.2012 не понячл зачем нужен был подзапрос, но точно он приводил к следущей проблеме
	-- если отбираем с фильтром по статусу, то статус проверял на любой из дней, а не тот на который формируется список
	and SSD.SD_Date = @Date
	--and exists (select 1 from ServiceByDate as SSD2 where SSD.SD_DLKey = SSD2.SD_DLKey and SSD2.SD_Date = @Date)
	
	declare @Id int, @SDDate datetime, @SDDLKey int, @SDTUKey int,
	@oldDlKey int, @oldDate datetime, @i int

	set @i = -1
	 
	DECLARE noBodyTurists CURSOR FOR 
	select SD_ID, SD_Date, SD_DLKey, SD_TUKey
	from #TempServiceByDate
	where SD_TUKey is null
	order by SD_DLKey, SD_Date

	OPEN noBodyTurists
	FETCH NEXT FROM noBodyTurists INTO @Id, @SDDate, @SDDLKey, @SDTUKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- если мы встретили новую дату или услугу то сбрасываем счетчик
		if @oldDlKey != @SDDLKey or @oldDate != @SDDate
		begin
			set @i = -1
		end
			
		update #TempServiceByDate
		set SD_TUKey = @i
		where SD_ID = @Id
		
		set @i = @i - 1

		set @oldDlKey = @SDDLKey
		set @oldDate = @SDDate
		
		FETCH NEXT FROM noBodyTurists INTO @Id, @SDDate, @SDDLKey, @SDTUKey
	END
	CLOSE noBodyTurists
	DEALLOCATE noBodyTurists 

	--select * from #TempServiceByDate

	-- 29.10.13 Гусак изменил привязку покупателя
	-- с left join Partners on dl_agent = pr_key
	-- на 		left join Partners on dg_partnerkey = pr_key
	SET @Query = '
		INSERT INTO #Result (DG_Code, DG_Key, DG_DiscountSum, DG_Price, DG_Payed, 
		DG_PriceToPay, DG_Rate, DG_NMen, 
		PR_Name, PR_Name_Lat, CR_Name,  CR_Name_Lat,
		DL_Key, DL_NDays, DL_NMen, DL_Reserved, DL_CTKeyTo, DL_CTKeyFrom, DL_SubCode1, ServiceDateBeg, ServiceDateEnd, 
		TL_Key, TUCount, TU_NameRus, TU_NameLat, TU_FNameRus, TU_FNameLat, TU_Key, 
		TU_Sex, TU_PasportNum, TU_PasportType, TU_PasportDateEnd, TU_BirthDay, TicketNumber, TU_SNAMERUS, TU_SNAMELAT, TU_IDKEY)
		SELECT	  DG_CODE, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED, 
		(case DG_PDTTYPE when 1 then DG_PRICE+DG_DISCOUNTSUM else DG_PRICE end ), DG_RATE, DG_NMEN, 
		PR_NAME, PR_NAMEENG, CR_NAME, CR_NameLat, DL_KEY, DL_NDays, DL_NMEN, DL_RESERVED, DL_CTKey, DL_SubCode2, DL_SubCode1, 
		DL_DateBeg, CASE WHEN ' + CAST(@SVKey as varchar(10)) + '=3 THEN DATEADD(DAY,1,DL_DateEnd) ELSE DL_DateEnd END,
		DG_TRKey, 0, TU_NAMERUS, TU_NAMELAT, TU_FNAMERUS, TU_FNAMELAT, SD_TUKey, case when SD_TUKey > 0 then isnull(TU_SEX,0) else null end, TU_PASPORTTYPE + ''№'' + TU_PASPORTNUM, TU_PASPORTTYPE, 
		TU_PASPORTDATEEND, TU_BIRTHDAY, TU_NumDoc, TU_SNAMERUS, TU_SNAMELAT, TU_IDKEY
		FROM  Dogovor join Dogovorlist on dl_dGKEY = DG_KEY
--		left join Partners on dl_agent = pr_key
		left join Partners on dg_partnerkey = pr_key
		join Controls on dl_control = cr_key
		join #TempServiceByDate on SD_DLKey = DL_KEY
		left join TuristService on tu_dlkey = dl_key and TU_TUKEY = SD_TUKey
		left join Turist on tu_key = tu_tukey
		WHERE '

		SET @Query=@Query + '
			 DL_SVKEY=' + CAST(@SVKey as varchar(20)) + ' AND DL_CODE in (' + @Codes + ') AND ''' + CAST(@Date as varchar(20)) + ''' BETWEEN DL_DATEBEG AND DL_DATEEND '

		IF @QPID is not null or @QDID is not null
		BEGIN
			IF @QPID is not null
				SET @Query=@Query + 'and SD_QPID IN (' + CAST(@QPID as varchar(20)) + ')'
			ELSE
				--buryak
				--2013-02-20 TFS 11520 MT.Экран "Список на услугу".Не отображались путевки без туристов.
				SET @Query=@Query + 'and exists (SELECT top 1 SD_DLKEY FROM #TempServiceByDate, QuotaParts WHERE SD_QPID=QP_ID and QP_QDID IN (' + CAST(@QDID as varchar(20)) + ') and SD_DLKEY=DL_Key and (tu_tukey is null or sd_tukey = tu_tukey))'
		END
				
		if (@SubCode1 != '0')
			SET @Query=@Query + ' AND DL_SUBCODE1 in (' + CAST(@SubCode1 as varchar(20)) + ')'
		IF @State is not null
			SET @Query=@Query + ' and SD_State=' + CAST(@State as varchar(1))
		if (@SubCode2 != '0')
			SET @Query=@Query + ' AND DL_SUBCODE2 in (' + CAST(@SubCode2 as varchar(20)) + ')'
		SET @Query=@Query + ' 
		group by DG_CODE, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED, DG_PDTTYPE, DG_RATE, DG_NMEN, 
		PR_NAME, PR_NAMEENG, CR_NAME, CR_NameLat, DL_KEY, DL_NDays, DL_NMEN, DL_RESERVED, DL_CTKey, DL_SubCode2, DL_SubCode1, DL_DateBeg,
		DL_DateEnd, DG_TRKey, TU_NAMERUS, TU_NAMELAT, TU_FNAMERUS,
		TU_FNAMELAT, SD_TUKey, TU_SEX, TU_PASPORTNUM, TU_PASPORTTYPE, TU_PASPORTDATEEND, TU_BIRTHDAY, TU_NumDoc, TU_SNAMERUS, TU_SNAMELAT, TU_IDKEY'
end
else
begin
	-- 29.10.13 Гусак изменил привязку покупателя
	-- с left join Partners on dl_agent = pr_key
	-- на 		left join Partners on dg_partnerkey = pr_key
	SET @Query = '
		INSERT INTO #Result (DG_Code, SD_RLID, RM_Name, RC_Name, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED,
		DG_PriceToPay, DG_RATE, DG_NMEN,
		PR_NAME, PR_Name_Lat, CR_NAME, CR_NAME_Lat, DL_NDays, DL_NMEN, DL_RESERVED, DL_CTKeyTo, DL_SubCode1,
		ServiceDateBeg, ServiceDateEnd, TL_Key, TUCount, DL_Key, DL_CTKeyFrom)
		select DG_CODE, SD_RLID, RM_Name, RC_Name, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED,
		(case when DG_PDTTYPE = 1 then DG_PRICE+DG_DISCOUNTSUM else DG_PRICE end ), DG_RATE, DG_NMEN,
		PR_NAME, PR_NAMEENG, CR_NAME, CR_NAMELat, DL_NDays, 
		--mv 24.10.2012 -убрал очень странный код - в поле кол-во человек выводилосб количество комнат, сделал количество мест хотя бы
		--case when QT_ByRoom = 1 then count(distinct SD_RLID) else count(distinct SD_RPID) end as DL_NMEN,
		COUNT(SD_RPID),
		DL_RESERVED, DL_CTKey, DL_SubCode2, DL_DateBeg, CASE WHEN ' + CAST(@SVKey as varchar(10)) + ' = 3 THEN DATEADD(DAY,1,DL_DateEnd) ELSE DL_DateEnd END, DG_TRKey, Count(distinct SD_TUKey), DL_KEY, DL_SubCode2
		from ServiceByDate left join RoomNumberLists on sd_rlid = rl_id
		left join Rooms on rl_rmkey = rm_key
		left join RoomsCategory on rl_rckey = rc_key
		left join QuotaParts on sd_qpid = qp_id
		left join QuotaDetails on QP_QDID = QD_ID and QP_Date = QD_Date
		left join Quotas on QT_ID = QD_QTID
		join Dogovorlist on sd_dlkey = dl_key
		join Controls on dl_control = cr_key
--		left join Partners on dl_agent = pr_key
		join Dogovor on dl_dGKEY = DG_KEY
		left join Partners on dg_partnerkey = pr_key
		where DL_SVKEY=' + CAST(@SVKey as varchar(20)) + ' 
			AND DL_CODE in (' + @Codes + ') 
			AND ''' + CAST(@Date as varchar(20)) + ''' BETWEEN DL_DATEBEG AND DL_DATEEND
			--mv 24.10.2012 добавил фильтр по дате SD, так как просмотр идет относительно этой даты
			AND SD_Date = ''' + CAST(@Date as varchar(20)) + ''' '
		
	if @QDID is not null
		SET @Query = @Query + ' and qp_qdid = ' + CAST(@QDID as nvarchar(max))
	if @QPID is not null
		SET @Query = @Query + ' and qp_id = ' + CAST(@QPID as nvarchar(max))
	IF @State is not null
		SET @Query=@Query + ' and SD_State=' + CAST(@State as varchar(1))
	-- mv 24.10.2012 - не было фильтра по услуге, в список попадали лишние
	IF @SubCode1 is not null
		SET @Query=@Query + ' and DL_SUBCODE1 = ' + CAST(@SubCode1 as varchar(20))
	
	SET @Query = @Query + '
		group by DG_CODE, SD_RLID, DG_KEY, DG_DISCOUNTSUM, DG_PRICE, DG_PAYED,
		DG_PDTTYPE, DG_DISCOUNTSUM, DG_RATE, DG_NMEN,
		PR_NAME, PR_NAMEENG, CR_NAME,CR_NAMELat, DL_NDays, DL_RESERVED, DL_CTKey, DL_SubCode2,
		DL_DateBeg, DL_DateEnd, DG_TRKey, RM_Name, RC_Name, QT_ByRoom, DL_KEY'
end

--PRINT @Query
EXEC (@Query)
 
UPDATE #Result SET #Result.TL_Name=(SELECT TL_Name FROM TurList WHERE #Result.TL_Key=TurList.TL_Key)
UPDATE #Result SET #Result.TL_Name_Lat=(SELECT TL_NameLat FROM TurList WHERE #Result.TL_Key=TurList.TL_Key)

--select * from  #Result

if @TypeOfRelult=1
BEGIN
	UPDATE #Result SET #Result.Request=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=4)
	UPDATE #Result SET #Result.Commitment=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=2)
	UPDATE #Result SET #Result.Allotment=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=1)
	UPDATE #Result SET #Result.Ok=(SELECT COUNT(*) FROM ServiceByDate WHERE SD_DLKey = #Result.DL_Key AND SD_State=3)
END
else
BEGIN
	UPDATE #Result SET #Result.Request=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=4)
	UPDATE #Result SET #Result.Commitment=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=2)
	UPDATE #Result SET #Result.Allotment=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=1)
	UPDATE #Result SET #Result.Ok=(SELECT COUNT(*) FROM #TempServiceByDate WHERE SD_DLKey=#Result.DL_Key AND SD_TUKey=#Result.TU_Key and SD_State=3)
END
 
IF @ShowHotels=1
BEGIN
	IF @TypeOfRelult = 2
	BEGIN
		DECLARE @HD_Name varchar(100), @HD_Name2_Lat varchar(100),  @HD_Stars varchar(25), @PR_Name varchar(100), @PR_Name_Lat varchar(100), @TU_Key int, @HD_Key int, @PR_Key int, @TU_KeyPrev int, @TU_Hotels varchar(255), @TU_Hotels_Lat varchar(255)
		DECLARE curServiceList CURSOR FOR 
			SELECT	  DISTINCT HD_Name, HD_NAMELAT, HD_Stars, PR_Name, PR_NAMEENG, TU_TUKey, HD_Key, PR_Key 
			FROM  HotelDictionary, DogovorList, TuristService, Partners
			WHERE	  PR_Key=DL_PartnerKey and HD_Key=DL_Code and TU_DLKey=DL_Key and TU_TUKey in (SELECT TU_Key FROM #Result) and dl_SVKey=3 
			ORDER BY TU_TUKey
		OPEN curServiceList
		FETCH NEXT FROM curServiceList INTO	  @HD_Name,@HD_Name2_Lat, @HD_Stars,@PR_Name, @PR_Name_Lat, @TU_Key, @HD_Key, @PR_Key
		WHILE @@FETCH_STATUS = 0
		BEGIN
			IF @TU_Key!=@TU_KeyPrev or @TU_KeyPrev is null
			begin
			  Set @TU_Hotels=@HD_Name+' '+@HD_Stars+' ('+@PR_Name+')'
			  Set @TU_Hotels_Lat=@HD_Name2_Lat+' '+@HD_Stars+' ('+@PR_Name_Lat+')'
			end
			ELSE
			begin
			  Set @TU_Hotels=@TU_Hotels+', '+@HD_Name+' '+@HD_Stars+' ('+@PR_Name+')'
			  Set @TU_Hotels_Lat=@TU_Hotels_Lat+', '+@HD_Name2_Lat+' '+@HD_Stars+' ('+@PR_Name_Lat+')'
			end
			UPDATE #Result SET TU_Hotels=@TU_Hotels WHERE TU_Key=@TU_Key
			UPDATE #Result SET TU_Hotels_Lat=@TU_Hotels_Lat WHERE TU_Key=@TU_Key
			SET @TU_KeyPrev=@TU_Key
			FETCH NEXT FROM curServiceList INTO	   @HD_Name,@HD_Name2_Lat, @HD_Stars, @PR_Name, @PR_Name_Lat, @TU_Key, @HD_Key, @PR_Key
		END
		CLOSE curServiceList
		DEALLOCATE curServiceList
	END
	IF @TypeOfRelult = 1
	BEGIN
		DECLARE @HD_Name1 varchar(100), @HD_Name1_lat varchar(100), @HD_Stars1 varchar(25), @PR_Name1 varchar(100), @PR_Name1_Lat varchar(100), @DL_Key1 int, @HD_Key1 int, 
				@PR_Key1 int, @DL_KeyPrev1 int, @TU_Hotels1 varchar(255), @TU_Hotels1_Lat varchar(255), @DG_Key int, @DG_KeyPrev int
		DECLARE curServiceList CURSOR FOR 
			--SELECT DISTINCT HD_Name, HD_Stars, P.PR_Name, DogList.DL_Key, HD_Key, PR_Key--, DG_Key
			--FROM HotelDictionary, DogovorList DogList, TuristService, Partners P
			--WHERE P.PR_Key = DogList.DL_PartnerKey and HD_Key = DogList.DL_Code and TU_DLKey = DogList.DL_Key and
			--TU_TUKey in (SELECT TU_TUKEY FROM TuristService WHERE TU_DLKEY in (SELECT DL_KEY FROM #Result)) 
			--and DL_SVKey=3 
			--ORDER BY DogList.DL_Key
			SELECT DISTINCT HD_Name, HD_NameLat, HD_Stars, HD_Key, P.PR_Name, PR_NAMEENG, P.PR_Key, DogList.DL_Key, R.DG_Key
			FROM HotelDictionary, DogovorList DogList, Partners P, #Result R
			WHERE P.PR_Key = DogList.DL_PartnerKey and HD_Key = DogList.DL_Code and DogList.DL_DGKey = R.DG_Key			
				  and DogList.DL_SVKey=3 
			ORDER BY R.DG_Key
		OPEN curServiceList
		FETCH NEXT FROM curServiceList INTO @HD_Name1, @HD_Name1_lat, @HD_Stars1, @HD_Key1, @PR_Name1, @PR_Name1_Lat, @PR_Key1, @DL_Key1, @DG_Key
		WHILE @@FETCH_STATUS = 0
		BEGIN
			IF @DG_Key != @DG_KeyPrev or @DG_KeyPrev is null  
			BEGIN
			  Set @TU_Hotels1=@HD_Name1+' '+@HD_Stars1+' ('+@PR_Name1+')'
			  Set @TU_Hotels1_Lat=@HD_Name1_lat+' '+@HD_Stars1+' ('+@PR_Name1_Lat+')'
			END
			ELSE
			BEGIN
			  Set @TU_Hotels1=@TU_Hotels1+', '+@HD_Name1+' '+@HD_Stars1+' ('+@PR_Name1+')'
			  Set @TU_Hotels1=@TU_Hotels1_Lat+', '+@HD_Name1_lat+' '+@HD_Stars1+' ('+@PR_Name1_Lat+')'
			END
			UPDATE #Result SET TU_Hotels=@TU_Hotels1 WHERE DG_Key=@DG_Key --DL_Key=@DL_Key1
			UPDATE #Result SET TU_Hotels_Lat=@TU_Hotels1_Lat WHERE DG_Key=@DG_Key --DL_Key=@DL_Key1
			SET @DG_KeyPrev = @DG_Key
			FETCH NEXT FROM curServiceList INTO @HD_Name1, @HD_Name1_lat, @HD_Stars1, @HD_Key1, @PR_Name1, @PR_Name1_Lat, @PR_Key1, @DL_Key1, @DG_Key
		END
		CLOSE curServiceList
		DEALLOCATE curServiceList
	END
END
 
IF @ShowFligthDep=1 and @SVKey=1
BEGIN
	IF @TypeOfRelult = 2
	BEGIN
		Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and DL_SubCode2=#Result.DL_CTKeyTo and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)
		if exists (select 1 from #Result Where FlightDepDLKey is null)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc) where FlightDepDLKey is null
		--если по городу не нашли ишем по стране
		if exists (select 1 from #Result Where FlightDepDLKey is null)     
		begin
			update #Result set DL_CNKEYFROM = (select top 1 ct_cnkey from citydictionary where ct_key =#Result.DL_CTKEYFROM)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CNKey=#Result.DL_CNKeyFrom and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)	where FlightDepDLKey is null	  
		end
	END
	ELSE
	BEGIN
		Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList Where DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and DL_SubCode2=#Result.DL_CTKeyTo and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)
		if exists (select 1 from #Result Where FlightDepDLKey is null)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList Where DL_DGKey=#Result.DG_Key and DL_CTKey=#Result.DL_CTKeyFrom and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc) where FlightDepDLKey is null
		--если по городу не нашли ишем по стране
		if exists (select 1 from #Result Where FlightDepDLKey is null)     
		begin
			update #Result set DL_CNKEYFROM = (select top 1 ct_cnkey from citydictionary where ct_key =#Result.DL_CTKEYFROM)
			Update #Result SET FlightDepDLKey=(Select TOP 1 DL_Key From DogovorList,TuristService Where TU_DLKey=DL_Key and DL_DGKey=#Result.DG_Key and DL_CNKey=#Result.DL_CNKeyFrom and TU_TUKey=#Result.TU_Key and DL_DGKey=#Result.DG_Key and dl_svkey=1 order by dl_datebeg desc)	where FlightDepDLKey is null	  
		end
	END
	Update #Result set FligthDepDate = (select dl_dateBeg From DogovorList where DL_Key=#Result.FlightDepDLKey)
	Update #Result set FlightDepNumber = (select CH_AirLineCode + ' ' + CH_Flight From DogovorList, Charter where DL_Code=CH_Key and DL_Key=#Result.FlightDepDLKey)
END

IF @ShowDescription=1
BEGIN
	IF @SVKey=1
		Update #Result SET ServiceDescription=LEFT((SELECT ISNUll(AS_Code, '') + '-' + AS_NameRus FROM AirService WHERE AS_Key=DL_SubCode1),80),
		ServiceDescription_Lat=LEFT((SELECT ISNUll(AS_Code, '') + '-' + AS_NAMELAT FROM AirService WHERE AS_Key=DL_SubCode1),80)
	ELSE IF (@SVKey=2 or @SVKey=4)
		Update #Result SET ServiceDescription=LEFT((SELECT TR_Name FROM Transport WHERE TR_Key=DL_SubCode1),80),
							ServiceDescription_Lat=LEFT((SELECT TR_NAMELAT FROM Transport WHERE TR_Key=DL_SubCode1),80)
	ELSE IF (@SVKey=3 or @SVKey=8)
	BEGIN
		Update #Result SET ServiceDescription=LEFT((SELECT RM_Name + '(' + RC_Name + ')' + AC_Name FROM Rooms,RoomsCategory,AccMdMenType,HotelRooms WHERE HR_Key=DL_SubCode1 and HR_RMKey=RM_Key and HR_RCKey=RC_Key and HR_ACKey=AC_Key),80),
							ServiceDescription_Lat=LEFT((SELECT RM_NAMELAT + '(' + RC_NAMELAT + ')' + AC_NAMELAT FROM Rooms,RoomsCategory,AccMdMenType,HotelRooms WHERE HR_Key=DL_SubCode1 and HR_RMKey=RM_Key and HR_RCKey=RC_Key and HR_ACKey=AC_Key),80)
		IF @SVKey=8
			Update #Result SET ServiceDescription='All accommodations' where DL_SubCode1=0
	END
	ELSE IF (@SVKey=7 or @SVKey=9)
	BEGIN
		Update #Result SET ServiceDescription=LEFT((SELECT ISNULL(CB_Code,'') + ',' + ISNULL(CB_Category,'') + ',' + ISNULL(CB_Name,'') FROM Cabine WHERE CB_Key=DL_SubCode1),80),
							ServiceDescription=LEFT((SELECT ISNULL(CB_Code,'') + ',' + ISNULL(CB_Category,'') + ',' + ISNULL(CB_NAMELAT,'') FROM Cabine WHERE CB_Key=DL_SubCode1),80)
		IF @SVKey=9
			Update #Result SET ServiceDescription='All accommodations' where DL_SubCode1=0
	END
	ELSE
		Update #Result SET ServiceDescription=LEFT((SELECT A1_Name FROM AddDescript1 WHERE A1_Key=DL_SubCode1),80), 
							ServiceDescription_Lat=LEFT((SELECT A1_NAMELAT FROM AddDescript1 WHERE A1_Key=DL_SubCode1),80) WHERE ISNULL(DL_SubCode1,0)>0
END

--print @Query
SELECT * FROM #Result

GO
GRANT EXECUTE ON [dbo].[GetServiceList] TO Public
GO
/*********************************************************************/
/* end sp_GetServiceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_GetServiceLoadListData.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetServiceLoadListData]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[GetServiceLoadListData]
GO

create procedure [dbo].[GetServiceLoadListData]
(
--<VERSION>2009.2.20</VERSION>
--<DATE>2013-08-29</DATE>
@SVKey int,
@Code int,
@PRKey int =null,-- @PRKEY=null все
@DateStart smalldatetime = null,
@DaysCount int,
@CityDepartureKey int = null,-- город вылета
@bShowByRoom     bit =null,  -- показывать информацию по номерам (по умолчанию по людям)
@bShowByPartner  bit =null,  -- информацию разделять по партнерам
@bShowState      bit =null,  -- показать статус бронирования (запрос, на квоте, Ok) 
@bShowCommonInfo bit =null,  -- показывать общую информацию по загрузке услуги
@nGridFilter int = 0              -- фильтр в зависимости от экрана / 1-английский вариант экранов
)
as 
/*
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@DaysCount,@SVKey,89)
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@PRKey,@bShowByRoom,88)
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@bShowByPartner,@bShowState,87)
insert into debug (db_date,db_n1,db_n2,db_n3) values (@DateStart,@bShowCommonInfo,@Code,86)
*/
if @SVKey!=3
	Set @bShowByRoom=0

DECLARE @DateEnd smalldatetime
Set @DateEnd = DATEADD(DAY, @DaysCount-1, @DateStart)

CREATE TABLE #ServiceLoadList
(
SL_ID INT IDENTITY(1,1) NOT NULL, 
SL_ServiceName nvarchar(100), SL_State smallint,
SL_SubCode1 int, SL_SubCode2 int, SL_PRKey int
/*SL_DataType это мнимая колонка, есть только при выводе результата 
содержит тип информации для записей с итогами
(1 - общий итог, 2 - данные по услуге)
*/
)
DECLARE @n int, @nMax int, @str nvarchar(max),@SL_SubCode1 int, @SL_SubCode2 int, @s nvarchar(1), @ServiceName nvarchar(255), @ServiceName_1 nvarchar(255)
set @n=1 

WHILE @n <= @DaysCount
BEGIN
	set @str = 'ALTER TABLE #ServiceLoadList ADD SL_' + CAST(@n as nvarchar(3)) + ' nvarchar(20)'
	exec (@str)
	set @n = @n + 1
END

if @SVKey != 8
begin
	if @bShowByPartner =1 and @bShowState=1
	insert into #ServiceLoadList (SL_SubCode1, SL_PRKey, SL_State)
		select distinct DL_SubCode1, DL_PartnerKey, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
else if @bShowByPartner =0 and @bShowState=1
	insert into #ServiceLoadList (SL_SubCode1, SL_State)
		select distinct DL_SubCode1, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
else if @bShowByPartner =1 and @bShowState=0
	insert into #ServiceLoadList (SL_SubCode1, SL_PRKey)
		select distinct DL_SubCode1, DL_PartnerKey from DogovorList, Dogovor
		where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
else
	insert into #ServiceLoadList (SL_SubCode1)
		select distinct DL_SubCode1 from DogovorList, Dogovor
		where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
end if @SVKey = 8
begin 
	if @bShowByPartner =1 and @bShowState=1
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2, SL_PRKey, SL_State)
			select distinct DL_SubCode1, DL_SubCode2, DL_PartnerKey, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
			where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
	else if @bShowByPartner =0 and @bShowState=1
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2, SL_State)
			select distinct DL_SubCode1, DL_SubCode2, ISNULL(SD_State,0) from DogovorList, ServiceByDate, Dogovor
			where	SD_DLKey=DL_Key and DG_Key=DL_DGKey and DL_SVKey=@SVKey and DL_Code=@Code and SD_Date between @DateStart and @DateEnd and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
	else if @bShowByPartner =1 and @bShowState=0
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2, SL_PRKey)
			select distinct DL_SubCode1, DL_SubCode2, DL_PartnerKey from DogovorList, Dogovor
			where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
	else
		insert into #ServiceLoadList (SL_SubCode1, SL_SubCode2)
			select distinct DL_SubCode1, DL_SubCode2 from DogovorList, Dogovor
			where	DL_SVKey=@SVKey and DG_Key=DL_DGKey and DL_Code=@Code and ((DL_DateBeg between @DateStart and @DateEnd) or (DL_DateEnd between @DateStart and @DateEnd)) and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
end
 
while exists(select SL_SubCode1 from #ServiceLoadList where SL_ServiceName is null)
BEGIN
	if @SVKey != 8
	begin
		select @SL_SubCode1=SL_SubCode1 from #ServiceLoadList where SL_ServiceName is null
		if (@nGridFilter=1)
			begin
				--для англ версии
				exec GetSvCode1Name @SVKey, @SL_SubCode1, @s output,@s output,@s output,@ServiceName output
			end
		else
			begin
				--для русской версии
				exec GetSvCode1Name @SVKey,@SL_SubCode1,@s output,@ServiceName output,@s output,@s output
			end
		UPDATE #ServiceLoadList SET SL_ServiceName = COALESCE(@ServiceName, '') where SL_SubCode1=@SL_SubCode1
	end if @SVKey = 8
	begin
		select @SL_SubCode1=SL_SubCode1, @SL_SubCode2=SL_SubCode2 from #ServiceLoadList where SL_ServiceName is null
		exec GetSvCode1Name @SVKey,@SL_SubCode1,@s output,@ServiceName output,@s output,@s output
		exec dbo.GetSvCode2Name @SVKey, @SL_SubCode2, @ServiceName_1 output, @s output
		UPDATE #ServiceLoadList SET SL_ServiceName = COALESCE(@ServiceName, '') + N',' + COALESCE(@ServiceName_1, '') where SL_SubCode1=@SL_SubCode1 and SL_SubCode2=@SL_SubCode2
	end 
END

If @bShowByRoom=1
begin

	DECLARE curSLoadList CURSOR FOR SELECT
		'UPDATE #ServiceLoadList SET SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + '= ISNULL(SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + ',0)+' + CAST(Count(Distinct SD_RLID) as nvarchar(5)) + ' WHERE SL_SubCode1=' + CAST(DL_SubCode1 as nvarchar(10)) + CASE WHEN @bShowByPartner=1 THEN ' AND SL_PRKey=' + CAST(DL_PartnerKey as nvarchar(10)) ELSE '' END + CASE WHEN @bShowState=1 THEN ' AND SL_State=' + CAST(ISNULL(SD_STATE,0) as nvarchar(10)) ELSE '' END
		from	DogovorList,ServiceByDate, Dogovor 
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey
				and DL_SVKey=@SVKey and DL_Code=@Code 
				and DL_DateBeg<=@DateEnd and DL_DateEnd>=@DateStart
				and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
				and SD_Date<=@DateEnd and SD_Date>=@DateStart
		group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State
end
Else
begin

	DECLARE curSLoadList CURSOR FOR SELECT
		'UPDATE #ServiceLoadList SET SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + '= ISNULL(SL_' + CAST(CAST(SD_Date-@DateStart+1 as int) as nvarchar(5)) + ',0)+' + CAST(Count(SD_ID) as nvarchar(5)) + ' WHERE SL_SubCode1=' + CAST(DL_SubCode1 as nvarchar(10)) + CASE WHEN @SVKey=8 THEN 'AND SL_SubCode2=' + CAST(DL_SUBCODE2 as nvarchar(10)) ELSE '' END + CASE WHEN @bShowByPartner=1 THEN ' AND SL_PRKey=' + CAST(DL_PartnerKey as nvarchar(10)) ELSE '' END + CASE WHEN @bShowState=1 THEN ' AND SL_State=' + CAST(ISNULL(SD_STATE,0) as nvarchar(10)) ELSE '' END
		from	DogovorList,ServiceByDate, Dogovor 
		where	SD_DLKey=DL_Key and DG_Key=DL_DGKey
				and DL_SVKey=@SVKey and DL_Code=@Code
				and DL_DateBeg<=@DateEnd and DL_DateEnd>=@DateStart
				and ((DL_PartnerKey=@PRKEY) or (@PRKEY is null)) 
				and ((DG_CTDepartureKey=@CityDepartureKey) or (@CityDepartureKey is null))
				and SD_Date<=@DateEnd and SD_Date>=@DateStart
		group by SD_Date,DL_SubCode1,DL_PartnerKey,SD_State, DL_SVKey, DL_SUBCODE2
end
		

OPEN curSLoadList
FETCH NEXT FROM curSLoadList INTO	@str
WHILE @@FETCH_STATUS = 0
BEGIN
	--print @DateStart
	--print @str
	exec (@str)
	FETCH NEXT FROM curSLoadList INTO	@str
END
CLOSE curSLoadList
DEALLOCATE curSLoadList

Set @str = ''
set @n=1
set @str = @str + 'SELECT SL_ServiceName, SL_State, SL_SubCode1, ' + CASE WHEN @SVKey=8 THEN 'SL_SubCode2, ' ELSE '' END + ' SL_PRKey '
WHILE @n <= @DaysCount
BEGIN
	--print @str
	set @str = @str + ', SL_' + CAST(@n as nvarchar(3)) 
	set @n = @n + 1
END
/*
Set @str = @str + ' from #QuotaLoadList, Numbers where NU_ID between 1 and 3
and QL_IsQD=0
order by QL_Type,QL_Release,QL_Durations,QL_CityDepartments,QL_FilialKey,QL_CustomerInfo,NU_ID'
*/
Set @str = @str + ' from #ServiceLoadList order by SL_ServiceName, SL_SubCode1, ' + CASE WHEN @SVKey=8 THEN 'SL_SubCode2,' ELSE '' END + ' SL_PRKey, SL_State'

exec (@str)
GO

grant execute on [dbo].[GetServiceLoadListData] to public
GO
/*********************************************************************/
/* end sp_GetServiceLoadListData.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ImportExchangeQuotaStops.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ImportExchangeQuotaStops]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[ImportExchangeQuotaStops]
GO

CREATE PROCEDURE [dbo].[ImportExchangeQuotaStops]
	(
		@dateBeg datetime,
		@dateEnd datetime,
		@HotelKey int,
		@prKey int
	)
AS
BEGIN	
	-- процедура импортирует информацию о квотах из тиблицы ExchangeQuotaStops
	--<version>2009.2.21</version>
	--<data>2013-10-18</data>

	SET NOCOUNT ON;
	
	declare @SvKey int, @Code int, @SubCode1 int, @SubCode2 int, @SubCode3 int, @Date datetime, @IsStop bit, @Places int, @PartnerKey int
	declare @qtKey int, @qoKey int, @qdKey int, @releaseConst int, @release int

	set @releaseConst = 365
	set @release = null
	
	declare ExchangeQuotaStops_cursor cursor local fast_forward for
	select EQS_SvKey, EQS_Code, EQS_SubCode1, EQS_SubCode2, EQS_SubCode3, EQS_Date, EQS_IsStop, EQS_Places, EQS_PartnerKey
	from ExchangeQuotaStops 
	where EQS_Date between @dateBeg and @dateEnd
		AND EQS_Code = @HotelKey
		and EQS_SvKey = 3
	order by EQS_Date, EQS_IsStop;

	open ExchangeQuotaStops_cursor;
	
	fetch next from ExchangeQuotaStops_cursor into @SvKey, @Code, @SubCode1, @SubCode2, @SubCode3, @Date, @IsStop, @Places, @PartnerKey;	
	while @@FETCH_STATUS = 0
	begin		
		-- пришли обычные квоты
		if (@IsStop = 0 and @Places >= 0)
		begin

			if (not exists (select 1
									from Quotas join QuotaObjects on QT_ID = QO_QTID
									where QT_PRKey = @PartnerKey
									and QO_SVKey = @SvKey
									and QO_Code = @Code
									and QO_SubCode1 = @SubCode1
									and QO_SubCode2 = @SubCode3))
			begin
				insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment)
				values (@PartnerKey, 1, 'Quotas from Interlook. Load: ' + convert(nvarchar(max), GETDATE(), 121))
				set @qtKey = SCOPE_IDENTITY()
					
				insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
				values (@qtKey, @SvKey, @Code, @SubCode1, @SubCode3)
				set @qoKey = SCOPE_IDENTITY()
			end
			else
			begin
				select @qtKey = QT_ID, @qoKey = QO_ID
				from Quotas join QuotaObjects on QT_ID = QO_QTID
				where QT_PRKey = @PartnerKey
				and QO_SVKey = @SvKey
				and QO_Code = @Code
				and QO_SubCode1 = @SubCode1
				and QO_SubCode2 = @SubCode3
			end

			if not exists (select 1 from QuotaDetails with(nolock) where QD_QTID = @qtKey and QD_Date = @Date and QD_Type = 1)
			begin
				insert into QuotaDetails(QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey, QD_Release)
				values (@qtKey, @Date, 1, @Places, 0, GETDATE(), [dbo].[GetUserId](), @release)
				set @qdKey = SCOPE_IDENTITY()
			end
			else
			begin
				select top(1) @qdKey = QD_ID
				from QuotaDetails with(nolock) 
				where QD_QTID = @qtKey 
				and QD_Date = @Date 
				and QD_Type = 1

				update QuotaDetails
				set QD_Places = @Places,
				QD_Busy = 0,
				QD_Release = @release,
				QD_IsDeleted = null
				where QD_ID = @qdKey
			end
				
			if not exists (select 1 from QuotaParts where QP_QDID = @qdKey and QP_Date = @Date and QP_IsNotCheckIn = 0 and QP_Durations = '')
			begin
				insert into QuotaParts(QP_QDID, QP_Date, QP_Places, QP_Busy, QP_Limit, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey)
				values (@qdKey, @Date, @Places, 0, 1, 0, '', GETDATE(), [dbo].[GetUserId]())
			end
			else
			begin
				declare @qpKey int

				select top(1) @qpKey = QP_ID
				from QuotaParts 
				where QP_QDID = @qdKey 
				and QP_Date = @Date 
				and QP_IsNotCheckIn = 0 
				and QP_Durations = ''

				update QuotaParts
				set QP_Places = @Places,
				QP_Busy = 0,
				QP_Limit = 1,
				QP_IsDeleted = null
				where QP_ID = @qpKey

			end
		end
		else if (@IsStop = 1)
		begin
			-- пришел новый стоп, добавляем его
			if (@Places >= 0)
			begin
				if not exists (	select 1
								from QuotaObjects
								where QO_SVKey = @SvKey
								and QO_Code = @Code
								and QO_SubCode1 = @SubCode1
								and QO_SubCode2 = @SubCode3
								and QO_QTID is null)
				begin
					insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
					values (null, @SvKey, @Code, @SubCode1, @SubCode3)
					set @qoKey = SCOPE_IDENTITY()
				end
				else
				begin
					select @qoKey = QO_ID
					from QuotaObjects
					where QO_SVKey = @SvKey
					and QO_Code = @Code
					and QO_SubCode1 = @SubCode1
					and QO_SubCode2 = @SubCode3
					and QO_QTID is null
				end
				
				insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey)
				values (@qoKey, null, @PartnerKey, @Date, 1, '', GETDATE(), [dbo].[GetUserId]())
			end
			else
			begin
				-- стоп удален
				if exists (select 1 
						   from QuotaObjects 
						   join StopSales on SS_QOID = QO_ID 
						   where QO_SVKey = @SvKey
							   and QO_Code = @Code
							   and QO_SubCode1 = @SubCode1
							   and QO_SubCode2 = @SubCode3
							   and QO_QTID is null
							   and ISNULL(SS_IsDeleted, 0) = 0)
				begin
					update StopSales
					set SS_IsDeleted = 1
					from QuotaObjects
					where SS_QOID = QO_ID
						and QO_SVKey = @SvKey
						and QO_Code = @Code
						and QO_SubCode1 = @SubCode1
						and QO_SubCode2 = @SubCode3
						and QO_QTID is null
						and ISNULL(SS_IsDeleted, 0) = 0
						and SS_Date = @Date
				end
			end
		end		
	
		fetch next from ExchangeQuotaStops_cursor into @SvKey, @Code, @SubCode1, @SubCode2, @SubCode3, @Date, @IsStop, @Places, @PartnerKey;		
	end
	
	close ExchangeQuotaStops_cursor;
	deallocate ExchangeQuotaStops_cursor;
END
GO

grant exec on [dbo].[ImportExchangeQuotaStops] to public
go
/*********************************************************************/
/* end sp_ImportExchangeQuotaStops.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ImportExchangeQuotaStops_Bulk.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ImportExchangeQuotaStops_Bulk]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[ImportExchangeQuotaStops_Bulk]
GO

CREATE PROCEDURE [dbo].[ImportExchangeQuotaStops_Bulk]
AS
BEGIN	
	-- процедура импортирует информацию о квотах из таблицы ExchangeQuotaStops
	--<version>2009.2.21</version>
	--<data>2013-10-18</data>

	SET NOCOUNT ON;
	
	declare @SvKey int, @Code int, @SubCode1 int, @SubCode2 int, @SubCode3 int, @Date datetime, @IsStop bit, @Places int, @PartnerKey int
	declare @qtKey int, @qoKey int, @qdKey int, @releaseConst int, @release int, @id int

	set @releaseConst = 365
	set @release = null
	
	declare ExchangeQuotaStops_cursor cursor local fast_forward for
	select EQS_ID, EQS_SvKey, EQS_Code, EQS_SubCode1, EQS_SubCode2, EQS_SubCode3, EQS_Date, EQS_IsStop, EQS_Places, EQS_PartnerKey
	from ExchangeQuotaStops 
	where EQS_IsProcessed = 0
	and EQS_SvKey = 3
	order by EQS_Date, EQS_IsStop;

	-- list of processed ExchangeQuotaStops keys
	create table #processedRecords
	(
		EQS_ID int
	)

	-- error during records processing flag
	declare @wasError as bit
	declare @errorMessage as nvarchar(max)
	set @wasError = 0

	begin try

		open ExchangeQuotaStops_cursor;
	
		fetch next from ExchangeQuotaStops_cursor into @id, @SvKey, @Code, @SubCode1, @SubCode2, @SubCode3, @Date, @IsStop, @Places, @PartnerKey;	
		while @@FETCH_STATUS = 0
		begin		
		
			-- пришли обычные квоты
			if (@IsStop = 0 and @Places >= 0)
			begin

				if (not exists (select 1
										from Quotas join QuotaObjects on QT_ID = QO_QTID
										where QT_PRKey = @PartnerKey
										and QO_SVKey = @SvKey
										and QO_Code = @Code
										and QO_SubCode1 = @SubCode1
										and QO_SubCode2 = @SubCode3))
				begin
					insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment)
					values (@PartnerKey, 1, 'Quotas from Interlook. Load: ' + convert(nvarchar(max), GETDATE(), 121))
					set @qtKey = SCOPE_IDENTITY()
					
					insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
					values (@qtKey, @SvKey, @Code, @SubCode1, @SubCode3)
					set @qoKey = SCOPE_IDENTITY()
				end
				else
				begin
					select @qtKey = QT_ID, @qoKey = QO_ID
					from Quotas join QuotaObjects on QT_ID = QO_QTID
					where QT_PRKey = @PartnerKey
					and QO_SVKey = @SvKey
					and QO_Code = @Code
					and QO_SubCode1 = @SubCode1
					and QO_SubCode2 = @SubCode3
				end

				if not exists (select 1 from QuotaDetails with(nolock) where QD_QTID = @qtKey and QD_Date = @Date and QD_Type = 1)
				begin
					insert into QuotaDetails(QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey, QD_Release)
					values (@qtKey, @Date, 1, @Places, 0, GETDATE(), [dbo].[GetUserId](), @release)
					set @qdKey = SCOPE_IDENTITY()
				end
				else
				begin
					select top(1) @qdKey = QD_ID
					from QuotaDetails with(nolock) 
					where QD_QTID = @qtKey 
					and QD_Date = @Date 
					and QD_Type = 1

					update QuotaDetails
					set QD_Places = @Places,
					QD_Busy = 0,
					QD_Release = @release,
					QD_IsDeleted = null
					where QD_ID = @qdKey
				end
				
				if not exists (select 1 from QuotaParts where QP_QDID = @qdKey and QP_Date = @Date and QP_IsNotCheckIn = 0 and QP_Durations = '')
				begin
					insert into QuotaParts(QP_QDID, QP_Date, QP_Places, QP_Busy, QP_Limit, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey)
					values (@qdKey, @Date, @Places, 0, 1, 0, '', GETDATE(), [dbo].[GetUserId]())
				end
				else
				begin
					declare @qpKey int

					select top(1) @qpKey = QP_ID
					from QuotaParts 
					where QP_QDID = @qdKey 
					and QP_Date = @Date 
					and QP_IsNotCheckIn = 0 
					and QP_Durations = ''

					update QuotaParts
					set QP_Places = @Places,
					QP_Busy = 0,
					QP_Limit = 1,
					QP_IsDeleted = null
					where QP_ID = @qpKey

				end
			end
			else if (@IsStop = 1)
			begin
				-- пришел новый стоп, добавляем его
				if (@Places >= 0)
				begin
					if not exists (	select 1
									from QuotaObjects
									where QO_SVKey = @SvKey
									and QO_Code = @Code
									and QO_SubCode1 = @SubCode1
									and QO_SubCode2 = @SubCode3
									and QO_QTID is null)
					begin
						insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
						values (null, @SvKey, @Code, @SubCode1, @SubCode3)
						set @qoKey = SCOPE_IDENTITY()
					end
					else
					begin
						select @qoKey = QO_ID
						from QuotaObjects
						where QO_SVKey = @SvKey
						and QO_Code = @Code
						and QO_SubCode1 = @SubCode1
						and QO_SubCode2 = @SubCode3
						and QO_QTID is null
					end
				
					insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey)
					values (@qoKey, null, @PartnerKey, @Date, 1, '', GETDATE(), [dbo].[GetUserId]())
				end
				else
				begin
					-- стоп удален
					if exists (select 1 
							   from QuotaObjects 
							   join StopSales on SS_QOID = QO_ID 
							   where QO_SVKey = @SvKey
								   and QO_Code = @Code
								   and QO_SubCode1 = @SubCode1
								   and QO_SubCode2 = @SubCode3
								   and QO_QTID is null
								   and ISNULL(SS_IsDeleted, 0) = 0)
					begin
						update StopSales
						set SS_IsDeleted = 1
						from QuotaObjects
						where SS_QOID = QO_ID
							and QO_SVKey = @SvKey
							and QO_Code = @Code
							and QO_SubCode1 = @SubCode1
							and QO_SubCode2 = @SubCode3
							and QO_QTID is null
							and ISNULL(SS_IsDeleted, 0) = 0
							and SS_Date = @Date
					end
				end
			end	

			-- mark record for update IsProcessed flag
			insert into #processedRecords (EQS_ID)
			values (@id)

			fetch next from ExchangeQuotaStops_cursor into @id, @SvKey, @Code, @SubCode1, @SubCode2, @SubCode3, @Date, @IsStop, @Places, @PartnerKey;		
		end
	
	end try
	begin catch
		set @wasError = 1
		set @errorMessage = error_message()
	end catch

	-- update IsProcessed flag in ExchangeQuotaStops table for processed records
	update ExchangeQuotaStops
	set EQS_IsProcessed = 1
	where EQS_ID in (select EQS_ID from #processedRecords)

	-- release resources
	close ExchangeQuotaStops_cursor;
	deallocate ExchangeQuotaStops_cursor;

	drop table #processedRecords

	-- rethrow error if needed
	if @wasError = 1
	begin
		RAISERROR(@errorMessage, 16, 1)
	end
END
GO

grant exec on [dbo].[ImportExchangeQuotaStops_Bulk] to public
go
/*********************************************************************/
/* end sp_ImportExchangeQuotaStops_Bulk.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ImportExchangeQuotaStops_Delete.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ImportExchangeQuotaStops_Delete]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[ImportExchangeQuotaStops_Delete]
GO

CREATE PROCEDURE [dbo].[ImportExchangeQuotaStops_Delete]
	(
		-- хранимка удаляет стопы и квоты которые пришли из интерука для удаления
		--<version>2009.2.21</version>
		--<data>2013-10-21</data>
		@SvKey int,
		@Code int,
		@SubCode1 int,
		@SubCode2 int,
		@SubCode3 int,
		@Date datetime,
		@IsStop bit,
		@PartnerKey int
	)
AS
BEGIN	
	
	declare @SDDLKey int, @SDDate datetime
	
	-- если это квота то снимаем с нее все услуги (если вдруг что то сидит, хотя не должно)
	if (@IsStop = 0)
	begin
		-- пометим для удаления
		update QuotaDetails
		set QD_IsDeleted = 4 -- Request
		from QuotaDetails join Quotas on QT_ID = QD_QTID
		join QuotaObjects on QT_ID = QO_QTID
		where QO_Code = @Code
		and QO_SVKey = @SvKey
		--and QO_SubCode1 = @SubCode1
		--and QO_SubCode2 = @SubCode3
		and (@SubCode1 = -1 or QO_SubCode1 =@SubCode1)
		and (@SubCode2 = -1 or QO_SubCode2 =@SubCode2)
		and QD_Date = @Date
		and QT_PrKey = @PartnerKey;
		
		-- в этой хранимке снимем если сидела и удалим
		exec QuotaDetailAfterDelete
	end

	-- стопы бывают 2 видов 
	-- 1. На объект квотирования 
	delete StopSales
	from StopSales join QuotaObjects on SS_QOID = QO_ID
	where QO_Code = @Code
	and QO_SVKey = @SvKey
	--and QO_SubCode1 = @SubCode1
	--and QO_SubCode2 = @SubCode3
		and (@SubCode1 = -1 or QO_SubCode1 =@SubCode1)
		and (@SubCode2 = -1 or QO_SubCode2 =@SubCode2)
	and SS_Date = @Date
	and SS_QDID is null
	and QO_QTID is null
	and SS_PRKey = @PartnerKey;
	
	-- 2. на саму квоту (QuotaDetails)
	delete StopSales
	from StopSales join QuotaObjects on SS_QOID = QO_ID
	join QuotaDetails on SS_QDID = QD_ID
	join Quotas on QT_ID = QD_QTID and QT_ID = QO_QTID
	where QO_Code = @Code
	and QO_SVKey = @SvKey
	--and QO_SubCode1 = @SubCode1
	--and QO_SubCode2 = @SubCode3
		and (@SubCode1 = -1 or QO_SubCode1 =@SubCode1)
		and (@SubCode2 = -1 or QO_SubCode2 =@SubCode2)
	and SS_Date = @Date
	and QT_PrKey = @PartnerKey;
	
	
	-- теперь удалим объект квотирования и саму квоту, к которым не привязанно ни QuotaDetails ни StopSales
	delete QuotaObjects
	from QuotaObjects join Quotas on QO_QTID = QT_ID
	where not exists (select 1 from StopSales where SS_QOID = QO_ID)
	and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
	and QO_SVKey = @SvKey
	and QO_Code = @Code
	
	delete Quotas
	from Quotas join QuotaObjects on QT_ID = QO_QTID
	where not exists (select 1 from QuotaObjects where QO_QTID = QT_ID)
	and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
	and QO_SVKey = @SvKey
	and QO_Code = @Code
END

GO

GRANT EXECUTE on [dbo].[ImportExchangeQuotaStops_Delete] to public
GO
/*********************************************************************/
/* end sp_ImportExchangeQuotaStops_Delete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_InsDogList.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='InsDogList')
	drop proc dbo.InsDogList
go


CREATE PROCEDURE [dbo].[InsDogList]
(
--<DATE>2013-10-10</DATE>
--<VERSION>2009.2.20.1</VERSION>
		@sDogovor varchar(10),
	@dTour datetime,
	@nSvKey int,
	@sService varchar(8000),
	@nDay int,
	@nCode int,
	@nCode1 int,
	@nCode2 int,
	@nNDays int,
	@nCountry int,
	@nCity int,
	@nPartner int,
	@nAgent int,
	@nMen int,
	@nNetto money,
	@nBrutto money,
	@nDiscount money,
	@nPaket int,
	@nTour int,
	@nAttribute int,
	@nControl int,
	@nCreator int,
	@nOwner int,
	@dBeg datetime,
	@dEnd datetime,
	@tTime datetime,
	@p_nIsComtmntFirst int,
	@bRet int OUTPUT,
	@nPrmPlaceNoHave money OUTPUT,
	@dPrmBadDate datetime OUTPUT,
	@nNewKey int OUTPUT,
	@nDGKey int = NULL,
	@sComment varchar(254) = NULL,
	@sFormulaNetto varchar(254) = NULL,
	@sFormulaBrutto varchar(254) = NULL,
	@sFormulaDiscount varchar(254) = NULL,
	@sServiceLat varchar(8000) = NULL,
	@nPrtDog int = NULL,
	@nTaxZone int = NULL,
	@bWait bit = NULL
) AS	
	DECLARE @nKey int
	DECLARE @n int
	DECLARE @nID int
	DECLARE @pName varchar(8000)
	DECLARE @sValue varchar(8000)
	DECLARE @nMain int
	--DECLARE @nWait int
	DECLARE @nLong SMALLint
	-- mv 18-11-2005 MEG00006142 
	
	DECLARE @isIndividual smallint
	DECLARE @nCounter int
	
	--koshelev MEG00034729
	declare @isCity int
	select @isCity = SV_ISCITY from Service where SV_KEY = @nSvKey
	if (@isCity = 0)
		set @nCity = 0

	select @sComment = case when len(@sComment)> 0 then substring(@sComment,1, len(@sComment)) else null end
	select @sFormulaNetto = case when len(@sFormulaNetto)> 0 then substring(@sFormulaNetto,1, len(@sFormulaNetto)) else null end
	select @sFormulaBrutto = case when len(@sFormulaBrutto)> 0 then substring(@sFormulaBrutto,1, len(@sFormulaBrutto)) else null end
	select @sFormulaDiscount = case when len(@sFormulaDiscount)> 0 then substring(@sFormulaDiscount,1, len(@sFormulaDiscount)) else null end

	-- установим статус в зависимости от настроек в справочнике услуг
	select @nControl = sv_control from [service] where sv_key = @nSvKey

	If @nDGKey is NULL
		SELECT @nDGKey = DG_KEY FROM tbl_Dogovor with (nolock) where DG_Code = @sDogovor ORDER BY DG_CRDATE DESC
	SELECT @nLong = ISNULL(DG_NDAY,0) FROM tbl_Dogovor with (nolock) where DG_Code = @sDogovor ORDER BY DG_CRDATE DESC
	
	DECLARE @NDL_TimeEnd datetime
	IF @nSvKey=1
		exec [dbo].[MakeFullSVName]
			@nCountry, @nCity, @nSvKey, @nCode, null, 
			@nCode1, @nCode2, 0, @dBeg, null, 
			@sService output, @sServiceLat output, @tTime output, @NDL_TimeEnd output
	set @nPrmPlaceNoHave = 0
	
	select @isIndividual = ISNULL(SV_IsIndividual, 0) from dbo.Service where SV_Key = @nSvKey	
	if @isIndividual = 0
	begin
		
		set @nKey = 0
		exec dbo.GETNEWKEY 'DogovorList', @nKey output
	
  		
			
			set @bRet = 1
			set @nNewKey = @nKey
			if @nAgent <= 0
				set @nAgent = 0
			
		
			Insert into tbl_DogovorList with(updlock) (	DL_DgCod,DL_Key,DL_TurDate,DL_DateBeg,DL_DateEnd,
														DL_TimeBeg,DL_SVKey,DL_Name,DL_NameLat,DL_Day,
														DL_Code,DL_SubCode1,DL_SubCode2,DL_NDays,DL_CnKey,
														DL_CtKey,DL_PartnerKey,DL_Agent,DL_Cost,DL_PaketKey,
														DL_Warning,DL_Control,DL_Creator,DL_Owner,DL_Brutto,
														DL_Discount,DL_NMen,DL_Wait,DL_Attribute,DL_TrKey,
														DL_QuoteKey,DL_DGKey, DL_Comment, DL_FormulaNetto, DL_FormulaBrutto, DL_FormulaDiscount,
														DL_Long, DL_PrtDogKey, DL_TaxZoneId)
											Values	(	@sDogovor,@nKey,@dTour,@dBeg,@dEnd,
														@tTime,@nSvKey,@sService,@sServiceLat,@nDay,
														@nCode,@nCode1,@nCode2,@nNDays,@nCountry,
														@nCity,@nPartner,@nAgent,@nNetto,@nPaket,
														0,@nControl,@nCreator,@nOwner,@nBrutto,
														@nDiscount,@nMen,@bWait,@nAttribute,@nTour,
														0,@nDGKey,@sComment,@sFormulaNetto, @sFormulaBrutto, @sFormulaDiscount,
														@nLong,	@nPrtDog, @nTaxZone)
			
	end
	else -- Task 8984 24.10.2012 kolbeshkin множим по кол-ву туристов услуги с классом, 
	begin -- у которого проставлен признак "Индивидуальное бронирование"
		set @nCounter = 0
		while @nCounter < @nMen
		begin
		
				set @nKey = 0
				exec dbo.GETNEWKEY 'DogovorList', @nKey output
			
				set @bRet = 1
				set @nNewKey = @nKey
				if @nAgent <= 0
					set @nAgent = 0
				
				
				Insert into tbl_DogovorList with(updlock) (	DL_DgCod,DL_Key,DL_TurDate,DL_DateBeg,DL_DateEnd,
															DL_TimeBeg,DL_SVKey,DL_Name,DL_NameLat,DL_Day,
															DL_Code,DL_SubCode1,DL_SubCode2,DL_NDays,DL_CnKey,
															DL_CtKey,DL_PartnerKey,DL_Agent,DL_Cost,DL_PaketKey,
															DL_Warning,DL_Control,DL_Creator,DL_Owner,DL_Brutto,
															DL_Discount,DL_NMen,DL_Wait,DL_Attribute,DL_TrKey,
															DL_QuoteKey,DL_DGKey, DL_Comment, DL_FormulaNetto, DL_FormulaBrutto, DL_FormulaDiscount,
															DL_Long, DL_PrtDogKey, DL_TaxZoneId)
												Values	(	@sDogovor,@nKey,@dTour,@dBeg,@dEnd,
															@tTime,@nSvKey,@sService,@sServiceLat,@nDay,
															@nCode,@nCode1,@nCode2,@nNDays,@nCountry,
															@nCity,@nPartner,@nAgent,@nNetto/@nMen,@nPaket,
															0,@nControl,@nCreator,@nOwner,@nBrutto/@nMen,
															@nDiscount,1,@bWait,@nAttribute,@nTour,
															0,@nDGKey,@sComment,@sFormulaNetto, @sFormulaBrutto, @sFormulaDiscount,
															@nLong,	@nPrtDog, @nTaxZone)
			
			set @nCounter = @nCounter + 1
		end
	end
	
	/*Посадим услугу в квоту*/
	-- если включена настройка о новом квотировании
	if exists (select top 1 1 from SystemSettings with (nolock) where SS_ParmName = 'NewSetToQuota' and SS_ParmValue = 1)
	begin
		-- Указывает, выполняет ли SQL Server автоматический откат текущей транзакции, если инструкция языка Transact-SQL вызывает ошибку выполнения.
		SET XACT_ABORT OFF
		begin try
			exec DogListToQuotas @nKey
		end try
		begin catch
			print 'Произошла ошибка при посадке услуги в квоту! Необходимо проверить лог файл Веб сервиса'
		end catch
	end	
	
	return 0

GO

grant execute on [dbo].[InsDogList] to public

GO
/*********************************************************************/
/* end sp_InsDogList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_InsHistory.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='InsHistory')
	drop proc dbo.InsHistory
go

--<DATE>2013-05-22</DATE>
--<VERSION>2009.2.20.0</VERSION>

CREATE PROCEDURE [dbo].[InsHistory]
(
	@sDGCod varchar(10),
	@nDGKey int,
	@nOAId int,
	@nTypeCode int,
	@sMod varchar(3),
	@sText varchar(254),
	@sRemark varchar(25),
	@nInvisible int,
	@sDocumentNumber varchar(255),
	@bMessEnabled bit=0,
	@nSVKey int=null,
	@nCode int=null,
	@nHiId int=null output,
	@DLKey int=null
)
AS
	declare @sWho varchar(25), @sType varchar(32)
	declare @nHI_USERID int		--MEG00040421 tkachuk 15.03.2011 Id пользователя, внесшего изменения
	
	Set @nHI_USERID = null
	
	EXEC dbo.CurrentUser @sWho output
	EXEC dbo.GetUserKey @nHI_USERID output
	
	select @sType = left(OA_Alias, 32) from ObjectAliases where OA_Id = @nOAId
	
	IF @nDGKey IS NULL AND @sDGCod IS NOT NULL
	BEGIN
		SELECT @nDGKey = DG_KEY 
		FROM dbo.tbl_Dogovor with(nolock)
		WHERE DG_CODE = @sDGCod
	END
	
	INSERT INTO dbo.History with(rowlock) (
		HI_DGCOD, HI_DGKEY, HI_OAId, HI_DATE, HI_WHO, 
		HI_TEXT, HI_MOD, HI_REMARK, HI_TYPE, HI_TYPECODE, 
		HI_INVISIBLE, HI_DOCUMENTNAME, HI_MessEnabled, HI_SVKey, HI_Code, HI_USERID, HI_DLKEY)
	VALUES (
		@sDGCod, @nDGKey, @nOAId, GETDATE(), @sWho, 
		@sText, @sMod, @sRemark, @sType, @nTypeCode, 
		@nInvisible, @sDocumentNumber, @bMessEnabled, @nSVKey, @nCode, @nHI_USERID, @DLKey)

		Set @nHiId = SCOPE_IDENTITY()

	RETURN SCOPE_IDENTITY()
go

grant exec on dbo.InsHistory to public
go

/*********************************************************************/
/* end sp_InsHistory.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_LoadMisQuotas.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[LoadMisQuotas]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[LoadMisQuotas]
go

CREATE PROCEDURE [dbo].[LoadMisQuotas]
(
	@hotelKey int = null,			-- ключ отеля
	@startDate datetime = null,		-- дата начала интервала, по которому изменялись квоты (для стопов передается null)
	@endDate datetime = null,		-- дата окончания интервала, по которому изменялись квоты (для стопов передается null)
	@quotesUpdate bit = null		-- признак того, что обновлять надо квоты (т.е. 1 - обновление квот, 0 - обновление стопов)
)
AS
BEGIN
	if (dbo.mwReplIsSubscriber() = 1)
		return;

	declare @qtid int, @qoid int, @qpid int, @qdid int, @stid int, @qdbusy int, @uskey int, @str nvarchar(max), @str1 nvarchar(max), @str3 nvarchar(max), @hdname varchar(100), 
			@partnerName varchar(100), @rcname varchar(100), @ss_allotmentAndCommitment int, @email varchar(1000), @bkid int, @isErrorState bit  
	
	if (@startDate is null)
		set @startDate = '1900-01-01'
	if (@endDate is null)
		set @endDate = '2099-12-01'
	
	set @str = 'Количество квот, полученное из MIS_Quotas меньше, чем число занятых мест. Параметры квот:'
	set @str1 = 'Из MIS_Quotas пришло отрицательное количество мест. Параметры квот:'
	set @str3 = 'Запрет на заезд не был проставлен, в связи с тем, что не существует квоты в Мастер-Туре. Параметры квот:'
	
	set @isErrorState = 0			
	set @uskey = 0 
	select @uskey = ISNULL(US_Key,0) from dbo.UserList where US_USERID = SYSTEM_USER
	
	declare @mq_Id	int, @mq_PartnerKey int, @mq_HotelKey	int, @mq_RoomCategoryKey int, @mq_Date datetime,
	@mq_State smallint, @mq_CommitmentTotal int, @mq_AllotmentTotal int, @mq_Release int, @mq_StopSale bit, -- 0 - квоты, 1 - стопы 
	@mq_CancelStopSale bit, -- 1 - удаление стопов, 0 - добавление стопов 
	@mq_IsByCheckin bit, -- признак "запрет заезда"
	@mq_ErrorState tinyint -- если равен 1, то заново письмо менеджерам не отправляем
	
		-- ключи квот, которые нужно удалить
	declare @tmpDeleteQuotаs table(
		tmpQoid int,
		tmpQtid int
		)

	if (@quotesUpdate = 1 or @quotesUpdate is null)
	begin
		DECLARE qCur CURSOR FOR
		SELECT	MQ_Id, Mq_PartnerKey, Mq_HotelKey, Mq_RoomCategoryKey, Mq_Date, MQ_CommitmenTotal, MQ_AllotmentTotal, 
				Mq_Release, Mq_StopSale, Mq_CancelStopSale, MQ_ErrorState	
				FROM MIS_Quotas where
									((@hotelKey IS NOT NULL AND MQ_HotelKey = @hotelKey) or (@hotelKey is null))
									--and PTQ_Date between @startDate and @endDate
									and MQ_StopSale=0 
									and (MQ_IsByCheckin <> 1 or MQ_IsByCheckin is null)
		
		OPEN qCur
		FETCH NEXT FROM qCur INTO	@mq_Id, @mq_PartnerKey, @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date, 
							@mq_CommitmentTotal, @mq_AllotmentTotal, @mq_Release, @mq_StopSale, @mq_CancelStopSale, @mq_ErrorState
						
		WHILE @@FETCH_STATUS = 0
		BEGIN 
			BEGIN TRY
				if (@mq_CommitmentTotal >= 0 or (@mq_CommitmentTotal = 0 and @mq_AllotmentTotal = 0))
				begin 
					if not exists (select TOP 1 1
								from Quotas with(nolock)
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and QT_ByRoom = 1
								and QT_IsByCheckIn = 0) 
						and (@mq_CommitmentTotal > 0)
					begin
						insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment, QT_IsByCheckIn) 
						values (@mq_PartnerKey, 1, '', 0)
						set @qtid = SCOPE_IDENTITY()
						
						insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
						values (@qtid, 3, @mq_HotelKey, 0, @mq_RoomCategoryKey)
						set @qoid = SCOPE_IDENTITY()
						
						insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
						values (@qtid, @mq_Date, 2, @mq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
						set @qdid = SCOPE_IDENTITY()
						
						update MIS_Quotas
						set Commitment_MT_Key = @qdid
						where MQ_Id = @mq_Id
						
						insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
						values (@qdid, @mq_Date, @mq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0) 
						
						update QuotaObjects
						set QO_CTKey = (select HD_CTKey from HotelDictionary where HD_Key = QO_Code)
						where QO_SVKey = 3 and QO_ID = @qoid and QO_CTKey is null
					
						update QuotaObjects
						set QO_CNKey= (select CT_CNKey from CityDictionary where CT_Key=QO_CTKey) 
						where QO_CNKey is null and QO_CTKey is not null and QO_ID = @qoid
						
						update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
					end
					else
					begin
						if exists (select TOP 1 1
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and QD_Date = @mq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								and QT_IsByCheckIn = 0)
						begin
							select @qdid = QD_ID, @qdbusy = QD_Busy 
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and QD_Date = @mq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								and QT_IsByCheckIn = 0
							
							if (@qdbusy > @mq_CommitmentTotal)
							begin
								-- если число занятых мест в МТ больше числа мест пришедших из Протура, то в Places = Busy
								update QuotaDetails set QD_Places = QD_Busy, QD_IsDeleted = null where QD_ID = @qdid 
								update QuotaParts set QP_Places = QP_Busy, QP_IsDeleted = null where QP_QDID = @qdid
								
								update MIS_Quotas
								set Commitment_MT_Key = @qdid
								where MQ_Id = @mq_Id
								
								-- чтобы несколько раз письмо не отправлять	
								if (@mq_ErrorState is null)
								begin
									-- и дальше отправляем письмо
									select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
									select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
									select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
									set @str = @str + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
																'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
																'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13) +
																'Количество мест:' + convert(varchar(100),@mq_CommitmentTotal) + CHAR(13)
									print @str
								end
								
								set @isErrorState = 1									
							end 
							else 
							begin
								-- если из Протура приходит 0 и в МТ кол-во занятых мест равно 0, то удаляем квоту, вне зависимости от значения кол-ва мест в МТ
								if (@mq_CommitmentTotal = 0 and @qdbusy = 0) 
								begin
									update QuotaDetails
									set QD_IsDeleted = 4 -- Request
									where QD_ID = @qdid
										
									update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
								end
								else
								begin
									update QuotaDetails set QD_Places = @mq_CommitmentTotal, QD_IsDeleted = null where QD_ID = @qdid 
									update QuotaParts set QP_Places = @mq_CommitmentTotal, QP_IsDeleted = null where QP_QDID = @qdid
									
									update MIS_Quotas
									set Commitment_MT_Key = @qdid
									where MQ_Id = @mq_Id
									
									update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
								end
							end 
						end
						else
						begin
							if (@mq_CommitmentTotal > 0)
							begin
							select top 1 @qtid = QT_ID, @qoid = QO_ID 
								from Quotas with(nolock)
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and QT_ByRoom = 1
								and QT_IsByCheckIn = 0
								order by QT_ID	
								
								insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
								values (@qtid, @mq_Date, 2, @mq_CommitmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
								set @qdid = SCOPE_IDENTITY()								

								update MIS_Quotas
								set Commitment_MT_Key = @qdid
								where MQ_Id = @mq_Id
								
								insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
								values (@qdid, @mq_Date, @mq_CommitmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
								
								update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
							end								
						end
					end
				end 
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage2 as nvarchar(max)
				SET @errorMessage2 = 'Error in SyncProtourQuotes commitment: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage2)
			END CATCH
			
			BEGIN TRY
				if (@mq_AllotmentTotal >= 0 or (@mq_CommitmentTotal = 0 and @mq_AllotmentTotal = 0)) 
					begin
						if not exists (select TOP 1 1
									from Quotas with(nolock) 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @mq_RoomCategoryKey
									and QT_ByRoom = 1
									and QT_IsByCheckIn = 0) 
							and (@mq_AllotmentTotal > 0) 
						begin
							insert into Quotas (QT_PRKey, QT_ByRoom, QT_Comment, QT_IsByCheckIn) 
							values (@mq_PartnerKey, 1, '', 0)
							set @qtid = SCOPE_IDENTITY()
							
							insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
							values (@qtid, 3, @mq_HotelKey, 0, @mq_RoomCategoryKey)
							set @qoid = SCOPE_IDENTITY()
							
							insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
							values (@qtid, @mq_Date, 1, nullif(@mq_Release, 0), @mq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
							set @qdid = SCOPE_IDENTITY()

							update MIS_Quotas
							set Allotment_MT_Key = @qdid
							where MQ_Id = @mq_Id
							
							insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
							values (@qdid, @mq_Date, @mq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0) 
							
							update QuotaObjects
							set QO_CTKey = (select HD_CTKey from HotelDictionary where HD_Key = QO_Code)
							where QO_SVKey = 3 and QO_ID = @qoid and QO_CTKey is null
						
							update QuotaObjects
							set QO_CNKey= (select CT_CNKey from CityDictionary where CT_Key=QO_CTKey) 
							where QO_CNKey is null and QO_CTKey is not null and QO_ID = @qoid
							
							update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
						end
						else
						begin
							if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @mq_RoomCategoryKey
									and QD_Date = @mq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0)
							begin
								select @qdid = QD_ID, @qdbusy = QD_Busy 
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @mq_RoomCategoryKey
									and QD_Date = @mq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0
									
								if (@qdbusy > @mq_AllotmentTotal)
								begin
									-- если число занятых мест в МТ больше числа мест пришедших из Протура, то в Places = Busy
									update QuotaDetails set QD_Places = QD_Busy, QD_Release = nullif(@mq_Release, 0), QD_IsDeleted = null where QD_ID = @qdid 
									update QuotaParts set QP_Places = QP_Busy, QP_IsDeleted = null where QP_QDID = @qdid
												
									update MIS_Quotas
									set Allotment_MT_Key = @qdid
									where MQ_Id = @mq_Id
									-- чтобы несколько раз письмо не отправлять	
									if (@mq_ErrorState is null)
									begin									
										-- и дальше отправляем письмо
										select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
										select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
										select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
										set @str = @str + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13) +
																	'Количество мест:' + convert(varchar(100),@mq_AllotmentTotal) + CHAR(13)																											
									end	
									
									set @isErrorState = 1								
								end 
								else 
								begin
									-- если из Протура приходит 0 и в МТ кол-во занятых мест равно 0, то удаляем квоту, вне зависимости от значения кол-ва мест в МТ
									if (@mq_AllotmentTotal = 0 and @qdbusy = 0) 
									begin
										update QuotaDetails
										set QD_IsDeleted = 4 -- Request
										where QD_ID = @qdid
											
										update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
									end
									else
									begin
										update QuotaDetails set QD_Places = @mq_AllotmentTotal, QD_Release = nullif(@mq_Release, 0), QD_IsDeleted = null where QD_ID = @qdid 
										update QuotaParts set QP_Places = @mq_AllotmentTotal, QP_IsDeleted = null where QP_QDID = @qdid
														
										update MIS_Quotas
										set Allotment_MT_Key = @qdid
										where MQ_Id = @mq_Id
										
										update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
									end									
								end 
							end
							else
							begin
								if (@mq_AllotmentTotal > 0) 
								begin
								select top 1 @qtid = QT_ID, @qoid = QO_ID 
									from Quotas with(nolock) 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and QO_SubCode1 = 0
									and QO_SubCode2 = @mq_RoomCategoryKey
									and QT_ByRoom = 1
									and QT_IsByCheckIn = 0
									order by QT_ID	
									
									insert into QuotaDetails (QD_QTID, QD_Date, QD_Type, QD_Release, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
									values (@qtid, @mq_Date, 1, nullif(@mq_Release, 0), @mq_AllotmentTotal, 0, GETDATE(), ISNULL(@uskey,0)) 
									set @qdid = SCOPE_IDENTITY()									

									update MIS_Quotas
									set Allotment_MT_Key = @qdid
									where MQ_Id = @mq_Id
									
									insert into QuotaParts (QP_QDID, QP_Date, QP_Places, QP_Busy, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey, QP_Limit)
									values (@qdid, @mq_Date, @mq_AllotmentTotal, 0, 0, '', GETDATE(), ISNULL(@uskey,0), 0)
									
									update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
								end 							
							end
						end
					end
				
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage3 as nvarchar(max)
				SET @errorMessage3 = 'Error in SyncProtourQuotes allotment: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage3)
			END CATCH
			
			if (@mq_CommitmentTotal < 0 and @mq_AllotmentTotal < 0)
			begin
				-- и дальше отправляем письмо
				select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
				select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
				select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
				set @str1 = @str1 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
														'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
														'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
														'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13) +
														'Количество мест:' + convert(varchar(100),@mq_AllotmentTotal) + CHAR(13)
				print @str1
			end
			
			-- рассадка в квоты по раннее оформленным услугам, т.е. зажаем в квоты услуги, которые сидят на запросе
			if exists (select TOP 1 1
						from Dogovorlist with(nolock) join HotelRooms with(nolock) on DL_SUBCODE1 = HR_KEY
						where dl_svkey = 3
						and dl_code = @mq_HotelKey
						and ((@mq_RoomCategoryKey = 0) or (HR_RCKEY = @mq_RoomCategoryKey))
						and (select COALESCE(min(SD_State), 4) from ServiceByDate where SD_DLKey = DL_Key) = 4
						and @mq_Date between DL_DateBeg and DL_DATEEND)
			begin
				exec ProtourSetServiceToQuota @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date
			end
			
			if (@isErrorState = 1)
			begin
				-- проставляем PTQ_ErrorState = 1, чтобы не отправлять в след раз письмо, так оно уже было отправлено в первый раз
				-- проставляем Ptq_CommitmentTotal = -1 и Ptq_AllotmentTotal = -1, чтобы запись снова смогла загрузиться из плагина Протура  
				update MIS_Quotas set MQ_ErrorState = 1, MQ_CommitmenTotal = -1, MQ_AllotmentTotal = -1 
				where MQ_Id = @mq_Id	
			end
			else if (@isErrorState = 0 and @mq_CommitmentTotal <= 0 and @mq_AllotmentTotal <= 0)
			begin
				update MIS_Quotas set MQ_ErrorState = null where MQ_Id = @mq_Id
			end
			
			set @isErrorState = 0
		
			FETCH NEXT FROM qCur INTO @mq_Id, @mq_PartnerKey, @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date, 
							@mq_CommitmentTotal, @mq_AllotmentTotal, @mq_Release, @mq_StopSale, @mq_CancelStopSale, @mq_ErrorState
						
		END
		CLOSE qCur
		DEALLOCATE qCur	
		
		-- удаление квот
		exec QuotaDetailAfterDelete
		
		delete QuotaObjects where QO_ID in (select tmpQoid from @tmpDeleteQuotаs)
		delete Quotas where QT_ID in (select tmpQtid from @tmpDeleteQuotаs)
		--
				
		BEGIN TRY
			if exists (select 1 from SystemSettings where SS_ParmName='SYSEmailProtourQuotes')
				select @email = SS_ParmValue from SystemSettings where SS_ParmName='SYSEmailProtourQuotes'
				
			if (@str <> 'Количество квот, полученное из ProTour меньше, чем число занятых мест. Параметры квот:')
			begin
				-- отправка письма, если количество квот, полученное из ProTour меньше, чем число занятых мест				
				insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
			end
			
			if (@str1 <> 'Из ProTour пришло отрицательное количество мест. Параметры квот:')
			begin
				-- отправка письма, если из ProTour пришло отрицательное количество мест
				insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str1, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
			end
		END TRY
		BEGIN CATCH
			DECLARE @errorMessage4 as nvarchar(max)
			SET @errorMessage4 = 'Error in SyncProtourQuotes insert Blanks: ' + ERROR_MESSAGE()
			
			INSERT INTO SystemLog (sl_date, sl_message)
			VALUES (getdate(), @errorMessage4)
		END CATCH
	end
	--обрабатываем стопы
	if (@quotesUpdate = 0 or @quotesUpdate is null) 
	begin
		declare @tmpQuotаs table(
		mqId int,
		mqPartnerKey int,
		mqHotelKey int,
		mqRoomCategoryKey int,
		mqDate datetime,
		mqCommitmentTotal int,
		mqAllotmentTotal int,
		mqRelease int,
		mqStopSale bit,
		mqCancelStopSale bit
		)
		
		insert into @tmpQuotаs select * from
		(SELECT	MQ_Id, Mq_PartnerKey, Mq_HotelKey, Mq_RoomCategoryKey, Mq_Date, MQ_CommitmenTotal, MQ_AllotmentTotal, Mq_Release, Mq_StopSale, Mq_CancelStopSale	
			FROM MIS_Quotas where (MQ_HotelKey = @hotelKey or @hotelKey is null) and MQ_StopSale=1 and MQ_CancelStopSale = 0 and MQ_Date < '2079-06-05'
			and (MQ_IsByCheckin <> 1 or MQ_IsByCheckin is null)
		) as innerQuotas 
		
		DECLARE qCur CURSOR FOR
		
		SELECT	MQ_Id, Mq_PartnerKey, Mq_HotelKey, Mq_RoomCategoryKey, Mq_Date, MQ_CommitmenTotal, MQ_AllotmentTotal, Mq_Release, Mq_StopSale, Mq_CancelStopSale, MQ_IsByCheckin	
			FROM MIS_Quotas where (MQ_HotelKey = @hotelKey or @hotelKey is null) and MQ_StopSale=1 and MQ_Date < '2079-06-05'
										
		OPEN qCur
		FETCH NEXT FROM qCur INTO	@mq_Id, @mq_PartnerKey, @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date, @mq_CommitmentTotal, @mq_AllotmentTotal,
									@mq_Release, @mq_StopSale, @mq_CancelStopSale, @mq_IsByCheckin
						
		WHILE @@FETCH_STATUS = 0
		BEGIN
			BEGIN TRY
				if (@mq_CommitmentTotal = 1 and @mq_AllotmentTotal = 1)
				set @ss_allotmentAndCommitment = 1
				else if (@mq_AllotmentTotal = 1 and @mq_CommitmentTotal = 0) 
					set @ss_allotmentAndCommitment = 0
				else 
					set @ss_allotmentAndCommitment = 1
					
				if (@mq_CancelStopSale = 0 and (@mq_IsByCheckin <> 1 or @mq_IsByCheckin is null)) -- 0 - добавление стопов, 1 - удаление стопов
				begin
					if exists (select TOP 1 1 from QuotaObjects where QO_Code = @mq_HotelKey and QO_SVKey = 3 and QO_SubCode1 = 0 and QO_SubCode2 = @mq_RoomCategoryKey and QO_QTID is null) -- при передаче стопов, здесь лежит RM_Key
					begin
						if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @mq_PartnerKey
								and QO_Code = @mq_HotelKey
								and SS_Date = @mq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3) -- при передаче стопов, здесь лежит RM_Key
						begin
							select @qoid = QO_ID from QuotaObjects where QO_Code = @mq_HotelKey and QO_SVKey = 3 and QO_SubCode1 = 0 and QO_SubCode2 = @mq_RoomCategoryKey and QO_QTID is null 
							
							insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey, SS_LastUpdate)
							values (@qoid, null, @mq_PartnerKey, @mq_Date, @ss_allotmentAndCommitment, '', GETDATE(), ISNULL(@uskey,0), GETDATE())
							set @stid = SCOPE_IDENTITY()							
							
							update MIS_Quotas
							set Allotment_MT_Key = @qoid
							where MQ_Id = @mq_Id
							
						end
						else if exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @mq_PartnerKey
								and QO_Code = @mq_HotelKey
								and SS_Date = @mq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3
								and SS_IsDeleted = 1)
						begin
							update StopSales
							set SS_IsDeleted = 0
							from StopSales join QuotaObjects on SS_QOID=QO_ID
							where SS_PRKey = @mq_PartnerKey
								and QO_Code = @mq_HotelKey
								and SS_Date = @mq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3
								and SS_IsDeleted = 1							
						end
						else
						begin
							if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @mq_PartnerKey
								and QO_Code = @mq_HotelKey
								and SS_Date = @mq_Date
								and QO_SubCode1 = 0
								and QO_SubCode2 = @mq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3)	
							begin
								DECLARE @errorMessage as nvarchar(max)
								SET @errorMessage = 'Error in SyncProtourQuotes stop (not exists):  ' + convert(nvarchar(max), @mq_Id)

								INSERT INTO SystemLog (sl_date, sl_message)
								VALUES (getdate(), @errorMessage)
							end
							else
							begin
								update MIS_Quotas
								set Allotment_MT_Key = -1, Commitment_MT_Key = -1
								where MQ_Id = @mq_Id
							end
						end										
					end
					else
					begin
						insert into QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
						values (null, 3, @mq_HotelKey, 0, @mq_RoomCategoryKey)
						set @qoid = SCOPE_IDENTITY()
						
						insert into StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey, SS_LastUpdate)
								values (@qoid, null, @mq_PartnerKey, @mq_Date, @ss_allotmentAndCommitment, '', GETDATE(), ISNULL(@uskey,0), GETDATE())
								
						set @stid = SCOPE_IDENTITY()
								

						update MIS_Quotas
						set Allotment_MT_Key = @qoid
						where MQ_Id = @mq_Id	
					end
					
					-- временно, для того чтобы отловить ошибку
					if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
						where SS_PRKey = @mq_PartnerKey
						and QO_Code = @mq_HotelKey
						and SS_Date = @mq_Date
						and QO_SubCode1 = 0
						and QO_SubCode2 = @mq_RoomCategoryKey
						and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
						and QO_QTID is null
						and QO_SVKey = 3)	
					begin
						DECLARE @errorMessage1 as nvarchar(max)
						SET @errorMessage1 = 'Error in SyncProtourQuotes stop (not exists):  ' + convert(nvarchar(max), @mq_Id)

						INSERT INTO SystemLog (sl_date, sl_message)
						VALUES (getdate(), @errorMessage1)
									
					end
					--
							
					update QuotaObjects
							set QO_CTKEY = (select HD_CTKEY from HotelDictionary where HD_KEY = QO_Code)
							where QO_ID = @qoid
						
					update QuotaObjects
							set QO_CNKey = (select CT_CNKEY from CityDictionary where CT_KEY = QO_CTKey)
							where QO_CNKey is null
							and QO_CTKey is not null
							and QO_ID = @qoid
				end
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage_1 as nvarchar(max)
				SET @errorMessage_1 = 'Error in SyncProtourQuotes stop: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage_1)
			END CATCH
			BEGIN TRY
				if (@mq_CancelStopSale = 1 and (@mq_IsByCheckin <> 1 or @mq_IsByCheckin is null)) 
				begin
					if (@mq_CommitmentTotal = 1 and @mq_AllotmentTotal = 1)
						set @ss_allotmentAndCommitment = 2
					else if (@mq_AllotmentTotal = 1 and @mq_CommitmentTotal = 0) 
						set @ss_allotmentAndCommitment = 0
					else if (@mq_AllotmentTotal = 0 and @mq_CommitmentTotal = 1) 
						set @ss_allotmentAndCommitment = 1
						
					if (@ss_allotmentAndCommitment = 0 or @ss_allotmentAndCommitment = 1)
					begin
						if exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID = QO_ID
						where QO_Code = @mq_HotelKey
						and QO_SVKey = 3
						and SS_Date = @mq_Date
						and SS_PRKey = @mq_PartnerKey
						and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
						and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
						and QO_QTID is null)
						begin
							delete StopSales
							from StopSales join QuotaObjects on SS_QOID = QO_ID
							where QO_Code = @mq_HotelKey
							and QO_SVKey = 3
							and SS_Date = @mq_Date
							and SS_PRKey = @mq_PartnerKey
							and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
							and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
							and QO_QTID is null
						end
						else
						begin
							print 'Стоп-сейл был уже ранее удален'
						end
					end
					else if (@ss_allotmentAndCommitment = 2) -- если пришла отмена на все (на allotment+commitment и на allotment)
					begin
						if exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID = QO_ID
						where QO_Code = @mq_HotelKey
						and QO_SVKey = 3
						and SS_Date = @mq_Date
						and SS_PRKey = @mq_PartnerKey
						and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
						and QO_QTID is null)
						begin
							delete StopSales
							from StopSales join QuotaObjects on SS_QOID = QO_ID
							where QO_Code = @mq_HotelKey
							and QO_SVKey = 3
							and SS_Date = @mq_Date
							and SS_PRKey = @mq_PartnerKey
							and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
							and QO_QTID is null
						end
						else
						begin
							print 'Стоп-сейл был уже ранее удален'
						end				
					end
					else
					begin
						update MIS_Quotas
						set Allotment_MT_Key = -1, Commitment_MT_Key = -1
						where MQ_Id = @mq_Id
					end
				end
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage9 as nvarchar(max)
				SET @errorMessage9 = 'Error in SyncProtourQuotes cancel stop: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage9)
			END CATCH
			
			-- запретить заезд, т.е если @ptq_IsByCheckin = 1
			BEGIN TRY			
				if (@mq_IsByCheckin = 1 and (@mq_CancelStopSale = 0 or @mq_CancelStopSale is null))
				begin
					if (@mq_CommitmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
									and QD_Date = @mq_Date
									and QT_ByRoom = 1
									and QD_Type = 2
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 1 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
								and QD_Date = @mq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								and QT_IsByCheckIn = 0)
								
							set @qpid = SCOPE_IDENTITY()
							
							update MIS_Quotas
							set Commitment_MT_Key = @qpid
							where MQ_Id = @mq_Id
						end
						else
						begin
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13)							
						end
					end
					if (@mq_AllotmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
									and QD_Date = @mq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 1 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
								and QD_Date = @mq_Date
								and QT_ByRoom = 1
								and QD_Type = 1
								and QT_IsByCheckIn = 0)
								
								set @qpid = SCOPE_IDENTITY()
							
								update MIS_Quotas
								set Commitment_MT_Key = @qpid
								where MQ_Id = @mq_Id
						end
						else
						begin
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13)
						end
					end
				end
				
				--отправляем письмо
				if exists (select 1 from SystemSettings where SS_ParmName='SYSEmailProtourQuotes')
					select @email = SS_ParmValue from SystemSettings where SS_ParmName='SYSEmailProtourQuotes'
				
				if (@str3 <> 'Запрет на заезд не был проставлен, в связи с тем, что не существует квоты в Мастер-Туре. Параметры квот:')
				begin			
					insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str3, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
				end
			
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage_20 as nvarchar(max)
				SET @errorMessage_20 = 'Error in SyncProtourQuotes ByCheckin: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage_20)
			END CATCH
			
			-- отмена запрета на заезд, т.е если @ptq_IsByCheckin = 1 и @ptq_CancelStopSale = 1
			BEGIN TRY			
				if (@mq_IsByCheckin = 1 and @mq_CancelStopSale = 1)
				begin
					if (@mq_CommitmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
									and QD_Date = @mq_Date
									and QT_ByRoom = 1
									and QD_Type = 2
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 0 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
								and QD_Date = @mq_Date
								and QT_ByRoom = 1
								and QD_Type = 2
								and QT_IsByCheckIn = 0)
								
								set @qpid = SCOPE_IDENTITY()
								
								update MIS_Quotas
								set Commitment_MT_Key = @qpid
								where MQ_Id = @mq_Id
						end
						else
						begin
							
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13)				
							
						end						
					end
					if (@mq_AllotmentTotal > 0)
					begin
						if exists (select TOP 1 1
									from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
									inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
									where QT_PRKey = @mq_PartnerKey
									and QO_SVKey = 3
									and QO_Code = @mq_HotelKey
									and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
									and QD_Date = @mq_Date
									and QT_ByRoom = 1
									and QD_Type = 1
									and QT_IsByCheckIn = 0)
						begin
							UPDATE QuotaParts  SET QP_IsNotCheckIn = 0 WHERE QP_QDID in 
								(select QD_ID
								from Quotas with(nolock) inner join QuotaDetails with(nolock) on QT_ID = QD_QTID 
								inner join QuotaObjects with(nolock) on QT_ID = QO_QTID
								where QT_PRKey = @mq_PartnerKey
								and QO_SVKey = 3
								and QO_Code = @mq_HotelKey
								and (QO_SubCode2 = @mq_RoomCategoryKey or @mq_RoomCategoryKey = 0)
								and QD_Date = @mq_Date
								and QT_ByRoom = 1
								and QD_Type = 1
								and QT_IsByCheckIn = 0)
								
								set @qpid = SCOPE_IDENTITY()
							
								update MIS_Quotas
								set Commitment_MT_Key = @qpid
								where MQ_Id = @mq_Id
						end
						else
						begin
							-- и дальше отправляем письмо
							select @hdname = ISNULL(HD_Name,0) from HotelDictionary where HD_Key = @mq_HotelKey
							select @rcname = ISNULL(RC_Name,0) from RoomsCategory where RC_key = @mq_RoomCategoryKey
							select @partnerName = ISNULL(PR_FullName,0) from Partners where PR_Key = @mq_PartnerKey
							set @str3 = @str3 + CHAR(13) + CHAR(13) + 'Партнер:' + convert(varchar(100),@partnerName) + '(' + convert(varchar(100),@mq_PartnerKey) + ')' + CHAR(13) + 
																	'Отель:' + convert(varchar(100),@hdname) + '(' + convert(varchar(100),@mq_HotelKey) + ')' + CHAR(13) +
																	'Категория номера:' + convert(varchar(100),@rcname) + CHAR(13) + 
																	'Дата:' + convert(varchar(100),@mq_Date, 105) + CHAR(13)
						end
					end
				end
				
				--отправляем письмо
				if exists (select 1 from SystemSettings where SS_ParmName='SYSEmailProtourQuotes')
					select @email = SS_ParmValue from SystemSettings where SS_ParmName='SYSEmailProtourQuotes'
				
				if (@str3 <> 'Запрет на заезд не был снят, в связи с тем, что не существует квоты в Мастер-Туре. Параметры квот:')
				begin			
					insert into SendMail (SM_EMAIL, SM_Text, SM_Date, SM_DateGet, SM_Creator, SM_DgKey) values (ISNULL(@email,''), @str3, GETDATE(), '1900-01-01', ISNULL(@uskey,0), 0)
				end
			
			END TRY
			BEGIN CATCH
				DECLARE @errorMessage_21 as nvarchar(max)
				SET @errorMessage_21 = 'Error in SyncProtourQuotes cancel ByCheckin: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

				INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @errorMessage_21)
			END CATCH
			
			FETCH NEXT FROM qCur INTO @mq_Id, @mq_PartnerKey, @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date, @mq_CommitmentTotal, @mq_AllotmentTotal,
							@mq_Release, @mq_StopSale, @mq_CancelStopSale, @mq_IsByCheckin
		END
		CLOSE qCur
		DEALLOCATE qCur
	end
	
	-- Контрольная проверка (проверяем попали ли записи из Протура в МТ). 
	DECLARE Cur CURSOR FOR
	select * from @tmpQuotаs
	
	OPEN Cur
	FETCH NEXT FROM Cur INTO	@mq_Id, @mq_PartnerKey, @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date, @mq_CommitmentTotal, @mq_AllotmentTotal,
								@mq_Release, @mq_StopSale, @mq_CancelStopSale
						
	WHILE @@FETCH_STATUS = 0
	BEGIN
		if not exists (select TOP 1 1 from StopSales join QuotaObjects on SS_QOID=QO_ID
								where SS_PRKey = @mq_PartnerKey
								and QO_Code = @mq_HotelKey
								and SS_Date = @mq_Date
								and QO_SubCode2 = @mq_RoomCategoryKey
								and SS_AllotmentAndCommitment = @ss_allotmentAndCommitment
								and QO_QTID is null
								and QO_SVKey = 3)
		begin
			DECLARE @error as nvarchar(max)
			SET @error = 'Error in SyncProtourQuotes stop not exists: ' + ERROR_MESSAGE() + convert(nvarchar(max), @mq_Id)

			INSERT INTO SystemLog (sl_date, sl_message)
				VALUES (getdate(), @error)
		end
		FETCH NEXT FROM Cur INTO @mq_Id, @mq_PartnerKey, @mq_HotelKey, @mq_RoomCategoryKey, @mq_Date, @mq_CommitmentTotal, @mq_AllotmentTotal,
								@mq_Release, @mq_StopSale, @mq_CancelStopSale
	END
	CLOSE Cur
	DEALLOCATE Cur
	
	
	if not exists (select TOP 1 1 from History where (HI_Date between dateadd(dd,datediff(dd,0,getdate()),0) and getdate()) and HI_Text = 'Произошла закачка квот из ProtourQuotes')
	begin
		insert into History (HI_Date, HI_Text) values (getdate(), 'Произошла закачка квот из ProtourQuotes')
		--update SystemSettings set SS_ParmValue=convert(varchar(100), getdate(), 105) where SS_ParmName = 'SYSProtourQuotesHistory'
	end
															
END
GO

grant exec on [dbo].[LoadMisQuotas] to public
go

/*********************************************************************/
/* end sp_LoadMisQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_MISImportQuotaStops.sql */
/*********************************************************************/
--импорт наличия мест из внешних систем
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MISImportQuotaStops]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[MISImportQuotaStops]
GO

CREATE PROCEDURE [dbo].[MISImportQuotaStops]
	(
--<VERSION>2009.2.19</VERSION>
--<DATE>2013-07-01</DATE>
		@SvKey int,
		@Code int, 
		@SubCode1 int,
		@SubCode2 int,
		@Date datetime,
		@IsStop bit,
		@Places int,
		@PartnerKey int,
		@Comment varchar(255),
		@qdKey int output,
		@ssKey int output
	)
AS
BEGIN	
	SET NOCOUNT ON;

	EXEC [dbo].[MISImportQuotaStops_Delete] @SvKey, @Code, @SubCode1, @SubCode2, @Date, @IsStop, @PartnerKey

	DECLARE @qtKey int, @qoKey int

	BEGIN		
		-- теперь, после того как все удалено, создаем новые квоты и стопы
		IF (@IsStop = 0)
		BEGIN			
			IF @SvKey = 3
			BEGIN
				IF (NOT EXISTS (Select 1 
								FROM QuotaObjects WITH(NOLOCK)
								WHERE QO_QTID in (
												SELECT QT_ID
												FROM Quotas WITH(NOLOCK)
												JOIN QuotaObjects WITH(NOLOCK) ON QT_ID = QO_QTID
												WHERE QT_PRKey = @PartnerKey
													AND QO_SVKey = @SvKey
													AND QO_Code = @Code
												Group By QT_ID
												Having Count(QT_ID) = 1
								)
								AND QO_SubCode1 = @SubCode1
								AND QO_SubCode2 = @SubCode2))	
				BEGIN
					INSERT INTO Quotas (QT_PRKey, QT_ByRoom, QT_Comment)
					VALUES (@PartnerKey, 1, @Comment)
					SET @qtKey = SCOPE_IDENTITY()
					
					INSERT INTO QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
					VALUES (@qtKey, @SvKey, @Code, @SubCode1, @SubCode2)
					SET @qoKey = SCOPE_IDENTITY()
				END
				
				ELSE
				BEGIN
					SELECT @qtKey = QT_ID, @qoKey = QO_ID
					FROM Quotas WITH(NOLOCK)
					JOIN QuotaObjects WITH(NOLOCK) ON QT_ID = QO_QTID
					WHERE QT_PRKey = @PartnerKey
						AND QO_SVKey = @SvKey
						AND QO_Code = @Code
						AND QO_SubCode1 = @SubCode1
						AND QO_SubCode2 = @SubCode2
					PRINT 'добавили квоту в QuotaObjects'
				END
			
				INSERT INTO QuotaDetails(QD_QTID, QD_Date, QD_Type, QD_Places, QD_Busy, QD_CreateDate, QD_CreatorKey)
				VALUES (@qtKey, @Date, 1, @Places, 0, GETDATE(), [dbo].[GetUserId]())
				SET @qdKey = SCOPE_IDENTITY()
				PRINT 'добавили квоту в QuotaDetails'
				INSERT INTO QuotaParts(QP_QDID, QP_Date, QP_Places, QP_Busy, QP_Limit, QP_IsNotCheckIn, QP_Durations, QP_CreateDate, QP_CreatorKey)
				VALUES (@qdKey, @Date, @Places, 0, 1, 0, '', GETDATE(), [dbo].[GetUserId]())
				PRINT 'добавили квоту в QuotaParts'
			END
		END
		ELSE -- обрабатываем стопы
		BEGIN
			IF @SvKey = 3 
			BEGIN
				IF NOT EXISTS (	SELECT 1
								FROM QuotaObjects WITH(NOLOCK)
								WHERE QO_SVKey = @SvKey
								AND QO_Code = @Code
								AND QO_SubCode1 = @SubCode1
								AND QO_SubCode2 = @SubCode2
								AND QO_QTID IS NULL)
				BEGIN
					INSERT INTO QuotaObjects (QO_QTID, QO_SVKey, QO_Code, QO_SubCode1, QO_SubCode2)
					VALUES (NULL, @SvKey, @Code, @SubCode1, @SubCode2)
					SET @qoKey = SCOPE_IDENTITY()
					PRINT 'добавили стоп в QuotaObjects'
				END
				ELSE
				BEGIN
					SELECT @qoKey = QO_ID
					FROM QuotaObjects WITH(NOLOCK)
					WHERE QO_SVKey = @SvKey
						AND QO_Code = @Code
						AND QO_SubCode1 = @SubCode1
						AND QO_SubCode2 = @SubCode2
						AND QO_QTID IS NULL
				END

				INSERT INTO StopSales(SS_QOID, SS_QDID, SS_PRKey, SS_Date, SS_AllotmentAndCommitment, SS_Comment, SS_CreateDate, SS_CreatorKey)
				VALUES (@qoKey, null, @PartnerKey, @Date, 1, @Comment, GETDATE(), [dbo].[GetUserId]())
				SET @ssKey = SCOPE_IDENTITY()
				PRINT 'добавили стоп в StopSales'
			END
		END

		-- обновим информацию о городе и стране вставленной квоты
		UPDATE quotaobjects
		SET qo_ctkey = (SELECT hd_ctkey FROM HotelDictionary WITH(NOLOCK) WHERE hd_key = qo_code)
		WHERE qo_svkey = 3
		AND QO_ID = @qoKey

		UPDATE quotaobjects
		SET qo_cnkey = (SELECT ct_cnKey FROM citydictionary WITH(NOLOCK) WHERE ct_key = qo_ctkey ) 
		WHERE qo_cnkey IS NULL 
		AND qo_ctkey IS NOT NULL
		AND QO_ID = @qoKey
	END
END
GO

GRANT EXEC ON [dbo].[MISImportQuotaStops] TO PUBLIC 
GO
/*********************************************************************/
/* end sp_MISImportQuotaStops.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_MISImportQuotaStops_Delete.sql */
/*********************************************************************/
--удаление квот перед импортом
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MISImportQuotaStops_Delete]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MISImportQuotaStops_Delete]
GO

CREATE PROCEDURE [dbo].[MISImportQuotaStops_Delete]
(
--<VERSION>2009.2.19</VERSION>
--<DATE>2013-06-05</DATE>
	@SvKey int,
	@Code int,
	@SubCode1 int,
	@SubCode2 int,
	@Date datetime,
	@IsStop bit,
	@PartnerKey int
)
AS
BEGIN	

	declare @SDDLKey int, @SDDate datetime

	-- если это квота, то снимаем с нее все услуги (если вдруг что-то сидит, хотя не должно)
	if (@IsStop = 0)
	begin
		-- пометим для удаления
		update QuotaDetails
		set QD_IsDeleted = 4 -- Request
		from QuotaDetails
		join Quotas on QT_ID = QD_QTID
		join QuotaObjects on QT_ID = QO_QTID
		where QO_Code = @Code
		and QD_Type = 1
		and QO_SVKey = @SvKey
		and (@SubCode1 = -1 or QO_SubCode1 = @SubCode1)
		and (@SubCode2 = -1 or QO_SubCode2 = @SubCode2)
		and QD_Date = @Date
		and QT_PrKey = @PartnerKey
		
		-- в этой хранимке снимем, если сидела, и удалим
		exec QuotaDetailAfterDelete
	end

	-- стопы бывают 2 видов:
	-- 1. На объект квотирования 
	delete StopSales
	from StopSales join QuotaObjects on SS_QOID = QO_ID
	where QO_Code = @Code
	and QO_SVKey = @SvKey
	and (@SubCode1 = -1 or QO_SubCode1 = @SubCode1)
	and (@SubCode2 = -1 or QO_SubCode2 = @SubCode2)
	and SS_Date = @Date
	and SS_QDID is null
	and QO_QTID is null
	and SS_PRKey = @PartnerKey
	
	-- 2. на саму квоту (QuotaDetails)
	delete StopSales
	from StopSales
	join QuotaObjects on SS_QOID = QO_ID
	join QuotaDetails on SS_QDID = QD_ID
	join Quotas on QT_ID = QD_QTID and QT_ID = QO_QTID
	where QO_Code = @Code
	and QD_Type = 1
	and QO_SVKey = @SvKey
	and (@SubCode1 = -1 or QO_SubCode1 = @SubCode1)
	and (@SubCode2 = -1 or QO_SubCode2 = @SubCode2)
	and SS_Date = @Date
	and QT_PrKey = @PartnerKey
	
	-- теперь удалим объект квотирования и саму квоту, к которым не привязано ни QuotaDetails, ни StopSales
	delete QuotaObjects
	from QuotaObjects join Quotas on QO_QTID = QT_ID
	where not exists (select 1 from StopSales where SS_QOID = QO_ID)
	and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
	and QO_SVKey = @SvKey
	and QO_Code = @Code
	
	delete Quotas
	from Quotas join QuotaObjects on QT_ID = QO_QTID
	where not exists (select 1 from QuotaObjects where QO_QTID = QT_ID)
	and not exists (select 1 from QuotaDetails where QD_QTID = QT_ID)
	and QO_SVKey = @SvKey
	and QO_Code = @Code
END

GO

grant exec on [dbo].[MISImportQuotaStops_Delete] to public
go

/*********************************************************************/
/* end sp_MISImportQuotaStops_Delete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwAutobusQuotes.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwAutobusQuotes]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwAutobusQuotes]
GO

CREATE PROCEDURE [dbo].[mwAutobusQuotes]
	@Filter varchar(2000),		
	@AgentKey int, 	
	@RequestOnRelease smallint,
	@NoPlacesResult int,
	@CheckAgentQuotes smallint,
	@CheckCommonQuotes smallint,
	@ExpiredReleaseResult int,
	@CountryKeys varchar(2000) = null,
	@CityKey int = null
AS
--<DATE>2013-09-27</DATE>
---<VERSION>9.2.24</VERSION>

if PATINDEX('pt_main', @Filter) <= 0
begin
	if LEN(@Filter) > 0
		set @Filter = @Filter + ' and pt_main > 0 '
	else
		set @Filter = ' pt_main > 0 '
end

---=== СОЗДАНИЕ ВРЕМЕННОЙ ТАБЛИЦЫ ===---
CREATE TABLE #pricesTable
(	
	[TourMessage] varchar (1024) null,
	[CountryKey] [int] NOT NULL,
	[TourDate] [datetime] NULL,
	[TourKey] [int] NULL,
	[TurListKey] [int] NULL,
	[TourDuration] [int] null,--продолжительность тура в днях
	[TourDescription] varchar (2000) null,
	[HotelKey] [int] NULL,
	[HotelKeys] varchar(1024) NULL,
	[HotelPartnerKey] [int] null,
	[HotelDay] [int] null,
	[HotelNights] [int] null,
	[RoomKey] [int] null,
	[RoomCategoryKey] [int] null,
	[RoomCategoryName] [varchar](60) null,	
	[Nights] [int] NULL,	
	[TourName] [varchar](128) NULL,
	[TourTypeKey] [int] NULL,
	[TourTypeName] [varchar] (50) NULL,
	[HotelName] [varchar](60) NULL,		
	[Rate] [varchar](3) NULL,
	[TransportKey] int null,
	[TransferKey] int null,
	[TransferDay] int NULL,
	QuotaPlaces varchar(1024),
	QuotaAllPlaces varchar(1024)
)

declare @rmKey int, @script varchar(8000), @script2 varchar(8000), @mwSearchType int, @rmCount int, @PNames as varchar(4000), @hrKeys varchar(200),
	@cityKeyString as nvarchar(100), @countryKeyString as nvarchar(100)

--временная таблица с нужными типами номеров
--т.е. теми, на которые есть цены
create table #roomKeys (rm_key int null, rm_code varchar(35) null)

create table #minPricesTable (ptCNKey int, ptACKey int, ptRMKey int, ptTourDate datetime, ptTourKey int, ptDays int, ptHDKey int, ptHDKeys varchar(2000), ptHDPartnerKey int,
	ptHDDay int, ptHDNights int, ptRCKey int, ptNights int, ptTourType int, ptPrice decimal)

--ключи размещений и признак - все ли размещения основные
create table #hrKeysStringsTable (hrkey varchar(200), hrmain int)

--данные из таблиц основной базы
create table #services (tl_tikey int,ts_subcode1 int,ts_code int,ts_day int)

select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) where SS_ParmName = 'MWDivideByCountry'

if (@mwSearchType=0)
begin
	set @script = 'select distinct(pt_hotelroomkeys), 0 from mwPriceDataTable where ' + @Filter
	
	insert into #hrKeysStringsTable exec (@script)
	
	declare cur1 cursor fast_forward for select distinct hrkey from #hrKeysStringsTable
	open cur1
	fetch next from cur1 into @hrKeys
	while @@fetch_status = 0
		begin
			--вставляем данные об основных местах для размещений
			set @script = 'update #hrKeysStringsTable
								set hrmain=(select min(ac_main)
											from Accmdmentype with(nolock)
											where ac_key in(select distinct hr_ackey from hotelRooms where hr_key in(' + @hrKeys + '))
											)
								where hrkey=''' + @hrKeys + ''''
			exec (@script)
			fetch next from cur1 into @hrKeys
		end
	close cur1
	deallocate cur1
	
	delete from #hrKeysStringsTable where hrmain=0
	
	set @script = 'select distinct pt_rmkey,pt_rmcode from mwPriceDataTable where ' + @Filter
	INSERT INTO #roomKeys EXEC(@script)
	
	set @script = 'select pt_cnkey, pt_ackey, pt_rmkey, pt_tourdate, pt_tourkey, pt_days, pt_hdkey, pt_hotelkeys, pt_hdpartnerkey,
					pt_hdday, pt_hdnights, pt_rckey, pt_nights, pt_tourtype, min(pt_price)
					from mwPriceDataTable with (nolock)
					inner join #hrKeysStringsTable on pt_hotelroomkeys=hrkey
					where ' + @Filter + '
					and pt_isEnabled=1
					group by pt_cnkey,pt_rmkey,pt_tourdate,pt_tourkey,pt_days,pt_hdkey,pt_hotelkeys,pt_hdpartnerkey,
						pt_hdday,pt_hdnights,pt_rckey,pt_ackey, pt_nights,pt_tourname,pt_tourtype'
	
	INSERT INTO #minPricesTable EXEC(@script)
	
	select @rmCount = count(rm_key) from #roomKeys
	
	if(@rmCount = 0)
		return
	
	declare roomCursor cursor for
		select rm_key from #roomKeys order by rm_key
	
	--добавляем колонки типов номеров в темповую таблицу
	OPEN roomCursor
	FETCH NEXT FROM roomCursor INTO @rmKey
	while @@fetch_status = 0
		begin
			set @script = 'alter table #pricesTable add rmkey_' +  convert(varchar,@rmKey) + ' int, pr_' + convert(varchar,@rmKey) + ' int' 
			
			exec (@script)
			FETCH NEXT FROM roomCursor INTO @rmKey
		end
	close roomCursor
	deallocate roomCursor
	
	-- Cобираем колонки типов номеров для запроса
	set @PNames = ''
	
	select @PNames = @PNames + ',' + '0 as ''rmkey_' + convert(varchar,rm_key) + ''',
		max(case when pt_rmkey = ' + convert(varchar,rm_key) + ' then pt_pricekey else 0 end) as ''pr_' + convert(varchar,rm_key) + ''''
		from #roomKeys
		order by rm_key
	
	set @PNames = substring(@PNames, 2, len(@PNames))
	
	set @script =
		'select '''' as TourMessage,pt_cnkey,pt_tourdate,pt_tourkey,pt_tlkey,pt_days,TL_DESCRIPTION,pt_hdkey,pt_hotelkeys,
			pt_hdpartnerkey,pt_hdday,pt_hdnights,pt_rmkey,pt_rckey,rc_name,pt_nights,pt_tourname,pt_tourtype,tp_name,pt_hdname,pt_rate,ts_subcode1,ts_code,ts_day,-1,-1,'+ @PNames + '
		from mwpricedatatable with(nolock)
		inner join #hrKeysStringsTable on pt_hotelroomkeys=hrkey
		inner join tiptur with(nolock) on pt_tourtype = tp_key
		inner join turlist with(nolock) on pt_tlkey = tl_key
		inner join roomscategory with(nolock) on pt_rckey = rc_key '
		
		if (((select dbo.mwReplIsSubscriber()) = 0) and (select dbo.mwReplIsPublisher()) = 0)
				begin
					set @script = @script
						+ '
						inner join tp_servicelists with(nolock) on tl_tikey = pt_pricelistkey
						inner join tp_services with(nolock) on ts_key = tl_tskey and ts_svkey = 2'
				end
				else
				begin
					set @script2 = '
						select tl_tikey,ts_subcode1,ts_code,ts_day from mt.' + dbo.mwReplPublisherDB() + '.dbo.tp_servicelists with(nolock)
						inner join mt.' + dbo.mwReplPublisherDB() + '.dbo.tp_services with(nolock) on ts_key = tl_tskey and ts_svkey = 2'
					
					insert into #services exec(@script2)
					
					set @script = @script + '
					inner join #services on #services.tl_tikey=pt_pricelistkey'
				end
		
		set @script = @script + '
		where ' + @Filter + '
		and exists(select top 1 1 from #minPricesTable
					where pt_rmkey=ptrmkey
					and pt_cnkey=ptcnkey
					and pt_ackey=ptackey
					and pt_tourdate=pttourdate
					and	pt_tourkey=pttourkey
					and pt_days=ptdays
					and pt_hdkey=pthdkey
					and pt_hdpartnerkey=pthdpartnerkey
					and pt_hdday=pthdday
					and pt_hdnights=pthdnights
					and	pt_rckey=ptrckey
					and pt_days=ptdays
					and pt_nights=ptnights
					and	pt_price=ptprice)
		and pt_isEnabled=1
		group by pt_cnkey,pt_tourdate,pt_tourkey,pt_tlkey,pt_days,TL_DESCRIPTION,pt_hdkey,pt_hotelkeys,pt_hdpartnerkey,pt_hdday,pt_hdnights,
			pt_rckey,rc_name,pt_ackey,pt_rmkey,pt_nights,pt_tourname,pt_tourtype,tp_name,pt_hdname,pt_rate,ts_subcode1,ts_code,ts_day
		order by pt_tourdate, pt_days, tp_name'
	
	INSERT INTO #pricesTable EXEC(@script)
end
else
begin
	declare @now datetime
	
	declare @tableNameString as nvarchar(100), @countryKey int
	
	create table #tables (tableName varchar(200))
	create table #countryKeys (cnkey int)
	
	if (@CountryKeys is not null)
	begin
		insert into #countryKeys select distinct * from dbo.ParseKeys(@CountryKeys)
	end
	else
	begin
		insert into #countryKeys select distinct to_cnkey from tp_tours where to_isEnabled=1
	end
	
	if (@cityKey is null or @cityKey=0)
		begin
			set @cityKeyString = '%'
		end
		else
		begin
			set @cityKeyString = CAST(@cityKey as varchar(100))
		end
	
	declare cur1 cursor fast_forward for select distinct cnkey from #countryKeys
	open cur1
	fetch next from cur1 into @countryKey
	while @@fetch_status = 0
	begin
		if (@countryKey is null or @countryKey=0)
		begin
			set @countryKeyString = '%'
		end
		else
		begin
			set @countryKeyString = CAST(@countryKey as varchar(100))
		end
		
		set @script = 'select distinct rtrim(name) from sys.tables where name like ''mwPriceDataTable_' + @countryKeyString + '_' + @cityKeyString + ''''
		
		insert into #tables exec(@script)
		
		fetch next from cur1 into @countryKey
	end
	close cur1
	deallocate cur1
	
	declare cur0 cursor fast_forward for select distinct tableName from #tables
	open cur0
	fetch next from cur0 into @tableNameString
	while @@FETCH_STATUS = 0
	begin
		set @script = 'select distinct pt_rmkey,pt_rmcode from ' + @tableNameString + ' where not exists(select top 1 1 from #roomKeys where rm_key=pt_rmkey) and ' + @Filter
		
		INSERT INTO #roomKeys EXEC(@script)
		
		declare roomCursor cursor for
				select rm_key from #roomKeys order by rm_key
		
		--добавляем колонки типов номеров в темповую таблицу
		OPEN roomCursor
		FETCH NEXT FROM roomCursor INTO @rmKey
		while @@fetch_status = 0
			begin
				set @script = 'alter table #pricesTable add rmkey_' +  convert(varchar,@rmKey) + ' int, pr_' + convert(varchar,@rmKey) + ' int'
				begin try
					exec (@script)
				end try
				begin catch
					print 'Column already added'
				end catch
				FETCH NEXT FROM roomCursor INTO @rmKey
			end
		close roomCursor
		deallocate roomCursor
		
		fetch next from cur0 into @tableNameString
	end
	close cur0
	deallocate cur0
	
	-- Cобираем колонки типов номеров для запроса
	set @PNames = ''
	
	select @PNames = @PNames + ',
		' + '0 as ''rmkey_' + convert(varchar,rm_key) + ''',max(case when pt_rmkey = ' + convert(varchar,rm_key) + ' then pt_priceKey else 0 end) as ''pr_' + convert(varchar,rm_key) + ''''
		from #roomKeys
		order by rm_key
	
	set @PNames = substring(@PNames, 2, len(@PNames))
	
	declare cur2 cursor fast_forward for select distinct tableName from #tables
	open cur2
	fetch next from cur2 into @tableNameString
	while @@FETCH_STATUS = 0
	begin
		delete from #hrKeysStringsTable
	
		set @script = 'select distinct(pt_hotelroomkeys), 0 from ' + @tableNameString + ' where ' + @Filter
	
		insert into #hrKeysStringsTable exec (@script)
		
		declare cur1 cursor fast_forward for select distinct hrkey from #hrKeysStringsTable
		open cur1
		fetch next from cur1 into @hrKeys
		while @@fetch_status = 0
			begin
				--вставляем данные об основных местах для размещений
				set @script = 'update #hrKeysStringsTable
									set hrmain=(select min(ac_main)
												from Accmdmentype with(nolock)
												where ac_key in(select distinct hr_ackey from hotelRooms where hr_key in(' + @hrKeys + '))
												)
									where hrkey=''' + @hrKeys + ''''
				exec (@script)
				fetch next from cur1 into @hrKeys
			end
		close cur1
		deallocate cur1
		
		delete from #hrKeysStringsTable where hrmain=0
		
		select @rmCount = count(rm_key) from #roomKeys
		
		if(@rmCount <> 0)
		begin
			delete from #minPricesTable
		
			set @script = 'select pt_cnkey,pt_ackey,pt_rmkey,pt_tourdate,pt_tourkey,pt_days,pt_hdkey,pt_hotelkeys,
								pt_hdpartnerkey,pt_hdday,pt_hdnights,pt_rckey,pt_nights,pt_tourtype,min(pt_price)
							from ' + @tableNameString + ' with(nolock)
							where ' + @Filter + '
							and exists(select top 1 1 from #hrKeysStringsTable where pt_hotelroomkeys=hrkey)
							and pt_isEnabled=1
							group by pt_cnkey,pt_rmkey,pt_tourdate,pt_tourkey,pt_days,pt_hdkey,pt_hotelkeys,pt_hdpartnerkey,
								pt_hdday,pt_hdnights,pt_rckey,pt_ackey, pt_nights,pt_tourname,pt_tourtype'
			
			INSERT INTO #minPricesTable EXEC(@script)

			set @script =
				'select '''' as TourMessage,pt_cnkey,pt_tourdate,pt_tourkey,pt_tlkey,pt_days,TL_DESCRIPTION,pt_hdkey,pt_hotelkeys,
					pt_hdpartnerkey,pt_hdday,pt_hdnights,pt_rmkey,pt_rckey,rc_name,pt_nights,pt_tourname,pt_tourtype,tp_name,pt_hdname,pt_rate,ts_subcode1,ts_code,ts_day,-1,-1,'+ @PNames + '
				from ' + @tableNameString + ' with(nolock)
				inner join tipTur with(nolock) on pt_tourtype = tp_key
				inner join turList with(nolock) on pt_tlkey = tl_key
				inner join roomsCategory with(nolock) on pt_rckey = rc_key '
				
				if (((select dbo.mwReplIsSubscriber()) = 0) and (select dbo.mwReplIsPublisher()) = 0)
				begin
					set @script = @script
						+ '
						inner join tp_servicelists with(nolock) on tl_tikey = pt_pricelistkey
						inner join tp_services with(nolock) on ts_key = tl_tskey and ts_svkey = 2'
				end
				else
				begin
					set @script2 = null
					
					if (@CountryKeys is not null)
					begin
						set @script2 = ' where ts_cnkey in (' + @CountryKeys + ')'
					end
					
					set @script2 = 'select tl_tikey,ts_subcode1,ts_code,ts_day from mt.' + dbo.mwReplPublisherDB() + '.dbo.tp_servicelists with(nolock)
						inner join mt.' + dbo.mwReplPublisherDB() + '.dbo.tp_services with(nolock) on ts_key = tl_tskey and ts_svkey = 2 ' + isnull(@script2,'')

					insert into #services exec(@script2)
					
					set @script = @script + '
					inner join #services on #services.tl_tikey=pt_pricelistkey'
				end
				
				set @script = @script + '
				where ' + @Filter + '
				and exists(select top 1 1 from #minPricesTable
							where pt_rmkey=ptrmkey
							and pt_cnkey=ptcnkey
							and pt_ackey=ptackey
							and pt_tourdate=pttourdate
							and	pt_tourkey=pttourkey
							and pt_days=ptdays
							and pt_hdkey=pthdkey
							and pt_hdpartnerkey=pthdpartnerkey
							and pt_hdday=pthdday
							and pt_hdnights=pthdnights
							and	pt_rckey=ptrckey
							and pt_days=ptdays
							and pt_nights=ptnights
							and	pt_price=ptprice)
				and pt_isEnabled=1
				group by pt_cnkey,pt_tourdate,pt_tourkey,pt_tlkey,pt_days,TL_DESCRIPTION,pt_hdkey,pt_hotelkeys,pt_hdpartnerkey,
					pt_hdday,pt_hdnights,pt_rckey,rc_name,pt_ackey,pt_rmkey,pt_nights,pt_tourname,pt_tourtype,tp_name,pt_hdname,pt_rate,ts_subcode1,ts_code,ts_day
				order by pt_tourdate, pt_days, tp_name'
			
			INSERT INTO #pricesTable EXEC(@script)
		end
		fetch next from cur2 into @tableNameString
	end
	close cur2
	deallocate cur2
end

-- Формируем скрипт, заполняющий стоимость по ключу цены
declare @update_price as varchar(4000)
set @update_price = ''

select @update_price = @update_price + 'update #pricesTable set rmkey_' + convert(varchar,rm_key) + ' = TP_Gross from TP_Prices where tp_key = pr_' + convert(varchar,rm_key) + '; '
	from #roomKeys order by rm_key

exec (@update_price)

declare	@HotelKey int, @HotelKeys VARCHAR(1024), @RoomKey int, @RoomCategoryKey int, @FromDate datetime, @HotelPartnerKey int, @HotelDay int,
	@HotelNights int, @TourDuration int, @TourKey int, @TourMessage varchar (1024), @TurListKey int

DECLARE hSql CURSOR
	FOR
		SELECT HotelKey, HotelKeys, RoomKey, RoomCategoryKey,TourDate,HotelPartnerKey,HotelDay,HotelNights,TourDuration,TourKey,TourMessage,TurListKey FROM #pricesTable
	FOR UPDATE OF QuotaPlaces, QuotaAllPlaces, TourMessage

OPEN hSql
FETCH NEXT FROM hSql INTO @HotelKey, @HotelKeys, @RoomKey, @RoomCategoryKey, @FromDate, @HotelPartnerKey, @HotelDay,@HotelNights,@TourDuration,@TourKey,@TourMessage,@TurListKey

declare @qt_places int, @qt_allplaces int, @qt_tourMessage varchar (1024)

WHILE @@FETCH_STATUS = 0
BEGIN	      

	DECLARE @idx INT = 1      
	DECLARE @delimiter CHAR = ','
	DECLARE @slice VARCHAR(1024)
	DECLARE @quotas VARCHAR(1024) = ''
	DECLARE @allQuotas VARCHAR(1024) = ''
	DECLARE @hotelKeysVar VARCHAR(1024) = @HotelKeys
	DECLARE @curHotelKey as int
	
	WHILE @idx != 0       
	BEGIN       
		SET @idx = CHARINDEX(@delimiter, @hotelKeysVar)       
		IF @idx != 0       
			SET @slice = LEFT(@hotelKeysVar, @idx - 1)       
		ELSE       
			SET @slice = @hotelKeysVar    
			   
		SET @curHotelKey = CAST(@slice AS INT)

		SELECT TOP 1 @qt_places = qt_places, @qt_allplaces = qt_allplaces 
					 from mwCheckQuotesEx(3, @curHotelKey, @RoomKey, 
										  @RoomCategoryKey, @AgentKey, 
										  @HotelPartnerKey, @FromDate, 
										  @HotelDay, @HotelNights, 
										  @RequestOnRelease, @NoPlacesResult, 
										  @CheckAgentQuotes, @CheckCommonQuotes, 
										  1, 0, 0, 0, 0, 
										  @TourDuration, @ExpiredReleaseResult)		       
		if LEN(@quotas) > 0
			SET @quotas = @quotas + ',' + cast(@qt_places as VARCHAR(1024))
		else
			SET @quotas = cast(@qt_places as VARCHAR(1024))
		
		if LEN(@allQuotas) > 0
			SET @allQuotas = @allQuotas + ',' + cast(@qt_allplaces as VARCHAR(1024))
		else
			SET @allQuotas = cast(@qt_allplaces as VARCHAR(1024))
			 
			 
		set @hotelKeysVar = RIGHT(@hotelKeysVar, LEN(@hotelKeysVar) - @idx)       
		if LEN(@hotelKeysVar) = 0 break       
	END 
	
	 -- MEG00030302. Golubinsky. 07.06.2011
	SET @qt_tourMessage = ''
	SELECT TOP 1 @qt_tourMessage = MS_Text
	FROM [Messages] with (nolock) WHERE (( @FromDate between MS_ServiceDateBeg AND MS_ServiceDateEnd) AND MS_IsDeleted IS NULL OR MS_IsDeleted = 0) AND MS_LGId IN
			(SELECT DISTINCT LM_LGId FROM LimitationGroups, Limitations, LimitationTours WITH (NOLOCK)
				WHERE LM_ID = LD_LMId AND LG_ID = LM_LGId AND LD_TRKey = @TurListKey)
	ORDER BY MS_ServiceDateBeg, MS_ServiceDateEnd ASC
	-- MEG00030302 end
	
	UPDATE #pricesTable SET QuotaPlaces = @quotas, QuotaAllPlaces = @allQuotas, TourMessage = @qt_tourMessage
		WHERE current of hSql
	
	FETCH NEXT FROM hSql INTO @HotelKey, @HotelKeys, @RoomKey, @RoomCategoryKey, @FromDate, @HotelPartnerKey, @HotelDay,@HotelNights,@TourDuration,@TourKey,@TourMessage,@TurListKey
END
CLOSE hSql
DEALLOCATE hSql

select * from #pricesTable

drop table #pricesTable
drop table #roomKeys
drop table #minPricesTable
drop table #hrKeysStringsTable
GO

grant exec on [dbo].[mwAutobusQuotes] to public
GO
/*********************************************************************/
/* end sp_mwAutobusQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwEnablePriceTourNewSinglePrice.sql */
/*********************************************************************/
if exists (select * from [dbo].sysobjects where id = object_id(N'[dbo].[mwEnablePriceTourNewSinglePrice]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[mwEnablePriceTourNewSinglePrice]
GO

CREATE procedure [dbo].[mwEnablePriceTourNewSinglePrice] 
(
	@toKey int,
	@tempDataTableName varchar (1024)
)
as

begin

	if ISNULL(@tokey, 0) = 0
	return

	declare @today varchar(10)
	set @today = '''' + convert(varchar(10),getdate(), 112 ) + ''''

	declare @cityFromKey int
	declare @countryKey int

	select top 1 @countryKey = tl_cnkey, @cityFromKey = tl_ctdeparturekey
	from TurList with(nolock) join tp_tours with(nolock) on to_trkey = tl_key
	where to_key = @toKey

	declare @mwSinglePrice nvarchar(10)
	select @mwSinglePrice = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePrice'), N'0')

	if (dbo.mwReplIsPublisher() > 0)
		set @mwSinglePrice = '0'

	if @mwSinglePrice = '0'
	return

	declare @tableName varchar(100)

	declare @mwSearchType int
	select @mwSearchType = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings 
	where SS_ParmName = 'MWDivideByCountry'
	 
	if (@mwSearchType = 0)
		set @tableName = 'dbo.mwPriceDataTable'
	else
		set @tableName = dbo.mwGetPriceTableName(@countryKey, @cityFromKey)

	declare @sql varchar(8000)
	declare @where varchar(8000)

	declare @mwSinglePriceType nvarchar(10) -- 'last' or 'min'
	select @mwSinglePriceType = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceType'), N'last') 

	declare @mwSinglePriceAllTours nvarchar(10) -- single price for tour
	select @mwSinglePriceAllTours = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllTours'), N'0') 

	declare @mwSinglePriceAllHotelPrt nvarchar(10) -- single price for hotel partner
	select @mwSinglePriceAllHotelPrt = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllHotelPrt'), N'0') 

	declare @mwSinglePriceAllFlightPrt nvarchar(10) -- single price for flight partner
	select @mwSinglePriceAllFlightPrt = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllFlightPrt'), N'0')

	declare @mwSinglePriceAllTourTypes nvarchar(10) -- single price for tour type
	select @mwSinglePriceAllTourTypes = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllTourTypes'), N'0')

	declare @mwSinglePriceAllDeparts nvarchar(10) -- single price for depart from
	select @mwSinglePriceAllDeparts = isnull(dbo.GetCountrySetting(@countryKey, 'mwSinglePriceAllDeparts'), N'1')

	set @where = ' main.pt_main > 0 and main.pt_tourdate >= getdate() ' +
			 ' and main.pt_hdkey = temp.pt_hdkey ' + 
			 ' and main.pt_rmkey = temp.pt_rmkey ' + 
			 ' and main.pt_rckey = temp.pt_rckey ' + 
			 ' and main.pt_ackey = temp.pt_ackey ' + 
			 ' and main.pt_pnkey = temp.pt_pnkey ' + 
			 ' and main.pt_tourdate = temp.pt_tourdate ' + 
			 ' and main.pt_days = temp.pt_days ' + 
			 ' and main.pt_nights = temp.pt_nights ' 
						 
	if(@mwSinglePriceAllHotelPrt = '0') -- single price for hotel partner
		set @where = @where + ' and main.pt_hdpartnerkey = temp.pt_hdpartnerkey ' 

	if(@mwSinglePriceAllFlightPrt = '0') -- single price for flight partner
		set @where = @where + ' and main.pt_chprkey = temp.pt_chprkey ' 

	if(@mwSinglePriceAllTourTypes = '0') -- single price for tour type
		set @where = @where + ' and main.pt_tourtype = temp.pt_tourtype ' 

	if(@mwSinglePriceAllDeparts = '0') -- single price for departfrom
		set @where = @where + ' and main.pt_ctkeyfrom = temp.pt_ctkeyfrom ' 

	if(@mwSinglePriceType = 'min')
		set @where = @where + ' and main.pt_price > temp.pt_price ' 
	else if (@mwSinglePriceType = 'last')
		set @where = @where + ' and main.pt_tourcreated < temp.pt_tourcreated '

	if(@mwSinglePriceAllTours = '0')
		set @where = @where + ' and main.pt_tourkey = ' + ltrim(str(@tokey))
	else
		set @where = @where + ' and main.pt_tourkey != '+ ltrim(str(@tokey))

	create table #keysTable (xKey int, xPriceKey int, xTourKey int)
			
	set @sql = 'insert into #keysTable 
				select main.pt_key, main.pt_priceKey, main.pt_tourkey from ' + @tableName + ' main with(nolock), ' + @tempDataTableName + ' temp with(nolock) where ' + @where

	--print @sql
	exec(@sql)

	set @sql = 'update ' + @tableName + ' set pt_isenabled = 0, pt_autodisabled = 1 where pt_key in (select xKey from #keysTable)'
	--print @sql
	exec(@sql)

	-- выключаем вслед за ними соответствующие данные из tp_turdates
	set @sql = '
			update updturdates with(rowlock)
			set td_autodisabled = 1
			from tp_turdates updturdates
			where td_autodisabled = 0 and
				exists(select top (1) 1 from ' + @tableName + ' with(nolock) 
						where ' + @tableName + '.pt_tourkey = updturdates.td_tokey
								and ' + @tableName + '.pt_tourdate = updturdates.td_date
								and ' + @tableName + '.pt_pricekey in (select xPriceKey from #keysTable with (nolock)))
			and not exists (select top (1) 1 from ' +@tableName + ' with(nolock) 
						where ' + @tableName+ ' .pt_tourkey = updturdates.td_tokey
								and ' + @tableName + '.pt_tourdate = updturdates.td_date 
								and ' + @tableName + '.pt_isenabled = 1)'

	--print @sql
	exec (@sql)

	drop table #keysTable

	update dbo.mwSpoDataTable set sd_isenabled = 1 where sd_tourkey = @tokey
		
end
GO

GRANT exec ON [dbo].[mwEnablePriceTourNewSinglePrice] TO PUBLIC
GO

/*********************************************************************/
/* end sp_mwEnablePriceTourNewSinglePrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwFillTP.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwFillTP]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[mwFillTP]
GO

CREATE procedure [dbo].[mwFillTP] (@tokey int, @calcKey int = null)
as
begin
	-- <date>2013-10-14</date>
	-- <version>2009.2.20.1</version>
	declare @sql varchar(4000)
	declare @source varchar(200)
	set @source = ''
	
	declare @where as varchar(4000)

	declare @tokeyStr varchar (20)
	set @tokeyStr = cast(@tokey as varchar(20))

	declare @calcKeyStr varchar (20)
	set @calcKeyStr = cast(@calcKey as varchar(20))

	if dbo.mwReplIsSubscriber() > 0 and len(dbo.mwReplPublisherDB()) > 0
		set @source = '[mt].' + dbo.mwReplPublisherDB() + '.'
	
	delete from dbo.tp_tours where to_key = @calcKey	
	if not exists(select 1 from dbo.tp_tours with(nolock) where to_key = @tokey)
	begin
		set @sql = '
		insert into dbo.tp_tours with(rowlock) (
			[TO_Key],
			[TO_TRKey],
			[TO_Name],
			[TO_PRKey],
			[TO_CNKey],
			[TO_Rate],
			[TO_DateCreated],
			[TO_DateValid],
			[TO_PriceFor],
			[TO_OpKey],
			[TO_XML],
			[TO_DateBegin],
			[TO_DateEnd],
			[TO_IsEnabled],
			[TO_PROGRESS],
			[TO_UPDATE],
			[TO_UPDATETIME],
			[TO_DateValidBegin],
			[TO_CalculateDateEnd],
			[TO_PriceCount],
			[to_attribute],
			[TO_MinPrice],
			[TO_HotelNights]
		)
		select
			[TO_Key],
			[TO_TRKey],
			[TO_Name],
			[TO_PRKey],
			[TO_CNKey],
			[TO_Rate],
			[TO_DateCreated],
			[TO_DateValid],
			[TO_PriceFor],
			[TO_OpKey],
			[TO_XML],
			[TO_DateBegin],
			[TO_DateEnd],
			[TO_IsEnabled],
			[TO_PROGRESS],
			[TO_UPDATE],
			[TO_UPDATETIME],
			[TO_DateValidBegin],
			[TO_CalculateDateEnd],
			[TO_PriceCount],
			[to_attribute],
			[TO_MinPrice],
			[TO_HotelNights]
		from
			' + @source + 'dbo.tp_tours with(nolock)
		where
			to_key = ' + @tokeyStr

		exec (@sql)
	end
	
	if(@calcKey is not null)
		delete from dbo.TP_TurDates where TD_CalculatingKey = @calcKey
	else
		delete from dbo.TP_TurDates where TD_TOKey = @tokey
		
	--if not exists(select 1 from dbo.TP_TurDates with(nolock) where td_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.TP_TurDates with(rowlock) (
			[TD_Key],
			[TD_TOKey],
			[TD_Date],
			[TD_UPDATE],
			[TD_CHECKMARGIN],
			[TD_CalculatingKey]
		)
		select top 10000
			r.[TD_Key],
			r.[TD_TOKey],
			r.[TD_Date],
			r.[TD_UPDATE],
			r.[TD_CHECKMARGIN],
			r.[TD_CalculatingKey]
		from
			' + @source + 'dbo.TP_TurDates as r with(nolock)
		where
			'
			
		set @where = ''
		if(@calcKey is not null)
			set @where = 'r.TD_Date in (select TP_DateBegin from ' + @source + 'dbo.TP_Prices where TP_TOKey = TD_TOKey and TP_CalculatingKey = ' + ltrim(str(@calcKey)) + ') and '
			
		set @where = @where + ' r.TD_TOKey = ' + @tokeyStr
		set @where = @where + ' and r.TD_Key not in (select TD_Key from dbo.TP_TurDates where TD_TOKey = ' + @tokeyStr + ')'

		set @sql = 'while exists (select top 1 1 from ' + @source + 'dbo.TP_TurDates as r with (nolock) where ' + @where + ')
		begin
		' + @sql + @where + '
		end'
		
		exec (@sql)		
	end	
	
    delete dbo.tp_services where ts_tokey = @tokey
	--if not exists(select 1 from dbo.tp_services with(nolock) where ts_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.tp_services with(rowlock) (
			[TS_Key],
			[TS_TOKey],
			[TS_SVKey],
			[TS_Code],
			[TS_SubCode1],
			[TS_SubCode2],
			[TS_CNKey],
			[TS_CTKey],
			[TS_Day],
			[TS_Days],
			[TS_Men],
			[TS_Name],
			[TS_OpPartnerKey],
			[TS_OpPacketKey],
			[TS_Attribute],
			[TS_TEMPGROSS],
			[TS_CHECKMARGIN],
			[TS_CalculatingKey]
		)
		select top 10000
			[TS_Key],
			[TS_TOKey],
			[TS_SVKey],
			[TS_Code],
			[TS_SubCode1],
			[TS_SubCode2],
			[TS_CNKey],
			[TS_CTKey],
			[TS_Day],
			[TS_Days],
			[TS_Men],
			[TS_Name],
			[TS_OpPartnerKey],
			[TS_OpPacketKey],
			[TS_Attribute],
			[TS_TEMPGROSS],
			[TS_CHECKMARGIN],
			[TS_CalculatingKey]
		from
			' + @source + 'dbo.tp_services with(nolock)
		where
			'

		set @where = ''
		set @where = 'TS_TOKey = ' + @tokeyStr
		set @where = @where + ' and TS_Key not in (select TS_Key from dbo.tp_services with (nolock) where TS_TOKey = ' + @tokeyStr + ')'

		set @sql = 'while exists (select top 1 1 from ' + @source + 'dbo.tp_services  as r with (nolock) where ' + @where + ')
		begin
		' + @sql + @where + '
		end'

		exec (@sql)
	end

	delete from dbo.tp_lists where ti_tokey = @tokey
	--if not exists(select 1 from dbo.tp_lists with(nolock) where ti_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.tp_lists with(rowlock) (
			[TI_Key],
			[TI_TOKey],
			[TI_Name],
			[TI_FirstHDKey],
			[TI_FirstHRKey],
			[TI_FirstPNKey],
			[TI_Days],
			[TI_HotelKeys],
			[TI_PansionKeys],
			[TI_HotelDays],
			[TI_FirstHDStars],
			[TI_FirstRsKey],
			[TI_SecondHDKey],
			[TI_SecondHRKey],
			[TI_SecondPNKey],
			[TI_SecondHDStars],
			[TI_SecondCtKey],
			[TI_SecondRsKey],
			[TI_CtKeyFrom],
			[TI_CtKeyTo],
			[TI_ApKeyFrom],
			[TI_ApKeyTo],
			[ti_firsthotelday],
			[ti_hdpartnerkey],
			[ti_totaldays],
			[ti_nights],
			[ti_lasthotelday],
			[ti_chkey],
			[ti_chbackkey],
			[ti_hdday],
			[ti_hdnights],
			[ti_chday],
			[ti_chbackday],
			[ti_chpkkey],
			[ti_chprkey],
			[ti_chbackpkkey],
			[ti_chbackprkey],
			[TI_FirstCtKey],
			[TI_UPDATE],
			[TI_FIRSTHOTELPARTNERKEY],
			[ti_hotelroomkeys],
			[ti_hotelstars],
			[TI_CalculatingKey]
		)
		select top 10000
			[TI_Key],
			[TI_TOKey],
			[TI_Name],
			[TI_FirstHDKey],
			[TI_FirstHRKey],
			[TI_FirstPNKey],
			[TI_Days],
			[TI_HotelKeys],
			[TI_PansionKeys],
			[TI_HotelDays],
			[TI_FirstHDStars],
			[TI_FirstRsKey],
			[TI_SecondHDKey],
			[TI_SecondHRKey],
			[TI_SecondPNKey],
			[TI_SecondHDStars],
			[TI_SecondCtKey],
			[TI_SecondRsKey],
			[TI_CtKeyFrom],
			[TI_CtKeyTo],
			[TI_ApKeyFrom],
			[TI_ApKeyTo],
			[ti_firsthotelday],
			[ti_hdpartnerkey],
			[ti_totaldays],
			[ti_nights],
			[ti_lasthotelday],
			[ti_chkey],
			[ti_chbackkey],
			[ti_hdday],
			[ti_hdnights],
			[ti_chday],
			[ti_chbackday],
			[ti_chpkkey],
			[ti_chprkey],
			[ti_chbackpkkey],
			[ti_chbackprkey],
			[TI_FirstCtKey],
			[TI_UPDATE],
			[TI_FIRSTHOTELPARTNERKEY],
			[ti_hotelroomkeys],
			[ti_hotelstars],
			[TI_CalculatingKey]
		from
			' + @source + 'dbo.tp_lists with(nolock)
		where
			'
			
		set @where = ''
		if(@calcKey is not null)
			set @where = 'TI_Key in (select TP_TIKey from ' + @source + 'dbo.TP_Prices where TP_TOKey = TI_TOKey and TP_CalculatingKey = ' + ltrim(str(@calcKey)) + ') and '
		
		set @where = @where + 'TI_TOKey = ' + @tokeyStr
		set @where = @where + ' and TI_Key not in (select TI_Key from dbo.tp_lists with (nolock) where TI_TOKey = ' + @tokeyStr + ')'

		set @sql = 'while exists (select top 1 1 from ' + @source + 'dbo.tp_lists as r with (nolock) where ' + @where + ')
		begin
		' + @sql + @where + '
		end'

		exec (@sql)
	end

	delete from dbo.tp_servicelists where tl_tokey = @tokey
	--if not exists(select 1 from dbo.tp_servicelists with(nolock) where tl_tokey = @calcKey)
	begin	
		set @sql = 
		'
		set identity_insert tp_serviceLists on

		insert into dbo.tp_servicelists with(rowlock) (
			[TL_Key],
			[TL_TOKey],
			[TL_TSKey],
			[TL_TIKey],
			[TL_CalculatingKey]
		)
		select top 10000
			[TL_Key],
			[TL_TOKey],
			[TL_TSKey],
			[TL_TIKey],
			[TL_CalculatingKey]
		from
			' + @source + 'dbo.tp_servicelists with(nolock)
		where
			'

		set @where = 'TL_TOKey = ' + @tokeyStr
		set @where = @where + ' and TL_Key not in (select TL_Key from dbo.tp_servicelists with (nolock) where TL_TOKey = ' + @tokeyStr + ')'

		set @sql = 'while exists (select top 1 1 from ' + @source + 'dbo.tp_servicelists as r with (nolock) where ' + @where + ')
		begin
		' + @sql + @where + '
		end
		
		set identity_insert tp_serviceLists off'

		exec (@sql)
	end

	delete from dbo.tp_prices where tp_tokey = @tokey
	--if not exists(select 1 from dbo.tp_prices with(nolock) where tp_tokey = @calcKey)
	begin
		set @sql = 
		'insert into dbo.tp_prices with(rowlock) (
			[TP_Key],
			[TP_TOKey],
			[TP_DateBegin],
			[TP_DateEnd],
			[TP_Gross],
			[TP_TIKey],
			[TP_CalculatingKey]
		)
		select top 5000
			[TP_Key],
			[TP_TOKey],
			[TP_DateBegin],
			[TP_DateEnd],
			[TP_Gross],
			[TP_TIKey],
			[TP_CalculatingKey]
		from
			' + @source + 'dbo.tp_prices with(nolock)
		where
			'

		set @where = ''
		if(@calcKey is not null)
			set @where = 'TP_CalculatingKey = ' + @calcKeyStr + ' and TP_Key not in (select TP_Key from dbo.tp_prices with (nolock) where TP_CalculatingKey = ' + @calcKeyStr + ')'
		else
			set @where = 'TP_TOKey = ' + @tokeyStr + ' and TP_Key not in (select TP_Key from dbo.tp_prices with (nolock) where TP_TOKey = ' + @tokeyStr + ')'
			
		set @sql = 'while exists (select top 1 1 from ' + @source + 'dbo.tp_prices as r with (nolock) where ' + @where + ')
		begin
		' + @sql + @where + '
		end'
		
		exec (@sql)
	end
end
GO

GRANT EXEC ON [dbo].[mwFillTP] TO PUBLIC
GO
/*********************************************************************/
/* end sp_mwFillTP.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwGetHotelTypeImageHtml.sql */
/*********************************************************************/
if exists(select id from sysobjects where id = OBJECT_ID('mwGetHotelTypeImageHtml') and xtype = 'P')
	drop procedure dbo.mwGetHotelTypeImageHtml
go
--<DATE>2013-07-03</DATE>
---<VERSION>Main</VERSION>
CREATE procedure mwGetHotelTypeImageHtml 
	  @hotelID int
	, @sourceFolder varchar(64) = ''
as
begin
	declare @result varchar(2048)
	set @result = ''

	select @result = @result + '<img alt="' + htt_name + '" title="' + htt_name + '" src="' + @sourceFolder + HTT_ImageName + '" />'
	from HotelTypes with(nolock)
		join HotelTypeRelations with(nolock) on htr_httkey = htt_id
	where htr_hdkey = @hotelID and isnull(HTT_ImageName, '') != ''
	order by htt_id

	if (len(@result) > 0)
		set @result = '<div style="display:inline;">' + @result + '</div>'
	
	select @result as HotelTypeImageHtml
end
go

grant exec on dbo.mwGetHotelTypeImageHtml to public
go
/*********************************************************************/
/* end sp_mwGetHotelTypeImageHtml.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwGetTourMonthesQuotas.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='mwGetTourMonthesQuotas')
	drop proc dbo.mwGetTourMonthesQuotas
GO

--<DATE>2013-08-28</DATE>
--<VERSION>2009.17.2</VERSION>

CREATE proc [dbo].[mwGetTourMonthesQuotas] 
@month_count smallint,
@agent_key int,
@quoted_services nvarchar(100),
@cnkey int,
@tour_type int,
@checkAllPartnersQuota smallint,
@requestOnRelease smallint,
@noPlacesResult smallint,
@checkAgentQuotes smallint,
@checkCommonQuotes smallint,
@checkNoLongQuotes smallint,
@findFlight smallint,
@checkFlightPacket smallint,
@expiredReleaseResult smallint
as
begin
	create table #tourQuotas(
		tour_key int,
		tour_name nvarchar(250),
		tour_url nvarchar(500),
		tour_quotas nvarchar(4000)
	)
	
	declare tour_cursor cursor fast_forward read_only for
		select td_trkey, isnull(tl_nameweb, isnull(tl_name, '')), isnull(tl_webhttp, '') as tour_url, td_date, month(td_date), tl_nday
		from turdate with(nolock)
		inner join turlist with(nolock) on tl_key = td_trkey
		inner join tp_tours with(nolock) on to_trkey = td_trkey
		where td_date between getdate() 
			and dateadd(month, @month_count, getdate()) 
			and ((@cnkey >= 0 and tl_cnkey = @cnkey) or (@tour_type >= 0 and tl_tip = @tour_type))
			and to_isenabled = 1 
		order by isnull(tl_nameweb, isnull(tl_name, '')),td_date                 
	
	declare @tour_key int, @prev_tour_key int, @prev_month int, @tour_name nvarchar(250), @tour_url nvarchar(500), @tour_date datetime,
	@month int, @tour_quotas nvarchar(4000), @tour_duration int
	
	set @tour_key = -1
	set @prev_tour_key = -1
	set @prev_month = -1
	set @tour_name = ''
	set @tour_url = ''
	set @tour_date = '1800-01-01'
	set @month = 0
	set @tour_quotas = ''
	
	open tour_cursor
	
	create table #turService(
		ts_key int,
		ts_svkey int,
		ts_code int,
		ts_subcode1 int,
		ts_subcode2 int,
		ts_day int,
		ts_ndays int,
		ts_partnerkey int,
		ts_pkkey int
	)
	
	declare @sql nvarchar(4000)
	
	fetch next from tour_cursor into @tour_key, @tour_name, @tour_url, @tour_date, @month, @tour_duration
	while @@fetch_status = 0
	begin
		if (@tour_key != @prev_tour_key)
		begin
			insert into #tourQuotas (tour_key,	tour_name, tour_url) values (@tour_key, @tour_name, @tour_url)
			
			set @prev_month = -1
			
			if (@prev_tour_key > 0)
			begin
				update #tourQuotas set tour_quotas = @tour_quotas where tour_key = @prev_tour_key
			end
			
			set @tour_quotas = ''
			
			truncate table #turService
			
			set @sql = N'select ts_key, ts_svkey, ts_code,
							(case TS_SVKEY when 3 then (select HR_RMKEY from HotelRooms with(nolock) where HR_KEY=t1.ts_subcode1) else t1.ts_subcode1 end) as ts_subcode1,
							(case TS_SVKEY when 3 then (select HR_RCKEY from HotelRooms with(nolock) where HR_KEY=t1.ts_subcode1) else t1.ts_subcode1 end) as ts_subcode2,
							ts_day, ts_ndays, ts_partnerkey, ts_pkkey
						from turService t1 with(nolock)
						where ts_trkey = ' + str(@tour_key) + N' and ts_svkey in (' + isnull(@quoted_services, N'3') + N')'
			insert into #turService exec(@sql)
		end
		
		declare @key int, @svkey int, @code int, @subcode1 int, @subcode2 int, @day int, @ndays int,
			@partner_key int, @packet_key int, @places int, @allplaces int, @date_places int, @date_allplaces int, @qt_addit nvarchar(100)
		
		if (@month != @prev_month or @tour_key != @prev_tour_key)
		begin
			if (len(@tour_quotas) > 0)         
			begin
				set @tour_quotas = @tour_quotas + '|' 
			end
			
			set @tour_quotas = @tour_quotas + ltrim(str(@month)) + '='
		end
		
		declare service_cursor cursor fast_forward read_only for
			select ts_key, ts_svkey, ts_code, ts_subcode1, ts_subcode2, ts_day, ts_ndays,
				(case when @checkAllPartnersQuota > 0 then -1 else ts_partnerkey end),
				(case when ts_svkey = 1 and @checkFlightPacket > 0 then ts_pkkey else -1 end)
			from #turService
		
		set @date_places = 1000
		set @date_allplaces = 1000
		set @places = null
		set @allplaces = null
		
		open service_cursor
		
		fetch next from service_cursor into @key, @svkey, @code, @subcode1, @subcode2, @day, @ndays, @partner_key, @packet_key
		while @@fetch_status = 0
		begin
						select @places = qt_places, @allplaces = qt_allplaces, @qt_addit = qt_additional
			from dbo.mwCheckQuotesEx(@svkey, 
				@code, 
				@subcode1, 
				@subcode2, 
				@agent_key, 
				@partner_key, 
				@tour_date,
				@day,
				@ndays,
				@requestOnRelease,
				@noPlacesResult,
				@checkAgentQuotes,
				@checkCommonQuotes,
				@checkNoLongQuotes,
				@findFlight,
				0,
				0,
				@packet_key,
				@tour_duration,
				@expiredReleaseResult)
			
			if (@places > 0 and (@date_places > 0 or @date_places is null))
			begin
				set @date_places = @places
				set @date_allplaces = @allplaces
			end
			
			if (@places = -1 and @qt_addit is null and @date_places <> 0)
			begin
				set @date_places = -1
				set @date_allplaces = 0
			end
			
			if (@places < -1 or @places = 0)
			begin
				set @date_places = @places
				set @date_allplaces = @allplaces
			end
			
			fetch next from service_cursor into @key, @svkey, @code, @subcode1, @subcode2, @day, @ndays, @partner_key, @packet_key
		end
		
		close service_cursor
		deallocate service_cursor
		
		if (@date_places is null)
		begin
			set @date_places = -1
			set @date_allplaces = 0
		end
		
		if(substring(@tour_quotas, len(@tour_quotas), 1) != '=')
		begin
			set @tour_quotas = @tour_quotas + ','
		end
		
		set @tour_quotas = @tour_quotas + ltrim(str(day(@tour_date))) + '#' + ltrim(str(@date_places)) + ':' + ltrim(str(@date_allplaces))
		set @prev_tour_key = @tour_key
		set @prev_month = @month
		
		fetch next from tour_cursor into @tour_key, @tour_name, @tour_url, @tour_date, @month, @tour_duration
	end
	
	update #tourQuotas set tour_quotas = @tour_quotas where tour_key = @prev_tour_key
	
	close tour_cursor
	deallocate tour_cursor
	
	select * from #tourQuotas
end
GO

grant exec on dbo.mwGetTourMonthesQuotas to public
GO
/*********************************************************************/
/* end sp_mwGetTourMonthesQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwHotelQuotes.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwHotelQuotes]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[mwHotelQuotes]

GO
CREATE PROCEDURE [dbo].[mwHotelQuotes]
	(
		-- хранимка получает сведения о квотах для отелей
		--<version>2009.2.20</version>
		--<date>2013-07-18</date> 
		@Filter varchar(2000),
		@DaysCount int,
		@AgentKey int, 
		@FromDate	datetime,
		@RequestOnRelease smallint,
		@NoPlacesResult int,
		@CheckAgentQuotes smallint,
		@CheckCommonQuotes smallint,
		@ExpiredReleaseResult int
	)
AS
BEGIN

DECLARE @checkQuotesOnWebService as bit, @checkQuotesService as nvarchar(150)
DECLARE @webServiceFailure as bit

-- признак ошибки веб-сервиса
SET @webServiceFailure = 0
-- проверять квоты через веб-сервис
SET @checkQuotesOnWebService = 0
SELECT TOP 1 @checkQuotesOnWebService = ss_parmvalue FROM systemsettings WITH (nolock) WHERE ss_parmname = 'NewSetToQuota'

-- создание временной таблицы
CREATE TABLE #tmp
(
	CityKey int,
	CityName varchar(50) COLLATE Cyrillic_General_BIN,
	HotelKey int,
	HotelName varchar(200) COLLATE Cyrillic_General_BIN,
	HotelHTTP varchar(254),
	RoomKey int,
	RoomName varchar(35) COLLATE Cyrillic_General_BIN,
	RoomCategoryKey int,
	RoomCategoryName varchar(60) COLLATE Cyrillic_General_BIN,
	Quotas varchar(2000),
	HotelRoomsKey int,
	HotelRoomsMain int
)

-- формирование данных
DECLARE	@HotelKey int
DECLARE	@RoomKey int 
DECLARE	@RoomCategoryKey int 
DECLARE @HotelRoomsKey int
DECLARE @HotelRoomsMain int
DECLARE @freePlacesMask int

DECLARE @script VARCHAR(4000)
SET @script = 'SELECT DISTINCT SD_CTKEY, SD_CTNAME, mwSpoDataTable.SD_HDKEY, SD_HDNAME  + '' ('' + ISNULL(SD_RSNAME, SD_CTNAME) + '') '' + mwSpoDataTable.SD_HDSTARS as HotelName,
				ISNULL(HD_HTTP, ''''), SD_RMKEY, RM_NAME, SD_RCKEY, RC_NAME, '''', HR_Key, HR_Main
	FROM mwPriceHotels with(nolock)
		JOIN mwSpoDataTable with(nolock) ON mwPriceHotels.PH_SDKEY = mwSpoDataTable.SD_KEY
		JOIN Rooms with(nolock) ON SD_RMKEY = RM_KEY		
		JOIN RoomsCategory with(nolock) ON SD_RCKEY = RC_KEY
		JOIN HotelDictionary with(nolock) ON mwSpoDataTable.SD_HDKEY = HD_KEY
		JOIN HotelRooms with(nolock) ON (SD_HRKey = HR_Key)
		WHERE ' + @filter + ' ORDER BY HotelName'

INSERT INTO #tmp EXEC(@script)

-- если стоит флаг проверки через веб-сервис
if @checkQuotesOnWebService = 1
BEGIN TRY
	-- Stub. Check quotes will be in calling method (.net)
	set @checkQuotesOnWebService = 1
	set @webServiceFailure = 0
	
	--DECLARE @quotasResult TABLE ( quotaAdditional VARCHAR(100) )
	--DECLARE hSql CURSOR 
	--FOR 
	--	SELECT HotelKey, RoomKey, RoomCategoryKey, HotelRoomsKey, HotelRoomsMain FROM #tmp
	--FOR UPDATE OF Quotas

	--OPEN hSql
	--FETCH NEXT FROM hSql INTO @HotelKey, @RoomKey, @RoomCategoryKey, @HotelRoomsKey, @HotelRoomsMain

	--WHILE @@FETCH_STATUS = 0
	--BEGIN

		
	--	DELETE FROM @quotasResult
	--	INSERT INTO @quotasResult EXEC WcfGetQuotas 1, 3, @HotelKey, @HotelRoomsKey, @FromDate,
	--			@FromDate, @AgentKey, 1, null
		
	--	UPDATE #tmp SET Quotas = (SELECT TOP 1 quotaAdditional FROM @quotasResult) 
	--		WHERE current of hSql
	--	FETCH NEXT FROM hSql INTO @HotelKey, @RoomKey, @RoomCategoryKey, @HotelRoomsKey, @HotelRoomsMain
	--END
	--CLOSE hSql
	--DEALLOCATE hSql
END TRY
BEGIN CATCH
	SET @webServiceFailure = 1
	CLOSE hSql
	DEALLOCATE hSql
END CATCH

-- если произошла ошибка или стоит флаг проверки обычным методом
if @checkQuotesOnWebService = 0 or @webServiceFailure = 1
BEGIN
	DECLARE hSql CURSOR 
	FOR
		SELECT HotelKey, RoomKey, RoomCategoryKey, HotelRoomsKey, HotelRoomsMain FROM #tmp
	FOR UPDATE OF Quotas

	OPEN hSql
	FETCH NEXT FROM hSql INTO @HotelKey, @RoomKey, @RoomCategoryKey, @HotelRoomsKey, @HotelRoomsMain

	WHILE @@FETCH_STATUS = 0
	BEGIN
		UPDATE #tmp SET Quotas = (select top 1 qt_additional 
		from mwCheckQuotesEx(3, @HotelKey, @RoomKey, @RoomCategoryKey, @AgentKey, -1, @FromDate, 1, @DaysCount, @RequestOnRelease, @NoPlacesResult, @CheckAgentQuotes, @CheckCommonQuotes, 1, 0, 0, 0, 0, -1, @ExpiredReleaseResult))
			WHERE current of hSql
		FETCH NEXT FROM hSql INTO @HotelKey, @RoomKey, @RoomCategoryKey, @HotelRoomsKey, @HotelRoomsMain
	END
	CLOSE hSql
	DEALLOCATE hSql
END

SELECT DISTINCT CityKey, CityName, HotelKey, HotelName, HotelHTTP, RoomKey, RoomName, RoomCategoryKey, RoomCategoryName, Quotas, min(HotelRoomsKey)
FROM #tmp
GROUP BY CityKey, CityName, HotelKey, HotelName, HotelHTTP, RoomKey, RoomName, RoomCategoryKey, RoomCategoryName, Quotas

-- удаление временной таблицы
DROP TABLE #tmp

END

GO
grant exec on [dbo].[mwHotelQuotes] to public
go
/*********************************************************************/
/* end sp_mwHotelQuotes.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReindex.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReindex]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwReindex]
GO

CREATE procedure [dbo].[mwReindex] as
begin

	--<DATE>2013-09-13</DATE>
	--<VERSION>9.2.19</VERSION>
	
	DECLARE @objectid int;
	DECLARE @indexid int;
	DECLARE @partitioncount bigint;
	DECLARE @schemaname nvarchar(130); 
	DECLARE @objectname nvarchar(130); 
	DECLARE @indexname nvarchar(130); 
	DECLARE @partitionnum bigint;
	DECLARE @partitions bigint;
	DECLARE @frag float;
	DECLARE @db_id int;

	set @db_id = DB_ID()

	DECLARE @command nvarchar(4000); 
	SELECT
		object_id AS objectid,
		index_id AS indexid,
		partition_number AS partitionnum,
		avg_fragmentation_in_percent AS frag
	INTO #work_to_do
	FROM sys.dm_db_index_physical_stats (@db_id, NULL, NULL , NULL, NULL)
	WHERE avg_fragmentation_in_percent > 10.0 AND index_id > 0;
	DECLARE partitions CURSOR FOR SELECT * FROM #work_to_do;
	OPEN partitions;
	WHILE (1 = 1)
		BEGIN;
			FETCH NEXT
			   FROM partitions
			   INTO @objectid, @indexid, @partitionnum, @frag;
			IF @@FETCH_STATUS < 0 BREAK;
			SELECT @objectname = QUOTENAME(o.name), @schemaname = QUOTENAME(s.name)
			FROM sys.objects AS o
			JOIN sys.schemas as s ON s.schema_id = o.schema_id
			WHERE o.object_id = @objectid;
			SELECT @indexname = QUOTENAME(name)
			FROM sys.indexes
			WHERE  object_id = @objectid AND index_id = @indexid;
			SELECT @partitioncount = count (*)
			FROM sys.partitions
			WHERE object_id = @objectid AND index_id = @indexid;
			IF @frag < 30.0
				SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REORGANIZE';
			IF @frag >= 30.0
				SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REBUILD';
			IF @partitioncount > 1
				SET @command = @command + N' PARTITION=' + CAST(@partitionnum AS nvarchar(10));
			EXEC (@command);
			PRINT N'Executed: ' + @command;
		END;
	CLOSE partitions;
	DEALLOCATE partitions;
	DROP TABLE #work_to_do;

end
GO

grant exec on dbo.mwReindex to public
GO
/*********************************************************************/
/* end sp_mwReindex.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwRemoveDeleted.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwRemoveDeleted]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwRemoveDeleted]
GO

CREATE PROCEDURE [dbo].[mwRemoveDeleted] 
	@remove tinyint = 0
as
begin
	--<VERSION>2009.2.20.0</VERSION>
	--<DATE>2013-08-28</DATE>

	set nocount on

	if (dbo.mwReplIsPublisher() = 1)
	begin
		truncate table mwDeleted
		return
	end
	
	declare @name varchar(50)
	declare @sql varchar(8000)
		
	create table #tmpDeleted (del_key int)
	create table #ptKeys (xptKey int)

	declare @pubdb nvarchar(50)
	set @pubdb = dbo.mwReplPublisherDB()
	
	declare delCur cursor fast_forward read_only for 
	select [name] from sysobjects with(nolock) where name like 'mwPriceDataTable%' and xtype = 'u'			
	
	while exists(select top (1) 1 from dbo.mwDeleted with (nolock))
	begin

		insert into #tmpDeleted
		select top (500000) del_key 
		from dbo.mwDeleted with(nolock)				

		open delCur
		fetch next from delCur into @name
		while(@@fetch_status = 0)
		begin
			set @sql = 'insert into #ptKeys(xptKey) select pt_key from dbo.' + ltrim(rtrim(@name)) + ' with(nolock) where pt_pricekey in (select del_key from #tmpDeleted)'
			print (@sql)
			exec (@sql)

			if exists(select top 1 1 from #ptKeys)
			begin
				while (1 = 1)
				begin
					set @sql = 'delete top (10000) from dbo.' + ltrim(rtrim(@name)) + ' where pt_key in (select xptKey from #ptKeys)'
					print @sql
					exec(@sql)

					if @@rowcount = 0
						break
				end
			end

			truncate table #ptKeys

			fetch next from delCur into @name
		end
		close delCur

		delete from dbo.mwDeleted where del_key in (select del_key from #tmpDeleted)

		truncate table #tmpDeleted
	end
	
	set @sql = '		
			delete from dbo.mwSpoDataTable with(rowlock) where not exists(select top (1) 1 from mt.' + @pubdb + '.dbo.tp_prices with(nolock) where tp_tokey = sd_tourkey)
			delete from dbo.mwPriceHotels with(rowlock) where  not exists(select top (1) 1 from mt.' + @pubdb + '.dbo.tp_prices with(nolock) where tp_tokey = sd_tourkey)
			delete from dbo.mwPriceDurations with(rowlock) where  not exists(select top (1) 1 from mt.' + @pubdb + '.dbo.tp_prices with(nolock) where tp_tokey = sd_tourkey)		
		'
	exec (@sql)
	
	deallocate delCur
	
	drop table #tmpDeleted

	if not exists(select 1 from mwDeleted)
	begin
		truncate table mwDeleted
	end

	set nocount off
end
GO

grant execute on [dbo].[mwRemoveDeleted] to public
GO
/*********************************************************************/
/* end sp_mwRemoveDeleted.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplDeletePriceTour.sql */
/*********************************************************************/
if exists (select * from [dbo].sysobjects where id = object_id(N'[dbo].[mwReplDeletePriceTour]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[mwReplDeletePriceTour]
GO

create proc [dbo].[mwReplDeletePriceTour] @tokey int, @rqId int
as
begin

	--<VERSION>2009.2.20</VERSION>
	--<DATE>2013-05-17</DATE>

	if dbo.mwReplIsSubscriber() <= 0
		return

	declare @mwSearchType int
	select @mwSearchType = ltrim(rtrim(isnull(SS_ParmValue, ''))) from dbo.systemsettings 
		where SS_ParmName = 'MWDivideByCountry'

	if @mwSearchType = 0
	begin
		if (@rqId is not null)
			insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start insert into mwDeleted.'
		
		insert into mwDeleted with(rowlock) (del_key) 
			select pt_pricekey 
			from mwPriceDataTable with(nolock) 
			where pt_tourkey = @tokey

		if (@rqId is not null)
			insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start update mwPriceDataTable.'
								
		update mwPriceDataTable with(rowlock) 
		set pt_isenabled = 0 
		where pt_isenabled > 0 and pt_tourkey = @tokey
	end
	else
	begin
		declare @tablename varchar(100), @sql varchar(8000)
		declare dCur cursor for select name from sysobjects with(nolock) where name like 'mwPriceDataTable[_]%' and xtype = 'u'
		open dCur

		if (@rqId is not null)
			insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start insert into mwDeleted and update mwPriceDataTables.'

		fetch next from dCur into @tablename

		while (@@fetch_status=0)
		begin
			set @sql = 'insert into mwDeleted with(rowlock) (del_key) 
				select pt_pricekey 
				from ' + @tableName + ' with(nolock) 
				where pt_tourkey = ' + ltrim(str(@tokey))
			exec (@sql)

			set @sql = 'update ' + @tableName + ' with(rowlock) 
				set pt_isenabled = 0 
				where pt_isenabled > 0 and pt_tourkey = ' + ltrim(str(@tokey))
			exec (@sql)

			fetch next from dCur into @tablename
		end	
	end
	
	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start update mwSpoDataTable.'
			
	update mwSpoDataTable with(rowlock) 
	set sd_isenabled = 0 
	where sd_isenabled > 0 and sd_tourkey = @tokey
	
	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start delete from TP_Prices.'
	delete from TP_Prices with(rowlock) where tp_tokey = @tokey
	
	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start delete from TP_ServiceLists.'
	delete from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
	
	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start delete from TP_Services.'
	delete from TP_Services with(rowlock) where ts_tokey = @tokey
	
	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start delete from TP_Lists.'
	delete from TP_Lists with(rowlock) where ti_tokey = @tokey
	
	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start delete from TP_Tours.'
	delete from TP_Tours with(rowlock) where to_key = @tokey
end
GO

GRANT exec ON [dbo].[mwReplDeletePriceTour] TO PUBLIC
GO

/*********************************************************************/
/* end sp_mwReplDeletePriceTour.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplProcessQueueDivide.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplProcessQueueDivide]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwReplProcessQueueDivide]
GO

CREATE procedure [dbo].[mwReplProcessQueueDivide] (@jobId smallint = null)
as
begin
	--<VERSION>2009.2.20</VERSION>
	--<DATE>2013-08-12</DATE>

	if dbo.mwReplIsSubscriber() <= 0
		return

	-- обновляем инфу о стране и городе вылета по туру
	if exists(select 1 from mwReplQueue with(nolock) where rq_state = 1 and rq_cnkey is null)
	begin
		update mwReplQueue
		set rq_cnkey = TO_CNKey,
		rq_ctkeyfrom = TL_CTDepartureKey
		from tp_tours
		join tbl_TurList on tl_key = to_trkey
		where to_key = rq_tokey
		and rq_cnkey is null
		and rq_state = 1
	end
		
	if (@jobId is null)
		set @jobId = @@SPID
		
	-- такое может происходить только, если произошла аварийная остановка джоба и его повторный запуск
	-- апдейтим таблицу направлений и таблицу очереди
	if exists(select 1 from mwReplDirections where RD_IsUsed = @jobId)
	begin
		update mwReplQueue 
		set rq_state = 4 
		from mwReplDirections
		where RD_CNKey = rq_cnkey
		and RD_CTKeyFrom = rq_ctkeyfrom
		and rq_state = 3
		and RD_IsUsed = @jobId
		
		update mwReplDirections set RD_IsUsed = 0 where RD_IsUsed = @jobId
		
	end
		
	declare @mwSearchType int
	declare @cnKey int, @ctKey int
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'

	declare @rqId int
	declare @rqMode int
	declare @rqToKey int
	declare @rqCalculatingKey int
	declare @rqOverwritePrices bit	

	declare @directions table(CNKey int, CTKey int, IsUsed int default(0))
	declare @currentQueue table(xrq_id int, xrq_mode int, xrq_tokey int, xrq_CalculatingKey int, xRQ_OverwritePrices bit, xrq_state int, xrq_enddate datetime)

	select top 1 @cnKey = rq_cnkey, @ctKey = rq_ctkeyfrom
	from mwReplQueue with(nolock)
	join mwReplDirections with(nolock) on rd_cnkey = rq_cnkey and rd_ctkeyfrom = isnull(rq_ctkeyfrom, 0)
	where rd_isUsed = 0
	and (rq_state = 1 or rq_state = 2)
	and rq_mode <= 5
	order by rq_priority desc, rq_crdate
	
	update mwReplDirections set RD_IsUsed = @jobId where RD_IsUsed = 0 and rd_cnkey = @cnKey and RD_CTKeyFrom = @ctkey
	if not exists(select 1 from mwReplDirections where RD_IsUsed = @jobId)
		return
		
	insert into @currentQueue (xrq_id, xrq_mode, xrq_tokey, xrq_CalculatingKey, xRQ_OverwritePrices)
	select top 10 rq_id, rq_mode, rq_tokey, rq_CalculatingKey, RQ_OverwritePrices
	from mwReplQueue 
	where (rq_state = 1 or rq_state = 2)
	and rq_cnkey = @cnKey
	and rq_ctkeyfrom = @ctKey
	and rq_mode <= 5
	order by rq_priority desc, rq_crdate
	
	update mwReplQueue set [rq_state] = 3, [rq_startdate] = getdate() where rq_id in (select xrq_id from @currentQueue)
	
	declare queueCursor cursor local fast_forward for
	select xrq_id, xrq_mode, xrq_tokey, xrq_CalculatingKey, xRQ_OverwritePrices
	from @currentQueue
	
	open queueCursor
	fetch queueCursor into @rqId, @rqMode, @rqToKey, @rqCalculatingKey, @rqOverwritePrices
	
	while (@@FETCH_STATUS = 0)
	begin
		
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text])
			select @rqId, 'Command start.'
			
		begin try	
			if (@rqMode = 1)
			begin
				exec FillMasterWebSearchFields @tokey = @rqToKey, @calcKey = @rqCalculatingKey, @overwritePrices = @rqOverwritePrices
			end
			else if (@rqMode = 2)
			begin
				exec FillMasterWebSearchFields @tokey = @rqToKey, @calcKey = @rqCalculatingKey, @overwritePrices = @rqOverwritePrices
			end
			else if (@rqMode = 3)
			begin
				exec mwReplDisablePriceTour @rqToKey, @rqId
			end
			else if (@rqMode = 4)
			begin
				exec mwReplDeletePriceTour @rqToKey, @rqId
			end
			else if (@rqMode = 5)
			begin
				exec mwReplUpdatePriceTourDateValid @rqToKey, @rqId
			end
			
			update mwReplQueue set rq_state = 5, rq_enddate = getdate() where rq_id = @rqId
			
			insert into mwReplQueueHistory([rqh_rqid], [rqh_text])
			select @rqId, 'Command complete.'
		
		end try
		begin catch
			update mwReplQueue set rq_state = 4, rq_enddate = getdate() where rq_id = @rqId
			
			declare @errMessage varchar(max)
			set @errMessage = 'Error at ' + isnull(ERROR_PROCEDURE(), '[mwReplProcessQueueDivide]') +' : ' + isnull(ERROR_MESSAGE(), '[msg_not_set]')
			
			insert into mwReplQueueHistory([rqh_rqid], [rqh_text])
			select @rqId, @errMessage
		end catch
		
		fetch queueCursor into @rqId, @rqMode, @rqToKey, @rqCalculatingKey, @rqOverwritePrices
		
	end
	
	close queueCursor
	deallocate queueCursor
	
	update mwReplDirections set rd_isUsed = 0 where rd_isUsed = @jobId
	
	if exists(select top 1 1 from mwReplQueue with(nolock) where rq_state = 4 and DATEDIFF(MINUTE, rq_enddate, GETDATE()) > 10 and rq_priority > 0)
	begin
		delete from mwReplQueue where rq_tokey not in (select to_key from TP_Tours) and rq_mode <> 4 and (rq_startdate is null or rq_state = 4)
		
		update mwReplQueue set rq_state = 1, rq_startdate = null, rq_enddate = null, rq_priority = rq_priority - 1
		where rq_state = 4 
		and DATEDIFF(MINUTE, rq_enddate, GETDATE()) > 10
		and rq_priority > 0

	end
end
GO

grant exec on [dbo].[mwReplProcessQueueDivide] to public
GO
/*********************************************************************/
/* end sp_mwReplProcessQueueDivide.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwReplUpdatePriceTourDateValid.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwReplUpdatePriceTourDateValid]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwReplUpdatePriceTourDateValid]
GO

CREATE proc [dbo].[mwReplUpdatePriceTourDateValid] @tokey int, @rqId int
as
begin
	-- <date>2013-08-01</date>
	-- <version>2009.2.20.1</version>

	declare @mwSearchType int, @sql nvarchar(max)
	declare @countryKey int, @cityKey int
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'

	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start update mwSpoDataTable.'
	
	update mwSpoDataTable
	set sd_tourvalid  = TO_DateValid
	from TP_Tours where sd_tourkey = to_key and to_key = @tokey

	if (@rqId is not null)
		insert into mwReplQueueHistory([rqh_rqid], [rqh_text]) select @rqId, 'Start update mwPriceDataTable.'
		
	if @mwSearchType = 0
	begin
		update mwPriceDataTable
		set pt_tourvalid  = TO_DateValid
		from TP_Tours where pt_tourkey = to_key and to_key = @tokey
	end
	else
	begin
		select @countryKey = TO_CNKey, @cityKey = TL_CTDepartureKey
		from tp_tours 
		join tbl_TurList on TL_Key = TO_TRKey
		where to_key = @tokey

		set @sql = 'update ' + dbo.mwGetPriceTableName(@countryKey, @cityKey) + ' set pt_tourvalid  = TO_DateValid from TP_Tours where pt_tourkey = to_key and to_key = ' + str(@tokey)
		exec (@sql)
	end
end
GO

grant exec on [dbo].[mwReplUpdatePriceTourDateValid] to public
go

/*********************************************************************/
/* end sp_mwReplUpdatePriceTourDateValid.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_mwSyncDictionaryData.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mwSyncDictionaryData]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[mwSyncDictionaryData]
GO

create procedure [dbo].[mwSyncDictionaryData] 
	@update_search_table smallint = 0, -- нужно ли синхронизировать данные в mwPriceDataTable
	@update_fields varchar(1024) = NULL -- какие именно данные нужно синхронизировать
as
begin

	--<VERSION>2009.2.20.1</VERSION>
	--<DATE>2013-09-05</DATE>

	-- Список допустимых параметров для @update_fields (нечувствительны к регистру)
	-- COUNTRY
	-- HOTEL
	-- CITY
	-- RESORT
	-- TOUR
	-- TOURTYPE
	-- PANSION
	-- ROOM
	-- ROOMCATEGORY
	-- ACCOMODATION
	-- TP_TOUR     
	
	declare @mwSearchType int
	select @mwSearchType = isnull(SS_ParmValue, 1) from dbo.systemsettings with(nolock) 
	where SS_ParmName = 'MWDivideByCountry'     
	declare @sql as nvarchar(max)
	declare @tablesCondition as nvarchar(100), @tableName nvarchar(100)

	if @mwSearchType = 0
		set @tablesCondition = 'mwPriceDataTable'
	else
		set @tablesCondition = 'mwPriceDataTable[_]%'
	
	-- Признак того, откуда брать основые места
	-- Если @isMainPlacesFromAccomodation = 1, основные места беруться из таблицы Accmdmentype, иначе из Rooms
	-- Синхронизация основных мест происходит если pt_main > 0
	declare @isMainPlacesFromAccomodation bit
	select @isMainPlacesFromAccomodation = SS_ParmValue
	from dbo.SystemSettings
	where SS_ParmName='MWAccomodationPlaces'

	-- Признак того, откуда брать дополнительные места
	-- Если @isAddPlacesFromRooms = 1 и в таблице Accmdmentype по данному ключу NULL,
	-- дополнительные места беруться из таблицы Rooms, иначе из Accmdmentype
	declare @isAddPlacesFromRooms bit
	select @isAddPlacesFromRooms = SS_ParmValue
	from dbo.SystemSettings
	where SS_ParmName='MWRoomsExtraPlaces'
	
	--обновление синхронизируемых таблиц происходит пакетами; размер указывается в процентах
	declare @updatePackageSize real
	set @updatePackageSize = 10.0	--in

	declare @sdtUpdatePackageSize int
	set @sdtUpdatePackageSize = (select count(*) from mwSpoDataTable with(nolock)) * @updatePackageSize / 100.0
	
	if (@sdtUpdatePackageSize <= 0)
		set @sdtUpdatePackageSize = @updatePackageSize
		
	declare @pdtUpdatePackageSize int
	set @pdtUpdatePackageSize = 100000

	declare @fields table(fname varchar(20));
	declare @blUpdateAllFields smallint	

	-- если параметр @update_fields не задан, то будем выполнять синхронизацию по
	-- всем основным полям
	if @update_fields is null or @update_fields = ''
	begin
		set @blUpdateAllFields = 1
	end
	else
	begin
		set @blUpdateAllFields = 0

		-- произведём сплит строки @update_fields по запятой
		-- и запишем результат в таблицу @fields
		declare @nextString varchar(4000) 
		declare @pos int, @nextPos int 
		declare @commaCheck varchar(1) 
		declare @string varchar(4000)
		declare @delimiter varchar(1)
	 
		set @delimiter = ','
		set @nextString = '' 
		set @commaCheck = right(@update_fields, 1) 
		set @string = @update_fields + @delimiter 
	 
		set @pos = charindex(@delimiter, @string) 
		set @nextPos = 1 
		while (@pos <> 0) 
		begin 
			set @nextString = substring(@string, 1, @pos - 1) 
	 
			insert into @fields( fname) 
			values (upper(ltrim(rtrim(@nextString))))
	 
			set @string = substring(@string, @pos + 1, len(@string)) 
			set @nextPos = @pos 
			set @pos = charindex(@delimiter, @string) 
		end
	end
	
	-- страна
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='COUNTRY')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_cnkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 cn_key from tbl_country with(nolock) 
				where sd_cnkey = cn_key and isnull(sd_cnname, '-1') <> isnull(cn_name, '')))
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_cnname = isnull(cn_name, '')
			from
				tbl_country
			where
				sd_cnkey = cn_key and 
				isnull(sd_cnname, '-1') <> isnull(cn_name, '')
		end
	end
	
	-- отель
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='HOTEL')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_hdkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 hd_key from dbo.hoteldictionary with(nolock) where
				sd_hdkey = hd_key
				and (
					isnull(sd_hdstars, '-1') <> isnull(hd_stars, '') or 
					isnull(sd_ctkey, -1) <> isnull(hd_ctkey, 0) or 
					isnull(sd_rskey, -1) <> isnull(hd_rskey, 0) or 
					isnull(sd_hdname, '-1') <> isnull(hd_name, '') or 
					isnull(sd_hotelurl, '-1') <> isnull(hd_http, '')
				)
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_hdstars = isnull(hd_stars, ''),
				sd_ctkey = isnull(hd_ctkey, 0),
				sd_rskey = isnull(hd_rskey, 0),
				sd_hdname = isnull(hd_name, ''),
				sd_hotelurl = isnull(hd_http, '')
			from
				dbo.hoteldictionary
			where
				sd_hdkey = hd_key
				and (
					isnull(sd_hdstars, '-1') <> isnull(hd_stars, '') or 
					isnull(sd_ctkey, -1) <> isnull(hd_ctkey, 0) or 
					isnull(sd_rskey, -1) <> isnull(hd_rskey, 0) or 
					isnull(sd_hdname, '-1') <> isnull(hd_name, '') or 
					isnull(sd_hotelurl, '-1') <> isnull(hd_http, '')
				)
		end
		
		-- mwPriceDataTable	
		if @update_search_table > 0
		begin

			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_hdkey from @tableName with(nolock) 
where exists(select top 1 hd_key from dbo.hoteldictionary with(nolock) where
	pt_hdkey = hd_key
	and (
		isnull(pt_hdstars, ''-1'') <> isnull(hd_stars, '''') or 
		isnull(pt_ctkey, -1) <> isnull(hd_ctkey, 0) or
		isnull(pt_rskey, -1) <> isnull(hd_rskey, 0) or
		isnull(pt_hdname, ''-1'') <> isnull(hd_name, '''') or
		isnull(pt_hotelurl, ''-1'') <> isnull(hd_http, '''')
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_hdstars = isnull(hd_stars, ''''),
		pt_ctkey = isnull(hd_ctkey, 0),
		pt_rskey = isnull(hd_rskey, 0),
		pt_hdname = isnull(hd_name, ''''),
		pt_hotelurl = isnull(hd_http, '''')
	from
		dbo.hoteldictionary
	where
		pt_hdkey = hd_key
		and (
			isnull(pt_hdstars, ''-1'') <> isnull(hd_stars, '''') or 
			isnull(pt_ctkey, -1) <> isnull(hd_ctkey, 0) or
			isnull(pt_rskey, -1) <> isnull(hd_rskey, 0) or
			isnull(pt_hdname, ''-1'') <> isnull(hd_name, '''') or
			isnull(pt_hotelurl, ''-1'') <> isnull(hd_http, '''')
		)
end
				'

				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)

				exec (@sql)

				fetch tableCursor into @tableName
			end
			close tableCursor
			deallocate tableCursor

		end
	end
	
	-- город отправления
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='CITY')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_ctkeyfrom from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 ct_key from citydictionary with(nolock) 
				where sd_ctkeyfrom <> 0 and sd_ctkeyfrom = ct_key and isnull(sd_ctfromname, '-1') <> isnull(ct_name, '')))
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_ctfromname = isnull(ct_name,'')
			from
				dbo.citydictionary
			where
				sd_ctkeyfrom <> 0	-- город отправления -Без перелета- не обновляем, это константа (см. FillMasterwebSearchFields)
				and sd_ctkeyfrom = ct_key
				and isnull(sd_ctfromname, '-1') <> isnull(ct_name, '')
		end

		while exists(select top 1 sd_ctkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 ct_key from citydictionary with(nolock) 
				where sd_ctkey = ct_key and isnull(sd_ctname, '-1') <> isnull(ct_name, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_ctname = isnull(ct_name,'')
			from
				dbo.citydictionary
			where
				sd_ctkey = ct_key and 
				isnull(sd_ctname, '-1') <> isnull(ct_name, '')
		end
		
		-- mwPriceDataTable
		if @update_search_table > 0
		begin
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_ctkey from @tableName with(nolock)
	where exists(select top 1 ct_key from dbo.citydictionary with(nolock) where
		pt_ctkey = ct_key and isnull(pt_ctname, ''-1'') <> isnull(ct_name, '''')
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_ctname = isnull(ct_name,'''')
	from
		dbo.citydictionary
	where
		pt_ctkey = ct_key and 
		isnull(pt_ctname, ''-1'') <> isnull(ct_name, '''')
end
				'
				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName
			end
			close tableCursor
			deallocate tableCursor

		end
	end
	
	--курорт
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='RESORT')
	begin
		-- mwSpoDataTable
		while exists(select top 1 sd_rskey from dbo.mwSpoDataTable with(nolock)
			where exists(select top 1 rs_key from dbo.resorts with(nolock) where
				sd_rskey = rs_key and isnull(sd_rsname, '-1') <> isnull(rs_name, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_rsname = isnull(rs_name,'')
			from
				dbo.resorts
			where
				sd_rskey = rs_key and 
				isnull(sd_rsname, '-1') <> isnull(rs_name, '')
		end
		
		-- mwPriceDataTable	
		if @update_search_table > 0
		begin
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_rskey from @tableName with(nolock)
	where exists(select top 1 rs_key from dbo.resorts with(nolock) where
		pt_rskey = rs_key and isnull(pt_rsname, ''-1'') <> isnull(rs_name, '''')
	)
)		
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_rsname = isnull(rs_name, '''')
	from
		dbo.resorts
	where
		pt_rskey = rs_key and 
		isnull(pt_rsname, ''-1'') <> isnull(rs_name, '''')
end
				'

				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName
			end
			close tableCursor
			deallocate tableCursor

		end
	end
	
	-- тур
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='TOUR')
	begin
		while exists(select 1 from dbo.mwSpoDataTable with(nolock)
			where exists(select 1 from dbo.tbl_turlist with(nolock) where
				sd_tlkey = tl_key
				and (
					isnull(sd_tourname, '-1') <> isnull(tl_nameweb, '') or 
					isnull(sd_tourtype, -1) <> isnull(tl_tip, 0)
				)
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_tourname = isnull(tl_nameweb, ''),
				sd_tourtype = isnull(tl_tip, 0)
			from
				dbo.tbl_turlist
			where
				sd_tlkey = tl_key
				and (
					isnull(sd_tourname, '-1') <> isnull(tl_nameweb, '') or 
					isnull(sd_tourtype, -1) <> isnull(tl_tip, 0)
				)
		end
		
		-- mwPriceDataTable	
		if @update_search_table > 0
		begin			
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_tlkey from @tableName with(nolock)
	where exists(select top 1 tl_key from dbo.tbl_turlist with(nolock) where
		pt_tlkey = tl_key
		and (
			isnull(pt_tourname, ''-1'') <> isnull(tl_nameweb, '''') or
			isnull(pt_toururl, ''-1'') <> isnull(tl_webhttp, '''') or
			isnull(pt_tourtype, -1) <> isnull(tl_tip, 0)
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_tourname = isnull(tl_nameweb, ''''),
		pt_toururl = isnull(tl_webhttp, ''''),
		pt_tourtype = isnull(tl_tip, 0)
	from
		dbo.tbl_turlist
	where
		pt_tlkey = tl_key
		and (
			isnull(pt_tourname, ''-1'') <> isnull(tl_nameweb, '''') or
			isnull(pt_toururl, ''-1'') <> isnull(tl_webhttp, '''') or
			isnull(pt_tourtype, -1) <> isnull(tl_tip, 0)
		)
end
				'

				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName

			end
			close tableCursor
			deallocate tableCursor
		end
	end
	
	-- тип тура
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='TOURTYPE')
	begin
		while exists(select top 1 sd_tourtype from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 tp_key from dbo.tiptur with(nolock) 
				where sd_tourtype = tp_key and isnull(sd_tourtypename, '-1') <> isnull(tp_name, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_tourtypename = isnull(tp_name, '')
			from
				dbo.tiptur
			where
				sd_tourtype = tp_key
				and isnull(sd_tourtypename, '-1') <> isnull(tp_name, '')
		end
	end

	-- питание
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='PANSION')
	begin
		while exists(select top 1 sd_pnkey from dbo.mwSpoDataTable with(nolock) 
			where exists(select top 1 pn_key from dbo.pansion with(nolock) 
				where sd_pnkey = pn_key and isnull(sd_pncode, '-1') <> isnull(pn_code, '')
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_pncode = isnull(pn_code, '')
			from
				dbo.pansion
			where
				sd_pnkey = pn_key and 
				isnull(sd_pncode, '-1') <> isnull(pn_code, '')
		end	
		
		if @update_search_table > 0
		begin
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_pnkey from @tableName with(nolock)
	where exists(select top 1 pn_key from dbo.pansion with(nolock) where
		pt_pnkey = pn_key
		and (
			isnull(pt_pnname, ''-1'') <> isnull(pn_name, '''') or
			isnull(pt_pncode, ''-1'') <> isnull(pn_code, '''')
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set 
		pt_pnname = isnull(pn_name, ''''),
		pt_pncode = isnull(pn_code, '''')
	from dbo.pansion
	where
		pt_pnkey = pn_key
		and (
			isnull(pt_pnname, ''-1'') <> isnull(pn_name, '''') or
			isnull(pt_pncode, ''-1'') <> isnull(pn_code, '''')
		)
end
				'
				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName
			end

			close tableCursor
			deallocate tableCursor

			
		end
	end
	
	-- номер	
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ROOM')) and @update_search_table > 0
	begin
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_rmkey from @tableName with(nolock)
	where exists(select top 1 rm_key from dbo.rooms with(nolock) where
		pt_rmkey = rm_key
		and (
			isnull(pt_rmname, ''-1'') <> isnull(rm_name, '''') or 
			isnull(pt_rmcode, ''-1'') <> isnull(rm_code, '''') or 
			isnull(pt_rmorder, -1) <> isnull(rm_order, 0)
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_rmname = isnull(rm_name, ''''),
		pt_rmcode = isnull(rm_code, ''''),
		pt_rmorder = isnull(rm_order, 0)
	from
		dbo.rooms
	where
		pt_rmkey = rm_key
		and (
			isnull(pt_rmname, ''-1'') <> isnull(rm_name, '''') or 
			isnull(pt_rmcode, ''-1'') <> isnull(rm_code, '''') or 
			isnull(pt_rmorder, -1) <> isnull(rm_order, 0)
		)			
end
				'
				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName
			end

			close tableCursor
			deallocate tableCursor

		
	end
	
	-- категория номера
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ROOMCATEGORY')) and @update_search_table > 0
	begin
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_rckey from @tableName with(nolock)
	where exists(select top 1 rc_key from dbo.roomscategory with(nolock) where
		pt_rckey = rc_key
		and (
			isnull(pt_rcname, ''-1'') <> isnull(rc_name, '''') or 
			isnull(pt_rccode, ''-1'') <> isnull(rc_code, '''') or 
			isnull(pt_rcorder, -1) <> isnull(rc_order, 0)
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_rcname = isnull(rc_name, ''''),
		pt_rccode = isnull(rc_code, ''''),
		pt_rcorder = isnull(rc_order, 0)
	from
		dbo.roomscategory
	where
		pt_rckey = rc_key
		and (
			isnull(pt_rcname, ''-1'') <> isnull(rc_name, '''') or 
			isnull(pt_rccode, ''-1'') <> isnull(rc_code, '''') or 
			isnull(pt_rcorder, -1) <> isnull(rc_order, 0)
		)
end
				'
				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName
			end

			close tableCursor
			deallocate tableCursor

		
	end
	
	-- размещение
	--kadraliev MEG00029412 29.09.2010 Добавил синхронизацию признака isMain, возрастов детей
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ACCOMODATION')) and @update_search_table > 0
	begin	
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_ackey from @tableName with(nolock)
	where exists(select top 1 ac_key from dbo.accmdmentype with(nolock) where
		pt_ackey = ac_key
		and (
			isnull(pt_acname, ''-1'') <> isnull(ac_name, '''') or
			isnull(pt_accode, ''-1'') <> isnull(ac_code, '''') or
			isnull(pt_acorder, -1) <> isnull(ac_order, 0) or
			isnull(pt_main, -1) <> isnull(ac_main, 0) or
			isnull(pt_childagefrom, -1) <> isnull(ac_agefrom, 0) or
			isnull(pt_childageto, -1) <> isnull(ac_ageto, 0) or
			isnull(pt_childagefrom2, -1) <> isnull(ac_agefrom2, 0) or
			isnull(pt_childageto2, -1) <> isnull(ac_ageto2, 0)					
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_acname = isnull(ac_name, ''''),
		pt_accode = isnull(ac_code, ''''),
		pt_acorder = isnull(ac_order, 0),
		pt_main = isnull(ac_main, 0),
		pt_childagefrom = isnull(ac_agefrom, 0),
		pt_childageto = isnull(ac_ageto, 0),
		pt_childagefrom2 = isnull(ac_agefrom2, 0),
		pt_childageto2 = isnull(ac_ageto2, 0)
	from
		dbo.accmdmentype
	where
		pt_ackey = ac_key
		and (
			isnull(pt_acname, ''-1'') <> isnull(ac_name, '''') or
			isnull(pt_accode, ''-1'') <> isnull(ac_code, '''') or
			isnull(pt_acorder, -1) <> isnull(ac_order, 0) or
			isnull(pt_main, -1) <> isnull(ac_main, 0) or
			isnull(pt_childagefrom, -1) <> isnull(ac_agefrom, 0) or
			isnull(pt_childageto, -1) <> isnull(ac_ageto, 0) or
			isnull(pt_childagefrom2, -1) <> isnull(ac_agefrom2, 0) or
			isnull(pt_childageto2, -1) <> isnull(ac_ageto2, 0)	
		)
end
				'
				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName	
			end

			close tableCursor
			deallocate tableCursor

		
	end

	--kadraliev MEG00029412 29.09.2010 номер и размещение (количество основных и дополнительных мест)
	if ((@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='ROOM' or fname='ACCOMODATION')) and @update_search_table > 0
	begin	
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_key 
				from @tableName with(nolock)
				inner join rooms with(nolock) on pt_rmkey = rm_key
				inner join accmdmentype with(nolock) on pt_ackey = ac_key
				where
				pt_main > 0 and isnull(pt_mainplaces,-1) <> (case when @isMainPlacesFromAccomodation = 1
						then isnull(ac_nrealplaces,0)
						else isnull(rm_nplaces,0) end) or
				isnull(pt_addplaces,-1) <> (case isnull(ac_nmenexbed, -1) when -1 
						then (case when @isAddPlacesFromRooms = 1 
								then isnull(rm_nplacesex, 0)
								else isnull(ac_nmenexbed, 0) end)
						else isnull(ac_nmenexbed, 0) end))
begin									
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_mainplaces = (case when pt_main > 0
						then (case when @isMainPlacesFromAccomodation = 1
							then isnull(ac_nrealplaces,0)
							else isnull(rm_nplaces,0) end)
						else isnull(pt_mainplaces,0) end),
		pt_addplaces =	(case isnull(ac_nmenexbed, -1) when -1 
							then (case when @isAddPlacesFromRooms = 1 
									then isnull(rm_nplacesex, 0)
									else isnull(ac_nmenexbed, 0) end)
							else isnull(ac_nmenexbed, 0) end )
	from @tableName orig with(nolock)
		left join rooms with(nolock) on orig.pt_rmkey = rm_key
		left join accmdmentype with(nolock) on orig.pt_ackey = ac_key
	where
		pt_main > 0 and isnull(pt_mainplaces,-1) <> (case when @isMainPlacesFromAccomodation = 1
				then isnull(ac_nrealplaces,0)
				else isnull(rm_nplaces,0) end) or
		isnull(pt_addplaces,-1) <> (case isnull(ac_nmenexbed, -1) when -1 
				then (case when @isAddPlacesFromRooms = 1 
						then isnull(rm_nplacesex, 0)
						else isnull(ac_nmenexbed, 0) end)
				else isnull(ac_nmenexbed, 0) end)
end
				'

				set @sql = REPLACE(@sql, '@isMainPlacesFromAccomodation', @isMainPlacesFromAccomodation)
				set @sql = REPLACE(@sql, '@isAddPlacesFromRooms', @isAddPlacesFromRooms)
				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)
				exec (@sql)

				fetch tableCursor into @tableName	
			end

			close tableCursor
			deallocate tableCursor

			
	end

	-- расчитанный тур
	if (@blUpdateAllFields = 1) or exists(select top 1 * from @fields where fname='TP_TOUR')
	begin
		while exists(select top 1 sd_tourkey from dbo.mwSpoDataTable with(nolock)
			where exists(select top 1 to_key from dbo.tp_tours with(nolock) where
				sd_tourkey = to_key
				and (
					isnull(sd_tourcreated, '1900-01-02') <> isnull(to_datecreated, '1900-01-01') or 
					isnull(sd_tourvalid, '1900-01-02') <> isnull(to_datevalid, '1900-01-01')
				)
			)
		)
		begin
			update top (@sdtUpdatePackageSize) dbo.mwSpoDataTable
			set
				sd_tourcreated = isnull(to_datecreated, '1900-01-01'),
				sd_tourvalid = isnull(to_datevalid, '1900-01-01')
			from
				dbo.tp_tours
			where
				sd_tourkey = to_key
				and (
					isnull(sd_tourcreated, '1900-01-02') <> isnull(to_datecreated, '1900-01-01') or 
					isnull(sd_tourvalid, '1900-01-02') <> isnull(to_datevalid, '1900-01-01')
				)
		end
		
		-- mwPriceDataTable
		if @update_search_table > 0
		begin		
			declare tableCursor cursor for
			select name from sys.tables 
			where name like @tablesCondition

			open tableCursor
			fetch tableCursor into @tableName
			while @@FETCH_STATUS = 0
			begin
				set @sql = '
while exists(select top 1 pt_tourkey from @tableName with(nolock)
	where exists(select top 1 to_key from dbo.tp_tours with(nolock) where
		pt_tourkey = to_key
		and (
			isnull(pt_tourcreated, ''1900-01-02'') <> isnull(to_datecreated, ''1900-01-01'') or 
			isnull(pt_tourvalid, ''1900-01-02'') <> isnull(to_datevalid, ''1900-01-01'') or 
			isnull(pt_rate, ''-1'') COLLATE DATABASE_DEFAULT <> isnull(to_rate, '''') COLLATE DATABASE_DEFAULT
		)
	)
)
begin
	update top (@pdtUpdatePackageSize) @tableName
	set
		pt_tourcreated = isnull(to_datecreated, ''1900-01-01''),
		pt_tourvalid = isnull(to_datevalid, ''1900-01-01''),
		pt_rate = isnull(to_rate, '''')
	from
		dbo.tp_tours
	where
		pt_tourkey = to_key
		and (
			isnull(pt_tourcreated, ''1900-01-02'') <> isnull(to_datecreated, ''1900-01-01'') or 
			isnull(pt_tourvalid, ''1900-01-02'') <> isnull(to_datevalid, ''1900-01-01'') or 
			isnull(pt_rate, ''-1'') COLLATE DATABASE_DEFAULT <> isnull(to_rate, '''') COLLATE DATABASE_DEFAULT
		)
end
				'

				set @sql = REPLACE(@sql, '@tableName', @tableName)
				set @sql = REPLACE(@sql, '@pdtUpdatePackageSize', @pdtUpdatePackageSize)

				exec (@sql)
				fetch tableCursor into @tableName	
			end

			close tableCursor
			deallocate tableCursor
			
						
		end
	end
end
GO

grant exec on [dbo].[mwSyncDictionaryData] to public
GO

/*********************************************************************/
/* end sp_mwSyncDictionaryData.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_NationalCurrencyPrice2.sql */
/*********************************************************************/
if exists(select id from sysobjects where id = object_id(N'[dbo].[NationalCurrencyPrice2]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop proc [dbo].[NationalCurrencyPrice2]
GO

CREATE PROCEDURE [dbo].[NationalCurrencyPrice2]
@sRate varchar(5), -- валюта пересчета
@sRateOld varchar(5), -- старая валюта
@sDogovor varchar(100), -- код договора
@nPrice money, -- новая цена в указанной валюте
@nPriceOld money, -- старая цена
@nDiscountSum money, -- новая скидка в указанной валюте
@date DateTime, -- действие
@order_status smallint, -- null OR passing the new value for dg_sor_code from the trigger when it's (dg_sor_code) updated
@isAddToHistory bit = 1
AS
BEGIN
--<VERSION>9.2.20.0</VERSION>
--<DATE>2013-06-17</DATE>
      declare @national_currency varchar(5)
      declare @currencyKey int
	  declare @rc_course money
      declare @rc_courseStr char(30)
	  declare @dogovor_key int -- Task 10558 tfs neupokoev 26.12.2012: будем писать в историю и его тоже, чтобы потом не зморачиваться, а вдргуг сменили имя путевки
      
	  select top 1 @currencyKey = RA_KEY, @national_currency = RA_CODE from Rates where RA_National = 1
	  select @dogovor_key = dg_key from Dogovor where DG_CODE=@sDogovor
	  set @rc_course = -1
	  
	  select top 1 @rc_courseStr = RC_COURSE from RealCourses
	  where RC_RCOD1 = @national_currency and RC_RCOD2 = @sRate
	  and convert(char(10), RC_DATEBEG, 102) = convert(char(10), @date, 102)
	  
	  set @rc_course = cast(isnull(@rc_courseStr, -1) as money)

      if @sRate = @national_currency
      begin
            set @rc_courseStr = '1'
            set @rc_course = 1
      end
      
      declare @sHI_WHO varchar(25)
      exec dbo.CurrentUser @sHI_WHO output

      if @rc_course <> -1
      begin
            declare @final_price money
            set @final_price = @rc_course * @nPrice
            
            declare @sys_setting varchar(5)
			set @sys_setting = null
			select @sys_setting = SS_ParmValue from SystemSettings where SS_ParmName = 'RECALC_NATIONAL_PRICE'

            -- пересчитываем цену, если надо
            if (@sys_setting <> '-1')
            begin
				declare @tmp_final_price money
				set @tmp_final_price = null
				exec [dbo].[CalcPriceByNationalCurrencyRate] @sDogovor, @sRate, @sRateOld, @national_currency, @nPrice, @nPriceOld, @sHI_WHO, 'INSERT_TO_HISTORY', @tmp_final_price output, @rc_course, @order_status

				if @tmp_final_price is not null
				begin
					set @final_price = @tmp_final_price
				end
            end
            --
            if(@isAddToHistory=1)
            begin
				insert into dbo.history
				(HI_DGCOD, HI_WHO, HI_TEXT, HI_REMARK, HI_MOD, HI_TYPE, HI_OAId, HI_DGKEY)
				values
				(@sDogovor, @sHI_WHO, @rc_courseStr, @sRate, 'UPD', 'DOGOVORCURRENCY', 20, @dogovor_key)
            end
              if(@isAddToHistory=1)
				begin
					update dbo.tbl_Dogovor
					set
						  DG_NATIONALCURRENCYPRICE = @final_price,
						  DG_NATIONALCURRENCYDISCOUNTSUM = @rc_course * @nDiscountSum,
		                  
						  DG_CurrencyRate = @rc_course, 
						  DG_CurrencyKey =  @currencyKey 
					where
						  DG_CODE = @sDogovor
                  end
                  else
                  begin
					  update dbo.tbl_Dogovor
						set
							  DG_NATIONALCURRENCYPRICE = @final_price,
							  DG_NATIONALCURRENCYDISCOUNTSUM = @rc_course * @nDiscountSum			               
						where
							  DG_CODE = @sDogovor							  
					  
                  end
                  
      end
      else
      begin
            update dbo.tbl_Dogovor
            set
                DG_NATIONALCURRENCYPRICE = null,
                DG_NATIONALCURRENCYDISCOUNTSUM = null
            where
                  DG_CODE = @sDogovor
				  and (DG_NATIONALCURRENCYPRICE is not null or DG_NATIONALCURRENCYDISCOUNTSUM is not null)
            if(@isAddToHistory=1)
            begin
				insert into dbo.history
				(HI_DGCOD, HI_WHO, HI_TEXT, HI_REMARK, HI_MOD, HI_TYPE, HI_OAId, HI_DGKEY)
				values
				(@sDogovor, @sHI_WHO, 'Курс отсутствует', @sRate, 'UPD', 'DOGOVORCURRENCYISNULL', 21, @dogovor_key)
            end
      end
END
return 0
GO

GRANT EXEC ON [dbo].[NationalCurrencyPrice2] TO PUBLIC
GO

/*********************************************************************/
/* end sp_NationalCurrencyPrice2.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_QuotaDetailAfterDelete.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[QuotaDetailAfterDelete]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[QuotaDetailAfterDelete]
GO

CREATE PROCEDURE [dbo].[QuotaDetailAfterDelete]
AS
	--<VERSION>9.2</VERSION>
	--<DATE>2013-06-05</DATE>
	--Процедура освобождает удаленные квоты
	--QD_IsDeleted хранит статус, в который требуется поставить услуги, на данный момент находящиеся на данной квоте
	--QD_IsDeleted=3 - подтвердить (ВАЖНО подтверждается только те даты которые удаляются)
	--QD_IsDeleted=4 - Request (ВАЖНО на Request только те даты которые удаляются)
	--QD_IsDeleted=1 - попытка поставить на квоту (ВАЖНО на квоту пробуем поставить место, на всем протяжении услуги, то есть - если это проживание и только один день удаляем из квоты, то место снимается с квоты целиком и пытается сесть снова)

	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	DECLARE @SD_DLKey int
	DECLARE @ServiceByDateState int
	DECLARE @dateFrom datetime
	DECLARE @dateTo datetime

	IF Exists (SELECT top 1 1 
			   FROM QuotaDetails
			   join QuotaParts on QP_QDID = QD_ID
			   join ServiceByDate on SD_QPID=QP_ID
			   WHERE QD_IsDeleted in (3,4))
	BEGIN
		declare @DLKeysForUpdare table
		(
			DL_Key int,
			ServiceByDateState INT,
			DateFrom DATETIME,
			DateTo DATETIME
		)
		
		insert into @DLKeysForUpdare(DL_Key, ServiceByDateState, DateFrom, DateTo) 
		select SD_DLKey, 
			   MAX(QP_IsDeleted) AS ServiceByDateState,
			   MIN(QP_Date) as DateFrom,
			   MAX(QP_Date) as DateTo
		from ServiceByDate
		join QuotaParts on QP_ID = SD_QPID
		where QP_IsDeleted in (3,4) GROUP BY SD_DLKey

		UPDATE ServiceByDate 
		SET SD_State = 3, SD_QPID = null 
		WHERE SD_QPID in (SELECT QP_ID 
						  FROM QuotaDetails
						  join QuotaParts on QP_QDID = QD_ID
						  WHERE QD_IsDeleted = 3)
						  
		UPDATE ServiceByDate 
		SET SD_State = 4, SD_QPID = null 
		WHERE SD_QPID in (SELECT QP_ID 
						  FROM QuotaDetails
						  join QuotaParts on QP_QDID = QD_ID
						  WHERE QD_IsDeleted=4)
		
		DECLARE cur_QuotaDetailDelete CURSOR local fast_forward FOR 
		SELECT DISTINCT DL_Key, ServiceByDateState, DateFrom, DateTo FROM @DLKeysForUpdare
		
		OPEN cur_QuotaDetailDelete
		FETCH NEXT FROM cur_QuotaDetailDelete INTO @SD_DLKey, @ServiceByDateState, @dateFrom, @dateTo
		WHILE @@FETCH_STATUS = 0
		BEGIN
			EXEC dbo.DogListToQuotas @SD_DLKey, 1, @SetQuotaType = @ServiceByDateState, @ToSetQuotaDateFrom = @dateFrom, @ToSetQuotaDateTo = @dateTo
			FETCH NEXT FROM cur_QuotaDetailDelete INTO @SD_DLKey, @ServiceByDateState, @dateFrom, @dateTo
		END
		CLOSE cur_QuotaDetailDelete
		DEALLOCATE cur_QuotaDetailDelete
	END

	IF Exists (SELECT top 1 1 
			   FROM QuotaDetails
			   join QuotaParts on QP_QDID = QD_ID
			   join ServiceByDate on SD_QPID = QP_ID 
			   WHERE QD_IsDeleted in (1))
	BEGIN
		DECLARE cur_QuotaDetailDelete CURSOR local fast_forward FOR 
			SELECT DISTINCT SD_DLKey 
			FROM ServiceByDate 
			WHERE SD_QPID in (SELECT QP_ID 
							  FROM QuotaDetails
							  join QuotaParts on QP_QDID = QD_ID
							  WHERE QD_IsDeleted=1)
		OPEN cur_QuotaDetailDelete
		FETCH NEXT FROM cur_QuotaDetailDelete INTO @SD_DLKey
		WHILE @@FETCH_STATUS = 0
		BEGIN
			EXEC dbo.DogListToQuotas @SD_DLKey, 1
			FETCH NEXT FROM cur_QuotaDetailDelete INTO @SD_DLKey
		END
		CLOSE cur_QuotaDetailDelete
		DEALLOCATE cur_QuotaDetailDelete
	END

	update QuotaParts 
	set QP_IsDeleted = 1 
	from QuotaParts 
	join QuotaDetails on QP_QDID = QD_ID 
	where QD_IsDeleted in (1,3,4)

	DELETE FROM QuotaLimitations WHERE QL_QPID in (SELECT QP_ID FROM QuotaParts join QuotaDetails on QD_ID = QP_QDID WHERE QD_IsDeleted in (1,3,4))				  
	DELETE QuotaParts where exists(select top 1 1 from QuotaDetails WHERE QD_IsDeleted in (1,3,4) and QD_ID = QP_QDID) and not exists(select top 1 1 from ServiceByDate where SD_QPID=QP_ID) and QP_IsDeleted = 1
	DELETE FROM StopSales WHERE SS_QDID in (SELECT QD_ID FROM QuotaDetails with (nolock) WHERE QD_IsDeleted in (1,3,4))
	DELETE FROM QuotaDetails WHERE QD_IsDeleted in (1,3,4) and QD_ID not in (Select QP_QDID from ServiceByDate with (nolock), QuotaParts with (nolock) where SD_QPID=QP_ID and QP_QDID=QD_ID)
GO

GRANT EXECUTE on [dbo].[QuotaDetailAfterDelete] to public
GO
/*********************************************************************/
/* end sp_QuotaDetailAfterDelete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_QuotaPartsAfterDelete.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[QuotaPartsAfterDelete]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[QuotaPartsAfterDelete]
GO

Create PROCEDURE [dbo].[QuotaPartsAfterDelete] 

AS
BEGIN
	--version 9.2.21
	--data 2013-10-28
	--Процедура освобождает удаленные квоты
	--QD_IsDeleted хранит статус, в который требуется поставить услуги, на данный момент находящиеся на данной квоте
	--QD_IsDeleted=3 - подтвердить (ВАЖНО подтверждается только те даты которые удаляются)
	--QD_IsDeleted=4 - Request (ВАЖНО на Request только те даты которые удаляются)
	--QD_IsDeleted=1 - попытка поставить на квоту (ВАЖНО на квоту пробуем поставить место, на всем протяжении услуги, то есть - если это проживание и только один день удаляем из квоты, то место снимается с квоты целиком и пытается сесть снова)

	-- ставим вне квоты
	update ServiceByDate set SD_State = 3, SD_QPID = null where exists (select 1 from QuotaParts where QP_ID = SD_QPID and QP_IsDeleted = 3)

	-- пробуем сажать услуги, квоты которых помечены как alot/commit
	DECLARE @SD_DLKey int
	DECLARE cur_QuotaPartsDelete CURSOR FORWARD_ONLY FOR
		select distinct SD_DLKey
		from ServiceByDate
		where SD_State in (1, 2)
		and exists (select 1 from QuotaParts where QP_ID = SD_QPID and QP_IsDeleted = 1)

	-- вызываем пересадку
	OPEN cur_QuotaPartsDelete
	FETCH NEXT FROM cur_QuotaPartsDelete INTO @SD_DLKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC dbo.DogListToQuotas @SD_DLKey
		FETCH NEXT FROM cur_QuotaPartsDelete INTO @SD_DLKey
	END
	CLOSE cur_QuotaPartsDelete
	DEALLOCATE cur_QuotaPartsDelete

	declare @DLKeysForUpdare table
	(
		DL_Key int
	)

	-- ключи услуг, которые должны быть посажены на Request
	insert into @DLKeysForUpdare(DL_Key) select SD_DLKey from ServiceByDate,QuotaParts where QP_ID = SD_QPID and QP_IsDeleted = 4
	
	-- ставим на Request
	update ServiceByDate set SD_State = 4, SD_QPID = null where exists (select 1 from QuotaParts where QP_ID = SD_QPID and QP_IsDeleted = 4)
	
	DECLARE cur_QuotaPartsDelete2 CURSOR FORWARD_ONLY FOR
		select distinct DL_Key
		from @DLKeysForUpdare

	OPEN cur_QuotaPartsDelete2
	FETCH NEXT FROM cur_QuotaPartsDelete2 INTO @SD_DLKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
		declare @dlControlNull int
		EXEC SetServiceStatusOk @SD_DLKey,@dlControlNull output
		FETCH NEXT FROM cur_QuotaPartsDelete2 INTO @SD_DLKey
	END
	CLOSE cur_QuotaPartsDelete2
	DEALLOCATE cur_QuotaPartsDelete2

	-- запомним ключи, которые необходимо удалить
	declare @DelQPID table
	(
		DQPID int,
		DQDID int,
		DQD_IsDeleted int,
		DQ_DLKey int
	)

	insert into @DelQPID (DQPID, DQDID, DQD_IsDeleted, DQ_DLKey)
	select QP_ID, QP_QDID, QP_IsDeleted, SD_DLKey
	from QuotaParts left join ServiceByDate on SD_QPID = QP_ID
	where QP_IsDeleted in (1,3,4)

	-- удаляем
	DELETE FROM QuotaLimitations WHERE QL_QPID in (SELECT DQPID FROM @DelQPID)
	DELETE FROM QuotaParts WHERE QP_ID in (SELECT DQPID FROM @DelQPID)
	-- только те QuotaDetails которые есть в нашем списке и на них нету записей в QuotaParts
	DELETE FROM QuotaDetails WHERE QD_ID in (SELECT DQDID FROM @DelQPID) and not exists (select 1 from QuotaParts where QP_QDID = QD_ID)
	DELETE FROM StopSales WHERE SS_QDID in (SELECT DQDID FROM @DelQPID) and not exists (select 1 from QuotaDetails where QD_ID = SS_QDID)
END

go 

grant exec on QuotaPartsAfterDelete to public 

go

/*********************************************************************/
/* end sp_QuotaPartsAfterDelete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_RecalculateByTime.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RecalculateByTime]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RecalculateByTime]
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[RecalculateByTime] 
(
	--<VERSION>2009.2.20</VERSION>
	--<DATA>07.10.2013</DATA>
	@cpkey int = null
)
AS
DECLARE
	@priceTourKey int,			-- ключ обсчитываемого тура
	@priceTOKey int,
	@saleDate datetime,		-- дата продажи
	@nullCostAsZero smallint,	-- считать отсутствующие цены нулевыми (кроме проживания) 0 - нет, 1 - да
	@noFlight smallint,		-- при отсутствии перелёта в расписании 0 - ничего не делать, 1 - не обсчитывать тур, 2 - искать подходящий перелёт (если не найдено - не рассчитывать)
	@update smallint,			-- признак дозаписи 0 - расчет, 1 - дозапись
	@useHolidayRule smallint,		-- Правило выходного дня: 0 - не использовать, 1 - использовать
	@countReCalcMax smallint,   --максимальное число одновременно расчитываемых прайс-листов
	@countRecalc int,      --число расчитываемых прайс листов
	@priceTOKeyActiv int,  --ключ тура который сейчас активен
	@flagTran bit = 0
BEGIN
	--SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
	
	select @countRecalcMax = SS_ParmValue from SystemSettings where SS_ParmName='SYSCalcPriceCountMax'
	select @countRecalc=COUNT(*) from tp_tours WHERE TO_PROGRESS<>100 and TO_TrKey in (select CP_TourKey from CalculatingPriceLists where CP_Status=1)
	
	--если количество одновременно расчитываемых туров не превышает максимального значения или не задан параметр максимальное количество расчитываемых туров
	if (@countRecalcMax > @countRecalc or @countRecalcMax is null )
	begin	
		begin tran
		
			select top 1 @cpkey = CP_Key from CalculatingPriceLists 
											where CP_StartTime is not null and 
												(CP_Status = 0 or (CP_Status = 1 and CP_StartTime<=DateAdd(hour,-10,GETDATE()))) 
											order by CP_Priority desc
			UPDATE CalculatingPriceLists WITH (ROWLOCK) Set CP_Status = 1, CP_StartTime=GETDATE() where CP_Key=@cpkey
			UPDATE TP_Tours WITH (ROWLOCK) Set TO_PROGRESS = 0, TO_UPDATE = 0, TO_UPDATETIME=GETDATE() where TO_Key= (select CP_PriceTourKey from  CalculatingPriceLists where CP_Key=@cpkey)
			
		commit tran
		if (@cpkey is not null)
		begin
		
			select @priceTourKey=CP_TourKey,  @saleDate=CP_SaleDate, @nullCostAsZero=CP_NullCostAsZero,@noFlight=CP_NoFlight, @update=CP_Update,
				@useHolidayRule=CP_UseHolidayRule, @priceTOKey = CP_PriceTourKey from CalculatingPriceLists where CP_Key=@cpkey
				
			-- если у нас есть активный тур  и это не дозапись то удаляем его
			select @priceTOKeyActiv=TO_Key from TP_Tours left join CalculatingPriceLists on CP_PriceTourKey=TO_Key 
											where TO_TRKey=@priceTourKey and CP_StartTime is null and TO_Key<>@priceTOKey
			
			begin try								
			
				if (@priceTOKeyActiv!=0 and @update<>1 and @priceTOKeyActiv is not null)
				begin	
					EXEC RemoveReferences 'TP_TOURS', @priceTOKeyActiv
					DELETE FROM CalculatingPriceLists with (rowlock) WHERE CP_PriceTourKey = @priceTOKeyActiv
					DELETE FROM TP_TOURS with (rowlock) WHERE TO_KEY = @priceTOKeyActiv
				end

				--если у тура менялом название то, меняем его, на название из тур листа
				--запоминаем значения отличные от названия (иначе триггер их перетрет)
				declare @nameWeb varchar(250)
				select @nameWeb = TL_NAMEWEB from Turlist where TL_KEY=@priceTourKey
				update TP_Tours SET TO_Name=(select TL_NAMEWEB from Turlist where TL_KEY=@priceTourKey) where TO_Key=@priceTOKey
				update Turlist set TL_NAMEWEB = @nameWeb  where TL_KEY=@priceTourKey

				--запуск расчета
				exec CalculatePriceList @nPriceTourKey=@priceTOKey, @nCalculatingKey=@cpkey, @dtSaleDate=@saleDate, @nNullCostAsZero=@nullCostAsZero, @nNoFlight =@noFlight,
					@nUpdate=@update,@nUseHolidayRule = @useHolidayRule
					
				--если стоит параметр выставить в интернет, выставляем тур в интернет	
				if exists(select 1 from CalculatingPriceLists where CP_Key=@cpkey and CP_ExposeWeb=1)
				begin
					exec FillMasterWebSearchFields @tokey=@priceTOKey, @calcKey=@cpkey
					update TP_Tours SET TO_IsEnabled=1 where TO_Key=@priceTOKey
				end
				
				--расчет прайс-листа завершен
				UPDATE CalculatingPriceLists Set CP_Status=0, CP_StartTime = null where CP_Key=@cpkey
			end try
			begin catch
				insert into Debug (db_Text,db_n1, db_n2) values (ERROR_MESSAGE(),4, @cpkey)
			end catch
		end
	END
END

GO
grant exec on [dbo].[RecalculateByTime] to public
go
/*********************************************************************/
/* end sp_RecalculateByTime.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts_CalculatePriceList.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts_CalculatePriceList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts_CalculatePriceList]
GO
CREATE PROCEDURE [dbo].[ReCalculateCosts_CalculatePriceList]
	(
		@scpId int,
		@brutto money output,
		@IsCommission bit output,
		
		@svKey int,
		@code int,
		@code1 int,
		@code2 int,
		@prKey int,
		@packetKey int,
		@date datetime,
		@days int,
		@resRate varchar(2),
		@men int,
		@discountPercent decimal(14,6),
		@margin decimal(14,6),
		@marginType int,
		@sellDate dateTime, 
		@netto decimal(14,6),		
		@discount decimal(14,6),
		@nettoDetail varchar(100),
		@sBadRate varchar(2),
		@dtBadDate dateTime,
		@sDetailed varchar(100),
		@nSPId int,
		@tourKey int,
		@tourDate datetime,
		@tourDays int,
		@IsDuration smallint
	)
as

--<data>2013-07-23</data>
--<version>9.20</version>

BEGIN
	declare @useDiscountDays int
	
	-- если наща услуга без продолжительности то устанавливаем ей продолжительность равную продолжительности тура
	if (@IsDuration != 1)
	begin
		set @days = @tourDays
	end

	/*Нужно вставить логику которая идет перед расчетом услуги в старом CalculatePriceList*/

	set @brutto = null	
	set @sellDate = null
	set @margin = 0
	set @marginType = 0

	/*попробуем найти запись нужной нам цены*/
	-- gorshkov у строк вставленных этой хранимкой (там пониже есть инсерт)
	-- SPAD_DateLastChange = SPAD_DateLastCalculate = getdate()
	-- т.е. здесь нужно использовать <= а не <
	select	top 1 
		@brutto = xSPAD_Gross,
		@IsCommission = xSPAD_IsCommission
	from #ServicePriceActualDate with(nolock)
	where xSPAD_SCPId = @scpId
	and xSPAD_SaleDate is null
	-- или расчитана и перенесена или только расчитана но не перенесена
	and xSPAD_Rate = @resRate
	and xSPAD_NeedApply = 0
	
	if (@brutto is not null)
	begin
		--update Debug  set db_n1 = db_n1 +1 where db_Text = '- #GetServiceCost'
		return
	end
	
	-- не нашли расчитанной цены, нужно расчитать и записать результат в TP_ServicePriceActualDate
	exec GetServiceCost @svKey, @code, @code1, @code2, @prKey, @packetKey, @date, @days,
	@resRate, @men, @discountPercent, @margin, @marginType,
	@sellDate, @netto output, @brutto output, @discount output,
	@nettoDetail output, @sBadRate output, @dtBadDate output,
	@sDetailed output,  @nSPId output, @useDiscountDays output,
	@tourKey, @tourDate, @tourDays, 0
	
	--update Debug  set db_n1 = db_n1 +1 where db_Text = '+ #GetServiceCost'
	
	/*Нужно вствить логику на праверку устаревших данных по полю SPAD_SaleDate
	Если есть строки с SPAD_SaleDate <= getadte() то у ней, она должны быть нужно установить SPAD_SaleDate = null, а старые записи с SPAD_SaleDate = null удалить
	Пока не понятно как это будет работать нужно обсудить*/		
	
	if (@discount is null)
		set @IsCommission = 0
	else
		set @IsCommission = 1
	
	if (not exists (select top 1 1
					from #ServicePriceActualDate with(nolock)
					where xSPAD_SCPId = @scpId
					and xSPAD_SaleDate is null
					and xSPAD_Rate = @resRate))
	begin
		-- gorshkov зафиксировал время, которое будет вставляться в SPAD_DateLastChange и SPAD_DateLastCalculate
		declare @modificationDate datetime;
		set @modificationDate=getdate();
		insert into #ServicePriceActualDate (xSPAD_SCPId, xSPAD_IsCommission, xSPAD_Rate, xSPAD_SaleDate, xSPAD_Gross, xSPAD_Netto, xSPAD_DateLastChange,
												xSPAD_DateLastCalculate, xSPAD_NeedApply)
		values (@scpId, @IsCommission, @resRate, null, @brutto, @netto, @modificationDate, @modificationDate , 0)
	end
	else
	begin
		-- обновим и скажем чтобы обновились цены в других турах
		update #ServicePriceActualDate
		set xSPAD_Gross = @brutto,
		xSPAD_Netto = @netto,
		xSPAD_IsCommission = @IsCommission,
		xSPAD_DateLastCalculate = getdate(),
		xSPAD_NeedApply = 0
		where xSPAD_SCPId = @scpId
		and xSPAD_SaleDate is null
		and xSPAD_Rate = @resRate
	end
END

GO

grant exec on [dbo].[ReCalculateCosts_CalculatePriceList] to public
go

/*********************************************************************/
/* end sp_ReCalculateCosts_CalculatePriceList.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts_GrossMigrate.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts_GrossMigrate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts_GrossMigrate]
GO
CREATE PROCEDURE [dbo].[ReCalculateCosts_GrossMigrate]
	(
		-- хранимка переносит цены из таблицы TP_PriceActualDate в TP_PriceComponents
		-- <version>2009.02.11</version>
		-- <data>2013-05-26</data>
		@countItems int,
		-- ключи тех записей которые нужно расчитать
		@xSCPIdTable nvarchar(max) = null,
		-- ключи тех записей которые нужно расчитать, если задан этот параметр, то SPAD_AutoOnline игнорируется
		@xOnlySCPIdTable nvarchar(max) = null,
		-- так же публиковать остальные цены по этому отелю, отличающихся от выбранной только комнатой, категорией и питанием
		-- работает только если задан параметр @xOnlySCPIdTable
		@xPublichAllRoomAllCategoryAllPansion bit = null,
		-- список продолжительностей цены на которые нужно опубликовать
		@xLongList nvarchar(max) = null,
		-- svKey - тип услуги (1 -а/п, 3 - отель, внимание исключение '-1' - означает не отель и не а/п, а любая другая услуга)
		@nSVKey int = null,
		@nCode int = null 
	)
AS
BEGIN
	set nocount on;
	declare @beginTime datetime, @debug varchar(255)
	set @beginTime = getDate()
	
	--print '1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--set @debug = '1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--insert into Debug (db_Date, db_Mod, db_Text)
	--values(GETDATE(), 'GM', substring(@debug, 0, 255))
	--set @beginTime = getDate()
	
	create table #tpServicePriceActualDateTable
	(
		SPAD_SCPId bigint,
		SPAD_Id bigint,
		SPAD_Gross money,
		SPAD_Rate nvarchar(2) collate database_default,
		SPAD_IsCommission bit,
		SPAD_AutoOnline int,
		SCP_DateCheckIn datetime,
		SCP_SvKey int
	)
	
	create index x_tpServicePriceActualDateTable on #tpServicePriceActualDateTable
	(
		SCP_DateCheckIn,
		SPAD_Rate,
		SPAD_SCPId,
		SCP_SvKey,
		SPAD_Gross
	) include (SPAD_Id, SPAD_IsCommission, SPAD_AutoOnline)
	
	if (@xOnlySCPIdTable is not null)
	begin
		-- этот кусок кода вызывается только из экранов "Маржинальный монитор" и "Перерасчет расчитанных цен"		
		-- поэтому перед публикацией нужно найти 
		if (isnull(@xPublichAllRoomAllCategoryAllPansion, 0) = 1)
		begin
			update TP_ServicePriceActualDate
			set SPAD_AutoOnline = 1
			from TP_ServicePriceActualDate as spad1 join TP_ServiceCalculateParametrs as scp1 with(nolock) on SPAD_SCPId = SCP_Id
			join TP_ServiceComponents as sc1 with(nolock) on SCP_SCId = SC_Id
			where SPAD_SaleDate is null
			and exists (	select top 1 1
							from TP_ServiceCalculateParametrs as scp2 with(nolock) join TP_ServiceComponents as sc2 with(nolock) on SCP_SCId = SC_Id
							where 
							scp2.SCP_Id in (select xt_key from dbo.ParseKeys(@xOnlySCPIdTable))
							and scp1.SCP_Date = scp2.SCP_Date
							and scp1.SCP_DateCheckIn = scp2.SCP_DateCheckIn
							and scp1.SCP_PKKey = scp2.SCP_PKKey
							and scp1.SCP_SvKey = scp2.SCP_SvKey
							and (@xLongList is null or (scp1.SCP_TourDays in (select xt_key from dbo.ParseKeys(@xLongList))))
							and sc1.SC_Code = sc2.SC_Code
							and sc1.SC_PRKey = sc2.SC_PRKey
							and sc1.SC_SVKey = sc2.SC_SVKey
							)
		end
	
		insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
		select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
		from TP_ServicePriceActualDate with(nolock) join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
		where SPAD_SaleDate is null
		and SPAD_NeedApply = 0
		and SCP_Id in (select xt_key from dbo.ParseKeys(@xOnlySCPIdTable))
		
		--print '1.1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '1.1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	else if (@xSCPIdTable is not null)
	begin
		insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
		select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
		from TP_ServicePriceActualDate with(nolock) join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
		where SPAD_SaleDate is null
		and SPAD_NeedApply = 0
		and SPAD_AutoOnline = 1
		and SCP_Id in (select xt_key from dbo.ParseKeys(@xSCPIdTable))
		
		--print '1.2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '1.2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	else
	begin
		if ((@nSVKey = 3) or (@nSVKey = 1)) -- Если отель или а/п
		begin
			insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
			select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
			from TP_ServicePriceActualDate join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id join TP_ServiceComponents WITH (NOLOCK) on SCP_SCId = SC_Id
			where SPAD_SaleDate is null
			and SPAD_NeedApply = 0
			and SPAD_AutoOnline = 1
			and SCP_SvKey = @nSVKey
			and SC_SVKey = @nSVKey
			and (@nCode is null or SC_Code = @nCode)
		end		
		else if (@nSVKey = -1) -- '-1' зарезервирован под расчет всех услуг, кроме отеля и перелета
		begin
			insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
			select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
			from TP_ServicePriceActualDate join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
			where SPAD_SaleDate is null
			and SPAD_NeedApply = 0
			and SPAD_AutoOnline = 1
			and SCP_SvKey not in (1,3)
		end
		else if @nSVKey is null
		begin
			insert into #tpServicePriceActualDateTable (SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey)
			select top (@countItems) SPAD_SCPId, SPAD_Id, SPAD_Gross, SPAD_Rate, SPAD_IsCommission, SPAD_AutoOnline, SCP_DateCheckIn, SCP_SvKey
			from TP_ServicePriceActualDate join TP_ServiceCalculateParametrs with(nolock) on SPAD_SCPId = SCP_Id
			where SPAD_SaleDate is null
			and SPAD_NeedApply = 0
			and SPAD_AutoOnline = 1
--			declare @tmp_svkey int, @tmp_SPADId int
--			select TOP 1 @tmp_svkey=SCP_SvKey, @tmp_SPADId=SPAD_Id from #tpServicePriceActualDateTable
--			print '@tmp_svkey=' + CAST(@tmp_svkey as varchar(20))
--			print '@@tmp_SPADId=' + CAST(@tmp_SPADId as varchar(20))
		end
		
		--print '1.3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '1.3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end	
	
	--print '2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--set @debug = '2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--insert into Debug (db_Date, db_Mod, db_Text)
	--values(GETDATE(), 'GM', substring(@debug, 0, 255))
	--set @beginTime = getDate()

	declare @PriceComponentsRows int;
	set @PriceComponentsRows = 0;
	
	-- разобьем апдейт на 15 - по каждому картежу свой
	
	if exists(select 1 
			  from TP_PriceComponents with(nolock) 
			  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_1
			  where SCP_SvKey = SvKey_1
					and SCPId_1 is not null
					and (isnull(SPAD_Gross, -100500) != isnull(Gross_1, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_1, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_1 = SPAD_Gross,
		IsCommission_1 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_1
		where SCP_SvKey = SvKey_1
		and SCPId_1 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_1, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_1, -100500))
		
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.1: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_2
		  where SCP_SvKey = SvKey_2
				and SCPId_2 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_2, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_2, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_2 = SPAD_Gross,
		IsCommission_2 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_2
		where SCP_SvKey = SvKey_2
		and SCPId_2 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_2, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_2, -100500))
		
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.2: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_3
		  where SCP_SvKey = SvKey_3
				and SCPId_3 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_3, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_3, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_3 = SPAD_Gross,
		IsCommission_3 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_3
		where SCP_SvKey = SvKey_3
		and SCPId_3 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_3, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_3, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_4
		  where SCP_SvKey = SvKey_4
				and SCPId_4 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_4, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_4, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_4 = SPAD_Gross,
		IsCommission_4 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_4
		where SCP_SvKey = SvKey_4
		and SCPId_4 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_4, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_4, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.4: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.4: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_5
		  where SCP_SvKey = SvKey_5
				and SCPId_5 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_5, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_5, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_5 = SPAD_Gross,
		IsCommission_5 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_5
		where SCP_SvKey = SvKey_5
		and SCPId_5 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_5, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_5, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.5: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.5: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_6
		  where SCP_SvKey = SvKey_6
				and SCPId_6 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_6, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_6, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_6 = SPAD_Gross,
		IsCommission_6 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_6
		where SCP_SvKey = SvKey_6
		and SCPId_6 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_6, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_6, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.6: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.6: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_7
		  where SCP_SvKey = SvKey_7
				and SCPId_7 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_7, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_7, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_7 = SPAD_Gross,
		IsCommission_7 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_7
		where SCP_SvKey = SvKey_7
		and SCPId_7 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_7, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_7, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.7: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.7: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_8
		  where SCP_SvKey = SvKey_8
				and SCPId_8 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_8, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_8, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_8 = SPAD_Gross,
		IsCommission_8 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_8
		where SCP_SvKey = SvKey_8
		and SCPId_8 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_8, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_8, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.8: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.8: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_9
		  where SCP_SvKey = SvKey_9
				and SCPId_9 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_9, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_9, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_9 = SPAD_Gross,
		IsCommission_9 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_9
		where SCP_SvKey = SvKey_9
		and SCPId_9 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_9, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_9, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.9: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.9: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_10
		  where SCP_SvKey = SvKey_10
				and SCPId_10 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_10, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_10, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_10 = SPAD_Gross,
		IsCommission_10 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_10
		where SCP_SvKey = SvKey_10
		and SCPId_10 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_10, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_10, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.10: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.10: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_11
		  where SCP_SvKey = SvKey_11
				and SCPId_11 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_11, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_11, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_11 = SPAD_Gross,
		IsCommission_11 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_11
		where SCP_SvKey = SvKey_11
		and SCPId_11 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_11, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_11, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.11: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.11: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_12
		  where SCP_SvKey = SvKey_12
				and SCPId_12 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_12, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_12, -100500)))
	begin
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_12 = SPAD_Gross,
		IsCommission_12 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_12
		where SCP_SvKey = SvKey_12
		and SCPId_12 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_12, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_12, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.12: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.12: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_13
		  where SCP_SvKey = SvKey_13
				and SCPId_13 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_13, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_13, -100500)))
	begin	
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_13 = SPAD_Gross,
		IsCommission_13 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_13
		where SCP_SvKey = SvKey_13
		and SCPId_13 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_13, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_13, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.13: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.13: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_14
		  where SCP_SvKey = SvKey_14
				and SCPId_14 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_14, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_14, -100500)))
	begin
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_14 = SPAD_Gross,
		IsCommission_14 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_14
		where SCP_SvKey = SvKey_14
		and SCPId_14 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_14, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_14, -100500))
		
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.14: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.14: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	if exists(select 1 
		  from TP_PriceComponents with(nolock) 
		  join #tpServicePriceActualDateTable with(nolock) on SPAD_SCPId = SCPId_15
		  where SCP_SvKey = SvKey_15
				and SCPId_15 is not null
				and (isnull(SPAD_Gross, -100500) != isnull(Gross_15, -100500)
					or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_15, -100500)))
	begin
		update TP_PriceComponents
		set 
		PC_DateLastChangeGross = getdate(), 
		PC_UpdateDate = getdate(),
		Gross_15 = SPAD_Gross,
		IsCommission_15 = SPAD_IsCommission,
		PC_State = 1
		from TP_PriceComponents join #tpServicePriceActualDateTable on SPAD_SCPId = SCPId_15
		where SCP_SvKey = SvKey_15
		and SCPId_15 is not null
		and (isnull(SPAD_Gross, -100500) != isnull(Gross_15, -100500)
			or isnull(SPAD_IsCommission, -100500) != isnull(IsCommission_15, -100500))
			
		set @PriceComponentsRows = @PriceComponentsRows + @@rowcount;
		
		--print '2.15: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		--set @debug = '2.15: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime))) + '^' + convert(varchar(max), @PriceComponentsRows)
		--insert into Debug (db_Date, db_Mod, db_Text)
		--values(GETDATE(), 'GM', substring(@debug, 0, 255))
		--set @beginTime = getDate()
	end
	
	--print '3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--set @debug = '3: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--insert into Debug (db_Date, db_Mod, db_Text)
	--values(GETDATE(), 'GM', substring(@debug, 0, 255))
	--set @beginTime = getDate()
		
	print 'Количество строк в TP_PriceComponents: ' + convert(nvarchar(max), @PriceComponentsRows)
	
	/*обновим галку о необходимости переноса цены*/
	update TP_ServicePriceActualDate
	set SPAD_AutoOnline = 0
	where SPAD_Id in (select SPAD_Id from #tpServicePriceActualDateTable)
	
	declare @ServicePriceRows int
	set @ServicePriceRows = @@rowcount
	print 'Количество строк в TP_ServicePriceActualDate: ' + convert(nvarchar(max), @ServicePriceRows)

	insert into Debug (db_Date, db_Mod, db_Text, db_n1, db_n2, db_n3) 
	values (@beginTime, 'GM', '1.Duration(sec); 2.PriceComponents(rows); 3.ServicePriceActualDate(rows)', DATEDIFF(second, @beginTime, GetDate()), @PriceComponentsRows, @ServicePriceRows)
	
	
	--print '4: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--set @debug = '4: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	--insert into Debug (db_Date, db_Mod, db_Text)
	--values(GETDATE(), 'GM', substring(@debug, 0, 255))
	--set @beginTime = getDate()

END

GO

grant exec on [dbo].[ReCalculateCosts_GrossMigrate] to public
go
/*********************************************************************/
/* end sp_ReCalculateCosts_GrossMigrate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculateCosts_MarginMigrateTRKey.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculateCosts_MarginMigrateTRKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculateCosts_MarginMigrateTRKey]
GO

CREATE PROCEDURE [dbo].[ReCalculateCosts_MarginMigrateTRKey]
		-- хранимка переносит цены из таблицы TP_PriceActualDate в TP_PriceComponents
		-- <version>9.2.19</version>
		-- <data>2013-03-11</data>
		(@TrKey int = null,
		@MinValue smallint = null,
		@JobID smallint = null)
AS
BEGIN
	SET ARITHABORT ON;
	SET DATEFIRST 1;
	set nocount on;
	
	declare @beginTime datetime
	set @beginTime = getDate()	
	
	/*таблица первоночальной выборки*/
	declare @tableForMigrate table
	(
		TMAD_Id int,
		TMAD_TRKey int,
		TMAD_DateCheckIn datetime,
		TMAD_SvKey int,
		TMAD_Long smallint,
		TMAD_Percent money,
		TMAD_IsCommission bit
	)
	
	declare @count int, @DateCheckInMin datetime, @DateCheckInMax datetime, @Return smallint
	
	if @TrKey is null 
	Begin
		if @MinValue = 1
		begin
			select TOP 1 @TrKey=TMAD_TRKey, @count=COUNT(*)
			from TP_TourMarginActualDate with(nolock)
			where TMAD_NeedApply = 2
				and not exists (select 1 from Debug with(nolock) where db_Mod='MMI' and db_n1=TMAD_TRKey)
			group by TMAD_TRKey
			order by 2
		end
		else
		begin
			select TOP 1 @TrKey=TMAD_TRKey, @count=COUNT(*)
			from TP_TourMarginActualDate with(nolock)
			where TMAD_NeedApply = 2
				and not exists (select 1 from Debug with(nolock) where db_Mod='MMI' and db_n1=TMAD_TRKey)
			group by TMAD_TRKey
			order by 2 desc
		end
	end
	else
		select @count=COUNT(*) from TP_TourMarginActualDate with(nolock) where TMAD_NeedApply = 2 and TMAD_TRKey=@TrKey

	if @TrKey is null 
		print 'нет записей для переноса'
	begin
		if @TrKey is not null
			insert into Debug (db_Mod, db_n1, db_n2) values ('MMI',@TrKey, @JobID)
		
		insert into @tableForMigrate (TMAD_Id, TMAD_TRKey, TMAD_DateCheckIn, TMAD_SvKey, TMAD_Long, TMAD_Percent, TMAD_IsCommission)
		select TOP 5000 TMAD_Id, TMAD_TRKey, TMAD_DateCheckIn, TMAD_SvKey, TMAD_Long, TMAD_Percent, TMAD_IsCommission
		from TP_TourMarginActualDate with(nolock)
		where TMAD_NeedApply = 2
			and TMAD_TRKey = @TrKey --and TMAD_DateCheckIn=@DateCheckIn
		
		select @DateCheckInMin = MIN(TMAD_DateCheckIn), @DateCheckInMax = MAX(TMAD_DateCheckIn) from @tableForMigrate 
		
		print 'TourKey: ' + CAST(@TrKey as varchar(100)) + ' Дата c: ' + convert(varchar, @DateCheckInMin, 111) + ' Дата по: ' + convert(varchar, @DateCheckInMax, 111)
		
		print 'выборка записей из очереди: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()

		set @Return = 0
		
		/*перенесем изменения в основную таблицу*/
		-- разобьем апдейт по кортежам
		
		declare @tempPCIdtable table
		(
			xPCId bigint,
			xIsCommission bit,
			xPercent money
		)
		
		-- %%%%%%%%%%%%%%%%%%% Кортеж 1 %%%%%%%%%%%%%%%%%%%%%%%
		insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
		select PC_Id, TMAD_IsCommission, TMAD_Percent
		from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
		where PC_TourDate = TMAD_DateCheckIn
		and PC_Days = TMAD_Long
		and SVKey_1 = TMAD_SvKey
		and PC_TRKey = @TrKey

		if @TrKey is not null
			update Debug set db_n3 = 0 where db_Mod='MMI' and db_n1=@TrKey

		if exists (select top 1 1 from @tempPCIdtable)
		begin
			update TP_PriceComponents
			set	PC_DateLastChangeMargin = getdate(), 
				PC_UpdateDate = getdate(),
				CommissionOnly_1 = xIsCommission,
				MarginPercent_1 = xPercent,
				PC_State = 1
			from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
			WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
					and PC_TRKey = @TrKey		
			
			delete @tempPCIdtable
		end
		-- %%%%%%%%%%%%%%%%%%% Кортеж 1 %%%%%%%%%%%%%%%%%%%%%%%
		if @TrKey is not null
			update Debug set db_n3 = 1 where db_Mod='MMI' and db_n1=@TrKey
		
		-- %%%%%%%%%%%%%%%%%%% Кортеж 2 %%%%%%%%%%%%%%%%%%%%%%%
		insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
		select PC_Id, TMAD_IsCommission, TMAD_Percent
		from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
		where PC_TourDate = TMAD_DateCheckIn
		and PC_Days = TMAD_Long
		and SVKey_2 = TMAD_SvKey
		and PC_TRKey = @TrKey
		
		if exists (select top 1 1 from @tempPCIdtable)
		begin
			update TP_PriceComponents
			set	PC_DateLastChangeMargin = getdate(), 
				PC_UpdateDate = getdate(),
				CommissionOnly_2 = xIsCommission,
				MarginPercent_2 = xPercent,
				PC_State = 1
			from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
			WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
					and PC_TRKey = @TrKey		
						
			delete @tempPCIdtable
		end
		-- %%%%%%%%%%%%%%%%%%% Кортеж 2 %%%%%%%%%%%%%%%%%%%%%%%
		
		-- %%%%%%%%%%%%%%%%%%% Кортеж 3 %%%%%%%%%%%%%%%%%%%%%%%
		insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
		select PC_Id, TMAD_IsCommission, TMAD_Percent
		from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
		where PC_TourDate = TMAD_DateCheckIn
		and PC_Days = TMAD_Long
		and SVKey_3 = TMAD_SvKey
		and PC_TRKey = @TrKey
		
		if exists (select top 1 1 from @tempPCIdtable)
		begin
			update TP_PriceComponents
			set	PC_DateLastChangeMargin = getdate(), 
				PC_UpdateDate = getdate(),
				CommissionOnly_3 = xIsCommission,
				MarginPercent_3 = xPercent,
				PC_State = 1
			from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
			WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
					and PC_TRKey = @TrKey		
			
			delete @tempPCIdtable
		end
		-- %%%%%%%%%%%%%%%%%%% Кортеж 3 %%%%%%%%%%%%%%%%%%%%%%%
		
		if @TrKey is not null
			update Debug set db_n3 = 3 where db_Mod='MMI' and db_n1=@TrKey
	
		-- %%%%%%%%%%%%%%%%%%% Кортеж 4 %%%%%%%%%%%%%%%%%%%%%%%
		insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
		select PC_Id, TMAD_IsCommission, TMAD_Percent
		from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
		where PC_TourDate = TMAD_DateCheckIn
		and PC_Days = TMAD_Long
		and SVKey_4 = TMAD_SvKey
		and PC_TRKey = @TrKey
		
		if exists (select top 1 1 from @tempPCIdtable)
		begin
			update TP_PriceComponents
			set	PC_DateLastChangeMargin = getdate(), 
				PC_UpdateDate = getdate(),
				CommissionOnly_4 = xIsCommission,
				MarginPercent_4 = xPercent,
				PC_State = 1
			from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
			WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
					and PC_TRKey = @TrKey		
			
			delete @tempPCIdtable
		end
		-- %%%%%%%%%%%%%%%%%%% Кортеж 4 %%%%%%%%%%%%%%%%%%%%%%%
		
		-- %%%%%%%%%%%%%%%%%%% Кортеж 5 %%%%%%%%%%%%%%%%%%%%%%%
		insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
		select PC_Id, TMAD_IsCommission, TMAD_Percent
		from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
		where PC_TourDate = TMAD_DateCheckIn
		and PC_Days = TMAD_Long
		and SVKey_5 = TMAD_SvKey
		and PC_TRKey = @TrKey
		
		if exists (select top 1 1 from @tempPCIdtable)
		begin
			update TP_PriceComponents
			set	PC_DateLastChangeMargin = getdate(), 
				PC_UpdateDate = getdate(),
				CommissionOnly_5 = xIsCommission,
				MarginPercent_5 = xPercent,
				PC_State = 1
			from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
			WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
					and PC_TRKey = @TrKey		
			
			delete @tempPCIdtable
		end
		-- %%%%%%%%%%%%%%%%%%% Кортеж 5 %%%%%%%%%%%%%%%%%%%%%%%
		

		if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_6 is not null)				
		begin
			-- %%%%%%%%%%%%%%%%%%% Кортеж 6 %%%%%%%%%%%%%%%%%%%%%%%
			insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
			select PC_Id, TMAD_IsCommission, TMAD_Percent
			from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
			where PC_TourDate = TMAD_DateCheckIn
			and PC_Days = TMAD_Long
			and SVKey_6 = TMAD_SvKey
			and PC_TRKey = @TrKey
			
			if exists (select top 1 1 from @tempPCIdtable)
			begin
				update TP_PriceComponents
				set	PC_DateLastChangeMargin = getdate(), 
					PC_UpdateDate = getdate(),
					CommissionOnly_6 = xIsCommission,
					MarginPercent_6 = xPercent,
					PC_State = 1
				from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
				WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
						and PC_TRKey = @TrKey		
				
				delete @tempPCIdtable
			end
			-- %%%%%%%%%%%%%%%%%%% Кортеж 6 %%%%%%%%%%%%%%%%%%%%%%%
		end
		else
			set @Return = 1

		if @TrKey is not null
			update Debug set db_n3 = 6 where db_Mod='MMI' and db_n1=@TrKey

		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_7 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 7 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_7 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_7 = xIsCommission,
						MarginPercent_7 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 7 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end

		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_8 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 8 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_8 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_8 = xIsCommission,
						MarginPercent_8 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 8 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end
		
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_9 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 9 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_9 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_9 = xIsCommission,
						MarginPercent_9 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 9 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end

		if @TrKey is not null
			update Debug set db_n3 = 9 where db_Mod='MMI' and db_n1=@TrKey
		
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_10 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 10 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_10 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_10 = xIsCommission,
						MarginPercent_10 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 10 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end
				
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_11 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 11 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_11 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_11 = xIsCommission,
						MarginPercent_11 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 11 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end
		
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_12 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 12 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_12 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_12 = xIsCommission,
						MarginPercent_12 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 12 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end

		if @TrKey is not null
			update Debug set db_n3 = 12 where db_Mod='MMI' and db_n1=@TrKey
		
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_13 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 13 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_13 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_13 = xIsCommission,
						MarginPercent_13 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 13 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end
		
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_14 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 14 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_14 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_14 = xIsCommission,
						MarginPercent_14 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 14 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end
		
		if 	@Return != 1
		begin
			if exists (select 1 from TP_PriceComponents with (nolock) where PC_TRKey = @TrKey and SCPId_15 is not null)				
			begin
				-- %%%%%%%%%%%%%%%%%%% Кортеж 15 %%%%%%%%%%%%%%%%%%%%%%%
				insert into @tempPCIdtable (xPCId, xIsCommission, xPercent)
				select PC_Id, TMAD_IsCommission, TMAD_Percent
				from TP_PriceComponents with (nolock) join @tableForMigrate on PC_TRKey = TMAD_TRKey
				where PC_TourDate = TMAD_DateCheckIn
				and PC_Days = TMAD_Long
				and SVKey_15 = TMAD_SvKey
				and PC_TRKey = @TrKey
				
				if exists (select top 1 1 from @tempPCIdtable)
				begin
					update TP_PriceComponents
					set	PC_DateLastChangeMargin = getdate(), 
						PC_UpdateDate = getdate(),
						CommissionOnly_15 = xIsCommission,
						MarginPercent_15 = xPercent,
						PC_State = 1
					from TP_PriceComponents join @tempPCIdtable on PC_Id = xPCId
					WHERE	PC_TourDate between @DateCheckInMin and @DateCheckInMax
							and PC_TRKey = @TrKey		
					
					delete @tempPCIdtable
				end
				-- %%%%%%%%%%%%%%%%%%% Кортеж 15 %%%%%%%%%%%%%%%%%%%%%%%
			end
			else
				set @Return = 1
		end

		print 'Переносим записи: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
		set @beginTime = getDate()	
			
		/*обновим галку о необходимости переноса цены*/
		update TP_TourMarginActualDate
		set TMAD_NeedApply = 0
		where TMAD_Id in (select TMAD_Id from @tableForMigrate)

		print 'Количество строк в TP_TourMarginActualDate: ' + convert(nvarchar(max), @@rowcount)		
				
		if @TrKey is not null
		begin
			delete from Debug where db_Mod='MMI' and db_n1=@TrKey
			--insert into Megatec_StateData (SD_Code, SD_Name, SD_Value) values (3001, 'ReCalculateCosts_MarginMigrate', @count)
		end
	end
END
go
grant exec on [dbo].[ReCalculateCosts_MarginMigrateTRKey] to public
go
/*********************************************************************/
/* end sp_ReCalculateCosts_MarginMigrateTRKey.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_RecalculatePriceListScheduler.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalculatePriceListScheduler]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalculatePriceListScheduler]
GO

CREATE PROCEDURE [dbo].[RecalculatePriceListScheduler]
AS
--<DATE>2013-09-11</DATE>
---<VERSION>9.2.0</VERSION>
BEGIN

	declare @cpkey int
	declare @priceTOKey int
	declare @saleDate datetime
	declare @nullCostAsZero smallint
	declare @noFlight smallint
	declare @update smallint
	declare @useHolidayRule smallint
		
	begin tran
		select top 1 @cpkey = CP_Key 
		from CalculatingPriceLists 
		where CP_StartTime is not null and (CP_Status = 3 and CP_StartTime<=GETDATE()) order by CP_StartTime asc
		UPDATE CalculatingPriceLists WITH (ROWLOCK) Set CP_Status=1 where CP_Key=@cpkey
	commit tran
	if (@cpkey is not null)
	begin
		select @priceTOKey = CP_PriceTourKey, @saleDate = CP_SaleDate, @update = CP_Update,
			 @nullCostAsZero = CP_NullCostAsZero, @noFlight = CP_NoFlight, @useHolidayRule = CP_UseHolidayRule
		from CalculatingPriceLists where CP_Key = @cpkey
		exec CalculatePriceList @priceTOKey, @cpkey, @saleDate, @nullCostAsZero, @noFlight, @update,@useHolidayRule
		UPDATE CalculatingPriceLists WITH (ROWLOCK) Set CP_Status=0, CP_StartTime=null where CP_Key=@cpkey
	end
END
GO

GRANT EXEC ON [dbo].[RecalculatePriceListScheduler] TO PUBLIC
GO
/*********************************************************************/
/* end sp_RecalculatePriceListScheduler.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_CheckActualPrice.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_CheckActualPrice]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_CheckActualPrice]
GO
CREATE PROCEDURE [dbo].[ReCalculate_CheckActualPrice]
	(
		-- хранимка проверяет на актуальность цены перерасчитывает их и возвращает их актальное состояние
		-- <version>2009.02.02</version>
		-- <data>2013-05-16</data>
		@tpKeys nvarchar(max),
		@toOnline bit = null --признак выставления в онлайн цен
	)
AS
BEGIN
	SET ARITHABORT ON;
	SET DATEFIRST 1;
	set nocount on;
	
	declare @beginTime datetime
	set @beginTime = getDate()
	
	-- таблица ключей
	declare @tpKeysTable table
	(
		xt_key bigint
	)
	
	insert into @tpKeysTable (xt_key)
	select xt_key from dbo.ParseKeys(@tpKeys)	
	
	print 'Парсинг ключей: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()

	-- таблица ключей
	declare @tempPriceComponents table
	(
		xPCId bigint,
		xTPKey bigint,
		xTRKey int,
		xTourDate datetime,
		xDays int,
		
		xSCPId1 bigint,
		xSCPId2 bigint,
		xSCPId3 bigint,
		xSCPId4 bigint,
		xSCPId5 bigint,
		xSCPId6 bigint,
		xSCPId7 bigint,
		xSCPId8 bigint,
		xSCPId9 bigint,
		xSCPId10 bigint,
		xSCPId11 bigint,
		xSCPId12 bigint,
		xSCPId13 bigint,
		xSCPId14 bigint,
		xSCPId15 bigint,
		
		xSvKey1 int,
		xSvKey2 int,
		xSvKey3 int,
		xSvKey4 int,
		xSvKey5 int,
		xSvKey6 int,
		xSvKey7 int,
		xSvKey8 int,
		xSvKey9 int,
		xSvKey10 int,
		xSvKey11 int,
		xSvKey12 int,
		xSvKey13 int,
		xSvKey14 int,
		xSvKey15 int
	)
	
	insert into @tempPriceComponents(xPCId, xTPKey, xTRKey, xTourDate, xDays, xSCPId1, xSCPId2, xSCPId3, xSCPId4, xSCPId5, xSCPId6, xSCPId7, xSCPId8, xSCPId9, xSCPId10, xSCPId11, xSCPId12, xSCPId13, xSCPId14, xSCPId15,
	xSvKey1, xSvKey2, xSvKey3, xSvKey4, xSvKey5, xSvKey6, xSvKey7, xSvKey8, xSvKey9, xSvKey10, xSvKey11, xSvKey12, xSvKey13, xSvKey14, xSvKey15)
	select PC_Id, PC_TPKey, PC_TRKey, PC_TourDate, PC_Days, SCPId_1, SCPId_2, SCPId_3, SCPId_4, SCPId_5, SCPId_6, SCPId_7, SCPId_8, SCPId_9, SCPId_10, SCPId_11, SCPId_12, SCPId_13, SCPId_14, SCPId_15,
	SVKey_1, SVKey_2, SVKey_3, SVKey_4, SVKey_5, SVKey_6, SVKey_7, SVKey_8, SVKey_9, SVKey_10, SVKey_11, SVKey_12, SVKey_13, SVKey_14, SVKey_15
	from TP_PriceComponents with(nolock)
	where PC_TPKey in (select xt_key from @tpKeysTable)
	
	print 'Заполнение вспомогательной таблицы @tempPriceComponents: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- Цены
	-- найдем ключи цен которые нам нужно перерасчитать
	declare @xSCPIdTable table
	(
		xSCPId bigint
	)
		
	insert into @xSCPIdTable(xSCPId)
	select SPAD_SCPId as xSCPId
	from @tempPriceComponents join TP_ServicePriceActualDate with(nolock) on 1 = 1
	where SPAD_SaleDate is null
	--and SPAD_NeedApply != 0
	and (
			(isnull(xSCPId1, -100500) = SPAD_SCPId) or
			(isnull(xSCPId2, -100500) = SPAD_SCPId) or
			(isnull(xSCPId3, -100500) = SPAD_SCPId) or
			(isnull(xSCPId4, -100500) = SPAD_SCPId) or
			(isnull(xSCPId5, -100500) = SPAD_SCPId) or
			(isnull(xSCPId6, -100500) = SPAD_SCPId) or
			(isnull(xSCPId7, -100500) = SPAD_SCPId) or
			(isnull(xSCPId8, -100500) = SPAD_SCPId) or
			(isnull(xSCPId9, -100500) = SPAD_SCPId) or
			(isnull(xSCPId10, -100500) = SPAD_SCPId) or
			(isnull(xSCPId11, -100500) = SPAD_SCPId) or
			(isnull(xSCPId12, -100500) = SPAD_SCPId) or
			(isnull(xSCPId13, -100500) = SPAD_SCPId) or
			(isnull(xSCPId14, -100500) = SPAD_SCPId)
	)
	
	print 'Поиск ключей цен которые изменились: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	print 'Проставление признака выставление онлайн: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	--если есть признак выставить в онлайн, проставляем его
	if (@toOnline = 1)
	begin
		update TP_ServicePriceActualDate set SPAD_AutoOnline = 1 where SPAD_SCPId in (select xSCPId from @xSCPIdTable)
	end
	
	-- если есть цены которые нужно обсчитать
	if exists(select top 1 1 from @xSCPIdTable)
	begin
		print 'Запускаем расчет цен'
		
		declare @keys nvarchar(max)
		set @keys = ''
		
		select @keys = @keys + convert(nvarchar(max), xSCPId) + ',' from @xSCPIdTable where xSCPId is not null
		
		-- запускаем перерасчет цен, передав в хранимку dbo.ReCalculateCosts список ключей
		exec dbo.ReCalculateCosts 100500, @keys
		-- запускаем перенос цен, передав в хранимку dbo.ReCalculateCosts_GrossMigrate список ключей
		exec dbo.ReCalculateCosts_GrossMigrate 100500, @keys
	end
	
	print 'Расчет изменившихся цен: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- Наценки
	-- найдем ключи наценок которые необходимо перерасчитать
	declare @xTMADIdTable table
	(
		xTMADId int
	)
	insert into @xTMADIdTable(xTMADId)
	select TMAD_Id
	from @tempPriceComponents join TP_TourMarginActualDate on xTRKey = TMAD_TRKey
	where  xTourDate = TMAD_DateCheckIn
	and xDays = TMAD_Long
	--and TMAD_NeedApply != 0
	and (	xSVKey1 = TMAD_SvKey
			or xSVKey2 = TMAD_SvKey
			or xSVKey3 = TMAD_SvKey
			or xSVKey4 = TMAD_SvKey
			or xSVKey5 = TMAD_SvKey
			or xSVKey6 = TMAD_SvKey
			or xSVKey7 = TMAD_SvKey
			or xSVKey8 = TMAD_SvKey
			or xSVKey9 = TMAD_SvKey
			or xSVKey10 = TMAD_SvKey
			or xSVKey11 = TMAD_SvKey
			or xSVKey12 = TMAD_SvKey
			or xSVKey13 = TMAD_SvKey
			or xSVKey14 = TMAD_SvKey
			or xSVKey15 = TMAD_SvKey			
		)
	
	print 'Поиск ключей наценок которые изменились: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
		
	
	if (exists (select top  1 1 from @xTMADIdTable))
	begin
		print 'Запускаем перерасчет наценок'
		
		declare @marginKeys nvarchar(max)
		set @marginKeys = ''
		
		select @marginKeys = @marginKeys + convert(nvarchar(max), xTMADId) + ',' from @xTMADIdTable where xTMADId is not null
		
		-- запускаем хранимку dbo.ReCalculateMargin передав ей ключи
		exec dbo.ReCalculateMargin 100500, @marginKeys
		-- запускаем хранимку dbo.ReCalculateCosts_MarginMigrate передав ей ключи
		exec dbo.ReCalculateCosts_MarginMigrate 100500, @marginKeys
	end
	
	print 'Расчет изменившихся наценок: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- Доплаты
	-- Найдем ключи доплат которые нам необходимо перерасчитать
	declare @xTRKeyTable table
	(
		xTRKey int
	)
	-- для проживания
	insert into @xTRKeyTable(xTRKey)
	select distinct xTRKey
	from @tempPriceComponents join AddCosts on xTRKey = ADC_TLKey
	where exists (select top 1 1 from TP_QueueAddCosts where QAC_ADCId = ADC_Id)
	and (
		ADC_SVKey = xSvKey1
		or ADC_SVKey = xSvKey2
		or ADC_SVKey = xSvKey3
		or ADC_SVKey = xSvKey4
		or ADC_SVKey = xSvKey5
		or ADC_SVKey = xSvKey6
		or ADC_SVKey = xSvKey7
		or ADC_SVKey = xSvKey8
		or ADC_SVKey = xSvKey9
		or ADC_SVKey = xSvKey10
		or ADC_SVKey = xSvKey11
		or ADC_SVKey = xSvKey12
		or ADC_SVKey = xSvKey13
		or ADC_SVKey = xSvKey14
		or ADC_SVKey = xSvKey15
	)
	-- нам нужны только доплаты на будующие даты
	and xTourDate > getdate()
	and xTourDate between ADC_CheckInDateBeg and ADC_CheckInDateEnd
	
	print 'Поиск ключей туров доплаты в которых изменились: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	if (exists (select top 1 1 from @xTRKeyTable))
	begin
		print 'Запускаем перерасчет доплат'
		
		declare @trKeys nvarchar(max)
		set @trKeys = ''
		
		select @trKeys = @trKeys + convert(nvarchar(max), xTRKey) + ',' from @xTRKeyTable where xTRKey is not null
		
		exec WcfReCalculateAddCostsByCount 1000
	end
	
	print 'Расчет изменившихся доплат: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
	
	-- После перерасчета всех изменившихся цен, выводим актуальную информацию по ценам
	select PC_TPKey, PC_SummPrice
	from TP_PriceComponents with(nolock)
	where PC_TPKey in (select xt_key from @tpKeysTable)
	
	print 'Вывод результата: ' + convert(nvarchar(max), datepart(mi, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ss, convert(datetime, getDate() - @beginTime))) + '.' + convert(nvarchar(max), datepart(ms, convert(datetime, getDate() - @beginTime)))
	set @beginTime = getDate()
END
GO
grant exec on [dbo].[ReCalculate_CheckActualPrice] to public
go
/*********************************************************************/
/* end sp_ReCalculate_CheckActualPrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_CreateServiceCalculateParametrs.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_CreateServiceCalculateParametrs]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReCalculate_CreateServiceCalculateParametrs]
GO

CREATE PROCEDURE [dbo].[ReCalculate_CreateServiceCalculateParametrs]
	(
		-- хранимка создает структуру детализации цены по услугам
		--<data>2013-07-23</data>
		--<version>9.20</version>
		@trKey int,
		@toKey int,
		@nSvkey int,
		@nCode int,
		@nSubcode1 int,
		@nSubcode2 int,
		@nPrkey int,
		@nDay int,
		@turdate datetime,
		@nMen int,
		@nServiceDays int,
		@nPacketkey int,
		@nTourDays int,
		@scId int output, -- ключ найденой записи в таблице TP_ServiceComponents
		@scpId int output -- ключ найденой записи в таблице TP_ServiceCalculateParametrs
	)
AS
BEGIN
	declare @stId bigint

	-- обнулим значение
	set @scId = null
	set @stId = null
	set @scpId = null

	-- проверим есть ли на запись в TP_Services записи в TP_ServiceComponents
	-- пробуем найти запись под нашу услугу
	select top 1 @scId = xSC_Id
	from #ServiceComponents with (nolock)
	where xSC_SVKey = @nSvkey
	and xSC_Code = @nCode
	and xSC_SubCode1 = @nSubcode1
	and xSC_SubCode2 = @nSubcode2
	and xSC_PRKey = @nPrkey
						
	-- если не нашли то добавим новую
	if (@scId is null)
	begin
		insert into #ServiceComponents (xSC_SVKey, xSC_Code, xSC_SubCode1, xSC_SubCode2, xSC_PRKey)
		values (@nSvkey, @nCode, @nSubcode1, @nSubcode2, @nPrkey)
		
		set @scId = SCOPE_IDENTITY()
	end
	
	-- проверим есть ли запись в таблице TP_ServiceTours
	select top 1 @stId = xST_Id
	from #ServiceTours with (nolock)
	where xST_SVKey = @nSvkey
	and xST_SCId = @scId
	and xST_TOKey = @toKey
	and xST_TRKey = @trKey

	if (@stId is null)
	begin
		insert into #ServiceTours (xST_SVKey, xST_SCId, xST_TRKey, xST_TOKey)
		values (@nSvkey, @scId, @trKey, @toKey)
	end
	
	-- проверим есть ли подходящая запись в таблице TP_ServiceCalculateParametrs
	select top 1 @scpId = xSCP_Id
	from #ServiceCalculateParametrs with (nolock)
	where xSCP_SCId = @scId
	and xSCP_Date = dateAdd(dd, @nDay-1, @turdate)
	and xSCP_DateCheckIn = @turdate
	and xSCP_Men = @nMen
	and xSCP_Days = @nServiceDays
	and xSCP_TourDays = @nTourDays
	and xSCP_PKKey = @nPacketkey
	and xSCP_DeleteDate is null
							
	-- если не нашли, то добавим новую
	if (@scpId is null)
	begin
		insert into #ServiceCalculateParametrs(xSCP_SCId, xSCP_Date, xSCP_DateCheckIn, xSCP_Men, xSCP_Days, xSCP_PKKey, xSCP_TourDays, xSCP_SvKey)
		values (@scId, dateAdd(dd, @nDay-1, @turdate), @turdate, @nMen, @nServiceDays, @nPacketkey, @nTourDays, @nSvkey)
		
		set @scpId = SCOPE_IDENTITY()
	end
	
	-- создадим вспомогательную таблицу
	if not exists(select top 1 1 from #TourParametrs with(nolock) where xTP_TOKey = @toKey and xTP_TourDays = @nTourDays and xTP_DateCheckIn = @turdate)
	begin
		insert into #TourParametrs(xTP_TOKey, xTP_TourDays, xTP_DateCheckIn)
		values (@toKey, @nTourDays, @turdate)
	end
END


GO
grant exec on [dbo].[ReCalculate_CreateServiceCalculateParametrs] to public
go
/*********************************************************************/
/* end sp_ReCalculate_CreateServiceCalculateParametrs.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReCalculate_MigrateToPrice.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReCalculate_MigrateToPrice]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[ReCalculate_MigrateToPrice]
GO

--<VERSION>2009.2.19.1</VERSION>
--<DATE>2013-05-16</DATE>
CREATE PROCEDURE [dbo].[ReCalculate_MigrateToPrice]
	(
		-- хранимка суммирует стоимость отдельных услуг и кладет их в TP_Prices		
		-- максимальное количество записей для переноса за 1 раз
		@countItem INT,  
		
		--ключи цен на перерасчет
		@tpKeys dbo.ListIntValue readonly,
		
		--ключ тура
		--если указан, @tpToursCount не учитывается - обрабатывается только один тур
		@toKey INT = NULL,

		--количество туров
		@tpToursCount INT = NULL --для совместимости с предыдущими версиями
	)
AS
BEGIN
	SET ARITHABORT ON;

	--Таблица для цен из TP_PriceComponents
	DECLARE @tempGrossTable TABLE 
	(
		xPCId int,
		xTPKey int,
		xSummPrice money,
		xToKey int,
		xUpdateDate datetime
	)
	
	DECLARE  @numRowsInserted int , @numRowsUpdated int, @numRowsDeleted int
	SET @numRowsInserted = 0
	SET @numRowsUpdated = 0
	SET @numRowsDeleted = 0

	-- если указаны ключи цен, обрабатываем их
	IF (EXISTS(SELECT TOP 1 1 FROM @tpKeys))
	BEGIN
		  
		SELECT PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey, PC_UpdateDate
		FROM TP_PriceComponents
		INNER JOIN @tpKeys ON value = PC_TPKey
		WHERE pc_state = 1    
		
		
			--добавлен инсерт для обработки значений в этой же хранимой процедуре при применении ММ
				INSERT INTO @tempGrossTable (xPCId, xTPKey, xSummPrice, xToKey, xUpdateDate)
				SELECT TOP (@countItem) PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey, PC_UpdateDate
				FROM TP_PriceComponents INNER JOIN @tpKeys ON value = PC_TPKey
				WHERE PC_State = 1   
		 
	END  
	ELSE
	BEGIN  

		--Если указан @toKey, обрабатываем только один тур
		IF (@toKey IS NOT NULL)
		BEGIN
    
			INSERT INTO @tempGrossTable (xPCId, xTPKey, xSummPrice, xToKey, xUpdateDate)
			SELECT TOP (@countItem) PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey, PC_UpdateDate
			FROM TP_PriceComponents
			WHERE PC_State = 1 AND PC_TOKey = @toKey

			--добавлен инсерт для обработки значений в этой же хранимой процедуре при применении ММ
				INSERT INTO @tempGrossTable (xPCId, xTPKey, xSummPrice, xToKey, xUpdateDate)
				SELECT TOP (@countItem) PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey, PC_UpdateDate
				FROM TP_PriceComponents INNER JOIN @tpKeys ON value = PC_TPKey
				WHERE PC_State = 1 

		END
     		ELSE
		BEGIN
  
			--Если указано количество туров, берем в обработкe @countItem цен @toursCount туров    
			IF (@tpToursCount IS NOT NULL)
			BEGIN      
    
				DECLARE tourscursor CURSOR FAST_FORWARD READ_ONLY
				FOR SELECT TOP (@tpToursCount) to_key FROM tp_tours (NOLOCK)
				WHERE to_key IN (SELECT PC_TOKey FROM TP_PriceComponents WHERE PC_State = 1)

				OPEN toursCursor
	
				FETCH NEXT FROM toursCursor INTO @toKey

				WHILE @@FETCH_STATUS = 0
				BEGIN

					INSERT INTO @tempGrossTable (xPCId, xTPKey, xSummPrice, xToKey, xUpdateDate)
					SELECT TOP (@countItem) PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey, PC_UpdateDate
					FROM TP_PriceComponents
					WHERE PC_State = 1 AND PC_TOKey = @toKey

					FETCH NEXT FROM toursCursor INTO @toKey

				END

				CLOSE toursCursor
				DEALLOCATE toursCursor

			END
  
			-- Иначе обрабатываем первые @countItem записей из очереди         
			ELSE
			BEGIN    

				INSERT INTO @tempGrossTable (xPCId, xTPKey, xSummPrice, xToKey, xUpdateDate)
				SELECT TOP (@countItem) PC_Id, PC_TPKey, PC_SummPrice, PC_ToKey, PC_UpdateDate
				FROM TP_PriceComponents
				WHERE PC_State = 1

			END

		END
	
	END
    
	DECLARE @tempGrossTableCount INT
	SELECT @tempGrossTableCount=COUNT(1) FROM @tempGrossTable
	print 'Количество строк в TP_PriceComponents: ' + convert(nvarchar(max), @tempGrossTableCount)
	
	DECLARE currReCalculate_MigrateToPrice CURSOR FOR SELECT DISTINCT xToKey FROM @tempGrossTable
	OPEN currReCalculate_MigrateToPrice

	FETCH NEXT FROM currReCalculate_MigrateToPrice INTO @toKey
	WHILE @@FETCH_STATUS = 0
	BEGIN
			
		INSERT INTO CalculatingPriceLists (CP_CreateDate,CP_PriceTourKey) VALUES (GETDATE(),@toKey) 
		DECLARE	@cpKey int
		SET @cpKey = SCOPE_IDENTITY()
			
		-- переносим цены в таблицу для удаленных цен
		INSERT INTO tp_pricesdeleted (TPD_TPKey, TPD_TOKey, TPD_TIKey, TPD_Gross, TPD_DateBegin, TPD_DateEnd, TPD_CalculatingKey)
		SELECT TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, @cpKey 
		FROM tp_prices (NOLOCK)
		WHERE tp_key IN (SELECT xTPKey FROM @tempgrosstable WHERE xSummPrice IS NULL AND xToKey = @toKey)
								
		-- удаляем цены из tp_prices
		DELETE FROM tp_prices
		WHERE tp_key IN (SELECT xTPKey FROM @tempgrosstable WHERE xSummPrice IS NULL AND xToKey = @toKey)
		SET @numRowsDeleted = @@ROWCOUNT
			
		--восстанавливаем цены из таблицы удаленных цен
		INSERT INTO tp_prices (TP_Key, TP_TOKey, TP_TIKey, TP_Gross, TP_DateBegin, TP_DateEnd, TP_CalculatingKey)
		SELECT TPD_TPKey, TPD_TOKey, TPD_TIKey, TPD_Gross, TPD_DateBegin, TPD_DateEnd, @cpKey
		FROM tp_pricesdeleted (NOLOCK)
		WHERE tpd_tpkey IN (SELECT xTPKey FROM @tempgrosstable WHERE xSummPrice IS NOT NULL AND xToKey = @toKey)
		SET @numRowsInserted = @@ROWCOUNT
								
		-- и удаляем из из таблицы удаленных цен
		DELETE FROM tp_pricesdeleted
		WHERE tpd_tpkey IN (SELECT xTPKey FROM @tempgrosstable WHERE xSummPrice IS NOT NULL AND xToKey = @toKey)
								
		-- обновляем цены, которые ранее не были удалены и изменились, или ранее были удалены но сейчас востановились
		UPDATE TP_Prices
		SET TP_Gross = CEILING(xSummPrice),
		tp_updatedate = GetDate(),
		TP_CalculatingKey = @cpKey
		FROM TP_Prices join @tempGrossTable on TP_Key = xTPKey
		WHERE xSummPrice is not null
		AND xToKey = @toKey
			
		SET @numRowsUpdated = @@ROWCOUNT
			
		IF EXISTS (SELECT TOP 1 1 FROM TP_Tours WHERE to_Key = @toKey AND to_isEnabled = 1)
		BEGIN
			-- Реплицируем только если тур уже выставлен в online
			IF (@numRowsInserted > 0 or @numRowsDeleted > 0)
			BEGIN
				EXEC FillMasterWebSearchFields @toKey, @cpKey
			END
			ELSE IF (@numRowsUpdated > 0)
			BEGIN
				-- нужно для корректной обработки необходимости обновления кэша в TourML
				UPDATE TP_Tours SET TO_UPDATETIME = GETDATE() WHERE TO_Key = @toKey

				IF dbo.mwReplIsPublisher() > 0
				BEGIN
					INSERT INTO mwReplTours(rt_trkey, rt_tokey, rt_date, rt_calckey, rt_updateOnlinePrices)
					SELECT TO_TRKey, TO_Key, GETDATE(), @cpKey, 2
					FROM tp_tours
					WHERE TO_Key = @toKey
				END
				ELSE
				BEGIN
					EXEC mwReplUpdatePriceEnabledAndValue @toKey, @cpKey
				END
			END
		END
		
		-- отметим что уже перенесли
		UPDATE TP_PriceComponents
		SET PC_DateLastUpdateToPrice = GETDATE(),
		PC_State = 0
		FROM TP_PriceComponents inner join @tempGrossTable ON PC_Id = xPCId
		WHERE PC_TOKey = @toKey AND PC_UpdateDate = xUpdateDate
		
		FETCH NEXT FROM currReCalculate_MigrateToPrice INTO @toKey
	END

	CLOSE currReCalculate_MigrateToPrice
	DEALLOCATE currReCalculate_MigrateToPrice
	
END
GO

GRANT EXECUTE ON [dbo].[ReCalculate_MigrateToPrice]	TO PUBLIC
GO
/*********************************************************************/
/* end sp_ReCalculate_MigrateToPrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_RemoveDoubleTPLists.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='p' and name='RemoveDoubleTPLists')
	drop proc dbo.[RemoveDoubleTPLists]
go

CREATE PROCEDURE [dbo].[RemoveDoubleTPLists] 
  (
	@nPriceTourKey int,			-- ключ обсчитываемого тура
	@nCalculatingKey int		-- ключ итерации дозаписи
  )
AS
begin
	create table #delKeys
	(
		xti_key int
	)

	create table #hashTable
	(
		xhash nvarchar(max), 
		xtikey int
	)

	insert into #hashTable (xhash, xtikey)
	select dbo.GetTPListsHash(ti_key), TI_Key
	from tp_lists with(nolock)
	where TI_TOKey = @nPriceTourKey
	and TI_CalculatingKey = @nCalculatingKey
	and TI_Key not in (select TP_TIKey from tp_prices with(nolock) where TP_TOKey = @nPriceTourKey)

	declare @hash nvarchar(max)
	declare hashCursor cursor local fast_forward for
	select xhash
	from #hashTable
	group by xhash
	having count(*) > 1

	open hashCursor
	fetch hashCursor into @hash
	while (@@FETCH_STATUS = 0)
	begin

		insert into #delKeys (xti_key)
		select TI_Key
		from TP_Lists with(nolock)
		where TI_Key in (select top 1 xtikey from #hashTable where xhash = @hash)

		fetch hashCursor into @hash
	end
	close hashCursor
	deallocate hashCursor

	delete from TP_Lists where TI_Key in (select xti_key from #delKeys)

end
go

grant execute on [dbo].[RemoveDoubleTPLists]  to public
go
/*********************************************************************/
/* end sp_RemoveDoubleTPLists.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_ReСalculateNationalRatePrice.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReСalculateNationalRatePrice]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReСalculateNationalRatePrice]
GO
CREATE PROCEDURE [dbo].[ReСalculateNationalRatePrice]
(
	@DG_KEY INT,
	@NDG_RATE VARCHAR(3),
	@ODG_RATE VARCHAR(3),
	@ODG_CODE VARCHAR(10),
	@NDG_PRICE FLOAT,
	@ODG_PRICE FLOAT,
	@NDG_DISCOUNTSUM FLOAT,
	@NDG_SOR_CODE INT
)
AS
BEGIN
--<VERSION>9.2.20.0</VERSION>
--<DATE>2013-06-17</DATE>
-- Task 10558 tfs neupokoev 26.12.2012
-- Повторная фиксация курса валюты, в случае если он не зафиксировался
	DECLARE @HI_DATE DATETIME
	DECLARE @DG_NATIONALCURRENCYPRICE int
	DECLARE @DG_NATIONALCURRENCYDISCOUNTSUM int
	
	SET @DG_NATIONALCURRENCYPRICE = NULL
	SET @DG_NATIONALCURRENCYDISCOUNTSUM = NULL
		
	DECLARE CUR_DGNATIONALCURRENCYISNULL CURSOR LOCAL FAST_FORWARD FOR
		SELECT TOP 1 HI_DATE
			FROM HISTORY
				WHERE HI_DGKEY = @DG_KEY AND HI_OAID = 21 ORDER BY HI_DATE DESC

	OPEN CUR_DGNATIONALCURRENCYISNULL
		FETCH NEXT FROM CUR_DGNATIONALCURRENCYISNULL INTO @HI_DATE
	        
		WHILE @@FETCH_STATUS = 0
			BEGIN					
				EXEC DBO.NationalCurrencyPrice2 @NDG_RATE, @ODG_RATE, @ODG_CODE, @NDG_PRICE, @ODG_PRICE, @NDG_DISCOUNTSUM, @HI_DATE, @NDG_SOR_CODE
				
				SELECT @DG_NATIONALCURRENCYPRICE = DG_NATIONALCURRENCYPRICE, @DG_NATIONALCURRENCYDISCOUNTSUM = DG_NATIONALCURRENCYDISCOUNTSUM FROM DOGOVOR 
					WHERE DG_KEY = @DG_Key 

				IF(@DG_NATIONALCURRENCYPRICE IS NOT NULL AND @DG_NATIONALCURRENCYDISCOUNTSUM IS NOT NULL)
					BREAK

				FETCH NEXT FROM CUR_DGNATIONALCURRENCYISNULL INTO @HI_DATE
			END
	        
	CLOSE CUR_DGNATIONALCURRENCYISNULL
	DEALLOCATE CUR_DGNATIONALCURRENCYISNULL	
END

GO

GRANT EXEC ON [dbo].[ReСalculateNationalRatePrice] TO PUBLIC
GO
/*********************************************************************/
/* end sp_ReСalculateNationalRatePrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_SetServiceQuotasStatus.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SetServiceQuotasStatus]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[SetServiceQuotasStatus]
GO

--<VERSION>2009.2.21.0</VERSION>
--<DATE>2013-08-15</DATE>
CREATE PROCEDURE [dbo].[SetServiceQuotasStatus]
	(
		@DLKey int,
		@DLControl int = null
	)
AS
BEGIN
	declare @N_DLSVKey int, @N_DLDateBeg datetime, @N_DLDateEnd datetime, @N_GlobalControl int
	
	select @N_DLSVKey = DL_SVKEY, @N_DLDateBeg = DL_DATEBEG, @N_DLDateEnd = DL_DATEEND, @N_GlobalControl = CR_GlobalState
	from Dogovorlist join Controls on DL_CONTROL = CR_KEY
	where DL_KEY = @DLKey
	
	-- если глобальный статус услуги не Ок, то выходим
	if @DLControl <> 0 and (@N_GlobalControl != 1 or exists (select 1 from Dogovorlist where DL_KEY = @DLKey and DL_DATEBEG < '1950-01-01'))
	begin
		return 0
	end

	declare @serviceKeys nvarchar(max)	
	
	select @serviceKeys = SS_ParmValue
	from SystemSettings 
	where SS_ParmName = 'SYSNoSetToQuotaIfStatusOk'
	
	if exists (select 1 from [service] where sv_key = @N_DLSVKey) and not exists (select 1 from ParseKeys(@serviceKeys) where xt_key = @N_DLSVKey)
	begin
		if isnull((select max(isnull(SD_State, 4)) from ServiceByDate where SD_DLKey = @DLKey),4) = 4
		begin
			EXEC DogListToQuotas @DLKey, null, null, null, null, @N_DLDateBeg, @N_DLDateEnd, null, null, @SetOkIfRequest = 1
		end
	end
				
	if exists (select 1 from DogovorList where DL_KEY = @DLKey and DL_CONTROL = 0)
	begin
		update ServiceByDate set SD_State = 3 where SD_DLKey = @DLKey and SD_State = 4
	end	
	
	if (@DLControl is not null)
	begin
		-- koshelev. 13942
		-- устанавливаем статус услуги как был, если мы смогли посадить на квоту или вне квоты
		if not exists (select 1 from ServiceByDate where SD_DLKey = @DLKey and SD_State = 4)
			update Dogovorlist set DL_CONTROL = @DLControl where DL_KEY = @DLKey
	end
END
GO

grant exec on [dbo].[SetServiceQuotasStatus] to public
go
/*********************************************************************/
/* end sp_SetServiceQuotasStatus.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_SetServiceStatusOK.sql */
/*********************************************************************/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SetServiceStatusOK]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[SetServiceStatusOK]
GO

CREATE PROCEDURE [dbo].[SetServiceStatusOK]
	(
		--<VERSION>2009.2.5</VERSION>
		--<DATA>20.05.2013</DATA>
		-- хранимка определяет какой статус необходимо установить услуги, после изменения статуса квотирования
		@dlkey int,
		@dlcontrol int out -- новый статус
	)
AS
BEGIN
	set @dlcontrol = null
	-- теперь в завмсимости от настроек будем менять статусы на Ок
	-- 0 - все галки сняты
	-- 1 - Все услуги
	-- 2 - Авиаперелет
	-- 3 - Все услуги & Авиаперелет
	-- 4 - Проживание
	-- 5 - Все услуги & Проживание
	-- 6 - Авиаперелет & Проживание
	-- 7 - Все услуги & Авиаперелет & Проживание
	
	DECLARE @dlPartnerKey int, @svkey int, @sdState int, @svControl int, @svQuoted int, @oldDLControl int  
	
	-- Если это услуга из Интерлука, ничего не делаем
	select @dlPartnerKey=DL_PARTNERKEY, @svkey = dl_svkey, @oldDLControl = DL_Control, 
	@svControl = SV_CONTROL, @svQuoted = SV_QUOTED  
	from tbl_dogovorList join [service] on dl_svkey = sv_key 
	where dl_key = @dlkey and isnull(SV_QUOTED, 0) = 1
	
	if (exists (select top 1 1 from dbo.SystemSettings where SS_ParmName = 'IL_SyncILPartners' AND SS_ParmValue LIKE '%/' + convert(nvarchar(max) ,@dlPartnerKey) + '/%'))
		return
	
	select @sdState = MAX(COALESCE(SD_State, 4))
	from ServiceByDate 
	where SD_DLKey = @dlkey
	
	if (@sdState < 4 and @svQuoted = 1)
	begin 
		-- MEG00032041
		-- Теперь проверим есть ли на эту квоту запись в таблице QuotaStatuses
		-- которая говорит нам что нужно изменить статус услуги на тот который в этой таблице
		if exists(select 1 from QuotaStatuses join Quotas on QS_QTID = QT_ID						
					join QuotaDetails on QT_ID = QD_QTID
					join QuotaParts on QP_QDID = QD_ID
					join ServiceByDate on SD_QPID = QP_ID
					where SD_DLKey = @dlkey and SD_State = QS_Type) 
		begin
			select @dlcontrol = QS_CRKey
			from QuotaStatuses join Quotas on QS_QTID = QT_ID 
			join QuotaDetails on QT_ID = QD_QTID
			join QuotaParts on QP_QDID = QD_ID
			join ServiceByDate on SD_QPID = QP_ID
			where SD_DLKey = @dlkey and SD_State = QS_Type
					
			if (@oldDLControl != @dlcontrol)
			begin
				update Dogovorlist set DL_Control = @dlcontrol where DL_Key = @dlKey 
			end
			
			return;
		end
		
		-- Авиаперелет
		if (@svkey = 1)
		begin
			if exists(select 1 from SystemSettings where SS_ParmName = 'SYS_SET_SERVICE_STATUS_OK' and SS_ParmValue in ('2', '3', '6', '7'))
			begin
				set @dlcontrol = 0
				update Dogovorlist set DL_Control = @dlcontrol where DL_Key = @dlKey 
				return;
			end
		end
			
		-- Проживание
		if (@svkey = 3)
		begin
			if exists(select 1 from SystemSettings where SS_ParmName = 'SYS_SET_SERVICE_STATUS_OK' and SS_ParmValue in ('4', '5', '6', '7'))
			begin
				set @dlcontrol = 0
				update Dogovorlist set DL_Control = @dlcontrol where DL_Key = @dlKey 
				return;
			end
		end
			
		-- Все услуги
		if (@svkey not in (1, 3))
		begin
			if exists(select 1 from SystemSettings where SS_ParmName = 'SYS_SET_SERVICE_STATUS_OK' and SS_ParmValue in ('1', '3', '5', '7'))
			begin
				set @dlcontrol = 0
				update Dogovorlist set DL_Control = @dlcontrol where DL_Key = @dlKey 
				return;
			end
		end
	end
	
	-- установим нашей услуге статус из справочника услуг
	if (@svControl != @oldDLControl and @svQuoted = 1 and @svControl is not null)
	begin
		set @dlcontrol = @svControl
		update Dogovorlist set DL_Control = @svControl where DL_Key = @dlKey and DL_Control != @svControl
		return
	end
END
GO

grant execute on [dbo].[SetServiceStatusOK] to public
GO
/*********************************************************************/
/* end sp_SetServiceStatusOK.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_VerifiedCostOffer.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[VerifiedCostOffer]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[VerifiedCostOffer]
GO

CREATE PROCEDURE [dbo].[VerifiedCostOffer]
	(
		-- Хранимка проверки ценового блока
		--<version>9.2</version>
		--<data>2013-01-22</data>		
		
		--.03 - признак "@IfSuccessSetActiv" проставляется теперь только при явной передаче "1"
		--.02 - теперь проставляется дата активации (CO_DateActive)
		@costOfferId int,					-- Ключ ценового блока
		@IfSuccessSetActiv bit,				-- Устанавливать активность ценового блока в случае успешной проверки
		@isPublicate bit = NULL,				    -- Публиковать СПО
		@errorMessage nvarchar(max) output	-- сообщение о ошибки проверки ценового блока
	)
AS
BEGIN
	set @errorMessage = ''
	
	/*временная таблица для оптимизации запросов к таблице цен*/
	declare @tempCost table
	(
		xSvKey int,
		xCode int,
		xPkKey int,
		xPartnerKey int
	)
	
	/*заполняем временную таблицу*/
	insert into @tempCost (xSvKey, xCode, xPkKey, xPartnerKey)
	select CS_SVKEY, CS_CODE, CS_PKKEY, CS_PRKEY
	from tbl_Costs
	where CS_COID = @costOfferId
	group by CS_SVKEY, CS_CODE, CS_PKKEY, CS_PRKEY
	
	/*создаем привязки ценового блока к услугам*/
	insert into CostOfferServices (COS_COID, COS_SVKEY, COS_CODE, COS_IsDisable, COS_DisableDate)
	select @costOfferId, xSvKey, xCode, 0, null
	from @tempCost
	where not exists (	select top 1 1 
						from CostOfferServices 
						where COS_COID = @costOfferId 
						and COS_SVKEY = xSvKey 
						and COS_CODE = xCode)
	group by xSvKey, xCode
	
	/*Создаем привязки к пакетам*/
	insert into CostOfferPackets (COP_COID, COP_PKKey)
	select @costOfferId, xPkKey
	from @tempCost
	where not exists (	select top 1 1 
						from CostOfferPackets 
						where COP_COID = @costOfferId 
						and COP_PKKey = xPkKey)
	group by xPkKey
	
	/*проверка на ключ услуги*/
	if (select COUNT(X) from 
	(select xSvKey as X from @tempCost group by xSvKey) T )	> 1
	begin
		set @errorMessage = @errorMessage + 'Ошибка! Цены в рамках одного ценового блока заведены цены на разные классы услуг '
	end
	/*проверка на партнера*/
	
	if (select COUNT(X) from 
	(select xPartnerKey as X from @tempCost group by xPartnerKey) T ) > 1
	begin
		set @errorMessage = @errorMessage + 'Ошибка! Цены в рамках одного ценового блока заведены цены на разных партеров '
	end
		
	/*Если все проверки прошли успешно, то добавляем ЦБ в очередь*/
	/*9970.beylkhanov. Состояния очередей для цб:
	1 - активировать цб
	2 - деактивировать цб
	3 - опубликовать цб
	*/
	if (@errorMessage = '')
	  BEGIN
		if (@IfSuccessSetActiv=1)
			begin 
				insert into [QueuesCostOffers]([QCO_COId],[QCO_OperationId],[QCO_QueuedDate],[QCO_State]) values (@costOfferId,@IfSuccessSetActiv, GETDATE(), 0)
			end
		if (@isPublicate = 1)
			begin 
				insert into [QueuesCostOffers]([QCO_COId],[QCO_OperationId],[QCO_QueuedDate],[QCO_State]) values (@costOfferId, 3, GETDATE(), 0)
			end
	  END
END
GO

grant execute on [dbo].[VerifiedCostOffer] to public
GO

/*********************************************************************/
/* end sp_VerifiedCostOffer.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_WcfGetQuotas.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WcfGetQuotas]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[WcfGetQuotas]

GO
CREATE PROCEDURE [dbo].[WcfGetQuotas]
	(
		@useCache bit,
		@serviceKey int,
		@serviceCode int,
		@serviceSubCode1 int,
		@serviceDateBegin datetime,
		@serviceDateEnd datetime,
		@agentKey int,
		@quotaPlaces smallint,
		@pax smallint
		--<VERSION>Production</VERSION>
	    --<DATA>2013.06.28</DATA>
	)
AS
BEGIN
	declare @commandLine varchar(2000), @path varchar(2000)
	
	select @path = SS_ParmValue from SystemSettings where SS_ParmName = 'PathToWcfClient'
	
	if (@path is not null)
	begin
		set @commandLine = @path + ' GetQuotas'
		
		set @commandLine = @commandLine + ' ' + (case when @useCache = 1 then ' true' else ' false' end)
		set @commandLine = @commandLine + ' ' + convert(varchar, @serviceKey)
		set @commandLine = @commandLine + ' ' + convert(varchar, @serviceCode)
		set @commandLine = @commandLine + ' ' + convert(varchar, @serviceSubCode1)
		set @commandLine = @commandLine + ' "' + convert(varchar, @serviceDateBegin) + '"'
		set @commandLine = @commandLine + ' "' + convert(varchar, @serviceDateEnd) + '"'
		set @commandLine = @commandLine + ' ' + (case when @agentKey is null then 'null' else convert(varchar, @agentKey) end)
		set @commandLine = @commandLine + ' ' + convert(varchar, @quotaPlaces)
		set @commandLine = @commandLine + ' ' + (case when @pax is null then 'null' else convert(varchar, @pax) end)
	end
	else
	begin
		RAISERROR('Ошибка: не указан пусть к сервису', 16, 1)
	end
	--print @commandLine
	exec xp_cmdshell @commandLine
END

GO
grant exec on [dbo].[WcfGetQuotas] to public
go



/*********************************************************************/
/* end sp_WcfGetQuotas.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_WcfReCalculateAddCostsByCount.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WcfReCalculateAddCostsByCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[WcfReCalculateAddCostsByCount]
GO

CREATE PROCEDURE [dbo].[WcfReCalculateAddCostsByCount]
		--<VERSION>11.1.3</VERSION>
	    --<DATA>2013.05.24</DATA>
	    (
			@addCostsCount int
	    )
AS
BEGIN
	declare @commandLine varchar(2000), @path varchar(2000)
	
	select @path = SS_ParmValue from SystemSettings where SS_ParmName = 'PathToWcfClient'
	
	set @commandLine = @path + ' ReCalculateAddCosts'
	
	set @commandLine = @commandLine + ' ' + convert(varchar, @addCostsCount)

	exec xp_cmdshell @commandLine, no_output
END

GO
grant exec on [dbo].[WcfReCalculateAddCostsByCount] to public
go

/*********************************************************************/
/* end sp_WcfReCalculateAddCostsByCount.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_WcfSetServiceToQuota.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WcfSetServiceToQuota]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[WcfSetServiceToQuota]
GO

CREATE PROCEDURE [dbo].[WcfSetServiceToQuota]
	(
		--<VERSION>9.2</VERSION>
	    --<DATA>2013.06.05</DATA>
		@dlKey int, 
		@serviceQuotedState smallint,
		@dateFrom datetime = NULL,
		@dateTo datetime = NULL
	)
AS
BEGIN
	set nocount on;
	declare @commandLine varchar(2000), @path varchar(2000)
	
	select @path = SS_ParmValue from SystemSettings where SS_ParmName = 'PathToWcfClient'
	
	set @commandLine = @path + ' SetToQuota'
		
	set @commandLine = @commandLine + ' ' + convert(varchar, @dlKey)
	set @commandLine = @commandLine + ' ' + (case when @serviceQuotedState is null then 'null' else convert(varchar, @serviceQuotedState) end)
	set @commandLine = @commandLine + ' ' + (case when @dateFrom is null then 'null' else convert(varchar(10), @dateFrom, 120) end)
	set @commandLine = @commandLine + ' ' + (case when @dateTo is null then 'null' else convert(varchar(10), @dateTo,120) end)

	
	declare @result table
	(
		temp nvarchar(max)
	)
	insert into @result
	exec xp_cmdshell @commandLine
	
	if (select count(*) from @result) > 1
	begin
		select * from @result
		RAISERROR('Произошла ошибка при доступе к сервису', 15, 1)
	end
END

GO
grant exec on [dbo].[WcfSetServiceToQuota] to public
go

/*********************************************************************/
/* end sp_WcfSetServiceToQuota.sql */
/*********************************************************************/

/*********************************************************************/
/* begin sp_WcfTransferAllServices.sql */
/*********************************************************************/
--<VERSION>2011.1</VERSION>
--<DATE>2013-08-21</DATE>
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WcfTransferAllServices]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[WcfTransferAllServices]
GO
/*********************************************************************/
/* end sp_WcfTransferAllServices.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_CharterDeleteQueue.sql */
/*********************************************************************/
if exists ( select  *
            from    sys.triggers
            where   object_id = object_id(N'[dbo].[T_CharterDeleteQueue]') ) 
    drop trigger [dbo].[T_CharterDeleteQueue]
GO

CREATE trigger [dbo].[T_CharterDeleteQueue] on [dbo].[Charter]
INSTEAD OF DELETE
--<date>2013-08-09</date>
--<version>2009.2.20</version>
AS
begin
	if not exists (select top 1 1 from SystemSettings where SS_ParmName = 'ReplaceCharterOnDelete' and SS_ParmValue = 1)
	begin
		delete from Charter 
		where CH_KEY in (select ch_key from deleted)
		
		return
	end
	
	delete from Charter
	where CH_KEY in 
		(
			select ch_key from deleted
			left join CharterDeleteQueue on CH_KEY = charterIdToReplace
			where isProcessed = 1
		)

	declare @userId int
	EXEC dbo.GetUserKey @userId output

	insert into CharterDeleteQueue (charterIdToReplace, charterToReplaceName, createDate, userId)
	select ch_key, CH_AIRLINECODE + ' ' + CH_FLIGHT, GETDATE(), @userId
	from deleted
	where not exists (select top 1 1 from CharterDeleteQueue where charterIdToReplace = ch_key)
end

GO
/*********************************************************************/
/* end T_CharterDeleteQueue.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_mwDeleteTour.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[mwDeleteTour]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop trigger [dbo].[mwDeleteTour]
GO

CREATE trigger [dbo].[mwDeleteTour] on [dbo].[TP_Tours]
for delete
as
begin

	--<VERSION>2009.2.20</VERSION>
	--<DATE>2013-09-13</DATE>

	if dbo.mwReplIsSubscriber() > 0
	begin
	
		declare @DirTable table(xrq_cnkey int, xrq_ctkeyfrom int)
	
		insert into mwReplQueue(rq_mode, rq_tokey, rq_cnkey, rq_ctkeyfrom)
		output inserted.rq_cnkey, inserted.rq_ctkeyfrom into @DirTable (xrq_cnkey, xrq_ctkeyfrom)
		select 4, to_key, TO_CNKey, TL_CTDepartureKey
		from deleted
		join tbl_TurList on TL_KEY = TO_TRKey
		
		insert into mwReplDirections (rd_cnkey, rd_ctkeyfrom)
		select xrq_cnkey, isnull(xrq_ctkeyfrom, 0)
		from @DirTable
		left join mwReplDirections with(nolock) on xrq_cnkey = rd_cnkey and isnull(xrq_ctkeyfrom, 0) = rd_ctkeyfrom
		where rd_id is null

	end
	else if dbo.mwReplIsPublisher() <= 0
	begin

		declare @tableName nvarchar(100), @sql nvarchar(4000), @tokey int, @cnKey int, @ctDepartureKey int
		if exists(select 1 from SystemSettings where SS_ParmName = 'MWDivideByCountry' and SS_ParmValue = 1)
		begin
			--Используется секционирование ценовых таблиц
			declare disableCursor cursor fast_forward read_only for
			select 
				to_key, dbo.mwGetPriceTableName(to_cnkey, tl_ctdeparturekey), to_cnkey, tl_ctdeparturekey
			from 
				deleted 
				inner join tbl_turlist with(nolock) on to_trkey = tl_key
				inner join sys.tables tab on tab.name = dbo.mwGetPriceTableName(to_cnkey, tl_ctdeparturekey)

			open disableCursor
			fetch next from disableCursor into @tokey, @tableName, @cnKey, @ctDepartureKey
		
			while @@fetch_status = 0
			begin
				--koshelev 9454
				exec dbo.mwCreateNewPriceTable @cnKey, @ctDepartureKey
			
				if(@tableName is not null and len(@tableName) > 0)
				begin
					set @sql = 'insert into mwDeleted with(rowlock) (del_key) select pt_pricekey from ' + @tableName + ' with(nolock) where pt_tourkey = ' + ltrim(str(@tokey)) + '
								update ' + @tableName + ' with(rowlock) set pt_isenabled = 0 where pt_isenabled > 0 and pt_tourkey = ' + ltrim(str(@tokey)) + '
								update mwSpoDataTable with(rowlock) set sd_isenabled = 0 where sd_isenabled > 0 and sd_tourkey = ' + ltrim(str(@tokey))
					exec (@sql)
				end

				delete from TP_Prices with(rowlock) where tp_tokey = @tokey
				delete from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
				delete from TP_Services with(rowlock) where ts_tokey = @tokey
				delete from TP_Lists with(rowlock) where ti_tokey = @tokey

				fetch next from disableCursor into @tokey, @tableName, @cnKey, @ctDepartureKey
			end
		
			close disableCursor
			deallocate disableCursor
		end
		else
		begin
			--Секционирование ценовых таблиц НЕ используется
			set @tableName = 'dbo.mwPriceDataTable'
			declare disableCursor cursor fast_forward read_only for
			select 
				to_key
			from 
				deleted 

			open disableCursor
		
			fetch next from disableCursor into @tokey
			while @@fetch_status = 0
			begin
				if(@tableName is not null and len(@tableName) > 0)
				begin
					set @sql = 'insert into mwDeleted with(rowlock) (del_key) select pt_pricekey from ' + @tableName + ' with(nolock) where pt_tourkey = ' + ltrim(str(@tokey)) + '
								update ' + @tableName + ' with(rowlock) set pt_isenabled = 0 where pt_isenabled > 0 and pt_tourkey = ' + ltrim(str(@tokey)) + '
								update mwSpoDataTable with(rowlock) set sd_isenabled = 0 where sd_isenabled > 0 and sd_tourkey = ' + ltrim(str(@tokey))
					exec (@sql)
				end

				delete from TP_Prices with(rowlock) where tp_tokey = @tokey
				delete from TP_ServiceLists with(rowlock) where tl_tokey = @tokey
				delete from TP_Services with(rowlock) where ts_tokey = @tokey
				delete from TP_Lists with(rowlock) where ti_tokey = @tokey

				fetch next from disableCursor into @tokey
			end
		
			close disableCursor
			deallocate disableCursor
		end

	end

end
GO
/*********************************************************************/
/* end T_mwDeleteTour.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_mwReplDeletePrice.sql */
/*********************************************************************/
if exists(select id from sysobjects where xtype='TR' and name='mwReplDeletePrice')
	drop trigger dbo.mwReplDeletePrice

GO

create trigger [dbo].[mwReplDeletePrice] on [dbo].[TP_Prices]
for delete as
begin
	--<DATE>2013-08-27</DATE>
	--<VERSION>9.2.20</VERSION>
	
	if dbo.mwReplIsPublisher() > 0 or (dbo.mwReplIsPublisher() <= 0 and dbo.mwReplIsSubscriber() <= 0)
	begin
		if exists(select 1 from SystemSettings where SS_ParmName = 'MWDivideByCountry' and SS_ParmValue = 1)
		begin
			insert into dbo.mwReplDeletedPricesTemp with(rowlock) (rdp_pricekey, rdp_cnkey, rdp_ctdeparturekey) select tp_key, to_cnkey, tl_ctdeparturekey from deleted inner join 
						TP_Tours with(nolock) on TP_TOKey=TO_Key inner join
						tbl_TurList with(nolock) on TL_KEY = TO_TRKey;
		end
		else if dbo.mwReplIsPublisher() > 0 
		begin
			insert into dbo.mwReplDeletedPricesTemp with(rowlock) (rdp_pricekey, rdp_cnkey, rdp_ctdeparturekey) 
			select tp_key, TO_CNKey, TL_CTDepartureKey
			from deleted
			join tp_tours on tp_tokey = to_key
			join tbl_TurList on tl_key = to_trkey
		end
	end
end


GO

/*********************************************************************/
/* end T_mwReplDeletePrice.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaDetailsChange.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuotaDetailsChange')
	drop trigger dbo.[T_QuotaDetailsChange]
go

CREATE TRIGGER [dbo].[T_QuotaDetailsChange]
ON [dbo].[QuotaDetails]
FOR UPDATE, INSERT, DELETE
AS
--<VERSION>2009.2.01</VERSION>
--<DATE>2012-12-28</DATE>
IF @@ROWCOUNT > 0 and exists(select 1 from SystemSettings with(nolock) where SS_ParmName like 'SYSQuotasToHistory' and ISNULL(SS_ParmValue, '0') <> '0')
BEGIN
	DECLARE @QO_SVKey int, @QO_Code int, @QT_Id int, @QT_ByRoom bit, @QT_PRKey int, @QT_PrtDogsKey int, @QD_ID int,
			@OQD_Type smallint, @OQD_Date smalldatetime, @OQD_Places smallint, @OQD_Busy smallint, @OQD_Release smallint, @OQD_IsDeleted smallint,
			@NQD_Type smallint, @NQD_Date smalldatetime, @NQD_Places smallint, @NQD_Busy smallint, @NQD_Release smallint, @NQD_IsDeleted smallint
    DECLARE @sText_Old varchar(255), @sText_New varchar(255), @sHI_Text varchar(255)
    DECLARE @sMod varchar(3), @nDelCount int, @nInsCount int, @nHIID int

	SELECT @nDelCount = COUNT(*) FROM DELETED
	SELECT @nInsCount = COUNT(*) FROM INSERTED
	IF (@nDelCount = 0)
	BEGIN
		SET @sMod = 'INS'
		DECLARE cur_QuotaDetails CURSOR LOCAL FOR 
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, N.QD_ID,
					null, null, null, null, null, null,
					N.QD_Type, N.QD_Date, N.QD_Places, N.QD_Busy, N.QD_Release, N.QD_IsDeleted
			FROM	INSERTED N join dbo.Quotas on N.QD_QTID = QT_ID
	END
	ELSE IF (@nInsCount = 0)
	BEGIN
		SET @sMod = 'DEL'
		DECLARE cur_QuotaDetails CURSOR LOCAL FOR
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, O.QD_ID,
					O.QD_Type, O.QD_Date, O.QD_Places, O.QD_Busy, O.QD_Release, O.QD_IsDeleted,
					null, null, null, null, null, null
			FROM	DELETED O join dbo.Quotas on O.QD_QTID = QT_ID
	END
	ELSE 
	BEGIN
		SET @sMod = 'UPD'
		DECLARE cur_QuotaDetails CURSOR LOCAL FOR
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, N.QD_ID,
					O.QD_Type, O.QD_Date, O.QD_Places, O.QD_Busy, O.QD_Release, O.QD_IsDeleted,
					N.QD_Type, N.QD_Date, N.QD_Places, N.QD_Busy, N.QD_Release, N.QD_IsDeleted
			FROM	DELETED O join dbo.Quotas on O.QD_QTID = QT_ID
					join INSERTED N on N.QD_QTID = QT_ID
	END

	OPEN cur_QuotaDetails
	FETCH NEXT FROM cur_QuotaDetails INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, @QD_ID,
					@OQD_Type, @OQD_Date, @OQD_Places, @OQD_Busy, @OQD_Release, @OQD_IsDeleted,
					@NQD_Type, @NQD_Date, @NQD_Places, @NQD_Busy, @NQD_Release, @NQD_IsDeleted
	WHILE @@FETCH_STATUS = 0
	BEGIN 
		------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQD_Type, 0) !=			ISNULL(@NQD_Type, 0) OR
			ISNULL(@OQD_Date, 0) !=			ISNULL(@NQD_Date, 0) OR
			ISNULL(@OQD_Places, 0) !=		ISNULL(@NQD_Places, 0) OR
			ISNULL(@OQD_Busy, 0) !=			ISNULL(@NQD_Busy, 0) OR
			ISNULL(@OQD_Release, 0) !=		ISNULL(@NQD_Release, 0) OR
			ISNULL(@OQD_IsDeleted, 0) !=	ISNULL(@NQD_IsDeleted, 0)
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			If @QT_PRKey = 0
				Set @sHI_Text = 'All partners'
			Else
				Select @sHI_Text = PR_Name from Partners where PR_Key = @QT_PRKey
			SET @sText_New=@sHI_Text
			Set @sHI_Text = null
			If isnull(@QT_PrtDogsKey,0) >0
				Select @sHI_Text = PD_DogNumber from PrtDogs where PD_Key=@QT_PrtDogsKey
			If @sHI_Text is not null
				SET @sText_New=@sText_New + '(' + @sHI_Text + ')'
			
			Select TOP 1 @QO_SVKey=QO_SVKey, @QO_Code=QO_Code FROM QuotaObjects WHERE QO_QTID=@QT_Id
			If @QO_SVKey=3
			BEGIN
				If @QT_ByRoom=0
					SET @sText_New=@sText_New + '(BY PERSON)'
				Else
					SET @sText_New=@sText_New + '(BY ROOM)'
			END

			EXEC @nHIID = dbo.InsHistory 
							@sDGCod = '',
							@nDGKey = null,
							@nOAId = 34,
							@nTypeCode = @QD_ID,
							@sMod = @sMod,
							@sText = @sText_New,
							@sRemark = @sHI_Text,
							@nInvisible = 0,
							@sDocumentNumber  = '',
							@bMessEnabled = 0,
							@nSVKey = @QO_SVKey,
							@nCode = @QO_Code
			SET @sText_Old = ''
			SET @sText_New = ''
				
			--------Детализация--------------------------------------------------
			if ISNULL(@OQD_Type, 0) != ISNULL(@NQD_Type, 0)
			begin				
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34001, @OQD_Type, @NQD_Type, @OQD_Type, @NQD_Type, null, null, 0
			end
			if ISNULL(@OQD_Date, 0) != ISNULL(@NQD_Date, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34002, @OQD_Date, @NQD_Date, null, null, null, null, 0
			END
			if ISNULL(@OQD_Places, 0) != ISNULL(@NQD_Places, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34003, @OQD_Places, @NQD_Places, @OQD_Places, @NQD_Places, null, null, 0
			END
			if ISNULL(@OQD_Busy, 0) != ISNULL(@NQD_Busy, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34004, @OQD_Busy, @NQD_Busy, @OQD_Busy, @NQD_Busy, null, null, 0
			END
			if ISNULL(@OQD_Release, 0) != ISNULL(@NQD_Release, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34005, @OQD_Release, @NQD_Release, @OQD_Release, @NQD_Release, null, null, 0
			END
			if ISNULL(@OQD_IsDeleted, 0) != ISNULL(@NQD_IsDeleted, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 34006, @OQD_IsDeleted, @NQD_IsDeleted, @OQD_IsDeleted, @NQD_IsDeleted, null, null, 0
			END
		END
		
		FETCH NEXT FROM cur_QuotaDetails INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, @QD_ID,
					@OQD_Type, @OQD_Date, @OQD_Places, @OQD_Busy, @OQD_Release, @OQD_IsDeleted,
					@NQD_Type, @NQD_Date, @NQD_Places, @NQD_Busy, @NQD_Release, @NQD_IsDeleted
    END
	CLOSE cur_QuotaDetails
	DEALLOCATE cur_QuotaDetails
END

-- 04-07-2012 karimbaeva если изменился тип квоты, то меняем статус квоты и в путевках, которые сидят в этой квоте
if @sMod = 'UPD'
begin	
	update ServiceByDate
	set SD_State = QD_Type
	from inserted with(nolock) 
	join QuotaParts with(nolock) on QD_ID = QP_QDID 
	where SD_QPID = QP_ID 
	and SD_State <> QD_Type 
end
GO
/*********************************************************************/
/* end T_QuotaDetailsChange.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaDetailsDelete.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuotaDetailsDelete')
	drop trigger dbo.[T_QuotaDetailsDelete]
go

CREATE TRIGGER [dbo].[T_QuotaDetailsDelete]
ON [dbo].[QuotaDetails] 
FOR DELETE
AS
--<VERSION>9.2.20.1</VERSION>
--<DATE>2013-07-12</DATE>

	if exists (select 1 from SystemSettings where SS_ParmName='SYSDeleteProtourQuotes' and SS_ParmValue = 1)
	begin
		delete 
		from ProTourQuotes 
		where exists(select 1 
					 from Quotas with(nolock)
					 join DELETED with(nolock) on QT_ID = QD_QTID 
					 join QuotaObjects with(nolock) on QT_ID = QO_QTID
					 where QO_SVKey = 3 
					 and QT_ByRoom = 1 
					 and QO_SubCode1 = 0
					 and PTQ_HotelKey = QO_Code
					 and PTQ_Date = QD_Date
					 and PTQ_RoomCategoryKey = QO_SubCode2
					 and PTQ_PartnerKey = QT_PRKey
					 and PTQ_StopSale = 0
					 and PTQ_CancelStopSale is null
					 and ((QD_Type = 1 and PTQ_AllotmentTotal > 0) or (QD_Type = 2 and PTQ_CommitmentTotal > 0) or (PTQ_AllotmentTotal = 0 and PTQ_CommitmentTotal = 0)))				
	end
GO
/*********************************************************************/
/* end T_QuotaDetailsDelete.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaPartsChange.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuotaPartsChange')
	drop trigger dbo.[T_QuotaPartsChange]
go

CREATE TRIGGER [dbo].[T_QuotaPartsChange]
ON [dbo].[QuotaParts] 
FOR UPDATE, INSERT, DELETE
AS
--<VERSION>9.2.20.01</VERSION>
--<DATE>2013-07-12</DATE>
IF @@ROWCOUNT > 0 and exists(select 1 from SystemSettings with(nolock) where SS_ParmName like 'SYSQuotasToHistory' and ISNULL(SS_ParmValue, '0') <> '0')
BEGIN
	DECLARE @QO_SVKey int, @QO_Code int, @QT_Id int, @QT_ByRoom bit, @QT_PRKey int, @QT_PrtDogsKey int, @QP_ID int,
			@QD_Type smallint, @QD_Date smalldatetime, @QD_Release smallint,
			@OQP_Places smallint, @OQP_IsDeleted smallint, @OQP_AgentKey int, @OQP_Durations varchar(20), @OQP_IsNotCheckIn bit,
			@NQP_Places smallint, @NQP_IsDeleted smallint, @NQP_AgentKey int, @NQP_Durations varchar(20), @NQP_IsNotCheckIn bit
    DECLARE @sText_Old varchar(255), @sText_New varchar(255), @sHI_Text varchar(255)
    DECLARE @sMod varchar(3), @nDelCount int, @nInsCount int, @nHIID int

	SELECT @nDelCount = COUNT(*) FROM DELETED
	SELECT @nInsCount = COUNT(*) FROM INSERTED
	IF (@nDelCount = 0)
	BEGIN
		SET @sMod = 'INS'
		DECLARE cur_QuotaParts CURSOR LOCAL FOR 
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, 
					QD_Type, QD_Date, QD_Release, N.QP_ID,
					null, null, null, null, null,
					N.QP_Places, N.QP_IsDeleted, N.QP_AgentKey, N.QP_Durations, N.QP_IsNotCheckIn
			FROM	INSERTED N, dbo.Quotas, dbo.QuotaDetails
			WHERE	N.QP_QDID=QD_ID and QD_QTID=QT_ID
		
	END
	ELSE IF (@nInsCount = 0)
	BEGIN
		SET @sMod = 'DEL'
		DECLARE cur_QuotaParts CURSOR LOCAL FOR 
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, 
					QD_Type, QD_Date, QD_Release, O.QP_ID,
					O.QP_Places, O.QP_IsDeleted, O.QP_AgentKey, O.QP_Durations, O.QP_IsNotCheckIn,
					null, null, null, null, null
			FROM	DELETED O, dbo.Quotas, dbo.QuotaDetails
			WHERE	O.QP_QDID=QD_ID and QD_QTID=QT_ID
	END
	ELSE 
	BEGIN
		SET @sMod = 'UPD'
		DECLARE cur_QuotaParts CURSOR LOCAL FOR
			SELECT	QT_ID, QT_ByRoom, QT_PRKey, QT_PrtDogsKey, 
					QD_Type, QD_Date, QD_Release, N.QP_ID,
					O.QP_Places, O.QP_IsDeleted, O.QP_AgentKey, O.QP_Durations, O.QP_IsNotCheckIn,
					N.QP_Places, N.QP_IsDeleted, N.QP_AgentKey, N.QP_Durations, N.QP_IsNotCheckIn
			FROM	DELETED O, INSERTED N, dbo.Quotas, dbo.QuotaDetails
			WHERE	N.QP_QDID=QD_ID and QT_ID=QD_QTID and O.QP_Id=N.QP_Id
	END

	OPEN cur_QuotaParts
	FETCH NEXT FROM cur_QuotaParts INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, 
					@QD_Type, @QD_Date, @QD_Release, @QP_ID,
					@OQP_Places, @OQP_IsDeleted, @OQP_AgentKey, @OQP_Durations, @OQP_IsNotCheckIn,
					@NQP_Places, @NQP_IsDeleted, @NQP_AgentKey, @NQP_Durations, @NQP_IsNotCheckIn
	WHILE @@FETCH_STATUS = 0
	BEGIN 
		------------Проверка, надо ли что-то писать в историю-------------------------------------------   
		If (
			ISNULL(@OQP_Places, 0) != ISNULL(@NQP_Places, 0) OR
			ISNULL(@OQP_AgentKey, 0) != ISNULL(@NQP_AgentKey, 0) OR
			ISNULL(@OQP_Durations, 0) != ISNULL(@NQP_Durations, 0) OR
			ISNULL(@OQP_IsNotCheckIn, 0) != ISNULL(@NQP_IsNotCheckIn, 0) OR
			ISNULL(@OQP_IsDeleted, 0) != ISNULL(@NQP_IsDeleted, 0)
			)
		BEGIN
			------------Запись в историю--------------------------------------------------------------------
			If @QT_PRKey=0
				Set @sHI_Text='All partners'
			Else
				Select @sHI_Text = PR_Name from Partners where PR_Key=@QT_PRKey
			SET @sText_New=@sHI_Text
			Set @sHI_Text = null
			If isnull(@QT_PrtDogsKey,0) >0
				Select @sHI_Text = PD_DogNumber from PrtDogs where PD_Key=@QT_PrtDogsKey
			If @sHI_Text is not null
				SET @sText_New=@sText_New + '(' + @sHI_Text + ')'
			
			Select TOP 1 @QO_SVKey=QO_SVKey, @QO_Code=QO_Code FROM QuotaObjects WHERE QO_QTID=@QT_Id
			If @QO_SVKey=3
			BEGIN
				If @QT_ByRoom=0
					SET @sText_New=@sText_New + '(BY PERSON)'
				Else
					SET @sText_New=@sText_New + '(BY ROOM)'
			END
			If @QD_Type=2
				SET @sHI_Text='C'
			Else If @QD_Type=1
				SET @sHI_Text='A'
			If @QD_Release is not null
				SET @sHI_Text=@sHI_Text+'('+CAST(@QD_Release as varchar(4))+')'
			Set @sHI_Text=@sHI_Text+' (' + CONVERT(varchar(20),@QD_Date,104)+')'

			IF @NQP_IsDeleted=1 and @OQP_IsDeleted=0
				SET @sMod='DEL'
			EXEC @nHIID = dbo.InsHistory 
							@sDGCod = '',
							@nDGKey = null,
							@nOAId = 13,
							@nTypeCode = @QP_ID,
							@sMod = @sMod,
							@sText = @sText_New,
							@sRemark = @sHI_Text,
							@nInvisible = 0,
							@sDocumentNumber  = '',
							@bMessEnabled = 0,
							@nSVKey = @QO_SVKey,
							@nCode = @QO_Code
--'', null, 13, @QP_ID, @sMod, @sText_New, '', 0, @sHI_Text, 0, @QO_SVKey, @QO_Code
			SET @sText_Old=''
			SET @sText_New=''

			--------Детализация--------------------------------------------------
			if ISNULL(@OQP_Places, 0) != ISNULL(@NQP_Places, 0)
			begin
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13001, @OQP_Places, @NQP_Places, @OQP_Places, @NQP_Places, null, null, 0
			end
			if ISNULL(@OQP_AgentKey, 0) != ISNULL(@NQP_AgentKey, 0)
			BEGIN
				If @OQP_AgentKey is not null
					Select @sText_Old = PR_Name from Partners where PR_Key=@OQP_AgentKey
				If @NQP_AgentKey is not null
					Select @sText_Old = PR_Name from Partners where PR_Key=@NQP_AgentKey
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13002, @sText_Old, @sText_New, @OQP_AgentKey, @NQP_AgentKey, null, null, 0
				SET @sText_Old=''
				SET @sText_New=''
			END
			if ISNULL(@OQP_Durations, 0) != ISNULL(@NQP_Durations, 0)
			BEGIN
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13003, @OQP_Durations, @NQP_Durations, null, null, null, null, 0
				SET @sText_Old=''
				SET @sText_New=''
			END
			if ISNULL(@OQP_IsNotCheckIn, 0) != ISNULL(@NQP_IsNotCheckIn, 0)
			BEGIN
				Set @sText_Old=CAST(@OQP_IsNotCheckIn as varchar(1))
				Set @sText_New=CAST(@NQP_IsNotCheckIn as varchar(1))
				EXECUTE dbo.InsertHistoryDetail @nHIID, 13004, @sText_Old, @sText_New, @OQP_IsNotCheckIn, @NQP_IsNotCheckIn, null, null, 0
				SET @sText_Old=''
				SET @sText_New=''
			END
		END
		FETCH NEXT FROM cur_QuotaParts INTO @QT_Id, @QT_ByRoom, @QT_PRKey, @QT_PrtDogsKey, 
					@QD_Type, @QD_Date, @QD_Release, @QP_ID,
					@OQP_Places, @OQP_IsDeleted, @OQP_AgentKey, @OQP_Durations, @OQP_IsNotCheckIn,
					@NQP_Places, @NQP_IsDeleted, @NQP_AgentKey, @NQP_Durations, @NQP_IsNotCheckIn
    END
	CLOSE cur_QuotaParts
	DEALLOCATE cur_QuotaParts
END
GO
/*********************************************************************/
/* end T_QuotaPartsChange.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_QuotaPartsUpdateInsert.sql */
/*********************************************************************/
if exists (select id from sysobjects where xtype = 'TR' and name='T_QuotaPartsUpdateInsert')
	drop trigger dbo.[T_QuotaPartsUpdateInsert]
go

CREATE TRIGGER [dbo].[T_QuotaPartsUpdateInsert]
ON [dbo].[QuotaParts] 
FOR UPDATE, INSERT
AS
--<VERSION>9.2.20.1</VERSION>
--<DATE>2013-07-12</DATE>
	IF UPDATE (QP_Places)
	BEGIN
		update QuotaParts
		set QP_CheckInPlaces = n.QP_Places
		from inserted as n with(nolock)
		join QuotaDetails with(nolock) on QD_ID = QP_QDID
		join QuotaObjects with(nolock) on QO_QTID = QD_QTID
		join [Service] with(nolock) on SV_Key = QO_SVKey
		where QuotaParts.QP_ID = n.QP_ID
		and isnull(SV_IsDuration, 0) = 0
	END

	IF exists(SELECT TOP 1 1 FROM INSERTED)
	BEGIN
		update QuotaParts
		set QP_Date = QD_Date
		from QuotaParts as QP join QuotaDetails as QD on QD_ID = QP_QDID
		where exists (select 1 from Inserted as Ins where Ins.QP_ID = QP.QP_ID)
	END
GO

/*********************************************************************/
/* end T_QuotaPartsUpdateInsert.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TSToServiceByDate.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_TSToServiceByDate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
	drop trigger [dbo].[T_TSToServiceByDate]
GO

CREATE TRIGGER [dbo].[T_TSToServiceByDate]
   ON  [dbo].[TuristService]
   AFTER INSERT, DELETE 
AS 
--<VERSION>2009.2.20.0</VERSION>
--<DATE>2013-08-20</DATE>
DECLARE @TUID int, @O_DLKey int, @O_TUKey int, @N_DLKey int,@N_TUKey int,
		@BestPlace int, @BestRL int, @nDelCount int, @nInsCount int

SELECT @nDelCount = COUNT(*) FROM DELETED
SELECT @nInsCount = COUNT(*) FROM INSERTED

-- Task 8984 24.10.2012 kolbeshkin
-- Перераспределение туристов по услугам, класс которых имеет признак "Индивидуальное бронирование":
-- в каждой услуге должно быть не более 1 туриста.
IF (@nDelCount = 0)
begin
	DECLARE @isIndividualService smallint
    DECLARE @newTU_DLKEY int
    DECLARE @DL_DGKEY int
    DECLARE @DL_SVKEY int
        
	DECLARE cur_individual CURSOR FOR 
    SELECT 	N.TU_IDKey,	N.TU_DLKey
    FROM	INSERTED N 
    OPEN cur_individual
    FETCH NEXT FROM cur_individual 
	INTO @TUID, @O_DLKey

	WHILE @@FETCH_STATUS = 0
	BEGIN
		select @isIndividualService = ISNULL(SV_IsIndividual, 0),@DL_SVKEY=DL_SVKEY,@DL_DGKEY=DL_DGKEY  
		from dbo.Service,dbo.Dogovorlist where DL_KEY = @O_DLKey and SV_Key = DL_SVKEY 
		if @isIndividualService > 0 and (select COUNT(*) from TuristService where TU_DLKEY = @O_DLKey) > 1
		begin
				set @newTU_DLKEY = (select top 1 DL_KEY from dbo.Dogovorlist where DL_DGKEY = @DL_DGKEY
					and DL_SVKEY = @DL_SVKEY and not exists (select 1 from TuristService where TU_DLKEY = DL_KEY))
				if @newTU_DLKEY is not null
					update TuristService set TU_DLKEY = @newTU_DLKEY where TU_IDKEY = @TUID
		end
		FETCH NEXT FROM cur_individual 
		INTO @TUID, @O_DLKey
	end
	CLOSE cur_individual
	DEALLOCATE cur_individual
end
set @TUID=null
set @O_DLKey=null
-- 

IF (@nInsCount = 0)
BEGIN
    DECLARE cur_T_TSToServiceByDate CURSOR FOR 
    SELECT 	O.TU_IDKey,
			O.TU_DLKey, O.TU_TUKey,
			null, null
    FROM DELETED O
END
ELSE IF (@nDelCount = 0)
BEGIN
    DECLARE cur_T_TSToServiceByDate CURSOR FOR 
    SELECT 	N.TU_IDKey,
			null, null,
			N.TU_DLKey, N.TU_TUKey
    FROM	INSERTED N 
END

OPEN cur_T_TSToServiceByDate
FETCH NEXT FROM cur_T_TSToServiceByDate 
	INTO @TUID, @O_DLKey, @O_TUKey, @N_DLKey, @N_TUKey
WHILE @@FETCH_STATUS = 0
BEGIN
	IF @N_TUKey is not null
	BEGIN
		SET @BestRL = 0
		SET @BestPlace = 0
		SELECT @BestRL=Min(SD_RLID),@BestPlace=Max(SD_RPID) FROM ServiceByDate WHERE SD_DLKey=@N_DLKey and SD_TUKey is null
		If @BestRL is null
			UPDATE ServiceByDate SET SD_TUKey=@N_TUKey WHERE SD_DLKey=@N_DLKey and SD_RPID=@BestPlace and SD_RLID is null
		Else
		BEGIN
			SELECT @BestPlace=Max(SD_RPID) FROM ServiceByDate WHERE SD_DLKey=@N_DLKey and SD_RLID=@BestRL and SD_TUKey is null
			UPDATE ServiceByDate SET SD_TUKey=@N_TUKey WHERE SD_DLKey=@N_DLKey and SD_RPID=@BestPlace and SD_RLID=@BestRL
		END
	END
	ELSE IF @O_TUKey is not null
		UPDATE ServiceByDate SET SD_TUKey=null WHERE SD_DLKey=@O_DLKey AND SD_TUKey=@O_TUKey

	-- Golubinsky. 11.08.2012. 
	-- TFS 7219: бронирование авиаперелетов для инфантов: перелеты садятся на подтверждение вне квоты
	UPDATE ServiceByDate SET SD_State=3
	WHERE SD_DLKey = @N_DLKey
			AND SD_TUKey = @N_TUKey
			AND EXISTS (SELECT TOP 1 1 FROM tbl_DogovorList WHERE DL_KEY = SD_DLKey AND DL_SVKEY = 1)
			AND EXISTS (SELECT TOP 1 1 FROM tbl_Turist WHERE TU_KEY = SD_TUKey AND TU_SEX=3)

	FETCH NEXT FROM cur_T_TSToServiceByDate
		INTO @TUID, @O_DLKey, @O_TUKey, @N_DLKey, @N_TUKey
END
CLOSE cur_T_TSToServiceByDate
DEALLOCATE cur_T_TSToServiceByDate
GO
/*********************************************************************/
/* end T_TSToServiceByDate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TuristServiceUpdate.sql */
/*********************************************************************/
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_TuristServiceUpdate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
drop trigger [dbo].[T_TuristServiceUpdate]
GO

CREATE TRIGGER [T_TuristServiceUpdate]
ON [dbo].[TuristService] 
FOR UPDATE, INSERT, DELETE
AS
--<DATE>2013-05-22</DATE>
--<VERSION>2009.2.20.0</VERSION>
IF @@ROWCOUNT > 0
BEGIN
    DECLARE @OTU_TUKey int
    DECLARE @OTU_DLKey int
    DECLARE @OTU_NumDoc varchar(32)
    DECLARE @OTU_NumRoom int
    DECLARE @OTU_Seat varchar(32)
    DECLARE @OTU_Area int
    DECLARE @OTU_DocDate datetime
    
    DECLARE @NTU_TUKey int
    DECLARE @NTU_DLKey int
    DECLARE @NTU_NumDoc varchar(32)
    DECLARE @NTU_NumRoom int
    DECLARE @NTU_Seat varchar(32)
    DECLARE @NTU_Area int
    DECLARE @NTU_DocDate datetime

    DECLARE @sText_Old varchar(255)
    DECLARE @sText_New varchar(255)

	DECLARE @TU_IDKey int

	DECLARE @nDLKey int
	DECLARE @nTUKey int
	DECLARE @sDGCode varchar(10)
	DECLARE @nDGKey int
	DECLARE @sTUName varchar(32)
	DECLARE @sDLName varchar(170)
	DECLARE @sMod varchar(3)
	DECLARE @nDelCount int
	DECLARE @nInsCount int
	DECLARE @nHIID int
	DECLARE @sHI_Text varchar(254)
	DECLARE @bNeedCommunicationUpdate smallint
	DECLARE @nDL_SVKey int
	DECLARE @nDL_PRKey int

  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
    DECLARE cur_TuristService CURSOR FOR 
      SELECT N.TU_IDKey, 
			 null, null, null, null, null, null, null, 
		  	 N.TU_TUKey, N.TU_DLKey, N.TU_NumDoc, N.TU_NumRoom, N.TU_Seat, N.TU_Area, N.TU_DocDate 
      FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
    DECLARE cur_TuristService CURSOR FOR 
      SELECT O.TU_IDKey,
			 O.TU_TUKey, O.TU_DLKey, O.TU_NumDoc, O.TU_NumRoom, O.TU_Seat, O.TU_Area, O.TU_DocDate, 
		  	 null, null, null, null, null, null, null
      FROM DELETED O 
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
    DECLARE cur_TuristService CURSOR FOR 
      SELECT N.TU_IDKey,
			 O.TU_TUKey, O.TU_DLKey, O.TU_NumDoc, O.TU_NumRoom, O.TU_Seat, O.TU_Area, O.TU_DocDate, 
		  	 N.TU_TUKey, N.TU_DLKey, N.TU_NumDoc, N.TU_NumRoom, N.TU_Seat, N.TU_Area, N.TU_DocDate
      FROM DELETED O, INSERTED N 
      WHERE N.TU_IDKey = O.TU_IDKey
  END

  OPEN cur_TuristService
    FETCH NEXT FROM cur_TuristService INTO @TU_IDKey,
				@OTU_TUKey, @OTU_DLKey, @OTU_NumDoc, @OTU_NumRoom, @OTU_Seat, @OTU_Area, @OTU_DocDate,  
				@NTU_TUKey, @NTU_DLKey, @NTU_NumDoc, @NTU_NumRoom, @NTU_Seat, @NTU_Area, @NTU_DocDate 

    WHILE @@FETCH_STATUS = 0
    BEGIN 
	  ------------Проверка, надо ли что-то писать в историю-------------------------------------------   
	  If (	@sMod = 'INS' OR @sMod = 'DEL' OR
			ISNULL(@OTU_TUKey, 0) != ISNULL(@NTU_TUKey, 0) OR
			ISNULL(@OTU_DLKey, 0) != ISNULL(@NTU_DLKey, 0) OR
			ISNULL(@OTU_NumDoc, '') != ISNULL(@NTU_NumDoc, '') OR
			ISNULL(@OTU_NumRoom, 0) != ISNULL(@NTU_NumRoom, 0) OR
			ISNULL(@OTU_Seat, '') != ISNULL(@NTU_Seat, '') OR
			ISNULL(@OTU_Area, 0) != ISNULL(@NTU_Area, 0) OR
			ISNULL(@OTU_DocDate, 0) != ISNULL(@NTU_DocDate, 0)
		)
	  BEGIN
	  	------------Запись в историю--------------------------------------------------------------------
		if (@sMod = 'INS' or @sMod = 'UPD')
		BEGIN
			SET @nDLKey = @NTU_DLKey
			SET @nTUKey = @NTU_TUKey
		END
		else if (@sMod = 'DEL')
		BEGIN
			SET @nDLKey = @OTU_DLKey
			SET @nTUKey = @OTU_TUKey
		END

		SELECT 	@sTUName = LEFT(ISNULL(TU_NAMERUS, '') + ' ' + ISNULL(TU_SHORTNAME, ''),25)
		FROM tbl_Turist WHERE TU_Key = @nTUKey
		
		SELECT  @sDLName = DL_NAME,  @sDGCode = DL_DGCOD, @nDGKey = DL_DGKEY,
				@nDL_SVKey = DL_SVKey, @nDL_PRKey = DL_PartnerKey
		FROM tbl_DogovorList WHERE DL_KEY = @nDLKey

		if (@sDGCode is null)
		BEGIN
			SELECT  @sDGCode = TU_DGCOD, @nDGKey = TU_DGKEY
			FROM tbl_Turist WHERE TU_KEY = @nTUKey
		END


--		if (@sMod = 'INS')
--			SET @sHI_Text = 'Привязка туриста ' + @sTUName + ' к услуге ' + @sDLName
--		else if (@sMod = 'DEL')
--			SET @sHI_Text = 'Снятие туриста ' + @sTUName + ' с услуги ' + @sDLName
--		else if (@sMod = 'UPD')
--			SET @sHI_Text = 'Изменение данных о привязке туриста ' + @sTUName + ' к услуге ' + @sDLName

		SET @sHI_Text = @sDLName
		EXEC @nHIID = dbo.InsHistory @sDGCode, @nDGKey, 4, @TU_IDKey, @sMod, @sHI_Text, @sTUName, 0, '', @DLKey=@nDLKey
		--SELECT @nHIID = IDENT_CURRENT('History')
		--------Детализация--------------------------------------------------

		if (ISNULL(@OTU_TUKey, 0) != ISNULL(@NTU_TUKey, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1069, null, null, @OTU_TUKey, @NTU_TUKey, null, null, 1, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_DLKey, 0) != ISNULL(@NTU_DLKey, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1070, null, null, @OTU_DLKey, @NTU_DLKey, null, null, 1, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_NumDoc, '') != ISNULL(@NTU_NumDoc, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1071, @OTU_NumDoc, @NTU_NumDoc, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_NumRoom, 0) != ISNULL(@NTU_NumRoom, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1072, @OTU_NumRoom, @NTU_NumRoom, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_Seat, '') != ISNULL(@NTU_Seat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1073, @OTU_Seat, @NTU_Seat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_Area, 0) != ISNULL(@NTU_Area, 0))
			BEGIN
				Select @sText_Old = VA_Name from VehicleArea where VA_Key = @OTU_Area
				Select @sText_New = VA_Name from VehicleArea where VA_Key = @NTU_Area
				EXECUTE dbo.InsertHistoryDetail @nHIID , 1074, @OTU_Area, @NTU_Area, null, null, null, null, 0, @bNeedCommunicationUpdate output
			END
		if (ISNULL(@OTU_DocDate, 0) != ISNULL(@NTU_DocDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1075, @OTU_DocDate, @NTU_DocDate, null, null, null, null, 0, @bNeedCommunicationUpdate output

		If @bNeedCommunicationUpdate=1
		BEGIN
			If @nDL_SVKey=1
			BEGIN
				If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey)
					UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@nDGKey
			END
			ELSE
			BEGIN
				If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey and CM_PRKey=@nDL_PRKey)
					UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@nDGKey and CM_PRKey=@nDL_PRKey
			END
		END

	  ------------------------------------------------------------------------------------------------
	  END
	  FETCH NEXT FROM cur_TuristService INTO @TU_IDKey,
			  @OTU_TUKey, @OTU_DLKey, @OTU_NumDoc, @OTU_NumRoom, @OTU_Seat, @OTU_Area, @OTU_DocDate,  
			  @NTU_TUKey, @NTU_DLKey, @NTU_NumDoc, @NTU_NumRoom, @NTU_Seat, @NTU_Area, @NTU_DocDate 

    END
  CLOSE cur_TuristService
  DEALLOCATE cur_TuristService
END
GO
/*********************************************************************/
/* end T_TuristServiceUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_TuristUpdate.sql */
/*********************************************************************/
update Turist set TU_ISMAIN = 0 where TU_KEY not in 
(
select MIN(tu_key)
from Dogovor, Turist where TU_DGKEY = DG_Key and TU_ISMAIN = 1 group by DG_Key having COUNT(*) > 1
)
and TU_DGKEY in 
(
select dg_key from Dogovor, Turist where TU_DGKEY = DG_Key and TU_ISMAIN = 1 group by DG_Key having COUNT(*) > 1
)
and TU_ISMAIN = 1

GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[T_TuristUpdate]') and OBJECTPROPERTY(id, N'IsTrigger') = 1)
drop trigger [dbo].[T_TuristUpdate]
GO


CREATE TRIGGER [dbo].[T_TuristUpdate]
ON [dbo].[tbl_Turist] 
FOR UPDATE, INSERT, DELETE
AS
--<DATE>2012-12-4</DATE>
--<VERSION>2009.2.18.1</VERSION>
IF @@ROWCOUNT > 0
BEGIN
    DECLARE @OTU_DGCod 		varchar(10)
    DECLARE @OTU_NameRus 		varchar(25)
    DECLARE @OTU_NameLat 		varchar(25)
    DECLARE @OTU_FNameRus 	varchar(15)
    DECLARE @OTU_FNameLat 		varchar(15)
    DECLARE @OTU_SNameRus 	varchar(15)
    DECLARE @OTU_SNameLat 		varchar(15)
    DECLARE @OTU_BirthDay 		varchar(10)
    DECLARE @OTU_PasportType 	varchar(10)
    DECLARE @OTU_PasportNum 	varchar(20)
    DECLARE @OTU_PaspRuSer 	varchar(10)
    DECLARE @OTU_PaspRuNum 	varchar(20)
    DECLARE @OTU_PasportDate 	varchar(10)
    DECLARE @OTU_PasportDateEnd 	varchar(10)
    DECLARE @OTU_PasportByWhoM 	varchar(20)
    DECLARE @OTU_PaspRuDate 	varchar(10)
    DECLARE @OTU_PaspRuByWhoM 	varchar(50)
    DECLARE @OTU_Sex 	int
    DECLARE @OTU_RealSex 	int
	DECLARE @OTU_DGKey		int
-- 
	DECLARE @OTU_BIRTHCOUNTRY varchar(25)
	DECLARE @OTU_BIRTHCITY varchar(25)
    DECLARE @OTU_CITIZEN varchar(50)
	DECLARE @OTU_POSTINDEX varchar(8)
	DECLARE @OTU_POSTCITY varchar(15)
	DECLARE @OTU_POSTSTREET varchar(25)
	DECLARE @OTU_POSTBILD varchar(6)
	DECLARE @OTU_POSTFLAT varchar(4)

	DECLARE @OTU_ISMAIN smallint
	DECLARE @OTU_PHONE varchar(30)
	DECLARE @OTU_EMAIL varchar(50)
    
    DECLARE @NTU_DGCod 		varchar(10)
    DECLARE @NTU_NameRus 		varchar(25)
    DECLARE @NTU_NameLat 		varchar(25)
    DECLARE @NTU_FNameRus 	varchar(15)
    DECLARE @NTU_FNameLat 		varchar(15)
    DECLARE @NTU_SNameRus 	varchar(15)
    DECLARE @NTU_SNameLat 		varchar(15)
    DECLARE @NTU_BirthDay 		varchar(10)
    DECLARE @NTU_PasportType 	varchar(10)
    DECLARE @NTU_PasportNum 	varchar(20)
    DECLARE @NTU_PaspRuSer 	varchar(10)
    DECLARE @NTU_PaspRuNum 	varchar(20)
    DECLARE @NTU_PasportDate 	varchar(10)
    DECLARE @NTU_PasportDateEnd 	varchar(10)
    DECLARE @NTU_PasportByWhoM 	varchar(20)
    DECLARE @NTU_PaspRuDate 	varchar(10)
    DECLARE @NTU_PaspRuByWhoM 	varchar(50)
    DECLARE @NTU_Sex 	int
    DECLARE @NTU_RealSex 	int
	DECLARE @NTU_DGKey		int
--
	DECLARE @NTU_BIRTHCOUNTRY varchar(25)
	DECLARE @NTU_BIRTHCITY varchar(25)
    DECLARE @NTU_CITIZEN varchar(50)
	DECLARE @NTU_POSTINDEX varchar(8)
	DECLARE @NTU_POSTCITY varchar(15)
	DECLARE @NTU_POSTSTREET varchar(25)
	DECLARE @NTU_POSTBILD varchar(6)
	DECLARE @NTU_POSTFLAT varchar(4)

	DECLARE @NTU_ISMAIN smallint
	DECLARE @NTU_PHONE varchar(30)
	DECLARE @NTU_EMAIL varchar(50)

	DECLARE @TU_Key int

	DECLARE @sTU_ShortName varchar(8)
	DECLARE @sMod varchar(3)
	DECLARE @nDelCount int
	DECLARE @nInsCount int
	DECLARE @nHIID int
	DECLARE @sHI_Text varchar(254)

	DECLARE @sText_Old varchar(254)
	DECLARE @sText_New varchar(254)
	DECLARE @bNeedCommunicationUpdate smallint
	DECLARE @nDGKey int
	DECLARE @sDGCod	varchar(10)

  SELECT @nDelCount = COUNT(*) FROM DELETED
  SELECT @nInsCount = COUNT(*) FROM INSERTED
  IF (@nDelCount = 0)
  BEGIN
	SET @sMod = 'INS'
    DECLARE cur_Turist CURSOR FOR 
      SELECT N.TU_Key, N.TU_ShortName,
			 N.TU_DGCod, N.TU_DGKey, null, null, null, null, 
	  	     null, null, null, null, null, null,
			 null, null, null, null, null, null,
			 null, null,
			 null, null, null, null,
			 null, null, null, null, null, null, null,
		  	 N.TU_DGCod, N.TU_DGKey, N.TU_NameRus, N.TU_NameLat, N.TU_FNameRus, N.TU_FNameLat,
			 N.TU_SNameRus, N.TU_SNameLat, CONVERT( char(10),N.TU_BirthDay, 104), N.TU_PasportType, N.TU_PasportNum, N.TU_PaspRuSer,
			 N.TU_PaspRuNum, CONVERT( char(10),N.TU_PasportDate, 104), CONVERT( char(10),N.TU_PasportDateEnd, 104), N.TU_PasportByWhoM, CONVERT( char(10),N.TU_PaspRuDate, 104), N.TU_PaspRuByWhoM,
			 N.TU_Sex, N.TU_RealSex, 
				N.TU_BIRTHCOUNTRY,
				N.TU_BIRTHCITY,
				N.TU_CITIZEN,
				N.TU_POSTINDEX,
				N.TU_POSTCITY,
				N.TU_POSTSTREET,
				N.TU_POSTBILD,
				N.TU_POSTFLAT,
				N.TU_ISMAIN,
				N.TU_PHONE,
				N.TU_EMAIL
      FROM INSERTED N 
  END
  ELSE IF (@nInsCount = 0)
  BEGIN
	SET @sMod = 'DEL'
    DECLARE cur_Turist CURSOR FOR 
      SELECT O.TU_Key, O.TU_ShortName,
			 O.TU_DGCod, O.TU_DGKey, O.TU_NameRus, O.TU_NameLat, O.TU_FNameRus, O.TU_FNameLat,
			 O.TU_SNameRus, O.TU_SNameLat, CONVERT( char(10),O.TU_BirthDay, 104), O.TU_PasportType, O.TU_PasportNum, O.TU_PaspRuSer,
			 O.TU_PaspRuNum, CONVERT( char(10), O.TU_PasportDate, 104), CONVERT( char(10), O.TU_PasportDateEnd, 104), O.TU_PasportByWhoM, CONVERT( char(10), O.TU_PaspRuDate, 104), O.TU_PaspRuByWhoM, 
			 O.TU_Sex, O.TU_RealSex, 
				O.TU_BIRTHCOUNTRY,
				O.TU_BIRTHCITY,
				O.TU_CITIZEN,
				O.TU_POSTINDEX,
				O.TU_POSTCITY,
				O.TU_POSTSTREET,
				O.TU_POSTBILD,
				O.TU_POSTFLAT,
				O.TU_ISMAIN,
				O.TU_PHONE,
				O.TU_EMAIL,
		  	 O.TU_DGCod, O.TU_DGKey, null, null, null, null,
			 null, null, null, null, null, null,
			 null, null, null, null, null, null,
			 null, null,
			 null, null, null, null,
			 null, null, null, null, null, null, null
      FROM DELETED O 
  END
  ELSE 
  BEGIN
	SET @sMod = 'UPD'
    DECLARE cur_Turist CURSOR FOR 
      SELECT N.TU_Key, N.TU_ShortName,
			 O.TU_DGCod, O.TU_DGKey, O.TU_NameRus, O.TU_NameLat, O.TU_FNameRus, O.TU_FNameLat,
			 O.TU_SNameRus, O.TU_SNameLat, CONVERT( char(10),O.TU_BirthDay, 104), O.TU_PasportType, O.TU_PasportNum, O.TU_PaspRuSer,
			 O.TU_PaspRuNum, CONVERT( char(10), O.TU_PasportDate, 104), CONVERT( char(10), O.TU_PasportDateEnd, 104), O.TU_PasportByWhoM, CONVERT( char(10), O.TU_PaspRuDate, 104), O.TU_PaspRuByWhoM, 
			 O.TU_Sex, O.TU_RealSex, 
				O.TU_BIRTHCOUNTRY,
				O.TU_BIRTHCITY,
				O.TU_CITIZEN,
				O.TU_POSTINDEX,
				O.TU_POSTCITY,
				O.TU_POSTSTREET,
				O.TU_POSTBILD,
				O.TU_POSTFLAT,
				O.TU_ISMAIN,
				O.TU_PHONE,
				O.TU_EMAIL,
		  	 N.TU_DGCod, N.TU_DGKey, N.TU_NameRus, N.TU_NameLat, N.TU_FNameRus, N.TU_FNameLat, 
			 N.TU_SNameRus, N.TU_SNameLat, CONVERT( char(10),N.TU_BirthDay, 104), N.TU_PasportType, N.TU_PasportNum, N.TU_PaspRuSer,
			 N.TU_PaspRuNum, CONVERT( char(10),N.TU_PasportDate, 104), CONVERT( char(10),N.TU_PasportDateEnd, 104), N.TU_PasportByWhoM, CONVERT( char(10),N.TU_PaspRuDate, 104), N.TU_PaspRuByWhoM,
			 N.TU_Sex, N.TU_RealSex, 
				N.TU_BIRTHCOUNTRY,
				N.TU_BIRTHCITY,
				N.TU_CITIZEN,
				N.TU_POSTINDEX,
				N.TU_POSTCITY,
				N.TU_POSTSTREET,
				N.TU_POSTBILD,
				N.TU_POSTFLAT,
				N.TU_ISMAIN,
				N.TU_PHONE,
				N.TU_EMAIL
      FROM DELETED O, INSERTED N 
      WHERE N.TU_Key = O.TU_Key
  END

  OPEN cur_Turist
    FETCH NEXT FROM cur_Turist INTO @TU_Key, @sTU_ShortName,
				@OTU_DGCod, @OTU_DGKey, @OTU_NameRus, @OTU_NameLat, @OTU_FNameRus, @OTU_FNameLat,
				@OTU_SNameRus, @OTU_SNameLat, @OTU_BirthDay, @OTU_PasportType, @OTU_PasportNum,	@OTU_PaspRuSer,
				@OTU_PaspRuNum, @OTU_PasportDate, @OTU_PasportDateEnd, @OTU_PasportByWhoM, @OTU_PaspRuDate, @OTU_PaspRuByWhoM, 
				@OTU_Sex, @OTU_RealSex, 
				@OTU_BIRTHCOUNTRY,
				@OTU_BIRTHCITY,
				@OTU_CITIZEN,
				@OTU_POSTINDEX,
				@OTU_POSTCITY,
				@OTU_POSTSTREET,
				@OTU_POSTBILD,
				@OTU_POSTFLAT,
				@OTU_ISMAIN,
				@OTU_PHONE,
				@OTU_EMAIL,
				@NTU_DGCod, @NTU_DGKey, @NTU_NameRus, @NTU_NameLat,	@NTU_FNameRus, @NTU_FNameLat,
				@NTU_SNameRus, @NTU_SNameLat, @NTU_BirthDay, @NTU_PasportType, @NTU_PasportNum,	@NTU_PaspRuSer,
				@NTU_PaspRuNum, @NTU_PasportDate, @NTU_PasportDateEnd, @NTU_PasportByWhoM, @NTU_PaspRuDate, @NTU_PaspRuByWhoM,
				@NTU_Sex, @NTU_RealSex,
				@NTU_BIRTHCOUNTRY,
				@NTU_BIRTHCITY,
				@NTU_CITIZEN,
				@NTU_POSTINDEX,
				@NTU_POSTCITY,
				@NTU_POSTSTREET,
				@NTU_POSTBILD,
				@NTU_POSTFLAT,
				@NTU_ISMAIN,
				@NTU_PHONE,
				@NTU_EMAIL
    WHILE @@FETCH_STATUS = 0
    BEGIN 
	  ------------Проверка, надо ли что-то писать в историю-------------------------------------------   
	  If ((((@sMod = 'UPD') AND (@OTU_DGCod = @NTU_DGCod)) OR (@sMod = 'INS') OR (@sMod = 'DEL')) AND
		(
			ISNULL(@OTU_NameRus, '') != ISNULL(@NTU_NameRus, '') OR
			ISNULL(@OTU_NameLat, '') != ISNULL(@NTU_NameLat, '') OR
			ISNULL(@OTU_FNameRus, '') != ISNULL(@NTU_FNameRus, '') OR
			ISNULL(@OTU_FNameLat, '') != ISNULL(@NTU_FNameLat, '') OR
			ISNULL(@OTU_SNameRus, '') != ISNULL(@NTU_SNameRus, '') OR
			ISNULL(@OTU_SNameLat, '') != ISNULL(@NTU_SNameLat, '') OR
			ISNULL(@OTU_BirthDay, 0) != ISNULL(@NTU_BirthDay, 0) OR
			ISNULL(@OTU_PasportType, 0) != ISNULL(@NTU_PasportType, 0) OR
			ISNULL(@OTU_PasportNum, 0) != ISNULL(@NTU_PasportNum, 0) OR
			ISNULL(@OTU_PaspRuSer, 0) != ISNULL(@NTU_PaspRuSer, 0) OR
			ISNULL(@OTU_PaspRuNum, 0) != ISNULL(@NTU_PaspRuNum, 0) OR
			ISNULL(@OTU_PasportDate, 0) != ISNULL(@NTU_PasportDate, 0) OR
			ISNULL(@OTU_PasportDateEnd, 0) != ISNULL(@NTU_PasportDateEnd, 0) OR
			ISNULL(@OTU_PasportByWhoM, 0) != ISNULL(@NTU_PasportByWhoM, 0) OR
			ISNULL(@OTU_PaspRuDate, 0) != ISNULL(@NTU_PaspRuDate, 0) OR
			ISNULL(@OTU_PaspRuByWhoM, 0) != ISNULL(@NTU_PaspRuByWhoM, 0)  OR
			ISNULL(@OTU_Sex, 0) != ISNULL(@NTU_Sex, 0)  OR
			ISNULL(@OTU_RealSex, 0) != ISNULL(@NTU_RealSex, 0) OR
--
			ISNULL(@OTU_BIRTHCOUNTRY, '') != ISNULL(@NTU_BIRTHCOUNTRY, '') OR
			ISNULL(@OTU_BIRTHCITY, '') != ISNULL(@NTU_BIRTHCITY, '') OR
			ISNULL(@OTU_CITIZEN, '') != ISNULL(@NTU_CITIZEN, '') OR
			ISNULL(@OTU_POSTINDEX, '') != ISNULL(@NTU_POSTINDEX, '') OR
			ISNULL(@OTU_POSTCITY, '') != ISNULL(@NTU_POSTCITY, '') OR
			ISNULL(@OTU_POSTSTREET, '') != ISNULL(@NTU_POSTSTREET, '') OR
			ISNULL(@OTU_POSTBILD, '') != ISNULL(@NTU_POSTBILD, '') OR
			ISNULL(@OTU_POSTFLAT, '') != ISNULL(@NTU_POSTFLAT, '') OR
			ISNULL(@OTU_ISMAIN, 0) != ISNULL(@NTU_ISMAIN, 0)
		))
	  BEGIN
	  	------------Запись в историю--------------------------------------------------------------------
		
		SET @nDGKey=@NTU_DGKey
		SET @sHI_Text = ISNULL(@NTU_NameRus, '') + ' ' + ISNULL(@sTU_ShortName, '')
		SET @sDGCod=@NTU_DGCod
		if (@sMod = 'DEL')
		BEGIN
			SET @nDGKey=@OTU_DGKey
			SET @sHI_Text = ISNULL(@OTU_NameRus, '') + ' ' + ISNULL(@sTU_ShortName, '')
			SET @sDGCod=@OTU_DGCod
		END
		EXEC @nHIID = dbo.InsHistory @sDGCod, @nDGKey, 3, @TU_Key, @sMod, @sHI_Text, '', 0, ''
		--SELECT @nHIID = IDENT_CURRENT('History')
		--------Детализация--------------------------------------------------
		if (ISNULL(@OTU_NameRus, '') != ISNULL(@NTU_NameRus, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1051, @OTU_NameRus, @NTU_NameRus, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_NameLat, '') != ISNULL(@NTU_NameLat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1052, @OTU_NameLat, @NTU_NameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_FNameRus, '') != ISNULL(@NTU_FNameRus, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1053, @OTU_FNameRus, @NTU_FNameRus, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_FNameLat, '') != ISNULL(@NTU_FNameLat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1054, @OTU_FNameLat, @NTU_FNameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_SNameRus, '') != ISNULL(@NTU_SNameRus, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1055, @OTU_SNameRus, @NTU_SNameRus, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_SNameLat, '') != ISNULL(@NTU_SNameLat, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1056, @OTU_SNameLat, @NTU_SNameLat, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_BirthDay, 0) != ISNULL(@NTU_BirthDay, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1057, @OTU_BirthDay, @NTU_BirthDay, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportType, '') != ISNULL(@NTU_PasportType, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1058, @OTU_PasportType, @NTU_PasportType, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportNum, '') != ISNULL(@NTU_PasportNum, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1059, @OTU_PasportNum, @NTU_PasportNum, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuSer, '') != ISNULL(@NTU_PaspRuSer, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1060, @OTU_PaspRuSer, @NTU_PaspRuSer, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuNum, '') != ISNULL(@NTU_PaspRuNum, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1061, @OTU_PaspRuNum, @NTU_PaspRuNum, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportDate, 0) != ISNULL(@NTU_PasportDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1062, @OTU_PasportDate, @NTU_PasportDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportDateEnd, 0) != ISNULL(@NTU_PasportDateEnd, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1063, @OTU_PasportDateEnd, @NTU_PasportDateEnd, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PasportByWhoM, '') != ISNULL(@NTU_PasportByWhoM, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1064, @OTU_PasportByWhoM, @NTU_PasportByWhoM, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuDate, 0) != ISNULL(@NTU_PaspRuDate, 0))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1065, @OTU_PaspRuDate, @NTU_PaspRuDate, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_PaspRuByWhoM, '') != ISNULL(@NTU_PaspRuByWhoM, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1066, @OTU_PaspRuByWhoM, @NTU_PaspRuByWhoM, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_Sex, 0) != ISNULL(@NTU_Sex, 0))
			BEGIN
				IF not ((ISNULL(@OTU_Sex, 0) = 1 and ISNULL(@NTU_Sex, 0) = 0) or (ISNULL(@OTU_Sex, 0) = 0 and ISNULL(@NTU_Sex, 0) = 1))
				BEGIN
					IF @sMod != 'INS'
						SELECT @sText_Old = CASE ISNULL(@OTU_Sex, 0)
								WHEN 0 THEN 'Adult'
								WHEN 1 THEN 'Adult'
								WHEN 2 THEN 'Child'
								WHEN 3 THEN 'Infant'
								END
					ELSE
						SET @sText_Old = ''
					IF @sMod != 'DEL'
						SELECT @sText_New = CASE ISNULL(@NTU_Sex, 0)
								WHEN 0 THEN 'Adult'
								WHEN 1 THEN 'Adult'
								WHEN 2 THEN 'Child'
								WHEN 3 THEN 'Infant'
								END
					ELSE
						SET @sText_New = ''
					EXECUTE dbo.InsertHistoryDetail @nHIID , 1067, @sText_Old, @sText_New, @OTU_Sex, @NTU_Sex, null, null, 0, @bNeedCommunicationUpdate output
				END
			END
		if (ISNULL(@OTU_RealSex, 0) != ISNULL(@NTU_RealSex, 0))
		BEGIN
				IF @sMod != 'INS'
					SELECT @sText_Old = CASE ISNULL(@OTU_RealSex, 0)
							WHEN 0 THEN 'Male'
							WHEN 1 THEN 'Female'
							END
				ELSE
					Set @sText_Old = ''
				IF @sMod != 'DEL'
					SELECT @sText_New = CASE ISNULL(@NTU_RealSex, 0)
							WHEN 0 THEN 'Male'
							WHEN 1 THEN 'Female'
							END
				ELSE
					Set	@sText_New = ''
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1068, @sText_Old, @sText_New, @OTU_RealSex, @NTU_RealSex, null, null, 0, @bNeedCommunicationUpdate output
		END

		if (ISNULL(@OTU_BIRTHCOUNTRY, '') != ISNULL(@NTU_BIRTHCOUNTRY, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1126, @OTU_BIRTHCOUNTRY, @NTU_BIRTHCOUNTRY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_BIRTHCITY, '') != ISNULL(@NTU_BIRTHCITY, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1127, @OTU_BIRTHCITY, @NTU_BIRTHCITY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_CITIZEN, '') != ISNULL(@NTU_CITIZEN, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1128, @OTU_CITIZEN, @NTU_CITIZEN, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTINDEX, '') != ISNULL(@NTU_POSTINDEX, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1129, @OTU_POSTINDEX, @NTU_POSTINDEX, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTCITY, '') != ISNULL(@NTU_POSTCITY, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1130, @OTU_POSTCITY, @NTU_POSTCITY, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTSTREET, '') != ISNULL(@NTU_POSTSTREET, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1131, @OTU_POSTSTREET, @NTU_POSTSTREET, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTBILD, '') != ISNULL(@NTU_POSTBILD, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1132, @OTU_POSTBILD, @NTU_POSTBILD, null, null, null, null, 0, @bNeedCommunicationUpdate output
		if (ISNULL(@OTU_POSTFLAT, '') != ISNULL(@NTU_POSTFLAT, ''))
			EXECUTE dbo.InsertHistoryDetail @nHIID , 1133, @OTU_POSTFLAT, @NTU_POSTFLAT, null, null, null, null, 0, @bNeedCommunicationUpdate output
		-- 
		DECLARE @PrivatePerson int;
		DECLARE @NewMainTourist int;
		DECLARE @HaveMainMan int, @MainManSex int;
		DECLARE @Name varchar(35),
			@FName varchar(15),
			@SName varchar(15),
			@Phone varchar(60),
			@Email varchar(50),
			@PostIndex varchar(8),
			@PostCity varchar(60),
			@PostStreet varchar(25),
			@PostBuilding varchar(10),
			@PostFlat varchar(4),
			@PassportSeries varchar(10),
			@PassportNumber varchar(10);
		------- CRM02174G8K3 28.06.2012 kolbeshkin: будем проверять DG_DUPUSERKEY, если он уже проставлен, то покупателя не меняем,
		-- иначе в покупателе представитель партнера (DupUser) затрется главным туристом
		-- 9146 neupokoev 01.11.2012 Убрал проверку DG_DUPUSERKEY, потому что иначе при пронировании из веба в качестве dg_mainman
		-- вне зависимости от настройки SYSDGMainManRule всегда будет представитель партнера, а это дело регулируется из мт
		-------
		IF (@sMod = 'UPD')
		BEGIN
			IF ISNULL(@OTU_ISMAIN, 0) != ISNULL(@NTU_ISMAIN, 0)
			BEGIN
				IF(ISNULL(@NTU_ISMAIN,0) >= 1)
					BEGIN
						UPDATE [dbo].[TBL_TURIST]
						SET TU_ISMAIN = 0
						WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @NTU_DGCod;
						
						UPDATE [dbo].[TBL_TURIST]
						SET TU_ISMAIN = 1
						WHERE TU_KEY = @TU_Key
						 
						EXEC @PrivatePerson = dbo.CheckPrivatePerson @NTU_DGCOD;
						IF(@PrivatePerson = 1)
							BEGIN
								EXEC [dbo].[UpdateReservationMainManByTourist] @NTU_NAMERUS, @NTU_FNAMERUS, @NTU_SNAMERUS, @NTU_PHONE, @NTU_EMAIL
																			 , @NTU_POSTINDEX, @NTU_POSTCITY, @NTU_POSTSTREET
																			 , @NTU_POSTBILD, @NTU_POSTFLAT, @NTU_PASPRUSER
																			 , @NTU_PASPRUNUM, @NTU_DGCOD;
							END
					END
				ELSE
					BEGIN
						SELECT @HaveMainMan = TU_KEY, @MainManSex = TU_SEX
							FROM [dbo].[TBL_TURIST]
							WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @NTU_DGCOD AND TU_ISMAIN = 1
						IF @HaveMainMan IS NULL
							BEGIN
								SELECT @NewMainTourist = TU_KEY 
								FROM [dbo].[TBL_TURIST]
								WHERE TU_KEY <> @TU_Key AND TU_SEX < 2 AND TU_DGCOD = @NTU_DGCOD;
								IF(@NewMainTourist IS NULL)
									BEGIN
										SELECT @NewMainTourist = TU_KEY 
										FROM [dbo].[TBL_TURIST]
										WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @NTU_DGCOD;
									END
								IF(@NewMainTourist IS NOT NULL)
									BEGIN
										UPDATE [dbo].[TBL_TURIST]
										SET TU_ISMAIN = 0
										WHERE TU_KEY <> @NewMainTourist AND TU_DGCOD = @NTU_DGCod;
									
										UPDATE [dbo].[TBL_TURIST]
										SET TU_ISMAIN = 1
										WHERE TU_KEY = @NewMainTourist;
										
										EXEC @PrivatePerson = dbo.CheckPrivatePerson @OTU_DGCOD;
										IF(@PrivatePerson = 1)
										BEGIN
											SELECT @Name = TU_NAMERUS, @FName = TU_FNAMERUS, @SName = TU_SNAMERUS, @Phone = TU_PHONE, @Email=TU_EMAIL
											, @PostIndex = TU_POSTINDEX, @PostCity = TU_POSTCITY, @PostStreet = TU_POSTSTREET
											, @PostBuilding = TU_POSTBILD, @PostFlat = TU_POSTFLAT, @PassportSeries = TU_PASPRUSER
											, @PassportNumber = TU_PASPRUNUM
											FROM [dbo].[tbl_turist]
											WHERE TU_KEY = @NewMainTourist;
											EXEC [dbo].[UpdateReservationMainManByTourist] @Name, @FName, @SName, @Phone, @Email
																				 , @PostIndex, @PostCity, @PostStreet
																				 , @PostBuilding, @PostFlat, @PassportSeries
																				 , @PassportNumber, @OTU_DGCOD;
										END
									END
							END	
					END
			END	
		END
		ELSE IF (@sMod = 'DEL')
		BEGIN
			DECLARE @MainTouristExists int;
			SELECT @MainTouristExists = TU_KEY 
			  FROM [dbo].[TBL_TURIST]
			 WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @OTU_DGCOD AND TU_ISMAIN = 1;
		
			IF @MainTouristExists IS NULL
				BEGIN
					SELECT @NewMainTourist = TU_KEY 
					  FROM [dbo].[TBL_TURIST]
					 WHERE TU_KEY <> @TU_Key AND TU_SEX < 2 AND TU_DGCOD = @OTU_DGCOD;
					IF(@NewMainTourist IS NULL)
					BEGIN
						SELECT @NewMainTourist = TU_KEY 
						  FROM [dbo].[TBL_TURIST]
						 WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @OTU_DGCOD;
					END
					IF(@NewMainTourist IS NOT NULL)
					BEGIN
						UPDATE [dbo].[TBL_TURIST]
						   SET TU_ISMAIN = 1
						 WHERE TU_KEY = @NewMainTourist;
							EXEC @PrivatePerson = dbo.CheckPrivatePerson @OTU_DGCOD;
							IF(@PrivatePerson = 1)
							BEGIN
								SELECT @Name = TU_NAMERUS, @FName = TU_FNAMERUS, @SName = TU_SNAMERUS, @Phone = TU_PHONE, @Email=TU_EMAIL
									 , @PostIndex = TU_POSTINDEX, @PostCity = TU_POSTCITY, @PostStreet = TU_POSTSTREET
									 , @PostBuilding = TU_POSTBILD, @PostFlat = TU_POSTFLAT, @PassportSeries = TU_PASPRUSER
									 , @PassportNumber = TU_PASPRUNUM
								  FROM [dbo].[tbl_turist]
								 WHERE TU_KEY = @NewMainTourist;
								EXEC [dbo].[UpdateReservationMainManByTourist] @Name, @FName, @SName, @Phone, @Email
																			 , @PostIndex, @PostCity, @PostStreet
																			 , @PostBuilding, @PostFlat, @PassportSeries
																			 , @PassportNumber, @OTU_DGCOD;
							END
							ELSE
							BEGIN
								EXEC [dbo].[UpdateReservationMainMan] '','','','','',@OTU_DGCOD;
							END
						END
				END	
			END	
		ELSE IF(@sMod = 'INS')
		BEGIN
			SELECT @HaveMainMan = TU_KEY, @MainManSex = TU_SEX
			  FROM [dbo].[TBL_TURIST]
			 WHERE TU_KEY <> @TU_Key AND TU_DGCOD = @NTU_DGCOD AND TU_ISMAIN = 1
			IF(@HaveMainMan IS NULL OR ((ISNULL(@MainManSex,0) >= 2) AND ISNULL(@NTU_SEX,99) < 2 AND ISNULL(@NTU_ISMAIN,0) = 1))
			BEGIN
				IF(@HaveMainMan IS NULL)
				BEGIN
					UPDATE [dbo].[TBL_TURIST]
					   SET TU_ISMAIN = 1
					 WHERE TU_KEY = @TU_Key;
				END
				ELSE
				BEGIN
					UPDATE [dbo].[TBL_TURIST]
					   SET TU_ISMAIN = 0
					 WHERE TU_KEY = @HaveMainMan;
				END				
					EXEC @PrivatePerson = dbo.CheckPrivatePerson @NTU_DGCOD;
					IF(@PrivatePerson = 1)
					BEGIN
						EXEC [dbo].[UpdateReservationMainManByTourist] @NTU_NAMERUS, @NTU_FNAMERUS, @NTU_SNAMERUS, @NTU_PHONE, @NTU_EMAIL
																	 , @NTU_POSTINDEX, @NTU_POSTCITY, @NTU_POSTSTREET
																	 , @NTU_POSTBILD, @NTU_POSTFLAT, @NTU_PASPRUSER
																	 , @NTU_PASPRUNUM, @NTU_DGCOD;
					END
				END		
			ELSE IF(@HaveMainMan IS NOT NULL AND ISNULL(@NTU_ISMAIN,0) = 1)
			BEGIN
				UPDATE [dbo].[TBL_TURIST]
				   SET TU_ISMAIN = 0
				 WHERE TU_KEY = @HaveMainMan; 
				
					EXEC @PrivatePerson = dbo.CheckPrivatePerson @NTU_DGCOD;
					IF(@PrivatePerson = 1)
					BEGIN
						EXEC [dbo].[UpdateReservationMainManByTourist] @NTU_NAMERUS, @NTU_FNAMERUS, @NTU_SNAMERUS, @NTU_PHONE, @NTU_EMAIL
																	 , @NTU_POSTINDEX, @NTU_POSTCITY, @NTU_POSTSTREET
																	 , @NTU_POSTBILD, @NTU_POSTFLAT, @NTU_PASPRUSER
																	 , @NTU_PASPRUNUM, @NTU_DGCOD; 
				END
			END
		END
		
		If @bNeedCommunicationUpdate=1
			If exists (SELECT 1 FROM Communications WHERE CM_DGKey=@nDGKey)
				UPDATE Communications SET CM_ChangeDate=GetDate() WHERE CM_DGKey=@nDGKey

	  ------------------------------------------------------------------------------------------------
	  END
    FETCH NEXT FROM cur_Turist INTO @TU_Key, @sTU_ShortName,
				@OTU_DGCod, @OTU_DGKey, @OTU_NameRus, @OTU_NameLat, @OTU_FNameRus, @OTU_FNameLat,
				@OTU_SNameRus, @OTU_SNameLat, @OTU_BirthDay, @OTU_PasportType, @OTU_PasportNum,	@OTU_PaspRuSer,
				@OTU_PaspRuNum, @OTU_PasportDate, @OTU_PasportDateEnd, @OTU_PasportByWhoM, @OTU_PaspRuDate, @OTU_PaspRuByWhoM, 
				@OTU_Sex, @OTU_RealSex, 
				@OTU_BIRTHCOUNTRY,
				@OTU_BIRTHCITY,
				@OTU_CITIZEN,
				@OTU_POSTINDEX,
				@OTU_POSTCITY,
				@OTU_POSTSTREET,
				@OTU_POSTBILD,
				@OTU_POSTFLAT,
				@OTU_ISMAIN,
				@OTU_PHONE,
				@OTU_EMAIL,
				@NTU_DGCod, @NTU_DGKey, @NTU_NameRus, @NTU_NameLat,	@NTU_FNameRus, @NTU_FNameLat,
				@NTU_SNameRus, @NTU_SNameLat, @NTU_BirthDay, @NTU_PasportType, @NTU_PasportNum,	@NTU_PaspRuSer,
				@NTU_PaspRuNum, @NTU_PasportDate, @NTU_PasportDateEnd, @NTU_PasportByWhoM, @NTU_PaspRuDate, @NTU_PaspRuByWhoM,
				@NTU_Sex, @NTU_RealSex,
				@NTU_BIRTHCOUNTRY,
				@NTU_BIRTHCITY,
				@NTU_CITIZEN,
				@NTU_POSTINDEX,
				@NTU_POSTCITY,
				@NTU_POSTSTREET,
				@NTU_POSTBILD,
				@NTU_POSTFLAT,
				@NTU_ISMAIN,
				@NTU_PHONE,
				@NTU_EMAIL
    END
  CLOSE cur_Turist
  DEALLOCATE cur_Turist
END

GO




/*********************************************************************/
/* end T_TuristUpdate.sql */
/*********************************************************************/

/*********************************************************************/
/* begin T_UpdDogListQuota.sql */
/*********************************************************************/
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[T_UpdDogListQuota]'))
	DROP TRIGGER [dbo].[T_UpdDogListQuota]
GO

CREATE TRIGGER [dbo].[T_UpdDogListQuota] 
ON [dbo].[tbl_DogovorList]
AFTER INSERT, UPDATE, DELETE
AS
--<VERSION>2009.2.19.2</VERSION>
--<DATE>2013-08-30</DATE>

-- тип триггера (DEL - удаление, INS - вставка, UPD - обновление)
-- если включена настройка то выходим, рассадка теперь работает по другому
IF (EXISTS (SELECT TOP 1 1
		    FROM SystemSettings WITH (NOLOCK)
		    WHERE SS_ParmName = 'NewSetToQuota' AND SS_ParmValue = 1))
BEGIN
	RETURN;
END


DECLARE @DLKey int, @DGKey int, @O_DLSVKey int, @O_DLCode int, @O_DLSubcode1 int, @O_DLDateBeg datetime, @O_DLDateEnd datetime, @O_DLNMen int, @O_DLPartnerKey int, @O_DLControl int, 
		@N_DLSVKey int, @N_DLCode int, @N_DLSubcode1 int, @N_DLDateBeg datetime, @N_DLDateEnd datetime, @N_DLNMen int, @N_DLPartnerKey int, @N_DLControl int,
		@Date datetime, @RLID int, @RPID int,
		@HRIsMain smallint, @RMKey int, @RCKey int, @ACKey int,
		@RMPlacesMain smallint, @RMPlacesEx smallint,
		@ACPlacesMain smallint, @ACPlacesEx smallint, @ACPerRoom smallint,
		@RLPlacesMain smallint, @RLPlacesEx smallint, @RLCount smallint, 
		@AC_FreeMainPlacesCount smallint, @AC_FreeExPlacesCount smallint,
		@RL_Use smallint, @From int, --@SDPlace smallint, 
		@nDelCount smallint, @nInsCount smallint, @Mod varchar(3), @SetToNewQuota bit,
		@CurrentPlaceIsEx bit, @RL_FreeMainPlacesCount smallint, @RL_FreeExPlacesCount smallint,
		@Days smallint, @RPCount smallint, @NeedPlacesForMen smallint, @TUKey int,
		@SVQUOTED smallint

-- количество удаляемых записей
SELECT @nDelCount = COUNT(*)
FROM DELETED
-- количество вставляемых записей
SELECT @nInsCount = COUNT(*)
FROM INSERTED
SET @SetToNewQuota = 0
IF (@nInsCount = 0) -- если нет удаляемых записей, значит есть только вставляемые записи
BEGIN
    DECLARE cur_DogovorListChanged2 CURSOR 
    FOR 
    SELECT O.DL_Key, O.DL_DGKey, O.DL_SvKey, O.DL_Code, O.DL_SubCode1, O.DL_DateBeg, O.DL_DateEnd, O.DL_NMen, O.DL_PartnerKey, 
    		O.DL_Control, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
    FROM DELETED O
	SET @Mod = 'DEL'
END
ELSE IF (@nDelCount = 0) -- если нет вставляемых записей, есть только удаляемые записи
BEGIN
    DECLARE cur_DogovorListChanged2 CURSOR FOR 
    SELECT 	N.DL_Key, N.DL_DGKey,
			null, null, null, null, null, null, null, null,
			N.DL_SvKey, N.DL_Code, N.DL_SubCode1, N.DL_DateBeg, N.DL_DateEnd, N.DL_NMen, N.DL_PartnerKey, N.DL_Control
    FROM	INSERTED N 
	SET @Mod = 'INS'
END
ELSE -- если есть и удаляемые и вставляемые записи
BEGIN
    DECLARE cur_DogovorListChanged2 CURSOR FOR 
    SELECT 	N.DL_Key, N.DL_DGKey, 
			O.DL_SvKey, O.DL_Code, O.DL_SubCode1, O.DL_DateBeg, O.DL_DateEnd, O.DL_NMen, O.DL_PartnerKey, O.DL_Control, 
			N.DL_SvKey, N.DL_Code, N.DL_SubCode1, N.DL_DateBeg, N.DL_DateEnd, N.DL_NMen, N.DL_PartnerKey, N.DL_Control
    FROM DELETED O, INSERTED N 
    WHERE N.DL_Key = O.DL_Key
	SET @Mod = 'UPD'
END

OPEN cur_DogovorListChanged2
FETCH NEXT 
FROM cur_DogovorListChanged2 
INTO @DLKey, @DGKey, @O_DLSVKey, @O_DLCode, @O_DLSubCode1, @O_DLDateBeg, @O_DLDateEnd, @O_DLNMen, @O_DLPartnerKey, @O_DLControl, 
	@N_DLSVKey, @N_DLCode, @N_DLSubCode1, @N_DLDateBeg, @N_DLDateEnd, @N_DLNMen, @N_DLPartnerKey, @N_DLControl
WHILE @@FETCH_STATUS = 0
BEGIN
	--18-10-2012 saifullina
	--при удалении услуги в путевке или аннулировании путевки -> удаляем путевку -> высвобождаем квоты
	IF (@N_DLDateBeg < '01-01-1901' AND @O_DLDateBeg >= '01-01-1901')
	BEGIN
		SET @Mod = 'DEL'
	END
	IF (@Mod = 'DEL'
		OR (@Mod = 'UPD' AND (ISNULL(@O_DLSVKey, 0) != ISNULL(@N_DLSVKey, 0))
			OR (ISNULL(@O_DLCode, 0) != ISNULL(@N_DLCode, 0))
			OR (ISNULL(@O_DLSubCode1, 0) != ISNULL(@N_DLSubCode1, 0))
			OR (ISNULL(@O_DLPartnerKey, 0) != ISNULL(@N_DLPartnerKey, 0))
			OR (ISNULL(@O_DLDateBeg, 0) != ISNULL(@N_DLDateBeg, 0))
			OR (ISNULL(@O_DLDateEnd, 0) != ISNULL(@N_DLDateEnd, 0))))
	BEGIN	
		DELETE
		FROM ServiceByDate
		WHERE SD_DLKey = @DLKey

		SET @SetToNewQuota = 1
	END
		
	SELECT @SVQUOTED = ISNULL(SV_Quoted, 0)
	FROM [Service]
	WHERE SV_KEY = @N_DLSVKey

	EXEC InsMasterEvent 3, @DLKey

	IF ((@O_DLSVKey IN (3, 7)
	    AND (@N_DLCode != @O_DLCode
	        OR @N_DLSubCode1 != @O_DLSubCode1
	        OR @O_DLDateBeg != @N_DLDateBeg
	        OR @O_DLDateEnd != @N_DLDateEnd))
		OR (@O_DLSVKey IN (1, 2, 4) 
		    AND @O_DLDateBeg != @N_DLDateBeg))
	BEGIN
		UPDATE TuristService
		SET TU_NUMROOM = ''
		WHERE TU_DLKEY = @DLKey
	END

	IF (@N_DLDateBeg < '01-JAN-1901' AND @O_DLDateBeg >= '01-JAN-1901')
	BEGIN
		SET @Mod = 'DEL'
	END

	IF (@N_DLDateBeg > '01-JAN-1901' AND @O_DLDateBeg <= '01-JAN-1901')
	BEGIN
		SET @SetToNewQuota = 1
	END

	IF (@Mod = 'UPD' AND ISNULL(@O_DLNMen, 0) = 0 AND ISNULL(@N_DLNMen, 0) > 0)
	BEGIN
		SET @Mod = 'INS'
	END
	-- если ВЫКЛЮЧЕНА настройка то запускаем всю эту дребедень, это старая рассадка в квоту
	-- ИЛИ произошла ошибка при посадке новым сервисом, то запускаем старую рассадку и проверку
	if (exists (select top 1 1 from SystemSettings where SS_ParmName = 'NewSetToQuota' and SS_ParmValue = 0))
	BEGIN
		print 'Старая рассадка'
		--изменился период действия услуги
		IF @Mod = 'UPD' 
			and (
				@SetToNewQuota!=1 
				and (
					(@O_DLDateBeg != @N_DLDateBeg) 
					or (@O_DLDateEnd != @N_DLDateEnd)
					)
				)
		BEGIN
			IF (@N_DLDateBeg > @O_DLDateEnd OR @N_DLDateEnd < @O_DLDateBeg)
			BEGIN
				DELETE
				FROM ServiceByDate
				WHERE SD_DLKey = @DLKey
				SET @SetToNewQuota=1
			END
			-- для услуг имеющих продолжительность сохраняем информацию о квотировании в рамках периода
			ELSE
			BEGIN
				--если теперь услуга заканчивается раньше, чем до этого начиналась
				IF (@N_DLDateBeg < @O_DLDateBeg)
				BEGIN
					IF (@N_DLDateEnd < @O_DLDateBeg)
					BEGIN
						SET @Days = DATEDIFF(DAY, @N_DLDateBeg, @N_DLDateEnd) + 1
					END
					ELSE
					BEGIN
						SET @Days = DATEDIFF(DAY, @N_DLDateBeg, @O_DLDateBeg)
					END
						
					INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, SD_State)
					SELECT DATEADD(DAY,NU_ID-1,@N_DLDateBeg), SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, @SVQUOTED + 3 
					FROM ServiceByDate, Numbers
					WHERE (NU_ID BETWEEN 1 AND @Days) AND SD_Date = @O_DLDateBeg AND SD_DLKey = @DLKey
				END
				
				--если теперь услуга начинается позже, чем до этого заканчивалась
				IF (@N_DLDateEnd > @O_DLDateEnd)
				BEGIN
					IF (@N_DLDateBeg > @O_DLDateEnd)
					BEGIN
						SET @Days = DATEDIFF(DAY, @N_DLDateBeg, @N_DLDateEnd) + 1
					END
					ELSE
					BEGIN
						SET @Days = DATEDIFF(DAY, @O_DLDateEnd, @N_DLDateEnd)
					END
						
					INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, SD_State)
					SELECT DATEADD(DAY, - NU_ID + 1, @N_DLDateEnd), SD_DLKey, SD_RLID, SD_TUKey, SD_RPID, @SVQUOTED + 3
					FROM ServiceByDate, Numbers
					WHERE (NU_ID BETWEEN 1 AND @Days) AND SD_Date = @O_DLDateEnd AND SD_DLKey = @DLKey
				END
				
				
				IF (@N_DLDateBeg > @O_DLDateBeg)
				BEGIN
					DELETE
					FROM ServiceByDate
					WHERE SD_DLKey = @DLKey AND SD_Date < @N_DLDateBeg
				END
				IF (@N_DLDateEnd < @O_DLDateEnd)
				BEGIN
					DELETE
					FROM ServiceByDate
					WHERE SD_DLKey = @DLKey AND SD_Date > @N_DLDateEnd
				END
			END
			
			-- если эта услуга на продолжительность
			-- и если услуга сидела на квоте с продолжительностью
			IF (EXISTS (SELECT 1
			            FROM [Service]
			            WHERE SV_KEY = @N_DLSVKey AND ISNULL(SV_ISDURATION, 0) = 1)
			    AND EXISTS (
			        SELECT 1
			        FROM ServiceByDate
			        WHERE SD_DLKey = @DLKey
			        AND EXISTS (
			            SELECT 1
			            FROM QuotaParts
			            WHERE QP_ID = SD_QPID AND QP_Durations IS NOT NULL)))
			BEGIN
				-- пересаживаем всю услугу
				EXEC DogListToQuotas @DLKey, NULL, NULL, NULL, NULL, @N_DLDateBeg, @N_DLDateEnd, NULL, NULL, @OldSetToQuota = 1
			END
		END
		SET @NeedPlacesForMen=0
		SET @From = CAST(@N_DLDateBeg as int)		
		-- если изменилось количество человек		
		IF @Mod = 'UPD' AND (@SetToNewQuota != 1 AND ISNULL(@O_DLNMen, 0) != ISNULL(@N_DLNMen, 0))
		BEGIN
		
			select *, 0 as xSD_STATE
			into #ServiceByDate
			from ServiceByDate
			where SD_DLKey = @DLKey
			
			SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)-ISNULL(@O_DLNMen,0)

			-- если новое число туристов меньше, чем было до этого (@O_DLNMen > @N_DLNMen)
			if ISNULL(@O_DLNMen,0) > ISNULL(@N_DLNMen,0)
			BEGIN
				while (SELECT count(1) FROM #ServiceByDate WHERE SD_DLKey=@DLKey and SD_Date=@N_DLDateBeg) > ISNULL(@N_DLNMen,0)
				BEGIN
					if @N_DLSVKey = 3 --для проживания отдельная ветка
					BEGIN					
						SELECT TOP 1 @RLID = SD_RLID, @RPCount = count(SD_ID) FROM #ServiceByDate WHERE SD_DLKey = @DLKey and SD_TUKey is null and SD_Date = @N_DLDateBeg
						GROUP BY SD_RLID
						ORDER BY 2
						
						SELECT TOP 1 @RPID = SD_RPID FROM #ServiceByDate WHERE SD_DLKey = @DLKey and SD_RLID = @RLID and SD_TUKey is null
						DELETE FROM #ServiceByDate WHERE SD_DLKey = @DLKey and SD_RLID = @RLID and ISNULL(SD_RPID,0) = ISNULL(@RPID,0) and SD_TUKey is null
					END
					ELSE
					BEGIN
						--обязательно!!! NULL туриста вперед 
						SELECT TOP 1 @RPID = SD_RPID FROM #ServiceByDate WHERE SD_DLKey = @DLKey order by SD_TUKey
						DELETE FROM #ServiceByDate WHERE SD_DLKey = @DLKey and ISNULL(SD_RPID,0) = ISNULL(@RPID,0)
					END
				END
				
				delete from ServiceByDate where SD_DLKey = @DLKey and SD_ID not in (select x.SD_ID from #ServiceByDate as x)
			END
			-- если новое число туристов больше, чем было до этого (@O_DLNMen < @N_DLNMen)
			ELSE
			BEGIN
				if @N_DLSVKey=3 --для проживания отдельная ветка
				BEGIN				
					SELECT	@HRIsMain=AC_MAIN, @ACPlacesMain=ISNULL(AC_NRealPlaces,0), @ACPlacesEx=ISNULL(AC_NMenExBed,0), @ACPerRoom=ISNULL(AC_PerRoom,0)
					FROM AccmdMenType
					WHERE AC_Key=(SELECT HR_ACKey From HotelRooms WHERE HR_Key=@N_DLSubCode1)
					IF @HRIsMain = 1 and @ACPlacesMain = 0 and @ACPlacesEx = 0
						set @ACPlacesMain = 1
					ELSE IF @HRIsMain = 0 and @ACPlacesMain = 0 and @ACPlacesEx = 0
						set @ACPlacesEx = 1
					--есть 3 варианта размещения: только основные, только дополнительные, основные и дополнительные
					--в первых 2-х вариантах сначала занимаем свободные уже существующие места данного типа в номерах этой услуги, в последнем занимаем все свободные места
					if @ACPlacesMain>0
						WHILE (@NeedPlacesForMen>0 and EXISTS(select RP_ID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_Type=0))
						BEGIN
							select TOP 1 @RPID=RP_ID,@RLID=RP_RLID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_Type=0
							INSERT INTO #ServiceByDate (xSD_STATE, SD_Date, SD_DLKey, SD_RLID, SD_RPID, SD_State)	
								SELECT 1, CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RLID, @RPID, 4
								FROM NUMBERS as N1 WHERE N1.NU_ID between 1 and CAST(@N_DLDateEnd as int)-@From+1
							SET @NeedPlacesForMen=@NeedPlacesForMen-1
						END
					if @ACPlacesEx>0
						WHILE (@NeedPlacesForMen>0 and EXISTS(select RP_ID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_Type=1))
						BEGIN
							select TOP 1 @RPID=RP_ID,@RLID=RP_RLID FROM RoomPlaces where RP_RLID in (SELECT SD_RLID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_ID not in (SELECT SD_RPID FROM #ServicebyDate where SD_DLKey=@DLKey) and RP_Type=1
							INSERT INTO #ServiceByDate (xSD_STATE, SD_Date, SD_DLKey, SD_RLID, SD_RPID, SD_State)	
								SELECT 1, CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RLID, @RPID, 4
								FROM NUMBERS as N1 WHERE N1.NU_ID between 1 and CAST(@N_DLDateEnd as int)-@From+1
							SET @NeedPlacesForMen=@NeedPlacesForMen-1
						END
				END
				
				insert into ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_QPID, SD_TUKey, SD_RPID, SD_State)
				select x.SD_Date, x.SD_DLKey, x.SD_RLID, x.SD_QPID, x.SD_TUKey, x.SD_RPID, x.SD_State
				from #ServiceByDate as x
				where x.xSD_STATE = 1
				
			END
			
			drop table #ServiceByDate
		END

		IF @Mod = 'INS'
			OR (@Mod = 'UPD' AND @SetToNewQuota = 1)
			OR @NeedPlacesForMen > 0
		BEGIN		
			-- для проживания отдельная ветка
			IF @N_DLSVKey = 3
			BEGIN
				If @NeedPlacesForMen>0
				BEGIN
				SELECT TOP 1 @RLPlacesMain = RL_NPlaces, @RLPlacesEx = RL_NPlacesEx, @RMKey = RL_RMKey, @RCKey = RL_RCKey
				FROM RoomNumberLists, ServiceByDate
				WHERE RL_ID = SD_RLID
					AND SD_DLKey = @DLKey
				END
				ELSE
				BEGIN
					SELECT @HRIsMain = HR_MAIN, @RMKey = HR_RMKEY, @RCKey = HR_RCKEY, @ACKey = HR_ACKEY, @RMPlacesMain = RM_NPlaces, 
					@RMPlacesEx = RM_NPlacesEx, @ACPlacesMain = ISNULL(AC_NRealPlaces, 0), @ACPlacesEx = ISNULL(AC_NMenExBed, 0), 
					@ACPerRoom = ISNULL(AC_PerRoom, 0)
					FROM HotelRooms, Rooms, AccmdMenType
					WHERE HR_Key = @N_DLSubcode1
						AND RM_Key = HR_RMKEY
						AND AC_KEY = HR_ACKEY
					IF @ACPerRoom = 1
						OR (
							ISNULL(@RMPlacesMain, 0) = 0
							AND ISNULL(@RMPlacesEx, 0) = 0
							)
					BEGIN
						SET @RLPlacesMain = @ACPlacesMain
						SET @RLPlacesEx = ISNULL(@ACPlacesEx,0)
					END
					ELSE
					BEGIN
						IF @HRIsMain = 1
							AND @ACPlacesMain = 0
							AND @ACPlacesEx = 0
						BEGIN
							SET @ACPlacesMain = 1
						END
						ELSE IF @HRIsMain = 0
							AND @ACPlacesMain = 0
							AND @ACPlacesEx = 0
						BEGIN
							SET @ACPlacesEx = 1
						END

						SET @RLPlacesMain = @RMPlacesMain
						SET @RLPlacesEx = ISNULL(@RMPlacesEx, 0)
					END

					-- если услуга полностью ставится на квоту (из-за глобальных изменений (было удаление из ServiceByDate))
					IF @Mod = 'UPD'
						AND @SetToNewQuota = 1
					BEGIN
						SET @NeedPlacesForMen = ISNULL(@N_DLNMen, 0)
					END
					ELSE
					BEGIN
						SET @NeedPlacesForMen = ISNULL(@N_DLNMen, 0) - ISNULL(@O_DLNMen, 0)
					END
				END
				
				SET @RLID = 0
				SET @AC_FreeMainPlacesCount = 0
				SET @AC_FreeExPlacesCount = 0
				SET @RL_FreeMainPlacesCount = 0
				SET @RL_FreeExPlacesCount = 0
				-- пока не распределили всех человек
				WHILE (@NeedPlacesForMen>0)
				BEGIN
					--если в последнем номере кончились места, то выставляем признак @RLID = 0
					IF @AC_FreeMainPlacesCount = 0
						AND @AC_FreeExPlacesCount = 0
					BEGIN
						SET @AC_FreeMainPlacesCount = @ACPlacesMain
						SET @AC_FreeExPlacesCount = @ACPlacesEx
						--создаем новый номер, всегда когда есть хоть кто-то на основном месте ???
						IF (@AC_FreeMainPlacesCount > @RL_FreeMainPlacesCount)
							OR (@AC_FreeExPlacesCount > @RL_FreeExPlacesCount)
						BEGIN
							--создаем новый номер для каждой услуги, если размещение на номер.
							IF @ACPerRoom>0
							BEGIN			
								INSERT INTO RoomNumberLists (RL_NPlaces, RL_NPlacesEx, RL_RMKey, RL_RCKey
									)
								VALUES (@RLPlacesMain, @RLPlacesEx, @RMKey, @RCKey)

								SET @RLID = SCOPE_IDENTITY()

								INSERT INTO RoomPlaces (RP_RLID, RP_Type)
								SELECT @RLID, CASE 
										WHEN NU_ID > @RLPlacesMain
											THEN 1
										ELSE 0
										END
								FROM NUMBERS
								WHERE NU_ID BETWEEN 1
										AND (@RLPlacesMain + @RLPlacesEx)
								set @RPID=SCOPE_IDENTITY()-@RLPlacesMain-@RLPlacesEx+1
								SET @RL_FreeMainPlacesCount = @RLPlacesMain
								SET @RL_FreeExPlacesCount = @RLPlacesEx
							END
							ELSE
							BEGIN
								-- ищем к кому подселиться в данной путевке, если не находим, то прийдется создавать новый номер
								set @RPID = null
								SELECT TOP 1 @RPID = RP_ID, @RLID = RP_RLID
								FROM RoomPlaces
								WHERE RP_Type = CASE 
										WHEN @ACPlacesMain > 0
											THEN 0
										ELSE 1
										END
									AND RP_RLID IN (
										SELECT SD_RLID
										FROM ServiceByDate, DogovorList, RoomNumberLists
										WHERE SD_DLKey = DL_Key
											AND DL_DGKey = @DGKey
											AND RL_ID = SD_RLID
											AND DL_SVKey = @N_DLSVKey
											AND DL_Code = @N_DLCode
											AND DL_DateBeg = @N_DLDateBeg
											AND DL_DateEnd = @N_DLDateEnd
											AND RL_RMKey = @RMKey
											AND RL_RCKey = @RCKey
										)
									AND NOT EXISTS (
										SELECT SD_RPID
										FROM ServiceByDate
										WHERE SD_RLID = RP_RLID
											AND SD_RPID = RP_ID
										)
								ORDER BY RP_ID
								-- надо создавать новый номер даже для дополнительного размещения
								IF @RPID IS NULL
								BEGIN
									INSERT INTO RoomNumberLists (RL_NPlaces, RL_NPlacesEx, RL_RMKey, RL_RCKey)
									VALUES (@RLPlacesMain, @RLPlacesEx, @RMKey, @RCKey)

									SET @RLID = SCOPE_IDENTITY()

									INSERT INTO RoomPlaces (RP_RLID, RP_Type)
									SELECT @RLID, CASE 
											WHEN NU_ID > @RLPlacesMain
												THEN 1
											ELSE 0
											END
									FROM NUMBERS
									WHERE NU_ID BETWEEN 1
											AND (@RLPlacesMain + @RLPlacesEx)

									SET @RPID = SCOPE_IDENTITY()
									-- Task 9853 29.11.2012 kolbeshkin: неправильное расселение при бронировании
									-- неправильно вычислять место как последнее созданное минус кол-во основных и доп мест + 1,
									-- лучше взять первое свободное место в комнате с ID = @RLID
									SET @RPID = (
									    SELECT MIN(rp_id)
										FROM RoomPlaces
										WHERE RP_RLID = @RLID
										    AND NOT EXISTS (
											    SELECT 1
												FROM ServiceByDate
												WHERE SD_RLID = @RLID
												    AND SD_RPID = RP_ID))
									SET @RL_FreeMainPlacesCount = @RLPlacesMain
									SET @RL_FreeExPlacesCount = @RLPlacesEx
								END
							END
						END
					END
					
					-- смотрим есть ли в текущем номере свободные основные места
					IF @AC_FreeMainPlacesCount > 0
					BEGIN
						SET @AC_FreeMainPlacesCount = @AC_FreeMainPlacesCount - 1
						SET @RL_FreeMainPlacesCount = @RL_FreeMainPlacesCount - 1
						SET @CurrentPlaceIsEx=0
					END
					--если ОСНОВНЫХ мест в номере уже нет, то может посадим на ДОПОЛНИТЕЛЬНОЕ? 
					ELSE
						IF @AC_FreeExPlacesCount > 0
						BEGIN
							SET @AC_FreeExPlacesCount = @AC_FreeExPlacesCount - 1
							SET @RL_FreeExPlacesCount = @RL_FreeExPlacesCount - 1
							SET @CurrentPlaceIsEx=1
						END

					SET @TUKey = NULL

					SELECT @TUKey = TU_TUKey
					FROM dbo.TuristService
					WHERE TU_DLKey = @DLKey
						AND TU_TUKey NOT IN (
							SELECT SD_TUKey
							FROM ServiceByDate
							WHERE SD_DLKey = @DLKey
							)
					INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RLID, SD_RPID, SD_TUKey)
					SELECT CAST((N1.NU_ID + @From - 1) AS DATETIME), @DLKey, @RLID, @RPID, @TUKey
					FROM NUMBERS AS N1
					WHERE N1.NU_ID BETWEEN 1
							AND CAST(@N_DLDateEnd AS INT) - @From + 1
					SET @NeedPlacesForMen=@NeedPlacesForMen-1
					SET @RPID=@RPID+1
				END		
			END
			-- для всех услуг кроме проживания
			ELSE
			BEGIN
				IF @Mod = 'UPD'
					AND @SetToNewQuota = 1
					-- если услуга полностью ставится на квоту (из-за глобальных изменений (было удаление из ServiceByDate))
						SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)
				ELSE
						SET @NeedPlacesForMen=ISNULL(@N_DLNMen,0)-ISNULL(@O_DLNMen,0)

				while(@NeedPlacesForMen > 0)
				BEGIN
					set @TUKey=null

					SELECT @TUKey = TU_TUKey
					FROM dbo.TuristService
					WHERE TU_DLKey = @DLKey
						AND TU_TUKey NOT IN (
							SELECT SD_TUKey
							FROM ServiceByDate
							WHERE SD_DLKey = @DLKey
							)
					INSERT INTO RoomPlaces (RP_RLID, RP_Type)
					VALUES (0, 0)
					set @RPID=SCOPE_IDENTITY()				
					INSERT INTO ServiceByDate (SD_Date, SD_DLKey, SD_RPID, SD_TUKey)	
						SELECT CAST((N1.NU_ID+@From-1) as datetime), @DLKey, @RPID, @TUKey
					FROM NUMBERS AS N1
					WHERE N1.NU_ID BETWEEN 1
							AND CAST(@N_DLDateEnd AS INT) - @From + 1
					SET @NeedPlacesForMen = @NeedPlacesForMen - 1
				END
			END

			exec dbo.DogListToQuotas @DLKey, @OldSetToQuota = 1
		END
	END
	
	FETCH NEXT 
	FROM cur_DogovorListChanged2 
	INTO @DLKey, @DGKey, @O_DLSVKey, @O_DLCode, @O_DLSubCode1, @O_DLDateBeg, @O_DLDateEnd, @O_DLNMen, @O_DLPartnerKey, 
		@O_DLControl, @N_DLSVKey, @N_DLCode, @N_DLSubCode1, @N_DLDateBeg, @N_DLDateEnd, @N_DLNMen, @N_DLPartnerKey, @N_DLControl
END
CLOSE cur_DogovorListChanged2
DEALLOCATE cur_DogovorListChanged2
GO
/*********************************************************************/
/* end T_UpdDogListQuota.sql */
/*********************************************************************/

/*********************************************************************/
/* begin DisableTriggersOnSubscriber.sql */
/*********************************************************************/
-- ===================== Disable triggers on replication articles
if dbo.mwReplIsSubscriber() > 0 and exists (select top 1 1 from sys.servers where name = 'mt')
begin	
	declare @sql varchar(4000)
	-- do not disable triggers on this tables

	set @sql = '
	declare @excludedTables table
	(
		tableName varchar(50)
	)

	insert into @excludedTables values (''mwReplTours'')
	insert into @excludedTables values (''tp_tours'')
	insert into @excludedTables values (''Charter'')

	declare @tabName as varchar(max)

	declare tabsCur cursor for
	select art.source_object
	from mt.distribution.dbo.MSArticles art
	inner join sys.tables localTabs on localTabs.name = art.source_object
	where
			(art.publication_id = (select top 1 publication_id 
 				from mt.distribution.dbo.MSpublications 
				where publication = ''MW_PUB''))
			and (art.source_object not in (select tableName from @excludedTables)) 			
	order by art.source_object

	open tabsCur

	declare @sql varchar(4000)
	set @sql = ''''

	fetch next from tabsCur into @tabName
	while @@fetch_status = 0
	begin

		set @sql = @sql + ''
			alter table @tabName disable trigger all
		''
		set @sql = replace(@sql, ''@tabName'', @tabName)
		fetch next from tabsCur into @tabName

	end

	close tabsCur
	deallocate tabsCur'
	
	begin try
		exec (@sql)
	end try
	begin catch
		declare @errMsg as nvarchar(max)
		set @errMsg = 'Не удалось отключить триггеры на статьях репликации поисковой базы. Пожалуйста, сообщите об этом службе поддержки. Причина: ' + error_message();
		RAISERROR(@errMsg, 1, 1)
	end catch
end

GO
/*********************************************************************/
/* end DisableTriggersOnSubscriber.sql */
/*********************************************************************/
update [dbo].[setting] set st_version = '9.2.20.1', st_moduledate = convert(datetime, '2013-11-08', 120),  st_financeversion = '9.2.20.1', st_financedate = convert(datetime, '2013-11-08', 120) 
 GO
 UPDATE dbo.SystemSettings SET SS_ParmValue='2013-11-08' WHERE SS_ParmName='SYSScriptDate'
 GO